<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>HashMap源码分析 | __°ゝ 浮华 つ __</title><meta name="keywords" content="Java,数据结构"><meta name="author" content="__°ゝ 浮华 つ __"><meta name="copyright" content="__°ゝ 浮华 つ __"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HashMap源码分析 以下代码都是基于java8的版本  HashMap简介源码： 1234public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable &amp;#123;    &#x2F;&#x2F;......&amp;#125;       jdk1."><meta property="og:type" content="article"><meta property="og:title" content="HashMap源码分析"><meta property="og:url" content="http://lixiaogou.gitee.io/posts/60ecd9a6f387/index.html"><meta property="og:site_name" content="__°ゝ 浮华 つ __"><meta property="og:description" content="HashMap源码分析 以下代码都是基于java8的版本  HashMap简介源码： 1234public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;    implements Map&lt;K,V&gt;, Cloneable, Serializable &amp;#123;    &#x2F;&#x2F;......&amp;#125;       jdk1."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic.3gbizhi.com/2021/0924/20210924105944980.jpg"><meta property="article:published_time" content="2021-10-23T16:00:00.000Z"><meta property="article:modified_time" content="2022-12-05T07:44:36.355Z"><meta property="article:author" content="__°ゝ 浮华 つ __"><meta property="article:tag" content="Java"><meta property="article:tag" content="数据结构"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic.3gbizhi.com/2021/0924/20210924105944980.jpg"><link rel="shortcut icon" href="http://yiguan-main.oss-cn-beijing.aliyuncs.com/tms/2020-08/1597503441421.jpg"><link rel="canonical" href="http://lixiaogou.gitee.io/posts/60ecd9a6f387/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta><meta><meta><meta><meta><meta><meta><meta><meta><meta><meta><meta><meta><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"HashMap源码分析",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-12-05 15:44:36"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/moyuyu.gif" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://pic.3gbizhi.com/2021/0924/20210924105944980.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">__°ゝ 浮华 つ __</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HashMap源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-23T16:00:00.000Z" title="发表于 2021-10-24 00:00:00">2021-10-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-05T07:44:36.355Z" title="更新于 2022-12-05 15:44:36">2022-12-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>75分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="HashMap源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h1><blockquote><p>以下代码都是基于java8的版本</p></blockquote><h1 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h1><p>源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221017.png" alt="img"></p><p>jdk1.7和jdk1.8的差距还是比较大的，1.8引入了红黑树，尾插入</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221024.jpg" alt="img"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221037.png" alt="img"></p><h1 id="HashMap主要使用API"><a href="#HashMap主要使用API" class="headerlink" title="HashMap主要使用API"></a>HashMap主要使用API</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得指定键的值</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定Map中的键值对 复制到 此Map中</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除该键值对</span></span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在该键的键值对；是 则返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在该值的键值对；是 则返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 单独抽取key序列，将所有key生成一个Set</span></span><br><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独value序列，将所有value生成一个Collection</span></span><br><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>;  </span><br><span class="line"><span class="comment">// 清除哈希表中的所有键值对</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回哈希表中所有 键值对的数量 = 数组中的键值对 + 链表中的键值对</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断HashMap是否为空；size == 0时 表示为 空</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>; </span><br></pre></td></tr></table></figure><h1 id="HashMap的属性"><a href="#HashMap的属性" class="headerlink" title="HashMap的属性"></a>HashMap的属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认初始容量 - 必须是 2 的幂。，通过位移运算得到是16.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量，在两个带参数的构造函数中的任何一个隐式指定更高的值时使用。 必须是 2 的幂 &lt;= 1&lt;&lt;30。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在构造函数中未指定时使用的负载因子。为什么是0.75 ，元素的空间利用率</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用树而不是列表的 bin 计数阈值。 将元素添加到至少具有这么多节点的 bin 时，bin 会转换为树。 该值必须大于 2 且至少应为 8，以与树移除中关于在收缩时转换回普通 bin 的假设相匹配。 （就是数组==&gt;树的阈值之一）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在调整大小操作期间取消（拆分）bin 的 bin 计数阈值。 应小于 TREEIFY_THRESHOLD，最多为 6 以在移除下进行收缩检测，（就是树==&gt;数组的阈值）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以将 bin 树化的最小表容量。 （否则，如果 bin 中的节点过多，则表将调整大小。） 应至少为 4 * TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间发生冲突，（就是数组==&gt;树的阈值之一）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表，在第一次使用时初始化，并根据需要调整大小。 分配时，长度始终是 2 的幂。 （我们还在某些操作中容忍长度为零，以允许当前不需要的引导机制。）</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存缓存的 entrySet()。 请注意，AbstractMap 字段用于 keySet() 和 values()。</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此映射中包含的键值映射的数量。  也就是常用的 map.size() 返回的那个数，表示目前里面有多少个键值对</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该 HashMap 被结构修改的次数，该字段用于在 HashMap 的 Collection-views 上创建迭代器快速失败。 （请参阅 ConcurrentModificationException）</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要调整大小的下一个大小值（容量 * 负载因子）。</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表的负载因子。其实就是前面的那个0.75f</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h2><p>如果不传入参数，则使用默认无参构造方法创建HashMap对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造一个具有默认初始容量 (16) 和默认负载因子 (0.75) 的空HashMap 。</span></span><br><span class="line"><span class="comment">// 这里就看出来了其实loadFactor 就是 0.75f</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 加载因子 &amp; 容量 = 默认 = 0.75、16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted 所有其他字段默认</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带初始容量的构造函数"><a href="#带初始容量的构造函数" class="headerlink" title="带初始容量的构造函数"></a>带初始容量的构造函数</h2><p>传入参数，代表指定HashMap的初始容量；如果参数小于0，则抛出 IllegalArgumentException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">构造一个具有指定初始容量和默认负载因子 (0.75) 的空HashMap 。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">initialCapacity – 初始容量。</span></span><br><span class="line"><span class="comment">抛出：</span></span><br><span class="line"><span class="comment">IllegalArgumentException – 如果初始容量为负</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带初始容量和负载因子的构造函数"><a href="#带初始容量和负载因子的构造函数" class="headerlink" title="带初始容量和负载因子的构造函数"></a>带初始容量和负载因子的构造函数</h2><p><strong>初始容量</strong></p><ul><li>如果初始容量小于0，则抛出 IllegalArgumentException。</li><li>如果初始容量大于最大容量时，设置初始容量等于最大容量</li></ul><p><strong>负载因子</strong></p><ul><li>如果负载因子为非正数， 则抛出 IllegalArgumentException。</li><li>设置负载因子为0.75f</li></ul><p><strong>调整容量</strong></p><ul><li>要调整大小的下一个大小值（容量 * 负载因子）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">构造一个具有指定初始容量和负载因子的空HashMap 。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">initialCapacity – 初始容量</span></span><br><span class="line"><span class="comment">loadFactor – 负载因子</span></span><br><span class="line"><span class="comment">抛出：</span></span><br><span class="line"><span class="comment">IllegalArgumentException – 如果初始容量为负或负载因子为非正</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//如果初始容量小于0，则抛出 IllegalArgumentException。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果初始容量大于最大容量时，设置初始容量等于最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果负载因子为非正数， 则抛出 IllegalArgumentException。</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置负载因子为0.75f</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整阈值</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Float.isNaN 如果指定的数字是非数字 (NaN) 值，则返回true否则返回false 。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNaN</span><span class="params">(<span class="type">float</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (v != v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看一下 <strong>tableSizeFor</strong> 方法</p><p>根据我们传入的容量计算一个大于等于该容量的最小的2的N次方，例如传 9，容量为2^4=16</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定目标容量的二次幂。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们先不看第一行“int n = cap - 1”，先看下面的5行计算。</p><p>|=（或等于）：例如：a |= b ，可以转成：a = a | b。或运算规则：0|0=0； 0|1=1； 1|0=1； 1|1=1；有1为1。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221049.png" alt="img"></p><p>&gt;&gt;&gt;（无符号右移）：例如 a &gt;&gt;&gt; b 指的是将 a 向右移动 b 指定的位数，右移后左边空出的位用零来填充，移出右边的位被丢弃。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221052.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 等同于 n = n | (n &gt;&gt;&gt; 1)</span></span><br></pre></td></tr></table></figure><p>假设 n 的值为 0010 0001，则该计算如下图：</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221106.jpeg" alt="img"></p><p>相信你应该看出来，这5个公式会通过最高位的1，拿到2个1、4个1、8个1、16个1、32个1。当然，有多少个1，取决于我们的入参有多大，但肯定的是经过这5个计算，得到的值是一个低位全是1的值，最后返回的时候 +1，则会得到一个比n 大的 2 的N次方。</p><p>这时再看开头的 cap - 1 就很简单了，这是为了处理 cap 本身就是 2 的N次方的情况。</p><p>计算机底层是二进制的，移位和或运算是非常快的，所以这个方法的效率很高。（对于<strong>移位、 或运算</strong> 等不明白的小伙伴，这一块可是要费点力气了）</p><h2 id="带Map的构造函数"><a href="#带Map的构造函数" class="headerlink" title="带Map的构造函数"></a>带Map的构造函数</h2><p>使用与指定Map相同的映射构造一个新的HashMap 。</p><p>新的HashMap是使用默认负载因子 (0.75) 创建的，初始容量足以在指定的Map 中保存映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用指定的map 创建新map</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认的负载因子 0.75f</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="putMapEntries"><a href="#putMapEntries" class="headerlink" title="putMapEntries"></a>putMapEntries</h3><p>下面看一下 <strong>putMapEntries</strong> 方法， 该方法的作用：将传入的子Map中的全部元素逐个添加到HashMap中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// 得到新传进来的m的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="comment">// 判断大小是否大于0</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前哈希表是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">//计算容量 当前（当前m的大小/负载因子 = 最大容量） 然后在加一 得到m最大的容量</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="comment">//判断传入的m的最大容量是否小于允许最大容量值，得到最终容量值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">//判断容量t是否大于当前map 的阈值，</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                <span class="comment">// 重新计算得到一个大于等于t 的最小的2次幂，说白了就是调整map的阈值。</span></span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//传进来的m大小 大于当前 map 的阈值时，需要扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            <span class="comment">// 扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历传入的m，取出每一个键值对，存入当前map中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize-扩容"><a href="#resize-扩容" class="headerlink" title="resize 扩容"></a>resize 扩容</h3><p>下面看一下 <strong>resize</strong> 方法，面试时最经常问的hashmap扩容机制就在这个地方，注意<code>newCap = oldCap &lt;&lt; 1</code>这句，扩容就在这，扩大两倍。</p><p>下面看一下resize 的源码，注释基本写的很明白了。按照我自己的理解写的。如有不对的，欢迎指正。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 先创建一个临时变量，存储当前的table</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//获取原来的table的长度（大小）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 创建临时变量存储旧的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">// 创建新容量、阈值，默认都是0</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断旧容量是否大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断旧容量大于等于 允许的最大值，2^30</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 设置当前阈值为Integer的最大值。2^31-1</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">// 返回旧table</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置新容量是旧容量的两倍，新容量是否小于允许的最大值，旧容量是否大于默认的16.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 设置新阈值是旧阈值的两倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 阈值翻倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断旧阈值是否大于0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 旧容量和旧阈值都不大于0，则使用默认的大小和容量</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 设置新容量为默认容量16</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 设置新阈值为 负载因子0.75f * 默认容量 16 = 12;</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新阈值 等于 0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 临时阈值 = 新容量 * 负载因子0.75f </span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 设置新的阈值</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新map的阈值字段</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建新的table键值对，容量是刚刚确定的新容量</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将map 的table指向新table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 旧table不为null</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历oldTab，取出每一个键值对，存入到新table,这里的 ++j  其实和j++没区别。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 创建一个临时变量指向oldTab中的第j个键值对，</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将置为null，释放内存，方便gc</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果当前e 没有第二个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 计算新表的索引位置，直接该位置</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 判断当前的e是不是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 将 node 转为 treeNode，之所以能转换是因为 treeNode 是 node 的子类</span></span><br><span class="line">                    <span class="comment">// 拆分树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当前节不是红黑树，不是null，并且还有下一个元素。此时为链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 取出来该链表中的所有节点，</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 如果计算得到的是0，则新表索引位置为“原索引位置” </span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//此时loTail为null，意味着lo链表还没有元素，</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                <span class="comment">// loHead指向e，也就是设置第一个元素</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="comment">// lo链表追加</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">// 赋值</span></span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 计算得到的索引不是0，则新表索引位置为“原索引 + oldCap 位置</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);<span class="comment">// 后移</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//不为null，表示新表索引位置为“原索引位置”</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 设置loTail为最后一个节点</span></span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 放入新数组中</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 新表索引位置为“原索引 + oldCap 位置”</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体的resize方法，也就是扩容逻辑如下图</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221136.png" alt="img"></p><p>个人认为resize方法中有几个点需要注意：</p><ul><li><p>一个是计算新索引的位置（e.hash &amp; oldCap），</p></li><li><p>另一个是红黑树的处理（split）。</p></li></ul><h3 id="e-hash-amp-oldCap-0-的解释"><a href="#e-hash-amp-oldCap-0-的解释" class="headerlink" title="e.hash &amp; oldCap == 0 的解释"></a>e.hash &amp; oldCap == 0 的解释</h3><p><strong>我们来看一下为什么红黑树和链表都是通过 e.hash &amp; oldCap == 0 来定位在新表的索引位置？</strong></p><p>为什么是e.hash &amp; oldCap 得到索引位置呢，因为在put 的时候 (n - 1) &amp; hash 得到索引位置</p><p>举个例子，扩容前 table 的容量n为16，a 节点和 b 节点在扩容前处于同一索引位置。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221142.png" alt="img"></p><p>扩容后，table 长度n为32，新表的 n - 1 只比老表的 n - 1 在高位多了一个1（图中标红的1）。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221146.png" alt="img"></p><p>因为 2 个节点在老表是同一个索引位置，因此计算新表的索引位置时，只取决于新表在高位多出来的这一位（图中标红1），而这一位的值刚好等于 oldCap。</p><p>因此会存在两种情况：1） (e.hash &amp; oldCap) == 0 ，则新表索引位置为“原索引位置” ；2）(e.hash &amp; oldCap) != 0，则新表索引位置为”原索引 + oldCap 位置”。</p><p>还不理解的话 网上还有一个说明，讲的比较详细的。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221151.png" alt="在这里插入图片描述"></p><h3 id="split-红黑树的拆分"><a href="#split-红黑树的拆分" class="headerlink" title="split 红黑树的拆分"></a>split 红黑树的拆分</h3><p><strong>再看一下红黑树的处理（split）。</strong></p><p>这一块难点就是 低位红黑树和高位红黑树的处理，至于(e.hash &amp; bit) == 0 这个刚刚已经讲过是为什么了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将红黑中的节点拆分为较高位红黑树和低位红黑树，或者如果树现在太小，则取消树化</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index 当前红黑树所在位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> bit   数组容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> index, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">    <span class="comment">//获得调用此方法的节点b</span></span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重新链接到 lo 和 hi 列表，保留顺序</span></span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>; <span class="comment">// 存储索引位置为:“原索引位置”的节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>; <span class="comment">// 存储索引位置为:“原索引+oldCap”的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//lc 低位红黑树的节点数，hc 高位红黑树的节点数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点b开始，遍历整个红黑树节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="literal">null</span>; e = next) &#123;</span><br><span class="line">        <span class="comment">// next赋值为e的下个节点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next; </span><br><span class="line">        <span class="comment">// 得到e的next后，将e的next指向null 以便垃圾收集器回收</span></span><br><span class="line">        e.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意此处&amp;运算的数组容量没有-1</span></span><br><span class="line">        <span class="comment">//那么数组的容量值二进制表达必定为：1000...，所以此处计算只有两个结果，1或者0</span></span><br><span class="line">        <span class="comment">//0：TreeNode在新数组的位置是原位置，1：原位置加上旧数组容量值的位置</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//将loTail节点变成e节点的前节点，</span></span><br><span class="line">            <span class="comment">//若loTail节点不存在，代表该节点为第一个节点</span></span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//将e节点赋值给loHead节点，loHead指向第一个节点</span></span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//存在则将e节点赋值给loTail的后节点</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            <span class="comment">//将e节点赋值给loTail节点</span></span><br><span class="line">            loTail = e;</span><br><span class="line">            <span class="comment">//计算低位红黑树的节点数</span></span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以下操作和上方操作一样</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果低位红黑树存在</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果低位红黑树节点小于等于红黑树瓦解阈值6，</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            <span class="comment">// 低位红黑树转为链表</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则将低位红黑树根节点放到数组上</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) <span class="comment">// (else is already treeified) 不存在则说明原先的节点都在当前红黑树上。不用变化</span></span><br><span class="line">                <span class="comment">//如果高位红黑树存在，则将低位红黑树重新树化，</span></span><br><span class="line">                <span class="comment">// 虽然当前已经是红黑树了，但是节点改变了，所以要重新再来一遍，梳理节点</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下操作与上方操作一样</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上对红黑树的处理 涉及到 树化 和 反树化 ，也就是链表和红黑树的互相转换，下面我们来看一下树化的代码</p><h3 id="treeify"><a href="#treeify" class="headerlink" title="treeify"></a>treeify</h3><p>链表转红黑树，参数为HashMap的元素数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形成从此节点链接的树。 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="literal">null</span>; <span class="comment">// 定义树的根节点</span></span><br><span class="line">    <span class="comment">// 遍历链表，x指向当前节点、next指向下一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123; </span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next; <span class="comment">// 下一个节点</span></span><br><span class="line">        x.left = x.right = <span class="literal">null</span>; <span class="comment">// 设置当前节点的左右节点为空</span></span><br><span class="line">        <span class="comment">// 如果还没有根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="literal">null</span>; <span class="comment">// 当前节点的父节点设为空</span></span><br><span class="line">            x.red = <span class="literal">false</span>; <span class="comment">// 当前节点的红色属性设为false（把当前节点设为黑色）</span></span><br><span class="line">            root = x; <span class="comment">// 根节点指向到当前节点（当前节点设置为根节点）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经存在根节点了</span></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key; <span class="comment">// 取得当前链表节点的key</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash; <span class="comment">// 取得当前链表节点的hash值</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>; <span class="comment">// 定义key所属的Class</span></span><br><span class="line">            <span class="comment">// 从根节点开始遍历，此遍历没有设置边界，只能从内部跳出</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; </span><br><span class="line">                <span class="comment">// GOTO1</span></span><br><span class="line">                <span class="comment">// dir 标识方向（左右）、ph标识当前树节点的hash值</span></span><br><span class="line">                <span class="type">int</span> dir, ph; </span><br><span class="line">                <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="comment">// 当前树节点的key</span></span><br><span class="line">                <span class="comment">// 如果当前树节点hash值 大于 当前链表节点的hash值</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) </span><br><span class="line">                    dir = -<span class="number">1</span>; <span class="comment">// 标识当前链表节点会放到当前树节点的左侧</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>; <span class="comment">// 右侧</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果两个节点的key的hash值相等，那么还要通过其他方式再进行比较</span></span><br><span class="line"><span class="comment">                 * 如果当前链表节点的key实现了comparable接口，</span></span><br><span class="line"><span class="comment">                 * 并且当前树节点和链表节点是相同Class的实例，那么通过comparable的方式再比较两者。</span></span><br><span class="line"><span class="comment">                 * 如果还是相等，最后再通过tieBreakOrder比较一次</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                            (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                            (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"> </span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p; <span class="comment">// 保存当前树节点</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果dir 小于等于0 ： 当前链表节点一定放置在当前树节点的左侧，但不一定是该树节点的左孩子，也可能是左孩子的右孩子 或者 更深层次的节点。</span></span><br><span class="line"><span class="comment">                 * 如果dir 大于0 ： 当前链表节点一定放置在当前树节点的右侧，但不一定是该树节点的右孩子，也可能是右孩子的左孩子 或者 更深层次的节点。</span></span><br><span class="line"><span class="comment">                 * 如果当前树节点不是叶子节点，那么最终会以当前树节点的左孩子或者右孩子 为 起始节点  再从GOTO1 处开始 重新寻找自己（当前链表节点）的位置</span></span><br><span class="line"><span class="comment">                 * 如果当前树节点就是叶子节点，那么根据dir的值，就可以把当前链表节点挂载到当前树节点的左或者右侧了。</span></span><br><span class="line"><span class="comment">                 * 挂载之后，还需要重新把树进行平衡。平衡之后，就可以针对下一个链表节点进行处理了。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.parent = xp; <span class="comment">// 当前链表节点 作为 当前树节点的子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x; <span class="comment">// 作为左孩子</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x; <span class="comment">// 作为右孩子</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 进行红黑树的插入平衡(通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求)</span></span><br><span class="line">                    root = balanceInsertion(root, x); </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 把所有的链表节点都遍历完之后，最终构造出来的树可能经历多个平衡操作，根节点目前到底是链表的哪一个节点是不确定的</span></span><br><span class="line">    <span class="comment">// 因为我们要基于树来做查找， 确保给定的根是其 tab 的第一个节点。</span></span><br><span class="line">    moveRootToFront(tab, root); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tieBreakOrder"><a href="#tieBreakOrder" class="headerlink" title="tieBreakOrder"></a>tieBreakOrder</h3><p>比较a和b的大小，-1：a&lt;=b；1：a&gt;b</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tieBreakOrder</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span> || (d = a.getClass().getName().compareTo(b.getClass().getName())) == <span class="number">0</span>)&#123;</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="balanceInsertion"><a href="#balanceInsertion" class="headerlink" title="balanceInsertion"></a>balanceInsertion</h3><p>红黑树的插入平衡(通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红黑树的插入平衡(通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    x.red = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 从内部终止循环</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="literal">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                xppr.red = <span class="literal">false</span>;</span><br><span class="line">                xp.red = <span class="literal">false</span>;</span><br><span class="line">                xpp.red = <span class="literal">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="literal">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="literal">false</span>;</span><br><span class="line">                xp.red = <span class="literal">false</span>;</span><br><span class="line">                xpp.red = <span class="literal">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="moveRootToFront"><a href="#moveRootToFront" class="headerlink" title="moveRootToFront"></a>moveRootToFront</h3><p>该方法的作用是， 确保给定的根是其 tab 的第一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将root放到头节点的位置, 原头节点放在root的next节点上</span></span><br><span class="line"><span class="comment"> * 如果当前索引位置的头节点不是root节点, 则将root的上一个节点和下一个节点进行关联,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; tab != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            tab[index] = root;</span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="literal">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="literal">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> <span class="title function_">checkInvariants</span><span class="params">(root)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="checkInvariants"><a href="#checkInvariants" class="headerlink" title="checkInvariants"></a>checkInvariants</h3><p>检查不变的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">        tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="literal">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="literal">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tp != <span class="literal">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="literal">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="literal">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="literal">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="literal">null</span> &amp;&amp; tr.red)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="literal">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="literal">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="untreeify"><a href="#untreeify" class="headerlink" title="untreeify"></a>untreeify</h3><p>将红黑树节点转为链表节点, 当节点&lt;=6个时会被触发。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将红黑树节点转为链表节点, 当节点&lt;=6个时会被触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>; <span class="comment">// hd指向头节点, tl指向尾节点</span></span><br><span class="line">    <span class="comment">// 从调用该方法的节点, 即链表的头节点开始遍历, 将所有节点全转为链表节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">        <span class="comment">// 调用replacementNode方法，将树节点构建成链表节点</span></span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 如果tl为null, 则代表当前节点为第一个节点, 将hd指向p</span></span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="comment">// 否则, 将尾节点的next指向当前节点p，也就是进行链表追加</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每次循环q都会后移一个，同理p也就是后移之后构建出来的链表节点</span></span><br><span class="line">        tl = p; <span class="comment">// 将tl节点指向链表节点p, 即尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回转换后的链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建链表节点</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><p>jdk1.7和jdk1.8的区别</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221219.png" alt="img"></p><h2 id="put流程图"><a href="#put流程图" class="headerlink" title="put流程图"></a>put流程图</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221222.png" alt="img"></p><h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p>将指定的键值对添加到map中，真正初始化哈希表（初始化存储数组table）的时候就在第1次添加键值对时，即第1次调用put()时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hash-–-计算-key-的-hash-值"><a href="#hash-–-计算-key-的-hash-值" class="headerlink" title="hash – 计算 key 的 hash 值"></a>hash – 计算 key 的 hash 值</h2><p>拿到 key 的 hashCode，并将 hashCode 的高16位和 hashCode 进行异或（XOR）运算，得到最终的 hash 值。</p><p>该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样 = 扰动函数 = 使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）</p><p>JDK 1.7 做了9次扰动处理（4次位运算 + 5次异或运算）</p><p>JDK 1.8 简化了扰动函数 , 只做了2次扰动（1次位运算 + 1次异或运算）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    h ^= k.hashCode(); </span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span></span><br><span class="line"><span class="comment">// 1. 取hashCode值： h = key.hashCode() </span></span><br><span class="line"><span class="comment">// 2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// a. 当key = null时，hash值 = 0，所以HashMap的key 可为null      </span></span><br><span class="line">    <span class="comment">// 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span></span><br><span class="line">    <span class="comment">// b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行 扰动处理： 按位 异或（^） 哈希码自身右移16位后的二进制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221228.png" alt="img"></p><h2 id="hash常见疑惑"><a href="#hash常见疑惑" class="headerlink" title="hash常见疑惑"></a>hash常见疑惑</h2><p><strong>为什么要将 hashCode 的高16位参与运算？</strong></p><p>例如下图，在 table 的长度较小的时候，此处等于8。如果不加入高位运算，由于 n - 1 是 0000 0111，所以结果只取决于 hash 值的低3位，无论高位怎么变化，索引计算结果都是一样的。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221234.png" alt="img"></p><p>如果我们将高位参与运算，则索引计算结果就不会仅取决于低位。索引冲突的情况就会大大减少</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221239.png" alt="img"></p><p><strong>为什么不直接采用经过hashCode（）处理的哈希码 作为 存储数组table的下标位置？</strong></p><ul><li>结论：容易出现 哈希码 与 数组大小范围不匹配的情况，即 计算出来的哈希码可能 不在数组大小范围内，从而导致无法匹配存储位置</li></ul><p>原因描述</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221247.png" alt="img"></p><p><strong>为什么采用 哈希码 与运算(&amp;) （数组长度-1） 计算数组下标？</strong></p><ul><li>结论：根据HashMap的容量大小（数组长度），按需取 哈希码一定数量的低位 作为存储的数组下标位置，从而 解决 “哈希码与数组大小范围不匹配” 的问题</li><li>具体解决方案描述</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221254.png" alt="img"></p><p><strong>为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？</strong></p><ul><li>结论：加大哈希码低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性 &amp; 均匀性，最终减少Hash冲突</li></ul><h2 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h2><p>put的真正存放逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Map.put 及相关方法</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> * hash – 密钥的散列</span></span><br><span class="line"><span class="comment"> * 钥匙——钥匙</span></span><br><span class="line"><span class="comment"> * value – 要放置的值</span></span><br><span class="line"><span class="comment"> * onlyIfAbsent – 如果为真，则不更改现有值</span></span><br><span class="line"><span class="comment"> * evict – 如果为 false，则表处于创建模式。</span></span><br><span class="line"><span class="comment"> * 返回：</span></span><br><span class="line"><span class="comment"> * 以前的值，如果没有，则为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tab是当前table数组, n 是tab数组的长度，i为数组索引，p为数组索引i位置的节点</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 若哈希表的数组tab为空，则 通过resize() 创建,</span></span><br><span class="line">    <span class="comment">//所以，初始化哈希表的时机是第1次调用put函数时，初始化创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 计算数组索引i = (n - 1) &amp; hash，即插入数组的位置。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取到i位置的节点p，判断是否存在。</span></span><br><span class="line">    <span class="comment">// 若p为null，表示当前位置没有元素，则直接在该数组位置新建节点，插入完毕</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p！=null，当前i位置有元素，此时发生了Hash冲突，需要在继续判断</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e 临时存储当前节点p，k 当前节点p的key</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. 若p节点的hash和key与新元素hash和key相同，就用e节点临时存储下p节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">            e = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// b. 若p节点是红黑树，则直接在树中插入或者更新键值对</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value); -&gt;&gt;分析<span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c. 若p节点是链表,则在链表中插入 or 更新键值对</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// d. 从p结点的下一个节点开始遍历链表，</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 先将 e 指向p节点的下一个节点，再判断p节点是不是链表的最后一个节点，</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 进入到这里说明循环到最后一个节点了也没找到与新数据key相同的节点。</span></span><br><span class="line">                    <span class="comment">// 将新数据使用尾插入追加到p节点后面</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 插入节点后，判断是否需要链表转红黑树，</span></span><br><span class="line">                    <span class="comment">// 链表元素数大于8才转，因为这里是从第二个节点开始的，所以 TREEIFY_THRESHOLD - 1 = 7 ，又因为binCount是从0开始的，所以用的是&gt;=号。</span></span><br><span class="line">                    <span class="comment">// 例如bigCount=7，表示循环了进行了7次，加上原来的那个头节点，表示该链表原先有8个节点，然后新元素又进行了尾插入，此时该链表就有9个元素了，所以此时就得树化操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">// 树化操作</span></span><br><span class="line">                    <span class="comment">// 终止循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历链表的key找到与新数据key相同的节点，然后终止循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 本轮循环没找到与新数据key相同的节点，则节点后移，进行下次循环</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对d情况的后续操作：e != null 表示key已存在，直接用新value 覆盖 旧value &amp; 返回旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">//此处onlyIfAbsent 是固定值 false，所以这个if是必进入的</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 直接用新value 覆盖 旧value &amp; 返回旧value</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            afterNodeAccess(e); <span class="comment">// 替换旧值时会调用的方法（默认实现为空）</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录该map被修改的次数，主要用于多线程并发时候</span></span><br><span class="line">    ++modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入成功后，若实际存在的键值对数量size &gt; 扩容阈值threshold 则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">// 插入成功时会调用的方法（默认实现为空）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="putTreeVal"><a href="#putTreeVal" class="headerlink" title="putTreeVal"></a>putTreeVal</h2><p>向红黑树插入 or 更新数据（键值对），遍历红黑树，找到与新数据key相同的节点，新数据value替换旧数据的value，找不到相同的key则创建新节点并插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">红黑树的put操作，红黑树插入会同时维护原来的链表属性, 即原来的next属性</span></span><br><span class="line"><span class="comment">map:当前调用该方法的对象实例，也就是当前map</span></span><br><span class="line"><span class="comment">tab：当前map里的数组，</span></span><br><span class="line"><span class="comment">h:新数据的key计算出来的hash，</span></span><br><span class="line"><span class="comment">k：新数据的key，</span></span><br><span class="line"><span class="comment">v：新数据的value </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 是否调用find方法进行查找，默认没调用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 查找根节点, 索引位置的头节点并不一定为红黑树的根节点，</span></span><br><span class="line">    <span class="comment">// 此处的this就是调用该方法的TreeNode实例，</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将根节点赋值给p节点，从根节点开始遍历红黑树，从内部终止遍历</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="comment">//dir：表示向哪个子树查找，-1左，1右； ph：当前树节点的hash，pk：当前树节点的key</span></span><br><span class="line">        <span class="type">int</span> dir, ph; K pk;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点p的hash赋值给ph，</span></span><br><span class="line">        <span class="comment">// 并且新数据的hash小于当前树节点的hash，则向p的左子树查找</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;<span class="comment">//dir赋值为-1，</span></span><br><span class="line">        <span class="comment">// 向p的右子树查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;<span class="comment">//dir赋值为1，</span></span><br><span class="line">        <span class="comment">// 当前树节点的key等于新数据的key，直接返回当前节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">// 如果k为null并且k所属的类没有实现Comparable接口 或者 k和p节点的key相等（dir==0）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还没有调用find方法进行查找</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="literal">true</span>;<span class="comment">// 改为已经调用find方法进行查找了，</span></span><br><span class="line">                <span class="comment">// 从p节点的左节点和右节点分别调用find方法进行查找, 如果查找到目标节点则并终止循环，返回q；</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用定义的一套规则来比较p节点的key和新数据的key大小, 用来决定向左还是向右查找</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);<span class="comment">// dir&lt;0 则代表 k&lt;pk，则向p左边查找；反之亦然</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x表示新元素构建出来的树节点</span></span><br><span class="line">        <span class="comment">// xp赋值为x的父节点,中间变量,用于下面给x的父节点赋值</span></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="comment">// dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 走进来代表已经找到x的位置，只需将x放到该位置即可</span></span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            <span class="comment">// 创建新的节点, 其中x的next节点为xpn, 即将x节点插入xp与xpn之间</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="comment">// 调整x、xp、xpn之间的属性关系</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)   <span class="comment">// 如果时dir &lt;= 0, 则代表x节点为xp的左节点</span></span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span>        <span class="comment">// 如果时dir&gt; 0, 则代表x节点为xp的右节点</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;    <span class="comment">// 将xp的next节点设置为x</span></span><br><span class="line">            x.parent = x.prev = xp; <span class="comment">// 将x的parent和prev节点设置为xp</span></span><br><span class="line">            <span class="comment">// 如果xpn不为空,则将xpn的prev节点设置为x节点,与上文的x节点的next节点对应</span></span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            <span class="comment">// 进行红黑树的插入平衡调整</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>查找红黑树的根节点，通过判断有没有父节点来找出根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">root</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="built_in">this</span>, p;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>从调用此方法的节点开始查找, 通过hash值和key找到对应的节点。查找过程无非就是，比较hash，判断往左找还是往右找，特殊情况就是 一边为空 那就只往另一边找，比较key是否相等，相等就找到了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从调用此方法的节点开始查找, 通过hash值和key找到对应的节点</span></span><br><span class="line"><span class="comment"> * 此方法是红黑树节点的查找, 红黑树是特殊的自平衡二叉查找树</span></span><br><span class="line"><span class="comment"> * 平衡二叉查找树的特点：左节点&lt;根节点&lt;右节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.将p节点赋值为调用此方法的节点，即为红黑树根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 2.从p节点开始向下遍历</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// ph p的hash，pk p的key</span></span><br><span class="line">        <span class="type">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">// 3.如果传入的hash值小于p节点的hash值，则往p节点的左边遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">// 4.如果传入的hash值大于p节点的hash值，则往p节点的右边遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">// 5.如果传入的hash值和key值等于p节点的hash值和key值,则p节点为目标节点,返回p节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">// 6.p节点的左节点为空则将向右遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)    </span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">// 7.p节点的右节点为空则向左遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)    </span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">// 8.将p节点与k进行比较</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp; <span class="comment">// 8.1 kc不为空代表k实现了Comparable</span></span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)<span class="comment">// 8.2 k&lt;pk则dir&lt;0, k&gt;pk则dir&gt;0</span></span><br><span class="line">            <span class="comment">// 8.3 k&lt;pk则向左遍历(p赋值为p的左节点), 否则向右遍历</span></span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="comment">// 9.代码走到此处, 代表key所属类没有实现Comparable, 向p的右边遍历查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="comment">// 10.代码走到此处代表上一步的向右边没找到“pr.find(h, k, kc)”为空, 因此向左遍历</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin"></a>treeifyBin</h2><p>将数组的某个索引里的链表转为红黑树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">将数组的某个索引里的链表转为红黑树</span></span><br><span class="line"><span class="comment">tab：数组</span></span><br><span class="line"><span class="comment">hash：新元素的hash值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="comment">// n：当前数组长度，index：hash经过计算得到的索引，e：index索引位置的元素</span></span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 当前数组为空或者当前数组长度小于数组转为红黑树的阈值64时，需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 计算得到索引index，并且取出来index索引对应的节点e，并且 e 不是null，</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="comment">// hd 存头节点，tl </span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从e节点开始遍历链表</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将链表节点e转红黑树节点p</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 如果是第一次遍历，将头节点赋值给hd</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="comment">// 如果不是第一次遍历，则处理当前节点的prev属性和上一个节点的next属性</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;    <span class="comment">// 当前节点的prev属性设为上一个节点</span></span><br><span class="line">                tl.next = p;    <span class="comment">// 上一个节点的next属性设置为当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将p节点赋值给tl，</span></span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>); <span class="comment">//后移，找下一个节点，再继续遍历</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将table该索引位置赋值为hd头节点，如果该节点不为空，则以头节点(hd)为根节点, 构建红黑树</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For treeifyBin 将指定的链表节点转为树节点</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h1><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>根据指定的key，查找对应的value值，找不到返回null，后续操作geit的结果的时候一定要判断非null，否则会出现空指针异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getNode"><a href="#getNode" class="headerlink" title="getNode"></a>getNode</h2><p>根据key的hash和key，查找节点。找不到返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// tab：当前map的数组，first：当前hash对应的索引位置上的节点，e：遍历过程中临时存储的节点，</span></span><br><span class="line">    <span class="comment">// n：tab数组的长度，k：first节点的key</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.对table进行校验：table不为空 &amp;&amp; table长度大于0 &amp;&amp; </span></span><br><span class="line">    <span class="comment">// hash对应的索引位置上的节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是要找的元素，比较hash值和key是否和入参的一样，如果一样，直接返回第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个节点不是要找的元素，</span></span><br><span class="line">        <span class="comment">// 取出来第二个节点，并且第二个节点不为null，说明还没走到该节点链的最后</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个节点是红黑树类型</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)&#123;</span><br><span class="line">                <span class="comment">// 调用红黑树的查找目标节点方法getTreeNode</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前提条件：第一个节点不为null，并且也不是红黑树，而且还有下一个节点，那么该索引位置的元素类型就是链表，从第二个节点开始遍历该链表，</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 找到了，返回节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);<span class="comment">// e指针后移，并且下一个节点不为null则继续遍历，不为null表示没到链表最后呢</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getTreeNode"><a href="#getTreeNode" class="headerlink" title="getTreeNode"></a>getTreeNode</h2><p>在红黑树中根据key和key的hash 查找对应的树节点，找不到返回null，这里要先找到根节点，然后从根节点再去查找树节点。root 和 find 方法之前已经讲解过了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前调用该方法的红黑树节点还有父级节点，说明该红黑树节点不是根节点，所以需要调用 root() 方法找到根节点，</span></span><br><span class="line">    <span class="comment">// 如果当前调用该方法的红黑树节点没有父级节点，说明该红黑树节点就是根节点，</span></span><br><span class="line">    <span class="comment">// 找到根节点后，根节点调用find方法去查找目标节点</span></span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>).find(h, k, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="判断key是否存在"><a href="#判断key是否存在" class="headerlink" title="判断key是否存在"></a>判断key是否存在</h1><h2 id="containsKey"><a href="#containsKey" class="headerlink" title="containsKey"></a>containsKey</h2><p>判断key是否存在，实际上调用的还是刚刚那个getNode，找到就返回ture，找不到返回false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="判断value是否存在"><a href="#判断value是否存在" class="headerlink" title="判断value是否存在"></a>判断value是否存在</h1><h2 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h2><p>根据给定的value查找当前map中是否有和value相同的节点，有的话返true，没有返回false；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// tab：当前map的数组，v：目标元素的value</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="comment">// 首先判断当前数组不为null 并且 含有的元素大于0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历该数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 遍历数组中每个索引位置的的链表，并且该位置不为null，</span></span><br><span class="line">            <span class="comment">// 其实可以改成while循环的。不知为什么开发jdk的这帮人这么喜欢用for循环</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="comment">// 如果节点的value与入参value相等，就直接返回true，return 会停止循环并且退出方法。</span></span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找不到则返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><h2 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h2><p>根据指定的key删除元素，若删除成功则返回被删除的元素的value，删除失败返回null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// 被删除的元素</span></span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode"></a>removeNode</h2><p>移除某个节点，根据指定的key hash 和另外的两个条件进行移除。</p><p>matchValue=true，表示仅在value相等时删除，=false，表示value不相等的时候也可以删除该节点。</p><p>HashMap.remove(key) 不去判断值相不相等。</p><p>HashMap.EntrySet.remove(key)、HashMap.remove(key,value)、LinkedHashMap.LinkedEntrySet.remove(key)需要判断value相不相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">移除某个节点，根据下面四个条件进行移除</span></span><br><span class="line"><span class="comment">hash - key 的hash值 </span></span><br><span class="line"><span class="comment">key - key</span></span><br><span class="line"><span class="comment">matchValue - 如果为真，则仅在值相等时删除</span></span><br><span class="line"><span class="comment">movable - 如果为false，则在删除时不移动其他节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    <span class="comment">// tab：当前map 的数组，p：hash对应的数组索引index位置上的节点，n：数组长度，index：hash对应的数组索引</span></span><br><span class="line">    <span class="comment">// 这几个值在hashMap的源码中很常见</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前提判断 数组不为空，并且长度大于0 并且</span></span><br><span class="line">    <span class="comment">// hash对应的数组索引位置上的节点p也不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// node：被移除的节点，e：当前头节点的下一个节点，k：e节点的key，v：被移除节点node 的value</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果第一个节点p就是目标节点，则将node指向第一个节点p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">            node = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个节点不是，那就看看第一个节点还有没有下一个元素。</span></span><br><span class="line">        <span class="comment">// 如果有第二个节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果刚刚第一个节点是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;</span><br><span class="line">                <span class="comment">// 调用红黑树的查询节点的方法，getTreeNode 已经在上文讲过了</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一个节点不是红黑树，并且还有第二个节点，那就说明，这里是链表了</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 那么开始循环链表，从第二个节点开始循环，因为第一个节点已经处理过了</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断e节点是不是目标节点，是的话就将node指向e，并且终止循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// e节点不是目标节点，那就将p节点指向e节点，</span></span><br><span class="line">                    <span class="comment">// 然后while里面e节点后移，在进入循环后发现e是目标节点了，退出循环，退出后此时p节点还是e节点的前一个节点，也就保证了在整个循环的过程中，p节点始终是e节点的前一个节点。</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);<span class="comment">// e指针后移，并且下一个节点不为null则继续遍历，不为null表示没到链表最后呢。是不是似曾相识的感觉。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到目标节点了</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 如果目标节点是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)&#123;</span><br><span class="line">                <span class="comment">// 调用红黑树的删除节点方法</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 目标节点是p节点，</span></span><br><span class="line">            <span class="comment">// 还记得之前 如果第一个节点p就是目标节点，则将node指向第一个节点p</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)&#123;</span><br><span class="line">                <span class="comment">// 将目标节点的下一个节点作为该索引位置的第一个元素</span></span><br><span class="line">                <span class="comment">// 也就是跳过目标节点，指向目标节点的下一位</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里就是遍历链表找到了目标节点</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 注意 进入到这里 node 其实也是指向 e的，说白了 node 就是 e，下面用node来替代e的登场 </span></span><br><span class="line">                <span class="comment">// p节点始终作为node的上一个节点，p.next始终指向目标节点node</span></span><br><span class="line">                <span class="comment">// 现在将p.next 指向目标节点node的next，这样跳过了目标节点node，就把node移除掉了</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录map结构被修改的次数，主要用于并发编程</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// 记录table存储了多少键值对，因为移除了一个，所以此处就减一，其实用size-- 也一样，不明白为啥非得用 --size</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 该方法在hashMap中是空方法，主要是供LinkedHashMap使用，因为LinkedHashMap重写了该方法</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="comment">//返回被移除的节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到 返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="removeTreeNode"><a href="#removeTreeNode" class="headerlink" title="removeTreeNode"></a>removeTreeNode</h2><p>红黑树的节点移除，还要根据movable判断删除时是否移动其他节点。谁调用该方法就删除谁，</p><p>movable - 如果为false，则在删除时不移动其他节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树的节点移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                          <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    <span class="comment">// --- 链表的处理start ---</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 1.table为空或者length为0直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 2.根据调用者的hash计算出索引的位置，也就是 根据将要被移除的node节点的hash进行计算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    <span class="comment">// 3.first：当前index位置的节点，root：当前index位置的节点，作为根节点，rl：root的左节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.succ：目标节点node.next节点，pred：目标节点node.prev节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="comment">// 5.如果pred节点为空，则代表目标节点node为头节点，</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 则将table索引位置和first都指向succ节点(node.next节点)</span></span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.否则将pred的next属性指向succ节点(node.next节点)</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 这块有一点点饶，主要是因为他这个变量搞得，其实等同于 node.prev.next = node.next;</span></span><br><span class="line">        <span class="comment">// 原来是 pred.next=node-&gt;node.next=succ</span></span><br><span class="line">        <span class="comment">// 现在是 pred.next=      node.next=succ,跳过了node，也就相当于把node删除了</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.如果succ节点(node.next节点)不为空，</span></span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 则将succ.prev(node.next.prev)节点设置为pred(node.prev), 与前面对应</span></span><br><span class="line">        <span class="comment">// 等同于 node.next.prev = node.prev;</span></span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.如果first节点为null，则代表该索引位置没有节点则直接返回</span></span><br><span class="line">    <span class="comment">// 这个if其实可以放在上方第3点后面，第4点前面，因为直接判断索引位置就是null，压根不用在找下个节点</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9.如果root的父节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 则从该root节点开始去查找根节点，得到根节点之后，将root指向真正的根节点</span></span><br><span class="line">        root = root.root();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10.通过root节点来判断此红黑树是否太小, 如果是太小了则调用untreeify方法转为链表节点并返回</span></span><br><span class="line">    <span class="comment">// (转链表后就无需再进行下面的红黑树处理)</span></span><br><span class="line">    <span class="comment">// 太小的判定依据：根节点为null，或者根的右节点为null，或者根的左节点为null，或者根的左节点的左节点为null</span></span><br><span class="line">    <span class="comment">// 是根据节点数来判断的，并没有遍历整个红黑树去统计节点数是否小于等于阈值6</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.right == <span class="literal">null</span> ||</span><br><span class="line">        (rl = root.left) == <span class="literal">null</span> || rl.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --- 链表的处理end ---</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 以下代码为红黑树的处理 ---</span></span><br><span class="line">    <span class="comment">// 11.p：目标节点node，pl：p的左节点，pr：p的右节点，replacement：被删除掉的节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="comment">// 12.如果p的左和右节点都不为空时</span></span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="literal">null</span> &amp;&amp; pr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 12.1 将s指向pr(p的右节点)，sl：s的左节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="comment">// 12.2 向左一直查找，跳出循环时,s为没有左节点的节点</span></span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="literal">null</span>)&#123;</span><br><span class="line">            s = sl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 12.3 交换p节点和s节点的颜色</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> s.red; s.red = p.red; p.red = c;</span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right; <span class="comment">// s的右节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;    <span class="comment">// p的父节点</span></span><br><span class="line">        <span class="comment">// --- 第一次调整和第二次调整：将p节点和s节点进行了位置调换 ---</span></span><br><span class="line">        <span class="comment">// 12.4 第一次调整</span></span><br><span class="line">        <span class="comment">// 如果p的右节点即为s节点，则将p和s交换位置，原先是s.parent = p；p.right = s；</span></span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123;</span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将sp指向s的父节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="comment">// 将sp作为p的父节点</span></span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果s节点为sp的左节点，则将sp的左节点指向p，此时sp的的左节点s变成了p节点</span></span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)&#123;</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则s节点为sp的右节点，则将sp的右节点指向p，此时sp的的右节点s变成了p节点</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    sp.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 完成了p和s的交换位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// s的右节点指向p的右节点</span></span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 如果pr不为空，则将pr的父节点指向s，此时p的右节点变成了s的右节点</span></span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 12.5 第二次调整</span></span><br><span class="line">        <span class="comment">// 将p的左节点赋值为空，pl已经保存了该节点</span></span><br><span class="line">        p.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 将p节点的右节点指向sr，如果sr不为空，则将sr的父节点指向p节点，此时s的右节点变成了p的右节点</span></span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="literal">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="comment">// 将s节点的左节点赋值为pl，如果pl不为空，则将pl的父节点指向s节点，此时p的左节点变成了s的左节点</span></span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="literal">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="comment">// 将s的父节点赋值为p的父节点pp</span></span><br><span class="line">        <span class="comment">// 如果pp为空，则p节点为root节点, 交换后s成为新的root节点</span></span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="literal">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="comment">// 如果p不为root节点, 并且p是pp的左节点，则将pp的左节点赋值为s节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="comment">// 如果p不为root节点, 并且p是pp的右节点，则将pp的右节点赋值为s节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="comment">// 12.6 寻找replacement节点，用来替换掉p节点</span></span><br><span class="line">        <span class="comment">// 12.6.1 如果sr不为空，则replacement节点为sr，因为s没有左节点，所以使用s的右节点来替换p的位置</span></span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="comment">// 12.6.1 如果sr为空，则s为叶子节点，replacement为p本身，只需要将p节点直接去除即可</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 13.承接12点的判断，如果p的左节点不为空，右节点为空，replacement节点为p的左节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="literal">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="comment">// 14.如果p的右节点不为空,左节点为空，replacement节点为p的右节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="literal">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="comment">// 15.如果p的左右节点都为空, 即p为叶子节点, replacement节点为p节点本身</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="comment">// 16.第三次调整：使用replacement节点替换掉p节点的位置，将p节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123; <span class="comment">// 如果p节点不是叶子节点</span></span><br><span class="line">        <span class="comment">// 16.1 将p节点的父节点赋值给replacement节点的父节点, 同时赋值给pp节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="comment">// 16.2 如果p没有父节点, 即p为root节点，则将root节点赋值为replacement节点即可</span></span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="literal">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="comment">// 16.3 如果p不是root节点, 并且p为pp的左节点，则将pp的左节点赋值为替换节点replacement</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="comment">// 16.4 如果p不是root节点, 并且p为pp的右节点，则将pp的右节点赋值为替换节点replacement</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        <span class="comment">// 16.5 p节点的位置已经被完整的替换为replacement, 将p节点清空, 以便垃圾收集器回收</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 17.如果p节点不为红色则进行红黑树删除平衡调整</span></span><br><span class="line">    <span class="comment">// (如果删除的节点是红色则不会破坏红黑树的平衡无需调整)</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 18.如果p节点为叶子节点, 则简单的将p节点去除即可</span></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="comment">// 18.1 将p的parent属性设置为空</span></span><br><span class="line">        p.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 18.2 如果p节点为父节点的左节点，则将父节点的左节点赋值为空</span></span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 18.3 如果p节点为父节点的右节点， 则将父节点的右节点赋值为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        <span class="comment">// 19.将root节点移到索引位置的头节点</span></span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="removeTreeNode-疑问"><a href="#removeTreeNode-疑问" class="headerlink" title="removeTreeNode 疑问"></a>removeTreeNode 疑问</h2><p>第一点：为什么 sr 是 replacement 的首选，p 为备选？</p><blockquote><p>解析：首先我们看 sr 是什么？从代码中可以看到 sr 第一次被赋值时，是在 s 节点进行了向左穷遍历结束后，因此此时 s 节点是没有左节点的，sr 即为 s 节点的右节点。而从上面的第一次调整和第二次调整我们知道，p 节点已经跟 s 节点进行了位置调换，所以此时 sr 其实是 p 节点的右节点，并且 p 节点没有左节点，因此要移除 p 节点，只需要将 p 节点的右节点 sr 覆盖掉 p 节点即可，因此 sr 是 replacement 的首选，而如果 sr 为空，则代表 p 节点为叶子节点，此时将 p 节点直接移除即可。</p></blockquote><p>第二点：关于红黑树的平衡调整？ 这点也是比较难的部分</p><blockquote><p>红黑树的操作涉及的操作比较复杂，三言两语无法说清。有兴趣的可以去单独学习，本文由于篇幅关系暂不详细介绍红黑树的具体操作，在这简单的介绍：红黑树是一种自平衡二叉树，拥有优秀的查询和插入/删除性能，广泛应用于关联数组。</p><p>对比 AVL 树，AVL 要求每个节点的左右子树的高度之差的绝对值（平衡因子）最多为 1，而红黑树通过适当的放低该条件（红黑树限制从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，结果是这个树大致上是平衡的），以此来减少插入/删除时的平衡调整耗时，从而获取更好的性能，而这虽然会导致红黑树的查询会比 AVL 稍慢，但相比插入/删除时获取的时间，这个付出在大多数情况下显然是值得的。</p><p>在 HashMap 中的应用：HashMap 在进行插入和删除时有可能会触发红黑树的插入平衡调整（balanceInsertion 方法）或删除平衡调整（balanceDeletion 方法），调整的方式主要有以下手段：左旋转（rotateLeft 方法）、右旋转（rotateRight 方法）、改变节点颜色（x.red = false、x.red = true），进行调整的原因是为了维持红黑树的数据结构。</p></blockquote><h2 id="removeTreeNode-图解"><a href="#removeTreeNode-图解" class="headerlink" title="removeTreeNode 图解"></a>removeTreeNode 图解</h2><p>本图解忽略红黑树的颜色，请注意。</p><p>下面的图解是代码中的<strong>最复杂</strong>的情况，即流程最长的那个，p 节点不为根节点，p 节点有左右节点，s 节点不为 pr 节点，s 节点有右节点。</p><p>另外，第一次调整和第二次调整的是本人根据代码而设定的，将第一次和第二次调整合起来看会更容易理解（看第1和3两棵树）。</p><p>如下：第一次调整 + 第二次调整：将 p 节点和 s 节点进行了位置调换，选出要替换掉 p 节点的 replacement<br>第三次调整：将 replacement 节点覆盖掉 p 节点。</p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221316.png" alt="img"></p><h2 id="balanceDeletion"><a href="#balanceDeletion" class="headerlink" title="balanceDeletion"></a>balanceDeletion</h2><p>红黑树的删除平衡调整，第一个输入参数是整棵红黑树的根节点，第二个输入参数是待删除节点或是其继承者，搞清楚了输入参数，下面我们就开始分析丧心病狂的balanceDeletion方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                           TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">//注意，传进来的x节点子树的黑节点数，肯定是比x的兄弟节点子树的黑节点数少1</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || x == root)<span class="comment">//如果x是root</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;<span class="comment">//（说明是循环后更新x后，使得x指向了root）但x没有父节点</span></span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;<span class="comment">//如果x不是root(有父节点)，且x为红色（这好办，直接把x变成黑色，让x子树的黑节点+1.多次循环可到达此分支）</span></span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接下来两个分支，x必为黑色</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;<span class="comment">//如果x是xp的左孩子</span></span><br><span class="line">            <span class="keyword">if</span> ((xpr = xp.right) != <span class="literal">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                xpr.red = <span class="literal">false</span>;</span><br><span class="line">                xp.red = <span class="literal">true</span>;</span><br><span class="line">                root = rotateLeft(root, xp);</span><br><span class="line">                xpr = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpr == <span class="literal">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                <span class="keyword">if</span> ((sr == <span class="literal">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                    (sl == <span class="literal">null</span> || !sl.red)) &#123;</span><br><span class="line">                    xpr.red = <span class="literal">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sr == <span class="literal">null</span> || !sr.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sl != <span class="literal">null</span>)</span><br><span class="line">                            sl.red = <span class="literal">false</span>;</span><br><span class="line">                        xpr.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpr);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="literal">null</span> ?</span><br><span class="line">                            <span class="literal">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xpr.red = (xp == <span class="literal">null</span>) ? <span class="literal">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sr = xpr.right) != <span class="literal">null</span>)</span><br><span class="line">                            sr.red = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="literal">false</span>;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// symmetric//如果x是xp的右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (xpl != <span class="literal">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.red = <span class="literal">false</span>;</span><br><span class="line">                xp.red = <span class="literal">true</span>;</span><br><span class="line">                root = rotateRight(root, xp);</span><br><span class="line">                xpl = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//经过上面if，不管它有没有执行，x的兄弟xpl肯定为黑色节点了</span></span><br><span class="line">            <span class="keyword">if</span> (xpl == <span class="literal">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                <span class="comment">//这种情况说明xpl的孩子里没有红色节点</span></span><br><span class="line">                <span class="keyword">if</span> ((sl == <span class="literal">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                    (sr == <span class="literal">null</span> || !sr.red)) &#123;</span><br><span class="line">                    xpl.red = <span class="literal">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="comment">//这种情况说明xpl的孩子里有红色节点</span></span><br><span class="line">                    <span class="comment">//如果sr为红色，则走此分支；sr其他情况则不会</span></span><br><span class="line">                    <span class="keyword">if</span> (sl == <span class="literal">null</span> || !sl.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">                            sr.red = <span class="literal">false</span>;</span><br><span class="line">                        xpl.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpl);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="literal">null</span> ?</span><br><span class="line">                            <span class="literal">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//xpl最终会旋转到之前xp的位置，并保持xp的颜色</span></span><br><span class="line">                        xpl.red = (xp == <span class="literal">null</span>) ? <span class="literal">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sl = xpl.left) != <span class="literal">null</span>)</span><br><span class="line">                            sl.red = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="literal">false</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;<span class="comment">//下一次循环直接返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>提前说明一下，当说到“x节点子树的黑节点数n”是指：从x节点到它的子树的任意一个叶子节点的路径上的黑色节点个数都等于n。</li><li>整个函数是一个循环过程，可能会经过若干次循环。不管是刚调用此函数的第一次循环，或者是以后的循环，每次循环体刚开始时，x节点子树的黑节点数，肯定是比x的兄弟节点子树的黑节点数少1，这是由removeTreeNode函数来做保证的（由于删掉了一个黑色节点，所以黑节点数少1）。<strong>既然知道了x的黑节点数，比x的兄弟节点饿黑节点数少1，那么就需要通过调整来使得平衡。</strong></li><li><code>if (x == null || x == root)</code>分支，如果x是root，则直接返回root。上一次循环执行了<code>x = root</code>后，会进入此分支。</li><li><code>else if ((xp = x.parent) == null)</code>分支，x的父节点xp为null，但xp为null说明x为root，但这样的话则只会进入上面的<code>if (x == null || x == root)</code>分支了，所以我认为此分支不可能进入。</li><li><code>else if (x.red)</code>分支，说明x不是root节点，且x为红色。这好办，直接把x变成黑色，让x的黑节点数+1。这样x的黑节点数就和x的兄弟节点的黑节点数一样了，也就到达了平衡。</li><li>接下来的两个分支，说明x不是root节点，且x为黑色，所以调整过程要稍微复杂一点了。但这两个分支是完全对称的，所以我只会讲一个分支。由于removeTreeNode函数的保证（总是以删除节点的后继作为替换节点，这里后继是指刚好大于删除节点的那个节点），所以调用此函数时，x肯定是xp的右孩子，所以我接下来讲解<code>else if ((xpl = xp.left) == x)</code>的else分支。</li><li>接下来这个大图是整个函数的<code>else if ((xpl = xp.left) == x)</code>的else分支的所有<strong>过程</strong>，每个<strong>过程</strong>都有标号以方便讲解。节点除标明为黑色或者红色外，灰色则代表不清楚此节点的颜色。建议读者对照着大图、源码和本博客同时进行查阅。</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221356.jpg" alt="图片过大，加载失败"></p><ul><li><p><code>if (xpl != null &amp;&amp; xpl.red)</code>这个分支可能执行，可能不执行。</p></li><li><p><strong>如果xpl为红色，那么则会进入此<code>if (xpl != null &amp;&amp; xpl.red)</code>分支</strong>，如下图所示。如果xpl为红色，那么xp和xpl的孩子的颜色都必为黑色节点。而之前说过，刚开始时<strong>x的黑节点数，比x的兄弟节点饿黑节点数少1</strong>，我们假设x的黑节点数为n，那么xpl作为它的兄弟节点，xpl的黑节点数则为n+1，由于xpl是红色的不属于黑色节点，那么可推理出xpl的两个孩子的黑节点数也为n+1。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221451.jpg" alt="在这里插入图片描述"></p></li><li><p><strong>如果xpl为红色，且执行完<code>if (xpl != null &amp;&amp; xpl.red)</code>分支后</strong>，如下图所示。调整后，x的兄弟节点变成了一个黑色节点。对比上下图发现，通过旋转操作后，使得x和一个黑节点数为n+1的黑色节点成为了兄弟。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221455.jpg" alt="在这里插入图片描述"></p></li><li><p><strong>如果xpl为黑色，那么则不会进入此<code>if (xpl != null &amp;&amp; xpl.red)</code>分支</strong>，如下图所示。xpl的黑节点数为n+1，比x多1。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221459.jpg" alt="在这里插入图片描述"></p></li><li><p>对比如果xpl为红色，和如果xpl为黑色的两种情况的最终结果，如下图所示，可以发现两种情况最终结果的共同点是：x的兄弟节点必为黑色，但此时兄弟节点的黑节点数多1，所以还需要调整。而两种情况的差异点是：xp的颜色。这也是后面要执行<code>xpl.red = (xp == null) ? false : xp.red</code>（把xp的颜色赋给xpl）的原因。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221502.jpg" alt="在这里插入图片描述"></p></li><li><p><strong>如果xpl为null，那么则不会进入此<code>if (xpl != null &amp;&amp; xpl.red)</code>分支</strong>，如下图所示。我认为此分支不可能进入。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221504.jpg" alt="在这里插入图片描述"></p></li><li><p>接下来讲解<code>if (xpl == null)</code>的else分支里的逻辑（根据上一条分析，所以是认为不可能进入<code>if (xpl == null)</code>分支的），在大图中是虚线以下的过程。</p></li><li><p>虚线下的过程，只能操作到x节点，xp节点（x的父节点），xpl节点（x的兄弟节点），sl节点（x的兄弟节点的左孩子）和sr节点（x的兄弟节点的右孩子），即只能操作这上下三层节点。这也是为什么虚线上的过程最后总会调整为xpl节点为黑色节点的情况，因为这样的话，xpl节点的两个孩子sl和sr的黑节点数就为n，而x节点本身的黑节点数也为n。只有找到了黑节点数都为n的节点们后，才方便进行调整，那之后就根据各种情况来再平衡就好了。</p></li><li><p><code>if (xpl == null)</code>的else分支的初始状态如下图（注意，此初始状态是从过程(4)(4)(4)而来的，所以虚线下的过程都是过程(4)(4)(4)接下来的过程。其实还可以画出从过程(6)(6)(6)而来的初始状态，但不必画出了）。由于xpl的黑节点数为n+1，则它自身为黑色，所以推理出，它的左右孩子的黑节点则为n。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221510.jpg" alt="在这里插入图片描述"></p></li><li><p>很有必要说明一下<code>if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red))</code>分支和它的else分支的各种情况，如下图所示，它的else分支里，sl和sr中必有一个节点是红色的。而且在else分支里，当sr为红色时，必然还会进入<code>if (sl == null || !sl.red)</code>子分支。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221514.jpg" alt="在这里插入图片描述"></p></li><li><p>如果进入了<code>if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red))</code>分支，如下图所示。那么说明“sl为null或sl为黑色”和“sr为null或sr为黑色”这两件事都成立，可见过程(8)(8)(8)时，x的兄弟节点的两个孩子都是黑色节点，这样的话根本没有操作空间使得x和x的兄弟节点平衡（但凡x的兄弟节点的两个孩子有一个红色节点，也不至于这样）。过程(9)(9)(9)里，所以只好另xpl为红色，这样xpl和它的兄弟节点平衡了（黑节点数一样），但由于这里是通过让xpl的黑节点数少1来使得平衡的，且xp的颜色我们又没有变过（<strong>这里考虑了虚线上的两种情况的差异点，即xp刚开始的颜色都有可能</strong>），所以不管xp的初始颜色是什么，xp必然比xp的兄弟节点的黑节点数少1，所以还是不平衡的，然后继续循环。如果考虑xp初始为黑色，那么过程(9)(9)(9)里，xp的黑节点数为n+1，xp的兄弟节点的黑节点数为n+2。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221518.jpg" alt="在这里插入图片描述"></p></li><li><p>如果进入了<code>if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red))</code>的else分支，如下图所示。那么说明“sl为null或sl为黑色”和“sr为null或sr为黑色”这两件事不是都成立的。观察逻辑可以发现，else分支里可以分为两种情况：1.如果sr为红色，此时不管sl的颜色。 2.如果sr为黑色，sl为红色。其实这两种情况的共同点就是sr和sl中至少有一个红色节点了。</p></li><li><p>假设情况为“如果sr为红色，此时不管sl的颜色”，因为此时sl的颜色无论为什么对过程不会有影响。如下图所示，为这种情况的开始过程和结束过程。发现过程(16)(16)(16)时，整个树已经平衡了，结束后会将x指向root（<code>x = root</code>），下次循环就会直接退出啦。且过程(10)(10)(10)里xp这个位置，对应到过程(16)(16)(16)里则变成了xpl这个节点，且过程(10)(10)(10)里xp的颜色还可能为黑色，那么过程(16)(16)(16)的xpl会和过程(10)(10)(10)里xp的颜色一致（虚线下的三行过程都保证了这一点）。这是通过将xp的颜色赋给xpl（<code>xpl.red = (xp == null) ? false : xp.red</code>），再右旋xp（<code>rotateRight(root, xp)</code>）来保证的，这样，就把虚线上的差异点考虑在内了。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221523.jpg" alt="在这里插入图片描述"></p></li><li><p>再假设情况为“如果sr为黑色，sl为红色”，如下图所示，为这种情况的开始过程和结束过程。发现过程(20)(20)(20)时，整个树已经平衡了，结束后会将x指向root（<code>x = root</code>），下次循环就会直接退出啦。同样的，过程(17)(17)(17)里xp这个位置对应过过程(20)(20)(20)里会保持相同位置的节点颜色一致。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221536.jpg" alt="在这里插入图片描述"></p></li><li><p>虚线下的第二行过程（过程(10)(10)(10)到过程(16)(16)(16)）和第三行过程（过程(17)(17)(17)到过程(20)(20)(20)），除了开始过程和结束过程外，中间过程里我只给那些调整过程中黑节点数不变的节点标注出来了黑节点数，其他没有标注出来的节点只需要在结束过程里进行确认就好了。</p></li><li><p>之所以虚线下的第二行过程和第三行过程要进行区分，是因为sr是否为红色，需要进行的调整操作是不一样的。比如过程过程(10)(10)(10)如果走的是第三行过程的流程，如下图所示，最终会造成sl和xp这两个兄弟节点不是平衡的。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221542.jpg" alt="在这里插入图片描述"></p></li></ul><p>总结一下：</p><ul><li>和balanceInsertion一样，此balanceDeletion函数同样只处理三层树的结构。</li><li>每次循环体里，除非进入那些直接return的终点，那么循环体开始时，x节点总是比x节点的兄弟节点的黑节点数少1的。</li><li>虚线下的过程，其主要技巧(指的是虚线下第二行和第三行。第一行是先让自己和兄弟平衡，但却是通过不是让自己加1，而是让兄弟减1，所以还需要x往上移动，往更高层借红色节点)是通过借用颜色为红色的兄弟节点的左右孩子，只要有一个孩子是红色的，就可以借用。而借用其实就是，通过旋转操作把红色节点弄到自己的子树里，然后通过红色变黑色，让自己子树的黑节点数加1，从达到平衡。</li><li>大图中，到达虚线时的过程，x的兄弟节点总会是黑色的。根据前提“x节点总是比x节点的兄弟节点的黑节点数少1”，而兄弟节点又是黑色，可以推理出“x的兄弟节点的两个孩子的黑节点数，和x节点一样大”，找到了一样大的节点，之后才好处理。</li></ul><h2 id="rotateLeft-左旋"><a href="#rotateLeft-左旋" class="headerlink" title="rotateLeft 左旋"></a>rotateLeft 左旋</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221603.webp" alt="img"></p><p>p：图示中的 E，r：图示中的 S</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 图示中的 E，r 图示中的 S</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (r = p.right) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 3 结点的中间部分挂在左节点 p（原始父节点）下</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="literal">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将红链接中的右节点 r（原始子节点）上移，左节点（原始父节点）下移为右节点的子节点</span></span><br><span class="line">        <span class="comment">// 子树（可能是包含根节点的完整二叉树）在父节点 pp 中的位置保持不变</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">            (root = r).red = <span class="literal">false</span>;<span class="comment">// 原始父节点即为根节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父子节点反转</span></span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始状态下：<code>r</code>为<code>p</code>的right child、<code>pp</code>为<code>p</code>的parent、<code>rl</code>为<code>r</code>的left child。</li><li><code>p</code>为rotateLeft函数要处理那个的节点。作为此函数的入参，一般认为<code>p</code>必有一个right child，即认为<code>if (p != null &amp;&amp; (r = p.right) != null)</code>分支一定能进入。</li><li><code>if ((rl = p.right = r.left) != null) rl.parent = p;</code>中，我们先认为<code>r.left</code>肯定不为null（其实无论它为不为null对旋转结果都没有影响，后面会讲到），那么把这一句拆成<code>rl = r.left</code>和<code>p.right = rl</code>，其过程如下图所示。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221613.jpg" alt="在这里插入图片描述"></li><li>示意图中，节点无颜色代表并不关心该节点的颜色，黑色箭头为左右孩子指针，绿色箭头为父亲指针。刚改变过指向的指针会用太阳标志标识出来。</li><li>接下来的if else嵌套有三个分支，这里不按照代码顺序分析，先假设程序会进入<code>else if (pp.left == p)</code>分支，此时说明之前的if分支没有进入，即<code>pp</code>不为null，<strong>且<code>p</code>为<code>pp</code>的左孩子</strong>。这里我们把<code>pp = r.parent = p.parent</code>拆分为<code>pp = p.parent</code>和<code>r.parent = pp</code>。这样，从<code>r.parent = pp</code>开始执行到最后的示意图如下：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221618.jpg" alt="在这里插入图片描述"></li><li>再假设程序会进入最后的<code>else</code>分支，说明<code>pp</code>不为null，<strong>且<code>p</code>为<code>pp</code>的右孩子</strong>。同样的，我们把<code>pp = r.parent = p.parent</code>拆分为<code>pp = p.parent</code>和<code>r.parent = pp</code>。这样，从<code>r.parent = pp</code>开始执行到最后的示意图如下：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221637.jpg" alt="在这里插入图片描述"></li><li>最后再假设程序会进入<code>if ((pp = r.parent = p.parent) == null)</code>分支，<strong>说明<code>pp</code>为null</strong>。同样的，我们把<code>pp = r.parent = p.parent</code>拆分为<code>pp = p.parent</code>和<code>r.parent = pp</code>。但进入这个分支说明<code>pp</code>为null，这样，从<code>r.parent = pp</code>（实际是<code>r.parent = null</code>）开始执行到最后的示意图如下：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221643.jpg" alt="在这里插入图片描述"></li><li>此函数并不关心旋转后红黑树是否平衡，它只负责完成旋转的任务，所以，是此函数的调用者负责维持平衡。</li><li>此函数的完整流程示意图如下。将三种情况对比分析后，可以发现，第4步和第5步都是为了处理好<code>pp</code>和<code>r</code>之间的连接，<code>pp</code>作为<code>p</code>的父节点，是整个旋转部分的上层，旋转后<code>pp</code>还是会与下层保持相同的孩子关系（原来<code>p</code>是<code>pp</code>的什么孩子，现在<code>r</code>就会是<code>pp</code>的什么孩子）（第三种情况由于<code>pp</code>为null，所以就不用处理<code>pp</code>和<code>r</code>之间的连接）。</li><li>第6步和第7步都是为了完成旋转的后半部分，即处理好<code>p</code>与<code>r</code>之间的连接，让<code>p</code>成为<code>r</code>的左孩子，完成左旋的任务。由于之前（第4、5步）已经处理好了<code>p</code>的父节点<code>pp</code>的孩子关系，所以可以改变<code>p.parent</code>了（反过来想，如果先执行第6、7步再执行第4、5步会导致<code>pp</code>节点再也找不到了，因为第7步会改变<code>p.parent</code>）。</li><li>第3步都是为了完成旋转的前半部分，即处理好<code>p</code>与<code>rl</code>之间的连接，让<code>rl</code>成为<code>p</code>的右孩子。</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221651.jpg" alt="在这里插入图片描述"></p><ul><li>若将最终旋转的结果总结一下，再忽略掉<code>pp</code>节点（因为<code>pp</code>节点其实不属于旋转部分，它只是等旋转好了以后再与新的旋转部分维持相同的孩子关系），可得出如下示意图。可以发现这种旋转十分巧妙，旋转后<code>p</code>节点的左孩子不会受到影响、<code>r</code>节点的右孩子不会受到影响、<code>rl</code>节点的左右孩子都不会受到影响。</li><li><code>r.left</code>是否存在，对旋转结果也不会产生本质影响。它只是会让<code>p</code>节点的右孩子为null。</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221701.jpg" alt="在这里插入图片描述"></p><h2 id="rotateRight-右旋"><a href="#rotateRight-右旋" class="headerlink" title="rotateRight 右旋"></a>rotateRight 右旋</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221706.webp" alt="img"></p><p>p：图示中的 S，l：图示中的 E</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p 图示中的 S，l 图示中的 E</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (l = p.left) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 3 结点的中间部分挂在右节点 p（原始父节点）下</span></span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="literal">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将红链接中的左节点 l（原始子节点）上移，右节点（原始父节点）下移为左节点的子节点</span></span><br><span class="line">        <span class="comment">// 子树（可能是包含根节点的完整二叉树）在父节点 pp 中的位置保持不变</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">            (root = l).red = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父子节点反转</span></span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>初始状态下：<code>l</code>为<code>p</code>的left child、<code>pp</code>为<code>p</code>的parent、<code>lr</code>为<code>l</code>的right child。</li><li>由于右旋和左旋完全类似，分析过程完全和上面章节类似，所以接下来只做重要讲解。</li><li><code>if ((lr = p.left = l.right) != null)</code>分支：<code>lr = p.left = l.right</code>拆分为<code>lr = l.right</code>和<code>p.left = lr</code>，然后接下来执行<code>lr.parent = p</code>。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221713.jpg" alt="在这里插入图片描述"></li><li>将<code>pp = l.parent = p.parent</code>拆分为<code>pp = p.parent</code>和<code>l.parent = pp</code>。</li><li>先假设进入最后的<code>else</code>分支（代表<code>pp.left == p</code>成立），示意图如下：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221719.jpg" alt="在这里插入图片描述"></li><li>再假设进入<code>else if (pp.right == p)</code>分支，示意图如下：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221730.jpg" alt="在这里插入图片描述"></li><li>最后假设进入<code>if ((pp = l.parent = p.parent) == null)</code>分支，示意图如下：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221800.jpg" alt="在这里插入图片描述"></li><li>完整流程示意图：</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221833.jpg" alt="在这里插入图片描述"></p><ul><li>右旋总结示意图：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221846.jpg" alt="在这里插入图片描述"></li></ul><h2 id="左旋右旋总结"><a href="#左旋右旋总结" class="headerlink" title="左旋右旋总结"></a>左旋右旋总结</h2><ul><li>不管是左旋还是右旋，<code>pp</code>节点其实都不算是旋转的部分，因为在旋转后，它只是与新的旋转部分保持相同的孩子关系。</li><li>从左旋、右旋的总结示意图里可以看出，没有画出来的子树部分之所以不用画，是因为在旋转后子树会保持相同的相对位置。比如，左旋总结示意图中：<code>p</code>的左子树还会是<code>p</code>的左子树，<code>r</code>的右子树还会是<code>r</code>的右子树。右旋总结示意图中：<code>p</code>的右子树还会是<code>p</code>的右子树，<code>l</code>的左子树还会是<code>l</code>的左子树。</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">__°ゝ 浮华 つ __</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lixiaogou.gitee.io/posts/60ecd9a6f387/">http://lixiaogou.gitee.io/posts/60ecd9a6f387/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lixiaogou.gitee.io" target="_blank">__°ゝ 浮华 つ __</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://pic.3gbizhi.com/2021/0924/20210924105944980.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/7eb995c6defb/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/o_201126142701street_race.jpg" onerror='onerror=null,src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第 3 章：稀疏数组和队列</div></div></a></div><div class="next-post pull-right"><a href="/posts/0330077f5cdb/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/bg14.jpg" onerror='onerror=null,src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Collection家族</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/0330077f5cdb/" title="Collection家族"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/bg14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-22</div><div class="title">Collection家族</div></div></a></div><div><a href="/posts/0207dc17c3c9/" title="布隆过滤器"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/bg14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-22</div><div class="title">布隆过滤器</div></div></a></div><div><a href="/posts/cf4ad7ff29a0/" title="Java并发容器和框架"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/bg14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-27</div><div class="title">Java并发容器和框架</div></div></a></div><div><a href="/posts/c230cf270419/" title="第 11 章 树结构实际应用【1、 堆排序】"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.imgdb.cn/item/5f674e17160a154a67ffd8b8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-25</div><div class="title">第 11 章 树结构实际应用【1、 堆排序】</div></div></a></div><div><a href="/posts/7eb995c6defb/" title="第 3 章：稀疏数组和队列"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/o_201126142701street_race.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-29</div><div class="title">第 3 章：稀疏数组和队列</div></div></a></div><div><a href="/posts/da24c4185170/" title="第 9 章 哈希表"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.3gbizhi.com/2021/0923/20210923085728945.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-16</div><div class="title">第 9 章 哈希表</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/moyuyu.gif" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">__°ゝ 浮华 つ __</div><div class="author-info__description">乘风破浪会有时，直挂云帆济沧海</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">65</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/lixiaogou"><i class="iconfont icon-gitee"></i><span>码云</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lixiaolong6881644" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/lixiaogou" target="_blank" title="iconfont icon-gitee"><i class="iconfont icon-gitee"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">HashMap源码分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap%E7%AE%80%E4%BB%8B"><span class="toc-number">2.</span> <span class="toc-text">HashMap简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8API"><span class="toc-number">3.</span> <span class="toc-text">HashMap主要使用API</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">HashMap的属性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">无参构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.</span> <span class="toc-text">带初始容量的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">带初始容量和负载因子的构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6Map%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.4.</span> <span class="toc-text">带Map的构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#putMapEntries"><span class="toc-number">5.4.1.</span> <span class="toc-text">putMapEntries</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#resize-%E6%89%A9%E5%AE%B9"><span class="toc-number">5.4.2.</span> <span class="toc-text">resize 扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e-hash-amp-oldCap-0-%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-number">5.4.3.</span> <span class="toc-text">e.hash &amp; oldCap &#x3D;&#x3D; 0 的解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#split-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%8B%86%E5%88%86"><span class="toc-number">5.4.4.</span> <span class="toc-text">split 红黑树的拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#treeify"><span class="toc-number">5.4.5.</span> <span class="toc-text">treeify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tieBreakOrder"><span class="toc-number">5.4.6.</span> <span class="toc-text">tieBreakOrder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#balanceInsertion"><span class="toc-number">5.4.7.</span> <span class="toc-text">balanceInsertion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#moveRootToFront"><span class="toc-number">5.4.8.</span> <span class="toc-text">moveRootToFront</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#checkInvariants"><span class="toc-number">5.4.9.</span> <span class="toc-text">checkInvariants</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#untreeify"><span class="toc-number">5.4.10.</span> <span class="toc-text">untreeify</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">6.</span> <span class="toc-text">添加元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#put%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">6.1.</span> <span class="toc-text">put流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#put"><span class="toc-number">6.2.</span> <span class="toc-text">put</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash-%E2%80%93-%E8%AE%A1%E7%AE%97-key-%E7%9A%84-hash-%E5%80%BC"><span class="toc-number">6.3.</span> <span class="toc-text">hash – 计算 key 的 hash 值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash%E5%B8%B8%E8%A7%81%E7%96%91%E6%83%91"><span class="toc-number">6.4.</span> <span class="toc-text">hash常见疑惑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#putVal"><span class="toc-number">6.5.</span> <span class="toc-text">putVal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#putTreeVal"><span class="toc-number">6.6.</span> <span class="toc-text">putTreeVal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#root"><span class="toc-number">6.7.</span> <span class="toc-text">root</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#find"><span class="toc-number">6.8.</span> <span class="toc-text">find</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#treeifyBin"><span class="toc-number">6.9.</span> <span class="toc-text">treeifyBin</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">7.</span> <span class="toc-text">查找元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#get"><span class="toc-number">7.1.</span> <span class="toc-text">get</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getNode"><span class="toc-number">7.2.</span> <span class="toc-text">getNode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getTreeNode"><span class="toc-number">7.3.</span> <span class="toc-text">getTreeNode</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A4%E6%96%ADkey%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">8.</span> <span class="toc-text">判断key是否存在</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#containsKey"><span class="toc-number">8.1.</span> <span class="toc-text">containsKey</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A4%E6%96%ADvalue%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-number">9.</span> <span class="toc-text">判断value是否存在</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#containsValue"><span class="toc-number">9.1.</span> <span class="toc-text">containsValue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">10.</span> <span class="toc-text">删除元素</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#remove-Object-key"><span class="toc-number">10.1.</span> <span class="toc-text">remove(Object key)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#removeNode"><span class="toc-number">10.2.</span> <span class="toc-text">removeNode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#removeTreeNode"><span class="toc-number">10.3.</span> <span class="toc-text">removeTreeNode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#removeTreeNode-%E7%96%91%E9%97%AE"><span class="toc-number">10.4.</span> <span class="toc-text">removeTreeNode 疑问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#removeTreeNode-%E5%9B%BE%E8%A7%A3"><span class="toc-number">10.5.</span> <span class="toc-text">removeTreeNode 图解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#balanceDeletion"><span class="toc-number">10.6.</span> <span class="toc-text">balanceDeletion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rotateLeft-%E5%B7%A6%E6%97%8B"><span class="toc-number">10.7.</span> <span class="toc-text">rotateLeft 左旋</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rotateRight-%E5%8F%B3%E6%97%8B"><span class="toc-number">10.8.</span> <span class="toc-text">rotateRight 右旋</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E5%8F%B3%E6%97%8B%E6%80%BB%E7%BB%93"><span class="toc-number">10.9.</span> <span class="toc-text">左旋右旋总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/6928685461da/" title="Synchronized锁升级过程"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/o_201126142701street_race.jpg" onerror='this.onerror=null,this.src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="Synchronized锁升级过程"></a><div class="content"><a class="title" href="/posts/6928685461da/" title="Synchronized锁升级过程">Synchronized锁升级过程</a><time datetime="2022-12-08T11:59:00.000Z" title="发表于 2022-12-08 19:59:00">2022-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/fd89fdb9ba19/" title="Hello World"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E8%8A%88%E6%9C%88-%E7%99%BD%E6%99%B6%E6%99%B6.jpg" onerror='this.onerror=null,this.src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="Hello World"></a><div class="content"><a class="title" href="/posts/fd89fdb9ba19/" title="Hello World">Hello World</a><time datetime="2022-12-05T07:44:36.376Z" title="发表于 2022-12-05 15:44:36">2022-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4cb61cd5a8db/" title="Redis数据结构和常用指令"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.3gbizhi.com/2021/0924/20210924105944980.jpg" onerror='this.onerror=null,this.src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="Redis数据结构和常用指令"></a><div class="content"><a class="title" href="/posts/4cb61cd5a8db/" title="Redis数据结构和常用指令">Redis数据结构和常用指令</a><time datetime="2022-09-23T03:50:00.000Z" title="发表于 2022-09-23 11:50:00">2022-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7a9e447fda95/" title="千万别再说redis是单线程了"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.3gbizhi.com/2021/0924/20210924105944980.jpg" onerror='this.onerror=null,this.src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="千万别再说redis是单线程了"></a><div class="content"><a class="title" href="/posts/7a9e447fda95/" title="千万别再说redis是单线程了">千万别再说redis是单线程了</a><time datetime="2022-09-23T03:00:00.000Z" title="发表于 2022-09-23 11:00:00">2022-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/96ac81e9dffc/" title="HashTable新增元素源码分析"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E7%99%BD%E4%B8%9D%E8%A2%9C%20%E5%A5%B3%E4%BB%863.jpg" onerror='this.onerror=null,this.src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="HashTable新增元素源码分析"></a><div class="content"><a class="title" href="/posts/96ac81e9dffc/" title="HashTable新增元素源码分析">HashTable新增元素源码分析</a><time datetime="2022-04-18T16:00:00.000Z" title="发表于 2022-04-19 00:00:00">2022-04-19</time></div></div></div></div></div></div></main><footer id="footer" style="background:#000"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 <i id="heartbeat" class="fa fas fa-heartbeat"></i> __°ゝ 浮华 つ __</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">乘风破浪会有时，直挂云帆济沧海</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="卧槽,🐂🍺,666" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>