<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>第 7 章 排序算法 | __°ゝ 浮华 つ __</title><meta name="keywords" content="Java,算法"><meta name="author" content="__°ゝ 浮华 つ __"><meta name="copyright" content="__°ゝ 浮华 つ __"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第 7 章 排序算法1、排序算法介绍1.1、排序算法的简介 排序也称排序算法(Sort Algorithm)， 排序是将一组数据， 依指定的顺序进行排列的过程。  1.2、排序算法的分类 内部排序：指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。 外部排序法：数据量过大， 无法全部加载到内存中， 需要借助外部存储(文件等)进行排序。 常见的排序算法分类   2、算法的复杂度2.1、时间"><meta property="og:type" content="article"><meta property="og:title" content="第 7 章 排序算法"><meta property="og:url" content="http://lixiaogou.gitee.io/posts/92e9d7099040/index.html"><meta property="og:site_name" content="__°ゝ 浮华 つ __"><meta property="og:description" content="第 7 章 排序算法1、排序算法介绍1.1、排序算法的简介 排序也称排序算法(Sort Algorithm)， 排序是将一组数据， 依指定的顺序进行排列的过程。  1.2、排序算法的分类 内部排序：指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。 外部排序法：数据量过大， 无法全部加载到内存中， 需要借助外部存储(文件等)进行排序。 常见的排序算法分类   2、算法的复杂度2.1、时间"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://pic.imgdb.cn/item/6188cfa22ab3f51d91ef1890.jpg"><meta property="article:published_time" content="2021-11-07T16:00:00.000Z"><meta property="article:modified_time" content="2022-12-05T07:44:36.393Z"><meta property="article:author" content="__°ゝ 浮华 つ __"><meta property="article:tag" content="Java"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://pic.imgdb.cn/item/6188cfa22ab3f51d91ef1890.jpg"><link rel="shortcut icon" href="http://yiguan-main.oss-cn-beijing.aliyuncs.com/tms/2020-08/1597503441421.jpg"><link rel="canonical" href="http://lixiaogou.gitee.io/posts/92e9d7099040/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta><meta><meta><meta><meta><meta><meta><meta><meta><meta><meta><meta><meta><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-right"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"第 7 章 排序算法",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2022-12-05 15:44:36"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/moyuyu.gif" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://pic.imgdb.cn/item/6188cfa22ab3f51d91ef1890.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">__°ゝ 浮华 つ __</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">第 7 章 排序算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-07T16:00:00.000Z" title="发表于 2021-11-08 00:00:00">2021-11-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-05T07:44:36.393Z" title="更新于 2022-12-05 15:44:36">2022-12-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">java数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="第 7 章 排序算法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="第-7-章-排序算法"><a href="#第-7-章-排序算法" class="headerlink" title="第 7 章 排序算法"></a>第 7 章 排序算法</h1><h2 id="1、排序算法介绍"><a href="#1、排序算法介绍" class="headerlink" title="1、排序算法介绍"></a>1、排序算法介绍</h2><h3 id="1-1、排序算法的简介"><a href="#1-1、排序算法的简介" class="headerlink" title="1.1、排序算法的简介"></a>1.1、排序算法的简介</h3><ul><li>排序也称排序算法(Sort Algorithm)， 排序是将一组数据， 依指定的顺序进行排列的过程。</li></ul><h3 id="1-2、排序算法的分类"><a href="#1-2、排序算法的分类" class="headerlink" title="1.2、排序算法的分类"></a>1.2、排序算法的分类</h3><ul><li><strong>内部排序</strong>：指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。</li><li><strong>外部排序法</strong>：数据量过大， 无法全部加载到内存中， 需要借助外部存储(文件等)进行排序。</li><li>常见的排序算法分类</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIxMjE5NTM4LnBuZw?x-oss-process=image/format,png" alt="image-20200714221219538"></p><h2 id="2、算法的复杂度"><a href="#2、算法的复杂度" class="headerlink" title="2、算法的复杂度"></a>2、算法的复杂度</h2><h3 id="2-1、时间复杂度的度量方法"><a href="#2-1、时间复杂度的度量方法" class="headerlink" title="2.1、时间复杂度的度量方法"></a>2.1、时间复杂度的度量方法</h3><ul><li>事后统计的方法：这种方法可行, 但是有两个问题：<ul><li>一是要想对设计的算法的运行性能进行评测， 需要实际运行该程序；</li><li>二是所得时间的统计量依赖于计算机的硬件、 软件等环境因素, 这种方式， 要在同一台计算机的相同状态下运行， 才能比较哪个算法速度更快。</li></ul></li><li>事前估算的方法：通过分析某个算法的时间复杂度来判断哪个算法更优</li></ul><h3 id="2-2、时间频度"><a href="#2-2、时间频度" class="headerlink" title="2.2、时间频度"></a>2.2、时间频度</h3><ul><li>基本介绍时间频度： 一个算法花费的时间与算法中语句的执行次数成正比例， 哪个算法中语句执行次数多， 它花费时间就多。 一个算法中的语句执行次数称为语句频度或时间频度。 记为 T(n)。 [举例说明]</li><li>举例说明-基本案例：比如计算 1-100 所有数字之和，我们设计两种算法：</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIxMzUyNjIzLnBuZw?x-oss-process=image/format,png" alt="image-20200714221352623"></p><ul><li>举例说明-忽略常数项：<ul><li>2n+20 和 2n 随着 n 变大， 执行曲线无限接近, 20 可以忽略</li><li>3n+10 和 3n 随着 n 变大， 执行曲线无限接近, 10 可以忽略</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIxNDA0MzY3LnBuZw?x-oss-process=image/format,png" alt="image-20200714221404367"></p><ul><li>举例说明-忽略低次项：<ul><li>2n^2+3n+10 和 2n^2 随着 n 变大, 执行曲线无限接近, 可以忽略 3n+10</li><li>n^2+5n+20 和 n^2 随着 n 变大,执行曲线无限接近, 可以忽略 5n+20</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIxNDQxMzM1LnBuZw?x-oss-process=image/format,png" alt="image-20200714221441335"></p><ul><li>举例说明-忽略系数：<ul><li>随着 n 值变大， 5n^2+7n 和 3n^2 + 2n ， 执行曲线重合, 说明 这种情况下, 5 和 3 可以忽略。</li><li>而 n^3+5n 和 6n^3+4n ， 执行曲线分离， 说明多少次方式关键</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIxNTI5MTc1LnBuZw?x-oss-process=image/format,png" alt="image-20200714221529175"></p><h3 id="2-3、时间复杂度"><a href="#2-3、时间复杂度" class="headerlink" title="2.3、时间复杂度"></a>2.3、时间复杂度</h3><ul><li>一般情况下， 算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数， 用 T(n)表示， 若有某个辅助函数 f(n)， 使得当 n 趋近于无穷大时， T(n) / f(n) 的极限值为不等于零的常数， 则称 f(n)是 T(n)<br>的同数量级函数。记作 T(n)=Ｏ ( f(n) )， 称Ｏ ( f(n) ) 为算法的渐进时间复杂度， 简称时间复杂度。</li><li>T(n) 不同， 但时间复杂度可能相同。 如： T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同， 但时间复杂度相同， 都为 O(n²)。</li><li>计算时间复杂度的方法：<ul><li>用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1</li><li>修改后的运行次数函数中， 只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n²</li><li>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li></ul></li></ul><h3 id="2-4、常见的时间复杂度"><a href="#2-4、常见的时间复杂度" class="headerlink" title="2.4、常见的时间复杂度"></a>2.4、常见的时间复杂度</h3><h4 id="2-4-1、常见时间复杂度概述"><a href="#2-4-1、常见时间复杂度概述" class="headerlink" title="2.4.1、常见时间复杂度概述"></a>2.4.1、常见时间复杂度概述</h4><ul><li>常见时间复杂度<ul><li>常数阶 O(1)</li><li>对数阶 O(log2n)</li><li>线性阶 O(n)</li><li>线性对数阶 O(nlog2n)</li><li>平方阶 O(n^2)</li><li>立方阶 O(n^3)</li><li>k 次方阶 O(n^k)</li><li>指数阶 O(2^n)</li></ul></li><li>结论：<ul><li>常见的算法时间复杂度由小到大依次为： Ο (1)＜Ο (log2n)＜Ο (n)＜Ο (nlog2n)＜Ο (n2)＜Ο (n3)＜ Ο (nk) ＜ Ο (2n) ， 随着问题规模 n 的不断增大， 上述时间复杂度不断增大，<br>算法的执行效率越低</li><li>从图中可见， 我们应该尽可能避免使用指数阶的算法</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIyNDE0NjY5LnBuZw?x-oss-process=image/format,png" alt="image-20200714222414669"></p><h4 id="2-4-2、常数阶-O-1"><a href="#2-4-2、常数阶-O-1" class="headerlink" title="2.4.2、常数阶 O(1)"></a>2.4.2、常数阶 O(1)</h4><ul><li>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</li><li>代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzMTM3NzU5LnBuZw?x-oss-process=image/format,png" alt="image-20200714223137759"></p><h4 id="2-4-3、对数阶-O-log2n"><a href="#2-4-3、对数阶-O-log2n" class="headerlink" title="2.4.3、对数阶 O(log2n)"></a>2.4.3、对数阶 O(log2n)</h4><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzMjQ0MzgyLnBuZw?x-oss-process=image/format,png" alt="image-20200714223244382"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzMjI1NjA5LnBuZw?x-oss-process=image/format,png" alt="image-20200714223225609"></p><h4 id="2-4-4、线性阶-O-n"><a href="#2-4-4、线性阶-O-n" class="headerlink" title="2.4.4、线性阶 O(n)"></a>2.4.4、线性阶 O(n)</h4><ul><li><strong>说明</strong>：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzMjU1Mjg4LnBuZw?x-oss-process=image/format,png" alt="image-20200714223255288"></p><h4 id="2-4-5、线性对数阶-O-nlogN"><a href="#2-4-5、线性对数阶-O-nlogN" class="headerlink" title="2.4.5、线性对数阶 O(nlogN)"></a>2.4.5、线性对数阶 O(nlogN)</h4><ul><li><strong>说明</strong>：线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzMzExNDcyLnBuZw?x-oss-process=image/format,png" alt="image-20200714223311472"></p><h4 id="2-4-6、平方阶-O-n²"><a href="#2-4-6、平方阶-O-n²" class="headerlink" title="2.4.6、平方阶 O(n²)"></a>2.4.6、平方阶 O(n²)</h4><ul><li><strong>说明</strong>：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n<em>n)，即 O(n²)<br>如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m</em>n)</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzMzI5MjU0LnBuZw?x-oss-process=image/format,png" alt="image-20200714223329254"></p><h4 id="2-4-7、其他阶"><a href="#2-4-7、其他阶" class="headerlink" title="2.4.7、其他阶"></a>2.4.7、其他阶</h4><ul><li>立方阶 O(n³)、 K 次方阶 O(n^k)</li><li>说明： 参考上面的 O(n²) 去理解就好了， O(n³)相当于三层 n 循环， 其它的类似</li></ul><h3 id="2-5、平均和最坏时间复杂度"><a href="#2-5、平均和最坏时间复杂度" class="headerlink" title="2.5、平均和最坏时间复杂度"></a>2.5、平均和最坏时间复杂度</h3><ul><li>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下， 该算法的运行时间。</li><li>最坏情况下的时间复杂度称最坏时间复杂度。 一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是： 最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限， 这就保证了算法的运行时间不会比最坏情况更长。</li><li>平均时间复杂度和最坏时间复杂度是否一致， 和算法有关(如图)。</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzNjE2NDM2LnBuZw?x-oss-process=image/format,png" alt="image-20200714223616436"></p><h3 id="2-6、算法的空间复杂度"><a href="#2-6、算法的空间复杂度" class="headerlink" title="2.6、算法的空间复杂度"></a>2.6、算法的空间复杂度</h3><ul><li>类似于时间复杂度的讨论， 一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间， 它也是问题规模 n 的函数。</li><li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。 有的算法需要占用的临时工作单元数与解决问题的规模 n 有关， 它随着 n 的增大而增大， 当 n 较大时， 将占用较多的存储单元，<br>例如快速排序和归并排序算法, 基数排序就属于这种情况</li><li>在做算法分析时， 主要讨论的是时间复杂度。 从用户使用体验上看， 更看重的程序执行的速度。 一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间</li></ul><h2 id="3、冒泡排序"><a href="#3、冒泡排序" class="headerlink" title="3、冒泡排序"></a>3、冒泡排序</h2><h3 id="3-1、基本介绍"><a href="#3-1、基本介绍" class="headerlink" title="3.1、基本介绍"></a>3.1、基本介绍</h3><ul><li>冒泡排序（Bubble Sorting） 的基本思想是： <strong>通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值， 若发现逆序则交换， 使值较大的元素逐渐从前移向后部， 就象水底下的气泡一样逐渐向上冒。</strong></li><li>优化：因为排序的过程中， 各元素不断接近自己的位置， 如果一趟比较下来没有进行过交换， 就说明序列有序， <strong>因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。 从而减少不必要的比较</strong>。 (这里说的优化，<br>可以在冒泡排序写好后， 再进行)</li></ul><h3 id="3-2、冒泡排序图解"><a href="#3-2、冒泡排序图解" class="headerlink" title="3.2、冒泡排序图解"></a>3.2、冒泡排序图解</h3><ul><li><p>第一趟：</p><ul><li>从数组 arr 第一个元素开始，与其后面一个元素比较大小</li><li>如果 arr[i] &gt; arr[i+1] ，则交换，将大的元素换到后面去</li><li>由于是当前元素与其后面一个元素比较大小，所以只需要执行 arr.length - 1 次循环</li></ul></li><li><p>第二趟：</p><ul><li>从数组 arr 第一个元素开始，与其后面一个元素比较大小</li><li>由于第一趟排序完成，数组最后一个元素已是最大元素，所以只需要执行 arr.length - 1 - 1 次循环</li></ul></li><li><p>啥时候完成？下面两个条件满足任意一个即可：</p><ul><li><p>当其中有一趟排序没有元素交换位置时，说明数组已经有序</p></li><li><p>或：按照上述流程，跑完第</p><p>arr.length - 1</p><p>趟之后</p><ul><li>这样来想：5 个元素的数组，最多只需要跑 4 趟</li><li>为什么最多只需要跑 4 趟？因为跑完 4 趟之后，数组第二个元素已经成为了数组第二小的元素，那么数组自然就是有序数组</li><li>即数组长度如果为 n ，那么则需要跑 n - 1 趟</li></ul></li></ul></li><li><p>总结：两层 for 循环</p><ul><li><strong>第一层 for 循环控制走多少趟：for (int i = 0; i &lt; arr.length - 1; i++) {</strong></li><li><strong>第二层 for 循环实现针对该趟循环，进行冒泡：for (int j = 0; j &lt; arr.length - 1 - i; j++) {</strong></li></ul></li><li><p>伪代码：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="comment">// 执行冒泡操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/* 该趟没有交换 */</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组已然有序，跳出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTcwNzMxMzc5LnBuZw?x-oss-process=image/format,png" alt="image-20200806170731379"></p><h3 id="3-3、代码实现"><a href="#3-3、代码实现" class="headerlink" title="3.3、代码实现"></a>3.3、代码实现</h3><h4 id="3-3-1、理解冒泡排序"><a href="#3-3-1、理解冒泡排序" class="headerlink" title="3.3.1、理解冒泡排序"></a>3.3.1、理解冒泡排序</h4><ul><li>上面的例子不好，我们把数组改成：int arr[] = { 3, 9, -1, 10, -2 }; 这样更能说明冒泡排序的特点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了容量理解，我们把冒泡排序的演变过程，给大家展示</span></span><br><span class="line">	System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一趟排序，就是将最大的数排在倒数第一位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">		<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">		<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">			temp = arr[j];</span><br><span class="line">			arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;第一趟排序后的数组&quot;</span>);</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二趟排序，就是将第二大的数排在倒数第二位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - <span class="number">1</span>; j++) &#123;</span><br><span class="line">		<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">		<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">			temp = arr[j];</span><br><span class="line">			arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;第二趟排序后的数组&quot;</span>);</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三趟排序，就是将第三大的数排在倒数第三位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - <span class="number">2</span>; j++) &#123;</span><br><span class="line">		<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">		<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">			temp = arr[j];</span><br><span class="line">			arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;第三趟排序后的数组&quot;</span>);</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第四趟排序，就是将第4大的数排在倒数第4位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - <span class="number">3</span>; j++) &#123;</span><br><span class="line">		<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">		<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">			temp = arr[j];</span><br><span class="line">			arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;第四趟排序后的数组&quot;</span>);</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">排序前</span><br><span class="line">[3, 9, -1, 10, -2]</span><br><span class="line">第一趟排序后的数组</span><br><span class="line">[3, -1, 9, -2, 10]</span><br><span class="line">第二趟排序后的数组</span><br><span class="line">[-1, 3, -2, 9, 10]</span><br><span class="line">第三趟排序后的数组</span><br><span class="line">[-1, -2, 3, 9, 10]</span><br><span class="line">第四趟排序后的数组</span><br><span class="line">[-2, -1, 3, 9, 10]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-2、编写冒泡排序"><a href="#3-3-2、编写冒泡排序" class="headerlink" title="3.3.2、编写冒泡排序"></a>3.3.2、编写冒泡排序</h4><ul><li>测试极端情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了容量理解，我们把冒泡排序的演变过程，给大家展示</span></span><br><span class="line">	System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	bubbleSort(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将前面额冒泡排序算法，封装成一个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">	<span class="comment">// 冒泡排序 的时间复杂度 O(n^2), 自己写出</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 临时变量</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 标识变量，表示是否进行过交换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;趟排序后的数组&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123; <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			flag = <span class="literal">false</span>; <span class="comment">// 重置flag!!!, 进行下次判断</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">排序前</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">第1趟排序后的数组</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-3、测试冒泡排序性能"><a href="#3-3-3、测试冒泡排序性能" class="headerlink" title="3.3.3、测试冒泡排序性能"></a>3.3.3、测试冒泡排序性能</h4><ul><li>测试代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试一下冒泡排序的速度O(n^2), 给80000个数据，测试</span></span><br><span class="line">	<span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line">	<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">80000</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">		arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">	<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">	<span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">	System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试冒泡排序</span></span><br><span class="line">	bubbleSort(arr);</span><br><span class="line"></span><br><span class="line">	<span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">	<span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(date2);</span><br><span class="line">	System.out.println(<span class="string">&quot;排序后的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将前面额冒泡排序算法，封装成一个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">	<span class="comment">// 冒泡排序 的时间复杂度 O(n^2), 自己写出</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 临时变量</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 标识变量，表示是否进行过交换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123; <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			flag = <span class="literal">false</span>; <span class="comment">// 重置flag!!!, 进行下次判断</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">排序前的时间是=2020-07-15 11:44:08</span><br><span class="line">排序后的时间是=2020-07-15 11:44:16</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4、选择排序"><a href="#4、选择排序" class="headerlink" title="4、选择排序"></a>4、选择排序</h2><h3 id="4-1、选择排序基本介绍"><a href="#4-1、选择排序基本介绍" class="headerlink" title="4.1、选择排序基本介绍"></a>4.1、选择排序基本介绍</h3><ul><li>选择式排序也属于内部排序法， 是从欲排序的数据中， 按指定的规则选出某一元素， 再依规定交换位置后达到排序的目的。</li></ul><h3 id="4-2、选择排序思想"><a href="#4-2、选择排序思想" class="headerlink" title="4.2、选择排序思想"></a>4.2、选择排序思想</h3><ul><li>选择排序（select sorting） 也是一种简单的排序方法。 它的基本思想是（n 是数组大小）：<ul><li>第一次从 arr[0]~arr[n-1]中选取最小值，与 arr[0] 交换</li><li>第二次从 arr[1]~arr[n-1]中选取最小值， 与 arr[1] 交换</li><li>第三次从 arr[2]~arr[n-1]中选取最小值， 与 arr[2] 交换， …，</li><li>第 i 次从 arr[i-1]~arr[n-1]中选取最小值， 与 arr[i-1] 交换， …，</li><li>第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2] 交换，</li><li>总共通过 n-1 次， 得到一个按排序码从小到大排列的有序序列。</li></ul></li></ul><h3 id="4-3、选择排序图解"><a href="#4-3、选择排序图解" class="headerlink" title="4.3、选择排序图解"></a>4.3、选择排序图解</h3><ul><li>选择排序流程：<ul><li>第一次循环，默认 arr[0] 是最小的元素，将其与 arr[1]~arr[n-1] 进行比较，找到最小的元素，并与 arr[0] 的位置位置</li><li>第二次循环，默认 arr[1] 是最小的元素，将其与 arr[2]~arr[n-1] 进行比较，找到最小的元素，并与 arr[1] 的位置位置</li><li>第 i 次循环，默认 arr[i] 是最小的元素，将其与 arr[i+1]~arr[n-1] 进行比较，找到最小的元素，并与 arr[i] 的位置位置</li><li>直到循环执行 n - 1 次</li></ul></li><li>总结：两层 for 循环<ul><li>第一层 for 循环控制走多少趟：for (int i = 0; i &lt; arr.length - 1; i++) {<ul><li>从数组第一个元素开始，因为每次都是拿当前元素 arr[j] 和其后一个元素 arr[j+1] 进行比较</li><li>到数组倒数第二个元素结束，将 arr[arr.length - 2] 与 arr[arr.length - 1] 进行比较后，数组就已经是有序数组</li><li>如果数组大小为 n ，那么执行完第 n - 1 趟时，数组就已经是有序数组</li></ul></li><li>第二层 for 循环控制从第几个元素开始执行选择排序：for (int j = i + 1; j &lt; arr.length; j++)<ul><li>每次进入第二层 for 循环时，先假设当前元素 arr[i] 是最小的元素：<strong>min = arr[i];</strong> ，并记录最小元素的下标：<strong>index = i;</strong></li><li>然后依次和其后面的元素 arr[j] 比较，如果找到比 arr[i] 小的元素，则更新最小值和最小值的索引：<strong>min = arr[j]</strong>; <strong>index = j</strong> ;</li></ul></li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE1MTk1NDMxNTEwLnBuZw?x-oss-process=image/format,png" alt="image-20200715195431510"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTcxMDA5NzcyLnBuZw?x-oss-process=image/format,png" alt="image-20200806171009772"></p><h3 id="4-4、代码实现"><a href="#4-4、代码实现" class="headerlink" title="4.4、代码实现"></a>4.4、代码实现</h3><h4 id="4-4-1、理解选择排序"><a href="#4-4-1、理解选择排序" class="headerlink" title="4.4.1、理解选择排序"></a>4.4.1、理解选择排序</h4><ul><li>一步一步理解选择排序算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span> &#125;;</span><br><span class="line">		selectSort(arr);</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 使用逐步推导的方式来，讲解选择排序</span></span><br><span class="line">		<span class="comment">// 第1轮</span></span><br><span class="line">		<span class="comment">// 原始的数组 ： 101, 34, 119, 1</span></span><br><span class="line">		<span class="comment">// 第一轮排序 : 1, 34, 119, 101</span></span><br><span class="line">		<span class="comment">// 算法 先简单--》 做复杂， 就是可以把一个复杂的算法，拆分成简单的问题-》逐步解决</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第1轮</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">				min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">				minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">		<span class="keyword">if</span> (minIndex != <span class="number">0</span>) &#123;</span><br><span class="line">			arr[minIndex] = arr[<span class="number">0</span>];</span><br><span class="line">			arr[<span class="number">0</span>] = min;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;第1轮后~~&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));<span class="comment">// 1, 34, 119, 101</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第2轮</span></span><br><span class="line">		minIndex = <span class="number">1</span>;</span><br><span class="line">		min = arr[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">				min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">				minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">		<span class="keyword">if</span> (minIndex != <span class="number">1</span>) &#123;</span><br><span class="line">			arr[minIndex] = arr[<span class="number">1</span>];</span><br><span class="line">			arr[<span class="number">1</span>] = min;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;第2轮后~~&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));<span class="comment">// 1, 34, 119, 101</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第3轮</span></span><br><span class="line">		minIndex = <span class="number">2</span>;</span><br><span class="line">		min = arr[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">				min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">				minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">		<span class="keyword">if</span> (minIndex != <span class="number">2</span>) &#123;</span><br><span class="line">			arr[minIndex] = arr[<span class="number">2</span>];</span><br><span class="line">			arr[<span class="number">2</span>] = min;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;第3轮后~~&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));<span class="comment">// 1, 34, 101, 119</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第1轮后~~</span><br><span class="line">[1, 34, 119, 101]</span><br><span class="line">第2轮后~~</span><br><span class="line">[1, 34, 119, 101]</span><br><span class="line">第3轮后~~</span><br><span class="line">[1, 34, 101, 119]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-4-2、编写选择排序"><a href="#4-4-2、编写选择排序" class="headerlink" title="4.4.2、编写选择排序"></a>4.4.2、编写选择排序</h4><ul><li>编写选择排序算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span> &#125;;</span><br><span class="line">		selectSort(arr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在推导的过程，我们发现了规律，因此，可以使用for来解决</span></span><br><span class="line">		<span class="comment">// 选择排序时间复杂度是 O(n^2)</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">			<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">					min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">					minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">			<span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">				arr[minIndex] = arr[i];</span><br><span class="line">				arr[i] = min;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;轮后~~&quot;</span>);</span><br><span class="line">			System.out.println(Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第1轮后~~</span><br><span class="line">[1, 34, 119, 101]</span><br><span class="line">第2轮后~~</span><br><span class="line">[1, 34, 119, 101]</span><br><span class="line">第3轮后~~</span><br><span class="line">[1, 34, 101, 119]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-4-3、测试选择排序性能"><a href="#4-4-3、测试选择排序性能" class="headerlink" title="4.4.3、测试选择排序性能"></a>4.4.3、测试选择排序性能</h4><ul><li>测试代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建要给80000个的随机的数组</span></span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Date</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(data1);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">		selectSort(arr);</span><br><span class="line"></span><br><span class="line">		<span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在推导的过程，我们发现了规律，因此，可以使用for来解决</span></span><br><span class="line">		<span class="comment">// 选择排序时间复杂度是 O(n^2)</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">			<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">					min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">					minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">			<span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">				arr[minIndex] = arr[i];</span><br><span class="line">				arr[i] = min;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">排序前的时间是=2020-07-15 19:59:19</span><br><span class="line">排序前的时间是=2020-07-15 19:59:20</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-5、总结"><a href="#4-5、总结" class="headerlink" title="4.5、总结"></a>4.5、总结</h3><ul><li>由于选择排序算法在最内层的 for 循环中，满足 <code>if (min &gt; arr[j]) &#123;</code> 条件后，只需要记录最小值和最小值在数组中的索引，无需像冒泡排序那样每次都要执行交换操作，所以选择排序算法的执行速度比冒泡排序算法快一些</li></ul><h2 id="5、插入排序"><a href="#5、插入排序" class="headerlink" title="5、插入排序"></a>5、插入排序</h2><h3 id="5-1、插入排序基本介绍"><a href="#5-1、插入排序基本介绍" class="headerlink" title="5.1、插入排序基本介绍"></a>5.1、插入排序基本介绍</h3><ul><li>插入式排序属于内部排序法， 是对于欲排序的元素以插入的方式找寻该元素的适当位置， 以达到排序的目的。</li></ul><h3 id="5-2、插入排序思想"><a href="#5-2、插入排序思想" class="headerlink" title="5.2、插入排序思想"></a>5.2、插入排序思想</h3><ul><li>插入排序（Insertion Sorting） 的基本思想是： <strong>把 n 个待排序的元素看成为一个有序表和一个无序表</strong></li><li>开始时有序表中只包含一个元素， 无序表中包含有 n-1 个元素， <strong>排序过程中每次从无序表中取出第一个元素， 把它的排序码依次与有序表元素的排序码进行比较， 将它插入到有序表中的适当位置， 使之成为新的有序表</strong></li></ul><h3 id="5-3、插入排序图解"><a href="#5-3、插入排序图解" class="headerlink" title="5.3、插入排序图解"></a>5.3、插入排序图解</h3><ul><li><p>插入排序逻辑：</p><ul><li>首先，<strong>将数组分为两个数组，前部分有序数组，后部分是无序数组，我们的目的就是一点一点取出无序数组中的值，将其放到有序数组中区</strong></li><li>第一趟：arr[0] 作为有序数组的元素，arr[1] 作为无序数组中第一个元素，将 arr[1] 与 arr[0] 比较，目标是将 arr[1] 插入到有序数组中</li><li>第一趟：arr[0] 和 arr[1] 作为有序数组的元素，arr[2] 作为无序数组中第一个元素，将 arr[2] 与 arr[0] 和 arr[1] 比较，目标是将 arr[2] 插入到有序数组中</li><li>第 i 趟：arr[0]<del>arr[i] 作为有序数组的元素，arr[i+1] 作为无序数组中第一个元素，将 arr[i+1] 与 arr[0]</del>arr[i] 比较，目标是将 arr[i+1] 插入到有序数组中</li><li>第 n-1 趟：此时有序数组为 arr[0]~arr[n-2] ，无序数组为 arr[n-1] ，将无序数组中最后一个元素插入到有序数组中即可</li><li>如何进行插入？<ul><li><strong>假设有个指针（index），指向无序数组中的第一个元素，即 arr[index] 是无序数组中的第一个元素</strong>，我们定义一个变量来存储该值：int insertVal = arr[index]<br>;，现在要将其插入到前面的有序数组中</li><li>将 index 前移一步，则指向有序数组最后一个元素，我们定义一个新的变量来存储该指针：<strong>insertIndex = index - 1;</strong> ，即 arr[insertIndex] 是有序数组最后一个元素</li><li>我们需要找到一个比 insertVal 小的值，并将 insertVal 插入在该值后面：<ul><li>如果 insertVal &gt; arr[insertIndex] ，执行插入</li><li>如果 insertVal &lt; arr[insertIndex] ，将有序数组后移，腾出插入空间，insertIndex 指针前移，再看看前一个元素满不满足条件，直到找到插入位置</li><li>即循环终止条件为找到插入位置，又分为两种情况：<ul><li>在有序数组中间找到插入位置</li><li>insertVal 比有序数组中所有的数都小，插入在数组第一个位置（insertIndex = 0 的情况）</li></ul></li></ul></li></ul></li></ul></li><li><p>总结：两层循环</p><ul><li><p>for 循环控制走多少趟：<strong>for(int i = 1; i &lt; arr.length; i++) {</strong> ，从数组第一个元素开始到数组最后一个元素结束</p></li><li><p>while 循环不断将指针前移，在有序数组中寻找插入位置，并执行插入：</p><p><strong>while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) {</strong></p></li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE1MjE0ODIyNDk4LnBuZw?x-oss-process=image/format,png" alt="image-20200715214822498"></p><h3 id="5-4、代码实现"><a href="#5-4、代码实现" class="headerlink" title="5.4、代码实现"></a>5.4、代码实现</h3><h4 id="5-4-1、理解插入排序"><a href="#5-4-1、理解插入排序" class="headerlink" title="5.4.1、理解插入排序"></a>5.4.1、理解插入排序</h4><ul><li>理解插入排序算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span> &#125;;</span><br><span class="line">		insertSort(arr);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用逐步推导的方式来讲解，便利理解</span></span><br><span class="line">		<span class="comment">// 第1轮 &#123;101, 34, 119, 1&#125;; =&gt; &#123;34, 101, 119, 1&#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// &#123;101, 34, 119, 1&#125;; =&gt; &#123;101,101,119,1&#125;</span></span><br><span class="line">		<span class="comment">// 定义待插入的数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[<span class="number">1</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">1</span>; <span class="comment">// 即arr[1]的前面这个数的下标</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line">		<span class="comment">// 说明</span></span><br><span class="line">		<span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line">		<span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line">		<span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line">		<span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">			arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];<span class="comment">// arr[insertIndex]</span></span><br><span class="line">			insertIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line">		<span class="comment">// 举例：理解不了，我们一会 debug</span></span><br><span class="line">		arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;第1轮插入&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第2轮</span></span><br><span class="line">		insertVal = arr[<span class="number">2</span>];</span><br><span class="line">		insertIndex = <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">			arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];<span class="comment">// arr[insertIndex]</span></span><br><span class="line">			insertIndex--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">		System.out.println(<span class="string">&quot;第2轮插入&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第3轮</span></span><br><span class="line">		insertVal = arr[<span class="number">3</span>];</span><br><span class="line">		insertIndex = <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">			arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];<span class="comment">// arr[insertIndex]</span></span><br><span class="line">			insertIndex--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">		System.out.println(<span class="string">&quot;第3轮插入&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第1轮插入</span><br><span class="line">[34, 101, 119, 1]</span><br><span class="line">第2轮插入</span><br><span class="line">[34, 101, 119, 1]</span><br><span class="line">第3轮插入</span><br><span class="line">[1, 34, 101, 119]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-4-2、编写插入排序"><a href="#5-4-2、编写插入排序" class="headerlink" title="5.4.2、编写插入排序"></a>5.4.2、编写插入排序</h4><ul><li>编写插入排序算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span> &#125;;</span><br><span class="line">		insertSort(arr);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//使用for循环来把代码简化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="comment">//定义待插入的数</span></span><br><span class="line">			insertVal = arr[i];</span><br><span class="line">			insertIndex = i - <span class="number">1</span>; <span class="comment">// 即arr[1]的前面这个数的下标</span></span><br><span class="line">	</span><br><span class="line">			<span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line">			<span class="comment">// 说明</span></span><br><span class="line">			<span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line">			<span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line">			<span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line">			<span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">				arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];<span class="comment">// arr[insertIndex]</span></span><br><span class="line">				insertIndex--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line">			<span class="comment">// 因为我们找到的元素，即下标为 insertIndex 的元素值比 insertVal 小</span></span><br><span class="line">             <span class="comment">// 所以我们要将 insertVal 插入到 insertIndex + 1 的位置</span></span><br><span class="line">			arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;轮插入&quot;</span>);</span><br><span class="line">			System.out.println(Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第1轮插入</span><br><span class="line">[34, 101, 119, 1]</span><br><span class="line">第2轮插入</span><br><span class="line">[34, 101, 119, 1]</span><br><span class="line">第3轮插入</span><br><span class="line">[1, 34, 101, 119]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-4-3、测试插入排序性能"><a href="#5-4-3、测试插入排序性能" class="headerlink" title="5.4.3、测试插入排序性能"></a>5.4.3、测试插入排序性能</h4><ul><li>测试插入排序性能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;插入排序前&quot;</span>);</span><br><span class="line">		<span class="type">Date</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(data1);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">		insertSort(arr); <span class="comment">// 调用插入排序算法</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//使用for循环来把代码简化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="comment">//定义待插入的数</span></span><br><span class="line">			insertVal = arr[i];</span><br><span class="line">			insertIndex = i - <span class="number">1</span>; <span class="comment">// 即arr[1]的前面这个数的下标</span></span><br><span class="line">	</span><br><span class="line">			<span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line">			<span class="comment">// 说明</span></span><br><span class="line">			<span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line">			<span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line">			<span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line">			<span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">				arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];<span class="comment">// arr[insertIndex]</span></span><br><span class="line">				insertIndex--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line">			<span class="comment">// 举例：理解不了，我们一会 debug</span></span><br><span class="line">			<span class="comment">//这里我们判断是否需要赋值</span></span><br><span class="line">			arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">插入排序前</span><br><span class="line">排序前的时间是=2020-07-15 21:49:48</span><br><span class="line">排序前的时间是=2020-07-15 21:49:50</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-5、总结"><a href="#5-5、总结" class="headerlink" title="5.5、总结"></a>5.5、总结</h3><ul><li>插入排序在寻找插入位置时，需要对数组元素进行整体挪位，所以效率比选择排序稍低</li></ul><h2 id="6、希尔排序"><a href="#6、希尔排序" class="headerlink" title="6、希尔排序"></a>6、希尔排序</h2><h3 id="6-1、简单插入排序问题"><a href="#6-1、简单插入排序问题" class="headerlink" title="6.1、简单插入排序问题"></a>6.1、简单插入排序问题</h3><ul><li>我们看简单的插入排序可能存在的问题，数组 arr = { 2, 3, 4, 5, 6, 1 } 这时需要插入的数 1(最小)，简单插入排序的过程如下</li><li>结论: 当需要插入的数是较小的数时， 后移的次数明显增多， 对效率有影响</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;2,3,4,5,6,6&#125;</span><br><span class="line">&#123;2,3,4,5,5,6&#125;</span><br><span class="line">&#123;2,3,4,4,5,6&#125;</span><br><span class="line">&#123;2,3,3,4,5,6&#125;</span><br><span class="line">&#123;2,2,3,4,5,6&#125;</span><br><span class="line">&#123;1,2,3,4,5,6&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-2、希尔排序基本介绍"><a href="#6-2、希尔排序基本介绍" class="headerlink" title="6.2、希尔排序基本介绍"></a>6.2、希尔排序基本介绍</h3><ul><li>希尔排序是希尔（Donald Shell） 于 1959 年提出的一种排序算法。 <strong>希尔排序也是一种插入排序， 它是简单插入排序经过改进之后的一个更高效的版本， 也称为缩小增量排序。</strong></li></ul><h3 id="6-3、希尔排序基本思想"><a href="#6-3、希尔排序基本思想" class="headerlink" title="6.3、希尔排序基本思想"></a>6.3、希尔排序基本思想</h3><ul><li><strong>希尔排序按照增量将数组进行分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止</strong></li></ul><h3 id="6-4、希尔排序图解（交换法）"><a href="#6-4、希尔排序图解（交换法）" class="headerlink" title="6.4、希尔排序图解（交换法）"></a>6.4、希尔排序图解（交换法）</h3><ul><li><p>第一次：<strong>gap = arr.length/5 = 5</strong> ， 将数组分为五组，每个数组元素的索引相差 5</p><ul><li>如何完成第一次的排序？<ul><li>仔细想想，我们需要用一次循环将每组中的元素排序</li><li>总共有五组，我们又需要一次循环</li><li>所以完成每次排序，需要两层循环</li></ul></li><li>程序代码如下，把 i ，j 都看作是辅助指针：<ul><li>i 与 j 配合使用，可以将指针从数组第一个元素，移动至最后一个元素，目的：把数组遍历一遍</li><li>j 与 i 配合使用，每次都从数组索引 i 处往前遍历，每次向前移动 gap 个位置，然后进行交换（冒泡排序的意思）：看看前面的元素有没有比我的值大，如果前面的元素比我的值大，我就要和他交换位置，跑到前面去</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序的第1轮排序</span></span><br><span class="line"><span class="comment">// 因为第1轮排序，是将10个数据分成了 5组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">5</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">5</span>]) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">5</span>];</span><br><span class="line">            arr[j + <span class="number">5</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>第二次：<strong>gap = gap /2 = 2;</strong> ， 将数组分为两组，每个数组元素的索引相差 2</p><ul><li>第一组：<ul><li>i = 2 时，数组从索引 2 处往前遍历，间隔为 2 ：将 arr[0]、arr[2] 排序</li><li>i = 4 时，数组从索引 4 处往前遍历，间隔为 2 ：将 arr[0]、arr[2]、arr[4] 排序</li><li>i = 6 时，数组从索引 6 处往前遍历，间隔为 2 ：将 arr[0]、arr[2]、arr[4]、arr[6] 排序</li><li>i = 8 时，数组从索引 8 处往前遍历，间隔为 2 ：将 arr[0]、arr[2]、arr[4]、arr[6]、arr[8] 排序</li></ul></li><li>第二组：<ul><li>i = 3 时，数组从索引 3 处往前遍历，间隔为 2 ：将 arr[1]、arr[3] 排序</li><li>i = 5 时，数组从索引 5 处往前遍历，间隔为 2 ：将 arr[1]、arr[3]、arr[5] 排序</li><li>i = 7 时，数组从索引 7 处往前遍历，间隔为 2 ：将 arr[1]、arr[3]、arr[5]、arr[7] 排序</li><li>i = 9 时，数组从索引 9 处往前遍历，间隔为 2 ：将 arr[1]、arr[3]、arr[5]、arr[7]、arr[9] 排序</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序的第2轮排序</span></span><br><span class="line"><span class="comment">// 因为第2轮排序，是将10个数据分成了 5/2 = 2组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">2</span>]) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">2</span>];</span><br><span class="line">            arr[j + <span class="number">2</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;希尔排序2轮后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>第三次：</p><p>gap = gap /2 = 1;</p><p>， 将数组分为一组，每个数组元素的索引相差 1 ，对于交换法而言，这就是异常冒泡排序</p><ul><li>i = 1 时，数组从索引 1 处往前遍历，间隔为 1 ：将 arr[0]、arr[1] 排序</li><li>i = 2 时，数组从索引 2 处往前遍历，间隔为 1 ：将 arr[0]、arr[1]、arr[2] 排序</li><li>i = 3 时，数组从索引 3 处往前遍历，间隔为 1 ：将 arr[0]、arr[1]、arr[2]、arr[3] 排序</li><li>…</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序的第3轮排序</span></span><br><span class="line"><span class="comment">// 因为第3轮排序，是将10个数据分成了 2/2 = 1组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;希尔排序3轮后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>总结：每次使用循环改变 gap 的值（初始值：数组大小/2 ，之后：gap = gap/2），然后在改变 gap 的循环中嵌套上面的双层 for 循环</p><ul><li>改变 gap ：<strong>for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) {</strong></li><li>内层循环：实现对每组数组的排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历各组中所有的元素(共gap组，每组有？个元素), 步长gap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">- 希尔排序伪代码</span><br><span class="line">    </span><br><span class="line">    ```java</span><br><span class="line">    for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123;</span><br><span class="line">        for (int i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">        	// 遍历各组中所有的元素(共gap组，每组有？个元素), 步长gap</span><br><span class="line">        	for (int j = i - gap; j &gt;= 0; j -= gap) &#123;</span><br><span class="line">                // 对每组进行冒泡排序</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE1MjIzNzA4MjcwLnBuZw?x-oss-process=image/format,png" alt="image-20200715223708270"></p><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE1MjIzNzQwNjA3LnBuZw?x-oss-process=image/format,png" alt="image-20200715223740607"></p><h3 id="6-5、代码实现"><a href="#6-5、代码实现" class="headerlink" title="6.5、代码实现"></a>6.5、代码实现</h3><h4 id="6-5-1、理解希尔排序（交换法）"><a href="#6-5-1、理解希尔排序（交换法）" class="headerlink" title="6.5.1、理解希尔排序（交换法）"></a>6.5.1、理解希尔排序（交换法）</h4><ul><li>理解基于交换法的希尔排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line">		shellSort(arr);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用逐步推导的方式来编写希尔排序</span></span><br><span class="line">	<span class="comment">// 希尔排序时， 对有序序列在插入时采用交换法,</span></span><br><span class="line">	<span class="comment">// 思路(算法) ===&gt; 代码</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 希尔排序的第1轮排序</span></span><br><span class="line">		<span class="comment">// 因为第1轮排序，是将10个数据分成了 5组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">5</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">5</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">				<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">5</span>]) &#123;</span><br><span class="line">					temp = arr[j];</span><br><span class="line">					arr[j] = arr[j + <span class="number">5</span>];</span><br><span class="line">					arr[j + <span class="number">5</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;希尔排序1轮后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 希尔排序的第2轮排序</span></span><br><span class="line">		<span class="comment">// 因为第2轮排序，是将10个数据分成了 5/2 = 2组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">				<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">2</span>]) &#123;</span><br><span class="line">					temp = arr[j];</span><br><span class="line">					arr[j] = arr[j + <span class="number">2</span>];</span><br><span class="line">					arr[j + <span class="number">2</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;希尔排序2轮后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 希尔排序的第3轮排序</span></span><br><span class="line">		<span class="comment">// 因为第3轮排序，是将10个数据分成了 2/2 = 1组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">				<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">					temp = arr[j];</span><br><span class="line">					arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">					arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;希尔排序3轮后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">希尔排序1轮后=[3, 5, 1, 6, 0, 8, 9, 4, 7, 2]</span><br><span class="line">希尔排序2轮后=[0, 2, 1, 4, 3, 5, 7, 6, 9, 8]</span><br><span class="line">希尔排序3轮后=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-5-2、编写希尔排序（交换法）"><a href="#6-5-2、编写希尔排序（交换法）" class="headerlink" title="6.5.2、编写希尔排序（交换法）"></a>6.5.2、编写希尔排序（交换法）</h4><ul><li>编写基于交换法的希尔排序算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line">		shellSort(arr);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用逐步推导的方式来编写希尔排序</span></span><br><span class="line">	<span class="comment">// 希尔排序时， 对有序序列在插入时采用交换法,</span></span><br><span class="line">	<span class="comment">// 思路(算法) ===&gt; 代码</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 根据前面的逐步分析，使用循环处理</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">				<span class="comment">// 遍历各组中所有的元素(共gap组，每组有？个元素), 步长gap</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">					<span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">					<span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">						temp = arr[j];</span><br><span class="line">						arr[j] = arr[j + gap];</span><br><span class="line">						arr[j + gap] = temp;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;希尔排序第&quot;</span> + (++count) + <span class="string">&quot;轮 =&quot;</span> + Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">希尔排序第1轮 =[3, 5, 1, 6, 0, 8, 9, 4, 7, 2]</span><br><span class="line">希尔排序第2轮 =[0, 2, 1, 4, 3, 5, 7, 6, 9, 8]</span><br><span class="line">希尔排序第3轮 =[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-5-3、测试希尔排序（交换法）性能"><a href="#6-5-3、测试希尔排序（交换法）性能" class="headerlink" title="6.5.3、测试希尔排序（交换法）性能"></a>6.5.3、测试希尔排序（交换法）性能</h4><ul><li>测试基于交换法的希尔排序算法性能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">		<span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">		shellSort(arr); <span class="comment">// 交换式</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用逐步推导的方式来编写希尔排序</span></span><br><span class="line">	<span class="comment">// 希尔排序时， 对有序序列在插入时采用交换法,</span></span><br><span class="line">	<span class="comment">// 思路(算法) ===&gt; 代码</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 根据前面的逐步分析，使用循环处理</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">				<span class="comment">// 遍历各组中所有的元素(共gap组，每组有？个元素), 步长gap</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">					<span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">					<span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">						temp = arr[j];</span><br><span class="line">						arr[j] = arr[j + gap];</span><br><span class="line">						arr[j + gap] = temp;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=2020-07-16 10:22:27</span><br><span class="line">排序前的时间是=2020-07-16 10:22:33</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>分析：由于使用交换法实现希尔排序算法，所以基于交换法的希尔排序算法比简单选择排序算法更慢，<strong>所以我们一定要编写基于插入法的希尔排序算法</strong></li></ul><h4 id="6-5-4、编写希尔排序（插入法）"><a href="#6-5-4、编写希尔排序（插入法）" class="headerlink" title="6.5.4、编写希尔排序（插入法）"></a>6.5.4、编写希尔排序（插入法）</h4><ul><li><p>编写基于插入法的希尔排序算法：</p><ul><li><p>记录当前位置的元素值</p><p>int temp = arr[j]</p><p>; ，从当前元素前一个位置开始，往前寻找，每次移动 gap 个距离</p><ul><li>如果 temp &lt; arr[j - gap] ：<ul><li>将数组元素后移，腾出插入空间：<strong>arr[j] = arr[j - gap];</strong></li><li>然后继续往前找：<strong>j -= gap;</strong></li></ul></li><li>如果 <strong>temp &gt; arr[j - gap]</strong> ，找到插入位置，执行插入 <strong>arr[j] = temp;</strong> ，因为在上一步已经腾出了插入空间，并且将指针 j 前移，所以可直接插入</li><li>如果 找到数组最前面还是没有找到插入位置：<strong>j - gap &lt; 0</strong> ，则证明 temp 需要插入在数组最前面</li></ul></li><li><p>仅仅就是将之前交换法的冒泡操作替换成了插入操作</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">		shellSort(arr);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对交换式的希尔排序进行优化-&gt;移位法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		<span class="comment">// 增量gap, 并逐步的缩小增量</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment">// 从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">				<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">				<span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">					<span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line">						<span class="comment">// 移动</span></span><br><span class="line">						arr[j] = arr[j - gap];</span><br><span class="line">						j -= gap;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// temp 比 arr[j - gap] 大，所以需要插入在 j 的位置</span></span><br><span class="line">					arr[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">排序前</span><br><span class="line">[8, 9, 1, 7, 2, 3, 5, 4, 6, 0]</span><br><span class="line">排序前</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-5-5、测试希尔排序（插入法）性能"><a href="#6-5-5、测试希尔排序（插入法）性能" class="headerlink" title="6.5.5、测试希尔排序（插入法）性能"></a>6.5.5、测试希尔排序（插入法）性能</h4><ul><li>测试基于插入法的希尔排序算法性能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">		<span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">		shellSort(arr); <span class="comment">// 交换式</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对交换式的希尔排序进行优化-&gt;移位法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		<span class="comment">// 增量gap, 并逐步的缩小增量</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment">// 从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">				<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">				<span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">					<span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line">						<span class="comment">// 移动</span></span><br><span class="line">						arr[j] = arr[j - gap];</span><br><span class="line">						j -= gap;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 当退出while后，就给temp找到插入的位置</span></span><br><span class="line">					arr[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果：1s 都不到，果然快啊</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=2020-07-16 11:02:20</span><br><span class="line">排序前的时间是=2020-07-16 11:02:20</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>八百万个数据的测试结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=2020-07-16 14:38:55</span><br><span class="line">排序前的时间是=2020-07-16 14:38:57</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7、快速排序"><a href="#7、快速排序" class="headerlink" title="7、快速排序"></a>7、快速排序</h2><h3 id="7-1、快排简介"><a href="#7-1、快排简介" class="headerlink" title="7.1、快排简介"></a>7.1、快排简介</h3><ol><li>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn)<br>算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</li><li>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</li><li><strong>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</strong></li><li>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。</li><li>虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N<br>多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</li><li>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn)<br>的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</li></ol><h3 id="7-2、代码思路"><a href="#7-2、代码思路" class="headerlink" title="7.2、代码思路"></a>7.2、代码思路</h3><ol><li><strong>从数列中挑出一个元素，称为 “基准”（pivot）;</strong> <em>个人喜欢用中间下标对应的数</em></li><li><strong>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。</strong></li><li>在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><hr><p><strong>快排流程分析</strong></p><p>快速排序（Quicksort）是对<strong>冒泡排序</strong>的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两 部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排 序，**<br>整个排序过程可以递归进行**，以此达到整个数据变成有序序列</p><h3 id="7-3、代码实现"><a href="#7-3、代码实现" class="headerlink" title="7.3、代码实现"></a>7.3、代码实现</h3><h4 id="7-3-1、编写快排算法"><a href="#7-3-1、编写快排算法" class="headerlink" title="7.3.1、编写快排算法"></a>7.3.1、编写快排算法</h4><ul><li>快排代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left; <span class="comment">//左下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right; <span class="comment">//右下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;(left + right) / 2 = &quot;</span> + (left + right) / <span class="number">2</span> + <span class="string">&quot; pivot = &quot;</span> + pivot);</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[l];</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        arr[r] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));<span class="comment">// 1, 34, 119, 101</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;===&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向左递归</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向左递归&quot;</span>);</span><br><span class="line">        quickSort2(arr, left, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向右递归</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; right) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向右递归&quot;</span>);</span><br><span class="line">        quickSort2(arr, l, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>测试代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">4561</span>, -<span class="number">9</span>, <span class="number">78</span>, <span class="number">0</span>, <span class="number">23</span>, -<span class="number">567</span>, <span class="number">70</span>, -<span class="number">1</span>, <span class="number">900</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序输出</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr=[-567, -9, -1, 0, 23, 70, 78, 900, 4561]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="7-3-2、测试快速排序性能"><a href="#7-3-2、测试快速排序性能" class="headerlink" title="7.3.2、测试快速排序性能"></a>7.3.2、测试快速排序性能</h4><ul><li>编测试快速排序算法性能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//        int[] arr = &#123;4561, -9, 78, 0, 23, -567, 70, -1, 900&#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//        测试快排的执行速度</span></span><br><span class="line">        <span class="comment">//         创建要给80000个的随机的数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">800000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">800000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">80000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(data1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line">        <span class="comment">//        System.out.println(&quot;arr=&quot; + Arrays.toString(arr));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left; <span class="comment">//左下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right; <span class="comment">//右下标</span></span><br><span class="line">        <span class="comment">//pivot 中轴值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//临时变量，作为交换时使用</span></span><br><span class="line">        <span class="comment">//while循环的目的是让比pivot 值小放到左边</span></span><br><span class="line">        <span class="comment">//比pivot 值大放到右边</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//在pivot的左边一直找,找到大于等于pivot值,才退出</span></span><br><span class="line">            <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在pivot的右边一直找,找到小于等于pivot值,才退出</span></span><br><span class="line">            <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是</span></span><br><span class="line">            <span class="comment">//小于等于pivot值，右边全部是大于等于pivot值</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移</span></span><br><span class="line">            <span class="comment">//当交换后 arr[l] == pivot 说明交换之前r下标已经指向了 pivot 所在的位置，</span></span><br><span class="line">            <span class="comment">//将r--是为了跳过这个pivot位置</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">            quickSort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">            quickSort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果：80万数据一秒钟，果然快。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=2021-11-11 16:47:19</span><br><span class="line">排序前的时间是=2021-11-11 16:47:20</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8、归并排序"><a href="#8、归并排序" class="headerlink" title="8、归并排序"></a>8、归并排序</h2><h3 id="8-1、归并排序基本介绍"><a href="#8-1、归并排序基本介绍" class="headerlink" title="8.1、归并排序基本介绍"></a>8.1、归并排序基本介绍</h3><ul><li>归并排序（MERGE-SORT） 是利用归并的思想实现的排序方法， 该算法采用经典的分治（divide-and-conquer）策略</li><li><strong>分治法将问题分(divide)成一些小的问题然后递归求解， 而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起， 即分而治之</strong></li></ul><h3 id="8-2、归并排序思想"><a href="#8-2、归并排序思想" class="headerlink" title="8.2、归并排序思想"></a>8.2、归并排序思想</h3><ul><li>分 –&gt; 治</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE2MTU1MTM3NDcwLnBuZw?x-oss-process=image/format,png" alt="image-20200716155137470"></p><h3 id="8-3、归并排序代码思路"><a href="#8-3、归并排序代码思路" class="headerlink" title="8.3、归并排序代码思路"></a>8.3、归并排序代码思路</h3><ul><li><p>合并时，其实是拿着原数组（arr）中两个相邻的子数组（arr1、arr2）进行合并</p><p>，我们使用三个指针，来表示两个子数组在原数组中的位置</p><ul><li>arr[left] ~ arr[mid] 为 arr1</li><li>arr[mid + 1] ~ arr[right] 为 arr2</li></ul></li><li><p>如何合并？</p><ul><li>首先，需要一个临时的 temp 数组，其大小与原数组 arr 一样</li><li><strong>定义辅助指针 i 遍历 arr1 ，定义辅助指针 j 遍历 arr2 ，原则就是，把 arr1 和 arr2 中的数往 temp 中放，使得 temp[left] ~ temp[right] 是有序数组</strong></li><li>最后把 temp 临时数组中的数据拷贝回原数组中（个人认为，最后一下次再拷贝回去就行。。。）</li></ul></li><li><p>如何分？</p><ul><li>向左递归拆分：mergeSort(arr, left, mid, temp);</li><li>向右递归拆分：mergeSort(arr, mid + 1, right, temp);</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE2MTU1MjEwMTE1LnBuZw?x-oss-process=image/format,png" alt="image-20200716155210115"></p><h3 id="8-4、代码实现"><a href="#8-4、代码实现" class="headerlink" title="8.4、代码实现"></a>8.4、代码实现</h3><h4 id="8-4-1、编写归并排序算法"><a href="#8-4-1、编写归并排序算法" class="headerlink" title="8.4.1、编写归并排序算法"></a>8.4.1、编写归并排序算法</h4><ul><li>归并排序算法实现代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergetSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span> arr[] = &#123; <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span> &#125;;</span><br><span class="line">		<span class="type">int</span> temp[] = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length]; <span class="comment">// 归并排序需要一个额外空间</span></span><br><span class="line">		mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">		System.out.println(<span class="string">&quot;归并排序后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分+合方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>; <span class="comment">// 中间索引</span></span><br><span class="line">			<span class="comment">// 向左递归进行分解</span></span><br><span class="line">			mergeSort(arr, left, mid, temp);</span><br><span class="line">			<span class="comment">// 向右递归进行分解</span></span><br><span class="line">			mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">			<span class="comment">// 合并</span></span><br><span class="line">			merge(arr, left, mid, right, temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 合并的方法</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr   排序的原始数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mid   中间索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> temp  做中转的数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; <span class="comment">// 初始化i, 左边有序序列的初始索引</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>; <span class="comment">// 初始化j, 右边有序序列的初始索引</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// (一)</span></span><br><span class="line">		<span class="comment">// 先把左右两边(有序)的数据按照规则填充到temp数组</span></span><br><span class="line">		<span class="comment">// 直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<span class="comment">// 继续</span></span><br><span class="line">			<span class="comment">// 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">			<span class="comment">// 即将左边的当前元素，填充到 temp数组</span></span><br><span class="line">			<span class="comment">// 然后 t++, i++</span></span><br><span class="line">			<span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">				temp[t] = arr[i];</span><br><span class="line">				t += <span class="number">1</span>;</span><br><span class="line">				i += <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 反之,将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">				temp[t] = arr[j];</span><br><span class="line">				t += <span class="number">1</span>;</span><br><span class="line">				j += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (二)</span></span><br><span class="line">		<span class="comment">// 把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt;= mid) &#123; <span class="comment">// 左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">			temp[t] = arr[i];</span><br><span class="line">			t += <span class="number">1</span>;</span><br><span class="line">			i += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (j &lt;= right) &#123; <span class="comment">// 右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">			temp[t] = arr[j];</span><br><span class="line">			t += <span class="number">1</span>;</span><br><span class="line">			j += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (三)</span></span><br><span class="line">		<span class="comment">// 将temp数组的元素拷贝到arr</span></span><br><span class="line">		<span class="comment">// 注意，并不是每次都拷贝所有</span></span><br><span class="line">		t = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">tempLeft</span> <span class="operator">=</span> left; <span class="comment">//</span></span><br><span class="line">		<span class="comment">// 第一次合并 tempLeft = 0 , right = 1 //第二次： tempLeft = 2 right = 3 //第三次： tL=0 ri=3</span></span><br><span class="line">		<span class="comment">// 最后一次 tempLeft = 0 right = 7</span></span><br><span class="line">		<span class="keyword">while</span> (tempLeft &lt;= right) &#123;</span><br><span class="line">			arr[tempLeft] = temp[t];</span><br><span class="line">			t += <span class="number">1</span>;</span><br><span class="line">			tempLeft += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">归并排序后=[1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-4-2、测试归并排序性能"><a href="#8-4-2、测试归并排序性能" class="headerlink" title="8.4.2、测试归并排序性能"></a>8.4.2、测试归并排序性能</h4><ul><li>测试归并排序算法的性能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergetSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试快排的执行速度</span></span><br><span class="line">        <span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(data1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> temp[] = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length]; <span class="comment">// 归并排序需要一个额外空间</span></span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(&quot;归并排序后=&quot; + Arrays.toString(arr));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分+合方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>; <span class="comment">// 中间索引</span></span><br><span class="line">            <span class="comment">// 向左递归进行分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">// 向右递归进行分解</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">// 合并</span></span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   排序的原始数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid   中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  做中转的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; <span class="comment">// 初始化i, 左边有序序列的初始索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>; <span class="comment">// 初始化j, 右边有序序列的初始索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (一)</span></span><br><span class="line">        <span class="comment">// 先把左右两边(有序)的数据按照规则填充到temp数组</span></span><br><span class="line">        <span class="comment">// 直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<span class="comment">// 继续</span></span><br><span class="line">            <span class="comment">// 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">            <span class="comment">// 即将左边的当前元素，填充到 temp数组</span></span><br><span class="line">            <span class="comment">// 然后 t++, i++</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 反之,将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (二)</span></span><br><span class="line">        <span class="comment">// 把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123; <span class="comment">// 左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123; <span class="comment">// 右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (三)</span></span><br><span class="line">        <span class="comment">// 将temp数组的元素拷贝到arr</span></span><br><span class="line">        <span class="comment">// 注意，并不是每次都拷贝所有</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempLeft</span> <span class="operator">=</span> left; <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 第一次合并 tempLeft = 0 , right = 1 //第二次： tempLeft = 2 right = 3 //第三次： tL=0 ri=3</span></span><br><span class="line">        <span class="comment">// 最后一次 tempLeft = 0 right = 7</span></span><br><span class="line">        <span class="keyword">while</span> (tempLeft &lt;= right) &#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            tempLeft += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果：八百万数据用了 1s ，也挺快</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=2020-07-16 16:18:32</span><br><span class="line">排序前的时间是=2020-07-16 16:18:33</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-5、总结"><a href="#8-5、总结" class="headerlink" title="8.5、总结"></a>8.5、总结</h3><ul><li>先将数组分为左右两半，先执行左半边递归：<ul><li>首先执行左递归到最深层，条件 <strong>if (left &lt; right)</strong> 不满足，开始执行合并，合并 { 8, 4 } 到临时数组 temp 中，变为有序数组 { 4, 8 } ，再拷贝回原数组 arr 中</li><li>然后执行最深层的右递归，条件 <strong>if (left &lt; right)</strong> 不满足，开始执行合并，合并 { 5, 7 } 到临时数组 temp 中，变为有序数组 { 2, 7 } ，再拷贝回原数组 arr 中</li><li>合并完后，递归回溯至上一节，开始执行合并，合并 { 4, 5, 7, 8 } 到临时数组 temp 中，变为有序数组 { 4, 5, 7, 8 } ，再拷贝回原数组 arr 中</li></ul></li><li>右左半边的递归也是同样的道理</li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE2MTYxMTM0ODMzLnBuZw?x-oss-process=image/format,png" alt="image-20200716161134833"></p><h2 id="9、基数排序"><a href="#9、基数排序" class="headerlink" title="9、基数排序"></a>9、基数排序</h2><h3 id="9-1、基数排序基本介绍"><a href="#9-1、基数排序基本介绍" class="headerlink" title="9.1、基数排序基本介绍"></a>9.1、基数排序基本介绍</h3><ul><li><strong>基数排序（radix sort） 属于“分配式排序” （distribution sort） ， 又称“桶子法” （bucket sort） 或 bin sort，</strong> 顾名思义， 它是通过键值的各个位的值，<br>将要排序的元素分配至某些“桶” 中， 达到排序的作用</li><li><strong>基数排序法是属于稳定性的排序，</strong> 基数排序法的是效率高的稳定性排序法</li><li>基数排序(Radix Sort)是桶排序的扩展</li><li>基数排序是 1887 年赫尔曼· 何乐礼发明的。 它是这样实现的： 将整数按位数切割成不同的数字， 然后按每个位数分别比较。</li></ul><h3 id="9-2、基数排序思想"><a href="#9-2、基数排序思想" class="headerlink" title="9.2、基数排序思想"></a>9.2、基数排序思想</h3><ul><li>将所有待比较数值统一为同样的数位长度， 数位较短的数前面补零。</li><li>然后， <strong>从最低位开始， 依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</strong></li></ul><h3 id="9-3、基数排序图解"><a href="#9-3、基数排序图解" class="headerlink" title="9.3、基数排序图解"></a>9.3、基数排序图解</h3><ul><li><p>有 10 个桶，对应编号为 0~9</p></li><li><p>步骤</p><ul><li>第一步：根据原数组 arr 中每个元素的个位数，将其依次放入 0~9 号桶中（每个桶从前往后放），放置完毕后，再将桶中的数据依次取出（每个桶从前往后取），放回原数组 arr 中，这样原数组 arr<br>中个位数的元素就已经按照顺序排好了</li><li>第二步：根据原数组 arr 中每个元素的十位数，将其依次放入 0~9 号桶中（每个桶从前往后放），放置完毕后，再将桶中的数据依次取出（每个桶从前往后取），放回原数组 arr 中，这样原数组 arr 中十位数 +<br>个位数的元素就已经按照顺序排好了</li><li>第三步：根据原数组 arr 中每个元素的百位数，将其依次放入 0~9 号桶中（每个桶从前往后放），放置完毕后，再将桶中的数据依次取出（每个桶从前往后取），放回原数组 arr 中，这样原数组 arr 中百位数 + 十位数 +<br>个位数的元素就已经按照顺序排好了</li><li>…</li></ul></li><li><p>何时排序完毕？当数组中最长位数的元素处理完毕，排序完成</p></li><li><p>桶的容量如何确定？假设数组每个元素位数相同，那么单个桶最大容量即为数组容量，我们用一个二维数组来表示桶：<code>int[][] bucket = new int[10][arr.length];</code></p></li><li><p>我们如何知道每桶中装了几个元素？这也需要记录，用一个一维数组来记录：</p><p><code>int[] bucketElementCounts = new int[10];</code></p></li><li><p>总结：</p><ul><li><p>假设数组中元素的最长位数为 maxLength ，则处理完 maxLength 位数后，数组排序完毕：<strong>for(int i = 0 , n = 1; i &lt; maxLength; i++, n *= 10) {</strong></p></li><li><p>使用一个 for 循环处理原一维数组 arr ，将其放入桶中</p><p><strong>for(int j = 0; j &lt; arr.length; j++) {</strong></p></li><li><p>使用两层 for 循环，处理 10 个 桶，将其中的元素放回原一维数组中</p><p><strong>for (int k = 0; k &lt; bucketElementCounts.length; k++) {</strong><br><strong>if (bucketElementCounts[k] != 0) {</strong><br><strong>for (int l = 0; l &lt; bucketElementCounts[k]; l++) {</strong></p></li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTg1ODA5MzE0LnBuZw?x-oss-process=image/format,png" alt="image-20200806185809314"></p><h3 id="9-4、代码实现"><a href="#9-4、代码实现" class="headerlink" title="9.4、代码实现"></a>9.4、代码实现</h3><h4 id="9-4-1、理解基数排序"><a href="#9-4-1、理解基数排序" class="headerlink" title="9.4.1、理解基数排序"></a>9.4.1、理解基数排序</h4><ul><li>逐步分解，理解基数排序算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;基数排序后 &quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基数排序方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//		//根据前面的推导过程，我们可以得到最终的基数排序代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 得到数组中最大的数的位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>]; <span class="comment">//假设第一数就是最大数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">        <span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line">        <span class="comment">//3. 名明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line">        <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">        <span class="comment">//可以这里理解</span></span><br><span class="line">        <span class="comment">//比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line">        <span class="type">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第1轮(针对每个元素的个位进行排序处理)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">//取出每个元素的个位的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / <span class="number">1</span> % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//放入到对应的桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">            <span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">            <span class="keyword">if</span> (bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                    <span class="comment">//取出元素放入到arr</span></span><br><span class="line">                    arr[index++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">            bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第1轮，对个位的排序处理 arr =&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第2轮(针对每个元素的十位进行排序处理)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 取出每个元素的十位的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / <span class="number">10</span> % <span class="number">10</span>; <span class="comment">//748 / 10 =&gt; 74 % 10 =&gt; 4</span></span><br><span class="line">            <span class="comment">// 放入到对应的桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">            <span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">            <span class="keyword">if</span> (bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                    <span class="comment">// 取出元素放入到arr</span></span><br><span class="line">                    arr[index++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">            bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第2轮，对个位的排序处理 arr =&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第3轮(针对每个元素的百位进行排序处理)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 取出每个元素的百位的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / <span class="number">100</span> % <span class="number">10</span>; <span class="comment">// 748 / 100 =&gt; 7 % 10 = 7</span></span><br><span class="line">            <span class="comment">// 放入到对应的桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">            <span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">            <span class="keyword">if</span> (bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                    <span class="comment">// 取出元素放入到arr</span></span><br><span class="line">                    arr[index++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">            bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第3轮，对个位的排序处理 arr =&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第1轮，对个位的排序处理 arr =[542, 53, 3, 14, 214, 748]</span><br><span class="line">第2轮，对个位的排序处理 arr =[3, 14, 214, 542, 748, 53]</span><br><span class="line">第3轮，对个位的排序处理 arr =[3, 14, 53, 214, 542, 748]</span><br><span class="line">基数排序后 [3, 14, 53, 214, 542, 748]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-4-2、编写基数排序"><a href="#9-4-2、编写基数排序" class="headerlink" title="9.4.2、编写基数排序"></a>9.4.2、编写基数排序</h4><ul><li>编写基数排序算法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> arr[] = &#123; <span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span> &#125;;</span><br><span class="line">		radixSort(arr);</span><br><span class="line">		System.out.println(<span class="string">&quot;基数排序后 &quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 基数排序方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根据前面的推导过程，我们可以得到最终的基数排序代码	</span></span><br><span class="line">		<span class="comment">//1. 得到数组中最大的数的位数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>]; <span class="comment">//假设第一数就是最大数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">				max = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//得到最大数是几位数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">		<span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line">		<span class="comment">//3. 名明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line">		<span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">		<span class="comment">//可以这里理解</span></span><br><span class="line">		<span class="comment">//比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line">		<span class="type">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// n=1 表示处理个位，n=10表示处理十位，n=100表示处理百位 ......</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="comment">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="comment">//取出每个元素的对应位的值</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / n % <span class="number">10</span>;</span><br><span class="line">				<span class="comment">//放入到对应的桶中</span></span><br><span class="line">				bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">				bucketElementCounts[digitOfElement]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//遍历每一桶，并将桶中的数据，放入到原数组</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">				<span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">				<span class="comment">// 遍历第k个桶(即第k个一维数组), 将桶中的数据放回原数组中</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">					<span class="comment">// 取出元素放入到arr</span></span><br><span class="line">					arr[index++] = bucket[k][l];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">				bucketElementCounts[k] = <span class="number">0</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;轮，对个位的排序处理 arr =&quot;</span> + Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第1轮，对个位的排序处理 arr =[542, 53, 3, 14, 214, 748]</span><br><span class="line">第2轮，对个位的排序处理 arr =[3, 14, 214, 542, 748, 53]</span><br><span class="line">第3轮，对个位的排序处理 arr =[3, 14, 53, 214, 542, 748]</span><br><span class="line">基数排序后 [3, 14, 53, 214, 542, 748]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-4-3、测试基数排序性能"><a href="#9-4-3、测试基数排序性能" class="headerlink" title="9.4.3、测试基数排序性能"></a>9.4.3、测试基数排序性能</h4><ul><li>测试基数排序算法的性能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G </span></span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8000000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">		<span class="type">Date</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(data1);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line">		</span><br><span class="line">		radixSort(arr);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 基数排序方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根据前面的推导过程，我们可以得到最终的基数排序代码	</span></span><br><span class="line">		<span class="comment">//1. 得到数组中最大的数的位数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>]; <span class="comment">//假设第一数就是最大数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">				max = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//得到最大数是几位数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">		<span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line">		<span class="comment">//3. 名明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line">		<span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">		<span class="comment">//可以这里理解</span></span><br><span class="line">		<span class="comment">//比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line">		<span class="type">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// n=1 表示处理个位，n=10表示处理十位，n=100表示处理百位 ......</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="comment">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="comment">//取出每个元素的对应位的值</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / n % <span class="number">10</span>;</span><br><span class="line">				<span class="comment">//放入到对应的桶中</span></span><br><span class="line">				bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">				bucketElementCounts[digitOfElement]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//遍历每一桶，并将桶中的数据，放入到原数组</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">				<span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">				<span class="comment">// 遍历第k个桶(即第k个一维数组), 将桶中的数据放回原数组中</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">					<span class="comment">// 取出元素放入到arr</span></span><br><span class="line">					arr[index++] = bucket[k][l];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">				bucketElementCounts[k] = <span class="number">0</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;轮，对个位的排序处理 arr =&quot;</span> + Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>程序运行结果：可以啊，八百万数据 1s 就排好了，但是太占空间了</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=2020-07-16 18:16:21</span><br><span class="line">排序前的时间是=2020-07-16 18:16:22</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-5、基数排序的说明"><a href="#9-5、基数排序的说明" class="headerlink" title="9.5、基数排序的说明"></a>9.5、基数排序的说明</h3><ul><li>基数排序是对传统桶排序的扩展， 速度很快</li><li>基数排序是经典的空间换时间的方式， 占用内存很大，当对海量数据排序时， 容易造成 OutOfMemoryError 。</li><li>基数排序时稳定的。 [注：假定在待排序的记录序列中， 存在多个具有相同的关键字的记录， 若经过排序， 这些记录的相对次序保持不变， 即在原序列中， r[i]=r[j]， 且 r[i]在 r[j]之前， 而在排序后的序列中， r[i]仍在<br>r[j]之前，则称这种排序算法是稳定的； 否则称为不稳定的]</li><li>有负数的数组， 我们不用基数排序来进行排序, 如果要支持负数， 参考: <a target="_blank" rel="noopener" href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9</a></li></ul><h2 id="10、常用排序算法总结和对比"><a href="#10、常用排序算法总结和对比" class="headerlink" title="10、常用排序算法总结和对比"></a>10、常用排序算法总结和对比</h2><h3 id="10-1、排序算法的比较图"><a href="#10-1、排序算法的比较图" class="headerlink" title="10.1、排序算法的比较图"></a>10.1、排序算法的比较图</h3><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE2MjAxMDQ2NTM0LnBuZw?x-oss-process=image/format,png" alt="image-20200716201046534"></p><h3 id="10-2、相关术语解释"><a href="#10-2、相关术语解释" class="headerlink" title="10.2、相关术语解释"></a>10.2、相关术语解释</h3><ul><li><strong>稳定</strong>：如果 a 原本在 b 前面， 而 a=b， 排序之后 a 仍然在 b 的前面；</li><li><strong>不稳定</strong>：如果 a 原本在 b 的前面， 而 a=b， 排序之后 a 可能会出现在 b 的后面；</li><li>内排序： 所有排序操作都在内存中完成；</li><li>外排序： 由于数据太大， 因此把数据放在磁盘中， 而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度： 一个算法执行所耗费的时间。</li><li>空间复杂度： 运行完一个程序所需内存的大小。</li><li>n: 数据规模</li><li>k: “桶” 的个数</li><li><strong>In-place</strong>：不占用额外内存</li><li><strong>Out-place</strong>：占用额外内存</li></ul></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">__°ゝ 浮华 つ __</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://lixiaogou.gitee.io/posts/92e9d7099040/">http://lixiaogou.gitee.io/posts/92e9d7099040/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://lixiaogou.gitee.io" target="_blank">__°ゝ 浮华 つ __</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="https://pic.imgdb.cn/item/6188cfa22ab3f51d91ef1890.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/86fd8817980f/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.3gbizhi.com/2020/0924/20200924124353869.jpg" onerror='onerror=null,src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第 8 章 查找算法</div></div></a></div><div class="next-post pull-right"><a href="/posts/ff721586239b/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E8%8A%88%E6%9C%88-%E7%99%BD%E6%99%B6%E6%99%B6.jpg" onerror='onerror=null,src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第 6 章 递归</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/ca739bba4473/" title="GC发生在JVM哪部分，有几种GC，他们的算法是什么?"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.imgdb.cn/item/5f674e17160a154a67ffd8b8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-22</div><div class="title">GC发生在JVM哪部分，有几种GC，他们的算法是什么?</div></div></a></div><div><a href="/posts/0207dc17c3c9/" title="布隆过滤器"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%AE%9D%E9%9D%92%E5%9D%8A%E4%B8%BB%E8%85%BF.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-22</div><div class="title">布隆过滤器</div></div></a></div><div><a href="/posts/cf4ad7ff29a0/" title="Java并发容器和框架"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/bg14.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-27</div><div class="title">Java并发容器和框架</div></div></a></div><div><a href="/posts/7344f528bbd2/" title="ThreadLocal作用、场景、原理"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.imgdb.cn/item/6108ac4d5132923bf8ca61c3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-22</div><div class="title">ThreadLocal作用、场景、原理</div></div></a></div><div><a href="/posts/58239c5dd394/" title="剑指 Offer 25. 合并两个排序的链表"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E8%8A%88%E6%9C%88-%E7%99%BD%E6%99%B6%E6%99%B6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-22</div><div class="title">剑指 Offer 25. 合并两个排序的链表</div></div></a></div><div><a href="/posts/e60f1873c6b0/" title="剑指 Offer 52. 两个链表的第一个公共节点"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.imgdb.cn/item/6108ac4d5132923bf8ca61c3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-22</div><div class="title">剑指 Offer 52. 两个链表的第一个公共节点</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/moyuyu.gif" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">__°ゝ 浮华 つ __</div><div class="author-info__description">乘风破浪会有时，直挂云帆济沧海</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">99</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/lixiaogou"><i class="iconfont icon-gitee"></i><span>码云</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/lixiaolong6881644" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://gitee.com/lixiaogou" target="_blank" title="iconfont icon-gitee"><i class="iconfont icon-gitee"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">第 7 章 排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1、排序算法介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1、排序算法的简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2、排序算法的分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.</span> <span class="toc-text">2、算法的复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1、时间复杂度的度量方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E3%80%81%E6%97%B6%E9%97%B4%E9%A2%91%E5%BA%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2、时间频度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E3%80%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3、时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4、常见的时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1%E3%80%81%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">2.4.1、常见时间复杂度概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2%E3%80%81%E5%B8%B8%E6%95%B0%E9%98%B6-O-1"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">2.4.2、常数阶 O(1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3%E3%80%81%E5%AF%B9%E6%95%B0%E9%98%B6-O-log2n"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">2.4.3、对数阶 O(log2n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4%E3%80%81%E7%BA%BF%E6%80%A7%E9%98%B6-O-n"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">2.4.4、线性阶 O(n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5%E3%80%81%E7%BA%BF%E6%80%A7%E5%AF%B9%E6%95%B0%E9%98%B6-O-nlogN"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">2.4.5、线性对数阶 O(nlogN)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-6%E3%80%81%E5%B9%B3%E6%96%B9%E9%98%B6-O-n%C2%B2"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">2.4.6、平方阶 O(n²)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-7%E3%80%81%E5%85%B6%E4%BB%96%E9%98%B6"><span class="toc-number">1.2.4.7.</span> <span class="toc-text">2.4.7、其他阶</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5%E3%80%81%E5%B9%B3%E5%9D%87%E5%92%8C%E6%9C%80%E5%9D%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5、平均和最坏时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6%E3%80%81%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.6.</span> <span class="toc-text">2.6、算法的空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3、冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1%E3%80%81%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1、基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2%E3%80%81%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2、冒泡排序图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3、代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1%E3%80%81%E7%90%86%E8%A7%A3%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">3.3.1、理解冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2%E3%80%81%E7%BC%96%E5%86%99%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">3.3.2、编写冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3%E3%80%81%E6%B5%8B%E8%AF%95%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">3.3.3、测试冒泡排序性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">4、选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1、选择排序基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2、选择排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3、选择排序图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4、代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-1%E3%80%81%E7%90%86%E8%A7%A3%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">4.4.1、理解选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-2%E3%80%81%E7%BC%96%E5%86%99%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">4.4.2、编写选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-3%E3%80%81%E6%B5%8B%E8%AF%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">4.4.3、测试选择排序性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text">5、插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1、插入排序基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2、插入排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3、插入排序图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4、代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1%E3%80%81%E7%90%86%E8%A7%A3%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">5.4.1、理解插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2%E3%80%81%E7%BC%96%E5%86%99%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.5.4.2.</span> <span class="toc-text">5.4.2、编写插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3%E3%80%81%E6%B5%8B%E8%AF%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD"><span class="toc-number">1.5.4.3.</span> <span class="toc-text">5.4.3、测试插入排序性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">6、希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1%E3%80%81%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1、简单插入排序问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2、希尔排序基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3、希尔排序基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3%EF%BC%88%E4%BA%A4%E6%8D%A2%E6%B3%95%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4、希尔排序图解（交换法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.5.</span> <span class="toc-text">6.5、代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-1%E3%80%81%E7%90%86%E8%A7%A3%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%A4%E6%8D%A2%E6%B3%95%EF%BC%89"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">6.5.1、理解希尔排序（交换法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-2%E3%80%81%E7%BC%96%E5%86%99%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%A4%E6%8D%A2%E6%B3%95%EF%BC%89"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">6.5.2、编写希尔排序（交换法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-3%E3%80%81%E6%B5%8B%E8%AF%95%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E4%BA%A4%E6%8D%A2%E6%B3%95%EF%BC%89%E6%80%A7%E8%83%BD"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">6.5.3、测试希尔排序（交换法）性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-4%E3%80%81%E7%BC%96%E5%86%99%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E6%8F%92%E5%85%A5%E6%B3%95%EF%BC%89"><span class="toc-number">1.6.5.4.</span> <span class="toc-text">6.5.4、编写希尔排序（插入法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-5%E3%80%81%E6%B5%8B%E8%AF%95%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E6%8F%92%E5%85%A5%E6%B3%95%EF%BC%89%E6%80%A7%E8%83%BD"><span class="toc-number">1.6.5.5.</span> <span class="toc-text">6.5.5、测试希尔排序（插入法）性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text">7、快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1%E3%80%81%E5%BF%AB%E6%8E%92%E7%AE%80%E4%BB%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1、快排简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2%E3%80%81%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2、代码思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3、代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1%E3%80%81%E7%BC%96%E5%86%99%E5%BF%AB%E6%8E%92%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">7.3.1、编写快排算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2%E3%80%81%E6%B5%8B%E8%AF%95%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD"><span class="toc-number">1.7.3.2.</span> <span class="toc-text">7.3.2、测试快速排序性能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">8、归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1、归并排序基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2、归并排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E6%80%9D%E8%B7%AF"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3、归并排序代码思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4、代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-1%E3%80%81%E7%BC%96%E5%86%99%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.4.1.</span> <span class="toc-text">8.4.1、编写归并排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-2%E3%80%81%E6%B5%8B%E8%AF%95%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD"><span class="toc-number">1.8.4.2.</span> <span class="toc-text">8.4.2、测试归并排序性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.</span> <span class="toc-text">9、基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.9.1.</span> <span class="toc-text">9.1、基数排序基本介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3"><span class="toc-number">1.9.2.</span> <span class="toc-text">9.2、基数排序思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E5%9B%BE%E8%A7%A3"><span class="toc-number">1.9.3.</span> <span class="toc-text">9.3、基数排序图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.9.4.</span> <span class="toc-text">9.4、代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-1%E3%80%81%E7%90%86%E8%A7%A3%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">9.4.1、理解基数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-2%E3%80%81%E7%BC%96%E5%86%99%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">9.4.2、编写基数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-3%E3%80%81%E6%B5%8B%E8%AF%95%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E6%80%A7%E8%83%BD"><span class="toc-number">1.9.4.3.</span> <span class="toc-text">9.4.3、测试基数排序性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5%E3%80%81%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">1.9.5.</span> <span class="toc-text">9.5、基数排序的说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%E5%92%8C%E5%AF%B9%E6%AF%94"><span class="toc-number">1.10.</span> <span class="toc-text">10、常用排序算法总结和对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1%E3%80%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83%E5%9B%BE"><span class="toc-number">1.10.1.</span> <span class="toc-text">10.1、排序算法的比较图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2%E3%80%81%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A"><span class="toc-number">1.10.2.</span> <span class="toc-text">10.2、相关术语解释</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c0c9053864e4/" title="剑指 Offer 48. 最长不含重复字符的子字符串"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E8%8A%88%E6%9C%88-%E7%99%BD%E6%99%B6%E6%99%B6.jpg" onerror='this.onerror=null,this.src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="剑指 Offer 48. 最长不含重复字符的子字符串"></a><div class="content"><a class="title" href="/posts/c0c9053864e4/" title="剑指 Offer 48. 最长不含重复字符的子字符串">剑指 Offer 48. 最长不含重复字符的子字符串</a><time datetime="2022-12-27T08:11:23.000Z" title="发表于 2022-12-27 16:11:23">2022-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/57171c70af23/" title="剑指 Offer 46. 把数字翻译成字符串"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/o_201126142701street_race.jpg" onerror='this.onerror=null,this.src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="剑指 Offer 46. 把数字翻译成字符串"></a><div class="content"><a class="title" href="/posts/57171c70af23/" title="剑指 Offer 46. 把数字翻译成字符串">剑指 Offer 46. 把数字翻译成字符串</a><time datetime="2022-12-27T08:11:23.000Z" title="发表于 2022-12-27 16:11:23">2022-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4e696c3a5663/" title="剑指 Offer 58 - I. 翻转单词顺序"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg" onerror='this.onerror=null,this.src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="剑指 Offer 58 - I. 翻转单词顺序"></a><div class="content"><a class="title" href="/posts/4e696c3a5663/" title="剑指 Offer 58 - I. 翻转单词顺序">剑指 Offer 58 - I. 翻转单词顺序</a><time datetime="2022-12-26T05:11:23.000Z" title="发表于 2022-12-26 13:11:23">2022-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3204e7f3f0b1/" title="剑指 Offer 57 - II. 和为s的连续正数序列"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.imgdb.cn/item/6108ac4d5132923bf8ca61c3.png" onerror='this.onerror=null,this.src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="剑指 Offer 57 - II. 和为s的连续正数序列"></a><div class="content"><a class="title" href="/posts/3204e7f3f0b1/" title="剑指 Offer 57 - II. 和为s的连续正数序列">剑指 Offer 57 - II. 和为s的连续正数序列</a><time datetime="2022-12-23T05:11:23.000Z" title="发表于 2022-12-23 13:11:23">2022-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/a777d4103eb9/" title="剑指 Offer 57. 和为s的两个数字"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://pic.imgdb.cn/item/6126fbbd44eaada739d33cad.jpg" onerror='this.onerror=null,this.src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg"' alt="剑指 Offer 57. 和为s的两个数字"></a><div class="content"><a class="title" href="/posts/a777d4103eb9/" title="剑指 Offer 57. 和为s的两个数字">剑指 Offer 57. 和为s的两个数字</a><time datetime="2022-12-23T05:11:23.000Z" title="发表于 2022-12-23 13:11:23">2022-12-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 <i id="heartbeat" class="fa fas fa-heartbeat"></i> __°ゝ 浮华 つ __</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">乘风破浪会有时，直挂云帆济沧海</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script data-pjax src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script data-pjax src="/js/xkTool.js"></script><script data-pjax src="/js/myDiyJs.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="卧槽,🐂🍺,666" data-fontsize="15px" data-random="false" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>