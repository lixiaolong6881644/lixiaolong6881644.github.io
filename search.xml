<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GC发生在JVM哪部分，有几种GC，他们的算法是什么?</title>
    <url>/posts/ca739bba4473/</url>
    <content><![CDATA[<h1 id="GC发生在JVM哪部分，有几种GC，他们的算法是什么"><a href="#GC发生在JVM哪部分，有几种GC，他们的算法是什么" class="headerlink" title="GC发生在JVM哪部分，有几种GC，他们的算法是什么?"></a>GC发生在JVM哪部分，有几种GC，他们的算法是什么?</h1><p>脑图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/JVM/20220325154932.png" alt="image-20210220093820879"></p>
<h2 id="GC发生在JVM哪部分"><a href="#GC发生在JVM哪部分" class="headerlink" title="GC发生在JVM哪部分"></a>GC发生在JVM哪部分</h2><p>GC 发生在JVM的堆里面</p>
<h2 id="JVM体系结构概况"><a href="#JVM体系结构概况" class="headerlink" title="JVM体系结构概况"></a>JVM体系结构概况</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/JVM/20220325154827.png" alt="image-20210220090604466"></p>
<h2 id="有几种GC？"><a href="#有几种GC？" class="headerlink" title="有几种GC？"></a>有几种GC？</h2><p>两种GC</p>
<ul>
<li>年轻代 Minor GC</li>
<li>老年代 Full GC</li>
<li>基本不动Perm区无GC</li>
</ul>
<h2 id="GC的算法是什么"><a href="#GC的算法是什么" class="headerlink" title="GC的算法是什么"></a>GC的算法是什么</h2><h3 id="4种算法"><a href="#4种算法" class="headerlink" title="4种算法"></a>4种算法</h3><p>1、<strong>引用计数法</strong>（java废弃）</p>
<p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；</p>
<p>计数器值为0的对象就是不再被使用的，垃圾收集器将回收该对象，若频繁被使用就将对象放到==老年代==中。</p>
<blockquote>
<p>特点：速度快。但是”互相引用,循环引用”的对象却无法回收。(正是由于这个缺陷,这个算法不再被使用)</p>
</blockquote>
<p>2、<strong>复制（Copying）算法</strong></p>
<p>它将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。</p>
<p>这样每次只对半个区域进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。   </p>
<blockquote>
<p>缺点：整体可用内存缩小了一半，这样代价太高了</p>
</blockquote>
<p>现在的商用虚拟机都采用这种算法来回收新生代，新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。</p>
<p>每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。当Survivor空间不够用时，需要依赖老年代进行分配担保（Handle Promotion）。</p>
<blockquote>
<p>特点：</p>
<ul>
<li>==年轻代==</li>
<li>效率高，没有内存碎片，占用空间大</li>
</ul>
</blockquote>
<p>复制算法的执行过程如图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/JVM/20220325154948.png" alt="image-20210220090950132"></p>
<p>3、<strong>标记-清除（Mark-Sweep）算法</strong></p>
<p>分为“标记”和“清除”两个阶段：首先标记出所有需要清除的对象，标记完成后统一清除所有被标记的对象。 不足主要体现在效率和空间: 从效率的角度讲，标记和清除两个过程的效率都不高； 从空间的角度讲，标记清除后会产生大量不连续的内存碎片， 内存碎片太多可能会导致以后程序运行过程中在需要分配较大对象时，无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。  </p>
<blockquote>
<p>特点：</p>
<ul>
<li>效率低，有碎片</li>
<li>==老年代==</li>
</ul>
</blockquote>
<p>标记-清除算法执行过程如图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/JVM/20220325154953.png" alt="image-20210220091356682"></p>
<p>4、<strong>标记-整理（Mark-Compact）算法</strong></p>
<p>复制算法在对象存活率较高的场景下要进行大量的复制操作，效率很低。万一对象100%存活，那么需要有额外的空间进行分配担保。老年代都是不易被回收的对象，对象存活率高，因此一般不能直接选用复制算法。老年代的标记-整理算法，过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。</p>
<blockquote>
<p>特点：</p>
<ul>
<li>==老年代==</li>
<li>需要移动碎片，效率低，没内存碎片</li>
</ul>
</blockquote>
<p>标记-整理算法的工作过程如图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/JVM/20220325154957.png" alt="image-20210220091431138"></p>
<p>5、<strong>分代收集算法</strong></p>
<p>现代商用虚拟机基本都采用分代收集算法来进行垃圾回收。这种算法就是上面内容的结合罢了，</p>
<p>根据对象的不同生命周期，将内存划分为几块，然后根据各块的特点采用最适当的收集算法。</p>
<blockquote>
<p>大批对象死去、少量对象存活的（新生代），使用复制算法，复制成本低；</p>
<p>对象存活率高、没有额外空间进行分配担保的（老年代），采用标记-清理算法或者标记-整理算法。</p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/JVM/20220325155001.png" alt="image-20210220091522897"></p>
]]></content>
      <categories>
        <category>GC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>6道题搞懂String关于相等比较的问题</title>
    <url>/posts/4f12af838c0e/</url>
    <content><![CDATA[<h1 id="String关于相等比较的面试题"><a href="#String关于相等比较的面试题" class="headerlink" title="String关于相等比较的面试题"></a>String关于相等比较的面试题</h1><p><strong>字符串字面值会存储在常量池中</strong></p>
<p><strong>关于String对象的存储</strong></p>
<p>请看这样两个语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>; </span><br><span class="line"><span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>现在来分析一下内存的分配情况。如图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220330145741.jpg" alt="img"></p>
<p> 可以看出，x与y存在栈中，它们保存了相应对象的引用。</p>
<p>第一条语句没有在堆中分配内存，而是将“abc”保存在常量池中。</p>
<p>对于第二条语句，同样会在常量池中有一个“abcd”的字符串，当new时，会拷贝一份该字符串存放到堆中，于是y指向了堆中的那个“abcd”字符串。</p>
<p><strong>final注意事项</strong></p>
<p>当final变量是基本数据类型以及String类型时，如果在编译期间能知道它的确切值，则编译器会把它当做编译期常量使用。也就是说在用到该final变量的地方，相当于直接访问的这个常量，不需要在运行时确定</p>
<p>如果您明白了，那么看一下接下里的六道题。</p>
<p>1、当<strong>两个字符串字面值连接时（相加）</strong>，得到的新字符串依然是字符串字面值，保存在常量池中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   </span><br><span class="line">    <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a1&quot;</span>;   </span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="number">1</span>;   </span><br><span class="line">    System.out.println(a == b); <span class="comment">//true  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220330145752.png" alt="image-20220330140346507"></p>
<p>2、当<strong>字符串字面值与String类型变量连接时</strong>，得到的新字符串不再保存在常量池中，而是在堆中新建一个String对象来存放。很明显常量池中要求的存放的是常量，有<strong>String类型变量</strong>当然不能存在常量池中了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   </span><br><span class="line">    <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;   <span class="comment">//1</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + b; <span class="comment">//2  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;  <span class="comment">//3</span></span><br><span class="line">    System.out.println(s1 == s2);   <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第2行 会先创建一个new StringBuilder()，然后再append(“a”)，再append(“b”)，最后toString()；下图里面展示了StringBuilder类的toString方法和 上方内存分布图。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220330145757.png" alt="image-20220330114008684"></p>
<p>3、 注意此题与上一题的区别，此处是<strong>字符串字面值与String类型常量</strong>连接，得到的新字符串依然保存在常量池中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   </span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;   <span class="comment">//1 常量</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + b; <span class="comment">//2  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;  <span class="comment">//3</span></span><br><span class="line">    System.out.println(s1 == s2);   <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220330145803.png" alt="image-20220330114941892"></p>
<p>4、此题中第条语句：<strong>final String b = getB()；其实与final String b = new String(“b”);是一样的</strong>。也就是说return “b”会在堆中创建一个String对象保存”b”，虽然bb被定义成了final。<strong>可见并非定义为final的就保存在常量池中，很明显此处bb常量引用的String对象保存在堆中</strong>，因为getB()得到的String已经保存在堆中了，final的String引用并不会改变String已经保存在堆中这个事实。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> getBB();</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + b;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    System.out.println(s1 == s2);   <span class="comment">// false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存分布如上面的案例2；</p>
<p>5、 可能很多人对intern()这个函数不了解。JDK API文档中对intern()方法的描述是：</p>
<p>  返回字符串对象的规范化表示形式。  一个初始为空的字符串池，它由类 String 私有地维护。</p>
<p>  当调用 intern 方法时，如果池已经包含一个等于此 String 对象的字符串（用 equals(Object) 方法确定），则返回池中的字符串。否则，将此 String 对象添加到池中，并返回此 String 对象的引用。</p>
<p>  它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。 所有字面值字符串和字符串赋值常量表达式都使用 intern 方法进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   </span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;   <span class="comment">//1</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;   <span class="comment">//2</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1 + s2;   <span class="comment">//3</span></span><br><span class="line">    System.out.println(s == a); <span class="comment">//4  //false</span></span><br><span class="line">    System.out.println(s.equals(a));<span class="comment">//5 //true  </span></span><br><span class="line">    System.out.println(s.intern() == a);<span class="comment">//6 //true  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过第2题之后，现在可以知道 s1+s2 会通过StringBuild创建新的String实例，也就是s指向堆中的变量，所以s==a是false，但是s,equals(a)是true，由于池中有 a.equals(s)=true，所以s.intern()得到的是a变量的字面值”ab”，所以6处是true</p>
<p>6、第五题看明白后，第六题就没什么好讲的了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>);   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   </span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;   <span class="comment">//1</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;   <span class="comment">//2</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1 + s2;   <span class="comment">//3</span></span><br><span class="line">    System.out.println(s == a);<span class="comment">//4 //false</span></span><br><span class="line">    System.out.println(s.equals(a));<span class="comment">//5 //true</span></span><br><span class="line">    System.out.println(s.intern() == a);<span class="comment">//6 //false</span></span><br><span class="line">    System.out.println(s.intern() == a.intern());<span class="comment">//7 //true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//3 新创建了一个String实例s，持有堆中的某引用；a也是新创建了一个String实例，持有堆中的另一个某引用；</p>
<p>//4 两个引用不相等所以false</p>
<p>//5 两个引用中的内容是相等的，所以true</p>
<p>//6 由于池中有 a.equals(s)=true，所以s.intern()得到的是a变量的字面值”ab”，所以6处字面值”ab” 不等于 变量a，所以为false</p>
<p>//7 由于池中有 a.equals(s)=true，所以s.intern()得到的是a变量的字面值”ab”，a.intern()得到的也是a变量的字面值”ab”，所以 true</p>
<hr>
<p>以上内容若有错误之处，欢迎各位批评指正，若有侵权，请告知删除！更多精彩内容请扫码关注，获取最新动态，一手资料，技术前沿。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg" alt="公众号"></p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/fd89fdb9ba19/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://lixiaogou.gitee.io/">Deployment</a></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>Class简介和两道送分题</title>
    <url>/posts/8531f37ee60e/</url>
    <content><![CDATA[<h1 id="Class简介和两道送分题"><a href="#Class简介和两道送分题" class="headerlink" title="Class简介和两道送分题"></a>Class简介和两道送分题</h1><p>Java中所有的类、接口、枚举、注解、数组、基本数据类型、void关键字，都有Class对象。通过Class对象可以得到类的完整结构，一个Class对象在jvm中只有一个实例。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325220651.png" alt="image-20201015142716166"></p>
<p>获取类实例测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;这个人是 &quot;</span> + person.name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一 通过getClass()获取类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> person.getClass();</span><br><span class="line">        System.out.println(c1.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二 通过forName获取类 可以获取到静态的类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.kuang.Student&quot;</span>);</span><br><span class="line">        System.out.println(c2.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式三 通过类名.class获得</span></span><br><span class="line">        Class&lt;Student&gt; c3 = Student.class;</span><br><span class="line">        System.out.println(c3.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式4 基本内置类型的 `包装类` 都有一个Type属性 通过该属性获得</span></span><br><span class="line">        Class&lt;Integer&gt; c4 = Integer.TYPE;</span><br><span class="line">        System.out.println(c4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取父类的类型</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> c1.getSuperclass();</span><br><span class="line">        System.out.println(c5);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Teacher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = <span class="string">&quot;老师&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang;</span><br><span class="line"><span class="comment">//哪些类有class对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Object.class; <span class="comment">//类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Comparable.class;<span class="comment">//接口</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> String[].class;<span class="comment">//一维数组</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="type">int</span>[][].class;<span class="comment">//二位数据</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c5</span> <span class="operator">=</span> Override.class;<span class="comment">//注解</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c6</span> <span class="operator">=</span> ElementType.class;<span class="comment">//枚举</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c7</span> <span class="operator">=</span> Integer.class;<span class="comment">//基本类型的包装类</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="keyword">void</span>.class;<span class="comment">//void</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c9</span> <span class="operator">=</span> Class.class;<span class="comment">///Class</span></span><br><span class="line">        System.out.println(c1);</span><br><span class="line">        System.out.println(c2);</span><br><span class="line">        System.out.println(c3);</span><br><span class="line">        System.out.println(c4);</span><br><span class="line">        System.out.println(c5);</span><br><span class="line">        System.out.println(c6);</span><br><span class="line">        System.out.println(c7);</span><br><span class="line">        System.out.println(c8);</span><br><span class="line">        System.out.println(c9);</span><br><span class="line"><span class="comment">//输出结果  注意数组的输出结果有点特殊</span></span><br><span class="line"><span class="comment">//        class java.lang.Object</span></span><br><span class="line"><span class="comment">//        interface java.lang.Comparable</span></span><br><span class="line"><span class="comment">//        class [Ljava.lang.String;</span></span><br><span class="line"><span class="comment">//        class [[I</span></span><br><span class="line"><span class="comment">//        interface java.lang.Override</span></span><br><span class="line"><span class="comment">//        class java.lang.annotation.ElementType</span></span><br><span class="line"><span class="comment">//        class java.lang.Integer</span></span><br><span class="line"><span class="comment">//        void</span></span><br><span class="line"><span class="comment">//        class java.lang.Class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>Class类实际是一个泛型类。</strong></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325220659.png" alt="image-20201015143706339"></p>
<h1 id="Class常用方法"><a href="#Class常用方法" class="headerlink" title="Class常用方法"></a>Class常用方法</h1><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325220754.png" alt="image-20201015143918733"></p>
<h1 id="JAVA内存分析"><a href="#JAVA内存分析" class="headerlink" title="JAVA内存分析"></a>JAVA内存分析</h1><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325220822.png" alt="image-20201015163057611"></p>
<h1 id="两道送分题"><a href="#两道送分题" class="headerlink" title="两道送分题"></a>两道送分题</h1><h1 id="一、java类装载过程分为3步："><a href="#一、java类装载过程分为3步：" class="headerlink" title="一、java类装载过程分为3步："></a>一、java类装载过程分为3步：</h1><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325220831.png" alt="image-20201015230405350"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325220838.png" alt="image-20201015155306516"></p>
<h2 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a><strong>1、加载</strong></h2><p>Jvm把class文件字节码加载到内存中，并将这些<strong>静态数据</strong>装换成运行时数据区中<strong>方法区</strong>的类型数据，在运行时数据区<strong>堆中</strong>生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。</p>
<blockquote>
<p>注：方法区不仅仅是存放方法，它还存放的是类的类型信息(class对象)。</p>
</blockquote>
<h2 id="2、链接"><a href="#2、链接" class="headerlink" title="2、链接"></a><strong>2、链接</strong></h2><p>执行下面的<strong>校验</strong>、<strong>准备</strong>和<strong>解析</strong>步骤，其中<strong>解析步骤是可选</strong>的</p>
<ul>
<li><p>校验：检查加载的class文件的正确性和安全性</p>
</li>
<li><p>准备：为<strong>类变量（static）</strong>分配存储空间并设置类变量初始值（变量类型的默认值），类变量随类型信息存放在<strong>方法区</strong>中，生命周期很长，使用不当很容易造成内存泄漏。</p>
</li>
<li><p>解析：jvm将常量池内的符号引用（常量名）转换为直接引用（地址）</p>
</li>
</ul>
<h2 id="3、初始化"><a href="#3、初始化" class="headerlink" title="3、初始化"></a><strong>3、初始化</strong></h2><p>执行<strong>类变量赋值</strong>和<strong>静态代码块</strong></p>
<h1 id="二、Class-forName和ClassLoader的区别？"><a href="#二、Class-forName和ClassLoader的区别？" class="headerlink" title="二、Class.forName和ClassLoader的区别？"></a>二、Class.forName和ClassLoader的区别？</h1><p>在了解了类装载过程之后我们继续比较二者区别：<br><strong>Classloder.loaderClass(String name)</strong><br>其实该方法内部调用的是：Classloder. loadClass(name, false)<br>方法：Classloder. loadClass(String name, boolean resolve)<br>a：参数name代表类的全限定类名<br>b：参数resolve代表是否解析，resolve为true是解析该类</p>
<p><strong>Class.forName(String name)</strong><br>其实该方法内部调用的是：Class.forName(className, true, ClassLoader.getClassLoader(caller))<br>方法：Class.forName0(String name, boolean initialize, ClassLoader loader)</p>
<p>参数name代表全限定类名</p>
<p>参数initialize表示是否初始化该类，为true是初始化该类</p>
<p>参数loader 对应的类加载器</p>
<p><strong>两者最大的区别</strong></p>
<ul>
<li>Class.forName除了将类的.class文件加载到jvm中之外，还会对类进行解释，<strong>执行类中的static块。也会加载静态方法。</strong></li>
<li>classloader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容，只有在newInstance才会去执行static块。</li>
<li>Class.forName(name,initialize,loader)带参数也可控制是否加载static块。并且只有调用了newInstance()方法才执行构造函数，创建类的对象。</li>
</ul>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassloaderAndForNameTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">wholeNameLine</span> <span class="operator">=</span> <span class="string">&quot;com.kuang.Line&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">wholeNamePoint</span> <span class="operator">=</span> <span class="string">&quot;com.kuang.Point&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;下面是测试Classloader的效果&quot;</span>);</span><br><span class="line">        testClassloader(wholeNameLine, wholeNamePoint);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;下面是测试Class.forName的效果&quot;</span>);</span><br><span class="line">        testForName(wholeNameLine, wholeNamePoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * classloader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wholeNameLine</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wholeNamePoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testClassloader</span><span class="params">(String wholeNameLine, String wholeNamePoint)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; line;</span><br><span class="line">        Class&lt;?&gt; point;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            line = loader.loadClass(wholeNameLine);</span><br><span class="line">            point = loader.loadClass(wholeNamePoint);</span><br><span class="line">            System.out.println(<span class="string">&quot;line &quot;</span> + line.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;point &quot;</span> + point.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class.forName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wholeNameLine</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> wholeNamePoint</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testForName</span><span class="params">(String wholeNameLine, String wholeNamePoint)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; line = Class.forName(wholeNameLine);</span><br><span class="line">            Class&lt;?&gt; point = Class.forName(wholeNamePoint);</span><br><span class="line">            System.out.println(<span class="string">&quot;line   &quot;</span> + line.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;point   &quot;</span> + point.getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行: loading point&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法执行给静态变量赋值：loading point&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;mask&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通静态方法执行：loading point&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;point普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Point</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;point构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行: loading line&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> getString();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;给静态变量赋值的静态方法执行：loading line&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;mask&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通静态方法执行：loading line&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Line</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造方法执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line"><span class="comment">//下面是测试Classloader的效果</span></span><br><span class="line"><span class="comment">//line com.kuang.Line</span></span><br><span class="line"><span class="comment">//point com.kuang.Point</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//下面是测试Class.forName的效果</span></span><br><span class="line"><span class="comment">//静态代码块执行: loading line</span></span><br><span class="line"><span class="comment">//给静态变量赋值的静态方法执行：loading line</span></span><br><span class="line"><span class="comment">//静态代码块执行: loading point</span></span><br><span class="line"><span class="comment">//静态方法执行给静态变量赋值：loading point</span></span><br><span class="line"><span class="comment">//line   com.kuang.Line</span></span><br><span class="line"><span class="comment">//point   com.kuang.Point</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Collection家族</title>
    <url>/posts/0330077f5cdb/</url>
    <content><![CDATA[<h1 id="Collection家族"><a href="#Collection家族" class="headerlink" title="Collection家族"></a>Collection家族</h1><p>Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。</p>
<h1 id="什么是集合"><a href="#什么是集合" class="headerlink" title="什么是集合"></a>什么是集合</h1><p>集合是存储对象的容器，面相对象语言对事物的体现都是以对象的形式，所以为了方便对多个对象的操作，存储对象，集合是存储对象最常用的一种方式。</p>
<p>集合的出现就是为了持有对象。集合中可以存储任意类型，而且长度可变。在程序中有可能无法预知需要多少个对象，那么用数组来装对象的话，长度不好定义，而集合解决了这样的问题。</p>
<h1 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h1><ul>
<li>数组的长度是固定的，集合长度是可变的。</li>
<li>数组中可以存储基本数据类型，集合只能存储对象（Java集合实际存放的只是对象的引用，每个集合元素都是一个引用变量，实际内容都放在堆内存或方法区里面，但是基本数据类型是在栈内存上分配空间的，栈上的数据随时就会被收回）。</li>
<li>数组中存储数据类型是单一的，集合中可以存储任意类型的对象。</li>
</ul>
<h1 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h1><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325220922.jpg" alt="img"></p>
<p>上图是Java集合框架图，这边我们就只先看Iterator接口、Collection接口和其子接口。</p>
<h2 id="Iterator简介"><a href="#Iterator简介" class="headerlink" title="Iterator简介"></a>Iterator简介</h2><p>Iterator的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterable</span>&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Iterator是一个接口，它是集合的迭代器。集合可以通过Iterator去遍历集合中的元素。</strong></p>
<p><strong>注意：Iterator遍历Collection时，是fail-fast机制的。即，当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛ConcurrentModificationException异常，产生fail-fast事件。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Iterator的API</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> E <span class="title function_">next</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span></span><br></pre></td></tr></table></figure>



<h2 id="ListIterator简介"><a href="#ListIterator简介" class="headerlink" title="ListIterator简介"></a>ListIterator简介</h2><p>ListIterator的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ListIterator</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ListIterator是一个继承于Iterator的接口。它是队列迭代器，专门用于遍历List，能提供向前/向后遍历。相比于Iterator，它新增了添加、是否存在上一个元素、获取上一个元素等API接口。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ListIterator的API</span></span><br><span class="line"><span class="comment">// 继承于Iterator的接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> E <span class="title function_">next</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span></span><br><span class="line"><span class="comment">// 新增API接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span> <span class="title function_">hasPrevious</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">nextIndex</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> E <span class="title function_">previous</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">previousIndex</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(E object)</span></span><br></pre></td></tr></table></figure>



<h2 id="Collection简介"><a href="#Collection简介" class="headerlink" title="Collection简介"></a>Collection简介</h2><p>Collection的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collection</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Iterable</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>它是一个接口，是高度抽象出来的集合，它包含了集合的基本操作：添加、删除、情况、遍历、是否为空、获取大小、是否保护某元素等等。一个Collection代表一组Object，即Collection的元素；Collection接口存储一组不唯一，无序的对象。</strong></p>
<p>Collection接口的所有子类（直接子类或间接子类）都必须实现2中构造函数：不带参数的构造函数和参数类型为Collection的构造函数。带参数的构造函数，可以用来转换Collection的类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collection的API</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">add</span><span class="params">(E object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span>            <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">contains</span><span class="params">(Object object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">equals</span><span class="params">(Object object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span>             <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> Iterator&lt;E&gt;     <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">remove</span><span class="params">(Object object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span>             <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> &lt;T&gt; T[]         toArray(T[] array)</span><br><span class="line"><span class="keyword">abstract</span> Object[]        toArray()</span><br></pre></td></tr></table></figure>



<h2 id="List简介"><a href="#List简介" class="headerlink" title="List简介"></a>List简介</h2><p>List的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>List是一个继承于Collection的接口，即List是集合的一种。List是有序的队列，List中的每一个元素都有一个索引；第一个元素的索引是0，往后的元素的索引值依次+1，而且允许有相同的元素。List接口存储一组不唯一，有序的对象。</strong></p>
<p>关于API方面。既然List是继承于Collection接口，它自然就包含了Collection中的全部函数接口；由于List是有序队列，它也有自己额外的API接口。主要有添加、删除、获取元素、修改指定位置的元素、获取List中的子队列等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collection的API</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">add</span><span class="params">(E object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span>            <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">contains</span><span class="params">(Object object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">equals</span><span class="params">(Object object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span>             <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> Iterator&lt;E&gt;     <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">remove</span><span class="params">(Object object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span>             <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> &lt;T&gt; T[]         toArray(T[] array)</span><br><span class="line"><span class="keyword">abstract</span> Object[]        toArray()</span><br><span class="line"><span class="comment">// 相比与Collection，List新增的API：</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span>                <span class="title function_">add</span><span class="params">(<span class="type">int</span> location, E object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>             <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> location, Collection&lt;? extends E&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> E                   <span class="title function_">get</span><span class="params">(<span class="type">int</span> location)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span>                 <span class="title function_">indexOf</span><span class="params">(Object object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span>                 <span class="title function_">lastIndexOf</span><span class="params">(Object object)</span></span><br><span class="line"><span class="keyword">abstract</span> ListIterator&lt;E&gt;     <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> location)</span></span><br><span class="line"><span class="keyword">abstract</span> ListIterator&lt;E&gt;     <span class="title function_">listIterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> E                   <span class="title function_">remove</span><span class="params">(<span class="type">int</span> location)</span></span><br><span class="line"><span class="keyword">abstract</span> E                   <span class="title function_">set</span><span class="params">(<span class="type">int</span> location, E object)</span></span><br><span class="line"><span class="keyword">abstract</span> List&lt;E&gt;             <span class="title function_">subList</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span><br></pre></td></tr></table></figure>



<h2 id="Set简介"><a href="#Set简介" class="headerlink" title="Set简介"></a>Set简介</h2><p>Set的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Set</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Set是一个继承于Collection的接口，Set具有和Collection完全一样的接口，只是行为上不同，Set不保存重复的元素。Set接口存储一组唯一，无序的对象。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set的API(跟Collection的API完全一样)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">add</span><span class="params">(E object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span>             <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">contains</span><span class="params">(Object object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">equals</span><span class="params">(Object object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span>             <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> Iterator&lt;E&gt;     <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">remove</span><span class="params">(Object object)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">boolean</span>         <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span>             <span class="title function_">size</span><span class="params">()</span></span><br><span class="line"><span class="keyword">abstract</span> &lt;T&gt; T[]         toArray(T[] array)</span><br><span class="line"><span class="keyword">abstract</span> Object[]         toArray()</span><br></pre></td></tr></table></figure>

<p><strong>Set和List的区别</strong></p>
<ul>
<li>Set接口实例存储的无序的、不重复的数据；List接口实例存储的是有序的、可以重复的数据。</li>
<li>Set检索效率低下，删除和插入效率高，插入和删除并不会引起元素位置改变。</li>
<li>List和数组类型，可以动态增长，根据实际存储的数据长度自动增长List的长度。查找元素效率高，插入、删除效率低，因为会引起其他元素的位置改变。</li>
</ul>
<h1 id="集合实现类"><a href="#集合实现类" class="headerlink" title="集合实现类"></a>集合实现类</h1><p>Java提供了一套实现了Collection接口的标准集合类。其中一些事具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。</p>
<ul>
<li>AbstractCollection<ul>
<li>实现了大部分Collection接口的方法。</li>
</ul>
</li>
<li>AbstractList<ul>
<li>继承于AbstractCollection，并且实现了大部分List接口的方法。</li>
</ul>
</li>
<li>AbstractSequentialList<ul>
<li>继承于AbstractList，提供了对数据元素的链式访问而不是随机访问。</li>
</ul>
</li>
<li>LinkedList<ul>
<li>实现了List接口，允许有null（空）元素；主要用于创建链表数据结构。该类不是同步的，多线程情况下不要使用。</li>
<li>LinkedList查找效率低。</li>
</ul>
</li>
<li>ArrayList<ul>
<li>实现了List接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的，在多线程情况下不要使用。ArrayList增长当前长度的50%。</li>
<li>ArrayList插入、删除效率低。</li>
</ul>
</li>
<li>AbstractSet<ul>
<li>继承于AbstractCollection，并且实现了大部分Set接口的方法。</li>
</ul>
</li>
<li>HashSet<ul>
<li>实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。</li>
</ul>
</li>
<li>LinkedHashSet<ul>
<li>继承HashSet，实现了Set接口。具有可预知迭代顺序。</li>
</ul>
</li>
<li>TreeSet<ul>
<li>实现了Set接口，可以根据元素的大小进行排序。</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>集合是一个对象，可容纳其他对象的引用。集合接口声明每一中类型的集合可以执行的操作。</li>
<li>任何对象加入集合类后，自动转变为Object类型，所以在取出的时候，需要强制类型转换。</li>
</ol>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HashTable新增元素源码分析</title>
    <url>/posts/96ac81e9dffc/</url>
    <content><![CDATA[<h1 id="HashTable新增元素源码分析"><a href="#HashTable新增元素源码分析" class="headerlink" title="HashTable新增元素源码分析"></a>HashTable新增元素源码分析</h1><p>先看一下类继承实现关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hashtable</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">Dictionary</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和HashMap一样，Hashtable 也是一个散列表，它存储的内容是键值对(key-value)映射。 </p>
<p>Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。 Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。 Hashtable中的映射不是有序的。</p>
<h2 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储数据的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中的元素个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组临界阈值 当前容量 * 负载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子 0.75</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的修改次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数有四个，无参构造，包含容量的构造，包含容量和负载因子的构造，map类型作为参数的构造。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initialCapacity 默认的初始容量，loadFactor 默认的加载因子</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始容量判断</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Load: &quot;</span>+loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始容量为0的时候设置初始容量为1</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置加载因子</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">// 初始化table字段</span></span><br><span class="line">    table = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[initialCapacity];</span><br><span class="line">    <span class="comment">// 计算扩容时的临界阈值</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含初始容量的构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造时 初始容量和加载因子默认是11和0.75</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// map类型作为参数的构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">    putAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="增加put方法"><a href="#增加put方法" class="headerlink" title="增加put方法"></a>增加put方法</h2><p>通过put方法添加元素，</p>
<ol>
<li>确保value不能为null，</li>
<li>获取key 的hashcode，</li>
<li>计算key存放在数组的下标，</li>
<li>取出tab数组中index位置对应的元素，</li>
<li>数据存在的话，就新值覆盖旧值，并将旧值返回，</li>
<li>新增元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加参数 key 和 value</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode();</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="literal">null</span> ; entry = entry.next) &#123;</span><br><span class="line">        <span class="comment">// 5、</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">old</span> <span class="operator">=</span> entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="addEntry方法"><a href="#addEntry方法" class="headerlink" title="addEntry方法"></a>addEntry方法</h2><p>实际内部进行增加元素的方法</p>
<ol>
<li>修改次数+1，</li>
<li>判断是否需要扩容，当前元素数量大于等于阈值的时候需要扩容</li>
<li>扩容，并重新计算hash</li>
<li>扩容后tab指向新数组</li>
<li>获取key 的hashcode，</li>
<li>计算key存放在数组的下标，</li>
<li>取出tab数组中index位置对应的元素，</li>
<li>将新元素加入到index位置，并且原位置的元素挂在新元素的next上面，<strong>头插入</strong></li>
<li>数组中元素个数+1</li>
<li>Entry对象构造器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEntry</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">        rehash();</span><br><span class="line">        <span class="comment">// 4 </span></span><br><span class="line">        tab = table;</span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        hash = key.hashCode();</span><br><span class="line">        <span class="comment">// 6</span></span><br><span class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">// 7</span></span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">    <span class="comment">// 8</span></span><br><span class="line">    tab[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class="line">    <span class="comment">// 9</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Entry</span><span class="params">(<span class="type">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.hash = hash;</span><br><span class="line">    <span class="built_in">this</span>.key =  key;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.next = next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="扩容过程rehash"><a href="#扩容过程rehash" class="headerlink" title="扩容过程rehash()"></a>扩容过程rehash()</h2><p>1、先取得旧的数组长度</p>
<p>2、扩容，旧长度*2+1得到新长度</p>
<p>3、判断新长度是否超过最大范围</p>
<p>4、根据新长度创建新的数组</p>
<p>5、数组修改次数+1</p>
<p>6、判断新的扩容阈值</p>
<p>7、table 指向新数组</p>
<p>8、table中元素的位置重新计算，并更新</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">rehash</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4</span></span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> <span class="title class_">Entry</span>&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//6</span></span><br><span class="line">    threshold = (<span class="type">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//7</span></span><br><span class="line">    table = newMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="literal">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="添加map到table里面"><a href="#添加map到table里面" class="headerlink" title="添加map到table里面"></a>添加map到table里面</h2><p>构造函数</p>
<ol>
<li>设置初始容量，和加载因子</li>
<li>调用方法将map添加到table里</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    putAll(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="putAll"><a href="#putAll" class="headerlink" title="putAll"></a>putAll</h2><p>将map里的所有元素添加到table中</p>
<p>1、循环</p>
<p>2、循环内调用put 添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : t.entrySet())</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot版本2.4 集成freemarker 添加自定义拦截器以后静态资源(css)无法访问的解决办法</title>
    <url>/posts/8cd09dfa66ca/</url>
    <content><![CDATA[<h1 id="SpringBoot版本2-4-集成freemarker-添加自定义拦截器以后静态资源-css-无法访问的解决办法"><a href="#SpringBoot版本2-4-集成freemarker-添加自定义拦截器以后静态资源-css-无法访问的解决办法" class="headerlink" title="SpringBoot版本2.4 集成freemarker 添加自定义拦截器以后静态资源(css)无法访问的解决办法"></a>SpringBoot版本2.4 集成freemarker 添加自定义拦截器以后静态资源(css)无法访问的解决办法</h1><p>最近在做一个项目的时候遇到了这种情况.</p>
<p>springboot 版本和 freemarker </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#    freemarker静态资源配置</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">charset:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">check-template-location:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content-type:</span> <span class="string">text/html</span></span><br><span class="line">    <span class="attr">expose-request-attributes:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">expose-session-attributes:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">request-context-attribute:</span> <span class="string">request</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.ftl</span></span><br><span class="line">    <span class="attr">tempalte-loader-path:</span> <span class="string">classpath:/templates</span></span><br></pre></td></tr></table></figure>

<p>静态文件路径</p>
<p><img src="https://img-blog.csdnimg.cn/20210424125334732.png" alt="静态文件路径"></p>
<p>拦截器配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.myoa.Interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置拦截器</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">/** 不进行拦截的路由     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; ALLOWED_PATHS = Collections.unmodifiableList(</span><br><span class="line">            Arrays.asList(<span class="string">&quot;/bootstrap/**&quot;</span>, <span class="string">&quot;/css/**&quot;</span>, <span class="string">&quot;/easyui/**&quot;</span>, <span class="string">&quot;/images/**&quot;</span>, <span class="string">&quot;/js/**&quot;</span>, <span class="string">&quot;/plugins/**&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">//        addInterceptor：需要一个实现HandlerInterceptor接口的拦截器实例</span></span><br><span class="line"><span class="comment">//        addPathPatterns：用于设置拦截器的过滤路径规则</span></span><br><span class="line"><span class="comment">//        excludePathPatterns：用于设置不需要拦截的过滤规则</span></span><br><span class="line"></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .excludePathPatterns(ALLOWED_PATHS)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/logins&quot;</span>)</span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/captcha&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* springboot 配置拦截器后出现静态资源无法访问：No mapping for GET的解决办法</span></span><br><span class="line"><span class="comment">    出现该问题是因为springboot 2.0后静态资源也经过拦截器导致的。</span></span><br><span class="line"><span class="comment">    由于WebMvcConfigurerAdapter 的废弃，现今配置拦截器可使用</span></span><br><span class="line"><span class="comment">    继承 WebMvcConfigurationSupport 类和实现 WebMvcConfigurer接口 两种方法。</span></span><br><span class="line"><span class="comment">    建议采用后一种方法（实现接口），否则会出现如题所示的方法。</span></span><br><span class="line"><span class="comment">    如果坚持使用继承WebMvcConfigurationSupport类 的方法，则必须要覆盖重写 WebMvcConfigurationSupport 类 的</span></span><br><span class="line"><span class="comment">    protected void addResourceHandlers(ResourceHandlerRegistry registry);</span></span><br><span class="line"><span class="comment">    然后上方的拦截器也要放开指定路径</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span></span><br><span class="line"><span class="comment">        registry.addResourceHandler(&quot;/**&quot;)</span></span><br><span class="line"><span class="comment">                .addResourceLocations(&quot;classpath:/static/&quot;)</span></span><br><span class="line"><span class="comment">                .addResourceLocations(&quot;classpath:/templates/&quot;);</span></span><br><span class="line"><span class="comment">        super.addResourceHandlers(registry);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>登陆拦截器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.myoa.Interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登陆拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/4/24 12:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法将在Controller处理之前进行调用。 当preHandle的返回值为false的时候整个请求就结束了</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;请求之前调用该方法,进行登录权限等一系列判断,然后并跳转&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021/4/22 17:16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 这里写拦截业务代码 放行返回ture，拦截则返回false，返回false之后请求就终止了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。</span></span><br><span class="line"><span class="comment">     * 该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图执行。</span></span><br><span class="line"><span class="comment">     * （这个方法的主要作用是用于清理资源的）</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 请求完成之后,添加操作日志</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2021/4/22 17:18</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//java8+  该方法非业务必要，可以不重写，因为他是接口的默认实现方法，java8的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTML</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>【Docker】10. Docker Compose</title>
    <url>/posts/8df92d17d51c/</url>
    <content><![CDATA[<h1 id="【Docker】10-Docker-Compose"><a href="#【Docker】10-Docker-Compose" class="headerlink" title="【Docker】10. Docker Compose"></a>【Docker】10. Docker Compose</h1><p>暂未学习</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>【Docker】1. 安装配置与卸载</title>
    <url>/posts/7ce2bb3f5fc9/</url>
    <content><![CDATA[<h1 id="【Docker】1-安装配置与卸载"><a href="#【Docker】1-安装配置与卸载" class="headerlink" title="【Docker】1. 安装配置与卸载"></a>【Docker】1. 安装配置与卸载</h1><blockquote>
<p><a href="https://docs.docker.com/engine/install/centos/">docker官方文档</a></p>
</blockquote>
<h1 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h1><h2 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1.安装依赖包"></a>1.安装依赖包</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2 </span><br></pre></td></tr></table></figure>

<h2 id="2-设置阿里云镜像源"><a href="#2-设置阿里云镜像源" class="headerlink" title="2.设置阿里云镜像源"></a>2.设置阿里云镜像源</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo </span><br></pre></td></tr></table></figure>

<h2 id="3-安装-Docker-CE"><a href="#3-安装-Docker-CE" class="headerlink" title="3.安装 Docker-CE"></a>3.安装 Docker-CE</h2><p>重建 Yum 缓存。(可选)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>

<p>安装docker相关的源 docker-ce 社区 ee 企业版</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<h2 id="4-查看是否安装成功"><a href="#4-查看是否安装成功" class="headerlink" title="4.查看是否安装成功"></a>4.查看是否安装成功</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325165830.png" alt="image-20210726145130208"></p>
<h2 id="5-启动-Docker-CE"><a href="#5-启动-Docker-CE" class="headerlink" title="5.启动 Docker-CE"></a>5.启动 Docker-CE</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325165837.png" alt="image-20210726145336682"></p>
<h2 id="6-测试运行docker"><a href="#6-测试运行docker" class="headerlink" title="6.测试运行docker"></a>6.测试运行docker</h2><p>查看下载的这个 hello-world 镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325165849.png" alt="image-20210726145829891"></p>
<h2 id="7-镜像加速配置"><a href="#7-镜像加速配置" class="headerlink" title="7.镜像加速配置"></a>7.镜像加速配置</h2><p>这里使用的是 ==阿里云提供的镜像加速== ，登录并且设置密码之后在左侧的 <strong>容器镜像服务</strong> 可以找到专属加速器地址，复制下来。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325165858.png" alt="image-20210726151309536"></p>
<p>然后执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;你的加速器地址&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>之后重新加载配置，并且重启 Docker 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="8-可选-为-Docker-建立用户组"><a href="#8-可选-为-Docker-建立用户组" class="headerlink" title="8.[可选] 为 Docker 建立用户组"></a>8.[可选] 为 Docker 建立用户组</h2><p>docker 命令与 Docker 引擎通讯之间通过 UnixSocket ，但是能够有权限访问 UnixSocket 的用户只有 root 和 docker 用户组的用户才能够进行访问，所以我们需要建立一个 docker 用户组，并且将需要访问 docker 的用户添加到这一个用户组当中来。</p>
<h3 id="1-建立-Docker-用户组"><a href="#1-建立-Docker-用户组" class="headerlink" title="1. 建立 Docker 用户组"></a>1. 建立 Docker 用户组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>

<h3 id="2-添加当前用户到-docker-组"><a href="#2-添加当前用户到-docker-组" class="headerlink" title="2.添加当前用户到 docker 组"></a>2.添加当前用户到 docker 组</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>

<h1 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、依赖卸载</span></span><br><span class="line"> sudo yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、删除资源</span></span><br><span class="line"> sudo rm -rf /var/lib/docker</span><br><span class="line"> sudo rm -rf /var/lib/containerd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/var/lib/docker docker的默认工作路径</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>Cannot expose request attribute &#39;errormess&#39; because of an existing model object of the same name</title>
    <url>/posts/db4756b90846/</url>
    <content><![CDATA[<h1 id="Cannot-expose-request-attribute-‘errormess’-because-of-an-existing-model-object-of-the-same-name"><a href="#Cannot-expose-request-attribute-‘errormess’-because-of-an-existing-model-object-of-the-same-name" class="headerlink" title="Cannot expose request attribute ‘errormess’ because of an existing model object of the same name"></a>Cannot expose request attribute ‘errormess’ because of an existing model object of the same name</h1><p>Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Cannot expose request attribute ‘errormess’ because of an existing model object of the same name] with root cause</p>
<p>先看代码：重复代属性值是errormess</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325215920.png" alt="image-20210425103624696"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325215936.png" alt="image-20210425103735935"></p>
<p>解决办法：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#    freemarker静态资源配置</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">charset:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">check-template-location:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content-type:</span> <span class="string">text/html</span></span><br><span class="line">    <span class="attr">expose-request-attributes:</span> <span class="literal">true</span> <span class="comment"># 是否在merge模板的时候，将request属性都添加到model中</span></span><br><span class="line">    <span class="attr">expose-session-attributes:</span> <span class="literal">true</span> <span class="comment"># 是否在merge模板的时候，将HttpSession属性都添加到model中</span></span><br><span class="line">    <span class="attr">request-context-attribute:</span> <span class="string">request</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.ftl</span></span><br><span class="line">    <span class="attr">tempalte-loader-path:</span> <span class="string">classpath:/templates</span></span><br><span class="line">    <span class="attr">allow-session-override :</span> <span class="literal">true</span>   <span class="comment">#设置允许session被重写</span></span><br><span class="line">    <span class="attr">allow-request-override :</span> <span class="literal">true</span>   <span class="comment">#设置允许request被重写</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>



<p>重点是这几个与request和session有关的。</p>
<p>设置了之后就允许覆盖了</p>
]]></content>
      <categories>
        <category>bug记录</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>【Docker】11. Docker Swarm</title>
    <url>/posts/557ce291eece/</url>
    <content><![CDATA[<h1 id="【Docker】11-Docker-Swarm"><a href="#【Docker】11-Docker-Swarm" class="headerlink" title="【Docker】11. Docker Swarm"></a>【Docker】11. Docker Swarm</h1><p>暂未学习</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>【Docker】3. 常用命令</title>
    <url>/posts/31c882842f54/</url>
    <content><![CDATA[<h1 id="【Docker】3-常用命令"><a href="#【Docker】3-常用命令" class="headerlink" title="【Docker】3. 常用命令"></a>【Docker】3. 常用命令</h1><blockquote>
<p>帮助文档的地址：<a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p>
</blockquote>
<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="查看所有本地主机上的镜像"><a href="#查看所有本地主机上的镜像" class="headerlink" title="查看所有本地主机上的镜像"></a>查看所有本地主机上的镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@AlibabaECS ~]# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              bf756fb1ae65        8 months ago        13.3kB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释</span></span><br><span class="line">REPOSITORY  镜像的仓库源</span><br><span class="line">TAG         镜像的标签</span><br><span class="line">IMAGE ID    镜像的id</span><br><span class="line">CREATED     镜像的创建时间</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项</span></span><br><span class="line">Options:</span><br><span class="line">  -a, --all             Show all images (default hides intermediate images)</span><br><span class="line">      --digests         Show digests</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print images using a Go template</span><br><span class="line">      --no-trunc        Don&#x27;t truncate output</span><br><span class="line">  -q, --quiet           Only show image IDs	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="搜索镜像"><a href="#搜索镜像" class="headerlink" title="搜索镜像"></a>搜索镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search </span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170128.png" alt="image-20210726152557996"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@AlibabaECS ~]# docker  search mysql</span><br><span class="line">NAME    DESCRIPTION                                     STARS       OFFICIAL      AUTOMATED</span><br><span class="line">mysql   MySQL is a widely used, open-source relation…   9911  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项</span></span><br><span class="line">--filter , -f		Filter output based on conditions provided</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过收藏不小于5000 搜索镜像</span></span><br><span class="line">docker search mysql -f=stars=5000</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载镜像 docker pull 镜像名   [:tag]版本</span></span><br><span class="line">docker pull mysql # 安装mysql 镜像</span><br></pre></td></tr></table></figure>

<p>官网仓库可以选择版本,每个版本的安装命令官网都有</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170134.png" alt="image-20210726153458495"></p>
<p>举例:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载镜像 docker pull 镜像名   [:tag]版本</span></span><br><span class="line">[root@AlibabaECS ~]# docker pull mysql</span><br><span class="line">Using default tag: latest # 如果不写tag,默认就是latest</span><br><span class="line">latest: Pulling from library/mysql </span><br><span class="line">bf5952930446: Pull complete # 分层下载，docker image的核心 联合文件系统</span><br><span class="line">8254623a9871: Pull complete </span><br><span class="line">938e3e06dac4: Pull complete </span><br><span class="line">ea28ebf28884: Pull complete </span><br><span class="line">f3cef38785c2: Pull complete </span><br><span class="line">894f9792565a: Pull complete </span><br><span class="line">1d8a57523420: Pull complete </span><br><span class="line">6c676912929f: Pull complete </span><br><span class="line">ff39fdb566b4: Pull complete </span><br><span class="line">fff872988aba: Pull complete </span><br><span class="line">4d34e365ae68: Pull complete </span><br><span class="line">7886ee20621e: Pull complete </span><br><span class="line">Digest: sha256:c358e72e100ab493a0304bda35e6f239db2ec8c9bb836d8a427ac34307d074ed # 签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest # 真实地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">两条命令等价</span></span><br><span class="line">docker pull mysql</span><br><span class="line">docker.io/library/mysql:latest</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170140.png" alt="image-20210726153932796"></p>
<p>当已经存在的文件不会再下载,多个版本之间会有文件共用</p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi -f 容器id                # 删除指定的镜像</span><br><span class="line">docker rmi -f  容器id 容器id 容器id  # 删除多个镜像</span><br><span class="line">docker rmi -f $(docker images -aq) # 删除全部镜像</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="typora/20210726154504.png" alt="image-20210726154503820"></p>
<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>

<h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">--name = &quot;Name&quot;    容器名字  tomcat01，tomcat02,用来区分容器</span><br><span class="line">-d                 后台方式运行</span><br><span class="line">-it                使用交互方式运行，进入容器查看区分</span><br><span class="line">-p                 指定容器的端口 -p 8080：8080</span><br><span class="line">    -p ip:主机端口：容器端口</span><br><span class="line">    -p 主机端口：容器端口(常用)</span><br><span class="line">    -p 容器端口</span><br><span class="line">    容器端口</span><br><span class="line">-p                 随机指定端口</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试，启动并进入容器</span></span><br><span class="line">[root@AlibabaECS bin]# docker run -it centos /bin/bash</span><br><span class="line">[root@94d468db18da /]# ls  # 查看容器内的centos，基础版本，很多命令都是不完善的！</span><br><span class="line">bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var</span><br><span class="line">dev  home  lib64  media       opt  root  sbin  sys  usr</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从容器中退回主机</span></span><br><span class="line">[root@94d468db18da /]# exit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="列出所有的运行的容器"><a href="#列出所有的运行的容器" class="headerlink" title="列出所有的运行的容器"></a>列出所有的运行的容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps # 列出当前正在运行的容器</span><br><span class="line">docker ps -a # 为查看所有的容器，包括已经停止的</span><br><span class="line">-a   # 列出当前正在运行的容器+带出历史运行过的容器</span><br><span class="line">-n=? # 显示最近创建的容器</span><br><span class="line">-q   # 只显示容器的编号</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit            # 容器停止并退出</span><br><span class="line">Ctrl + P + Q    # 容器不停止并退出</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm &lt;容器名 or ID&gt;          # 删除指定容器，不能删除正在运行的容器，如果要强制删除 rm -f</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">rm</span> $(docker ps -aq)    <span class="comment"># 删除所有的容器</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker ps -aq|xargs docker <span class="built_in">rm</span>    <span class="comment"># 删除所有的容器</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start &lt;容器名 or ID&gt; 	# 启动容器</span><br><span class="line">docker restart &lt;容器名 or ID&gt;  # 重启容器     </span><br><span class="line">docker stop &lt;容器名 or ID&gt; 	# 停止当前正在运行的容器</span><br><span class="line">docker kill &lt;容器名 or ID&gt; 	# 强制停止当前容器</span><br></pre></td></tr></table></figure>

<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs -f &lt;容器名 or ID&gt;</span><br><span class="line"></span><br><span class="line">docker logs -f -t --tail 容器，没有日志</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自己编写一段shell脚本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run -d centos /bin/sh -c <span class="string">&quot;while true;do echo 我是你爹;sleep 1;done&quot;</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示日志</span></span><br><span class="line">-tf                # 显示日志</span><br><span class="line">--tail number      # 要显示的日志条数</span><br><span class="line"></span><br><span class="line">[root@AlibabaECS /]# docker logs -tf  --tail 10   f1178d5b0bd8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="查看容器中的进程信息ps"><a href="#查看容器中的进程信息ps" class="headerlink" title="查看容器中的进程信息ps"></a>查看容器中的进程信息ps</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker top 容器<span class="built_in">id</span></span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]# docker run -d centos /bin/sh -c &quot;while true;do echo 我是你爹;sleep 1;done&quot;</span><br><span class="line">3833a6f9dcd6b69f70e10c38b71e69a8218fa938e5ec2903ccbdd9ab9c461448</span><br><span class="line">[root@localhost ~]# docker top 3833a6f9dcd6b69f70e10c38b71e69a8218fa938e5ec2903ccbdd9ab9c461448</span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                13611               13591               0                   18:31               ?                   00:00:00            /bin/sh -c while true;do echo 我是你爹;sleep 1;done</span><br><span class="line">root                13647               13611               0                   18:31               ?                   00:00:00            /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br><span class="line">[root@localhost ~]# </span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170146.png" alt="image-20210726183135635"></p>
<h3 id="查看镜像源数据"><a href="#查看镜像源数据" class="headerlink" title="查看镜像源数据"></a>查看镜像源数据</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 3833a6f9dcd6</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170148.png" alt="image-20210726183442950"></p>
<h3 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h3><p>#方式一</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令</span></span><br><span class="line">docker exec -it 容器名 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">[root@AlibabaECS ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">f1178d5b0bd8        centos              &quot;/bin/sh -c &#x27;while t…&quot;   2 hours ago         Up 2 hours                              stupefied_colden</span><br><span class="line">[root@AlibabaECS ~]# docker exec -it f1178d5b0bd8 /bin/bash</span><br><span class="line">[root@f1178d5b0bd8 /]# ls</span><br><span class="line">bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var</span><br><span class="line">dev  home  lib64  media       opt  root  sbin  sys  usr</span><br><span class="line"></span><br><span class="line">[root@f1178d5b0bd8 /]# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 05:10 ?        00:00:02 /bin/sh -c while true;do echo kuangshen;sleep 1;done</span><br><span class="line">root      8869     0  0 07:38 pts/0    00:00:00 /bin/bash</span><br><span class="line">root      8887     1  0 07:38 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/</span><br><span class="line">root      8888  8869  0 07:38 pts/0    00:00:00 ps -ef</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>#方式二 慎用 容易退不出来容器,只好强制退出远程连接.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker attach 容器id</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">[root@AlibabaECS ~]# docker attach f1178d5b0bd8</span><br><span class="line">正在执行当前的代码...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>区别</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span>        <span class="comment"># 进入容器后开启一个新的终端，可以在里面操作(常用)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker attach      <span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span></span><br></pre></td></tr></table></figure>

<h3 id="从容器拷贝文件到主机上"><a href="#从容器拷贝文件到主机上" class="headerlink" title="从容器拷贝文件到主机上"></a>从容器拷贝文件到主机上</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令</span></span><br><span class="line">docker cp [r] 容器id :容器内路径 目表主机路径</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数r : 递归拷贝</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">[root@AlibabaECS home]# docker cp a485a9d900b4:/home/test.java /home</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拷贝只是一个手动的过程,未来我们用 -v卷的技术可以实现,自动同步</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="映射数据卷"><a href="#映射数据卷" class="headerlink" title="映射数据卷"></a>映射数据卷</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker -v /home/data:/opt/data # 这里/home/data 指的是宿主机的目录地址，后者则是容器的目录地址</span><br></pre></td></tr></table></figure>

<h3 id="暴露端口"><a href="#暴露端口" class="headerlink" title="暴露端口"></a>暴露端口</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一共有三种形式进行端口映射</span></span><br><span class="line">docker -p ip:hostPort:containerPort # 映射指定地址的主机端口到容器端口</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如：docker -p 127.0.0.1:3306:3306 映射本机3306端口到容器的3306端口</span></span><br><span class="line">docker -p ip::containerPort # 映射指定地址的任意可用端口到容器端口</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如：docker -p 127.0.0.1::3306 映射本机的随机可用端口到容器3306端口</span></span><br><span class="line">docer -p hostPort:containerPort # 映射本机的指定端口到容器的指定端口</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如：docker -p 3306:3306 <span class="comment"># 映射本机的3306端口到容器的3306端口</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170152.png" alt="在这里插入图片描述"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【Docker】4. 可视化与Docker安装练习</title>
    <url>/posts/f75d56e00060/</url>
    <content><![CDATA[<h1 id="【Docker】4-可视化与Docker安装练习"><a href="#【Docker】4-可视化与Docker安装练习" class="headerlink" title="【Docker】4. 可视化与Docker安装练习"></a>【Docker】4. 可视化与Docker安装练习</h1><h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><ul>
<li>portainer（先用这个）</li>
<li>Rancher（CI/CD 持续集成和持续部署）</li>
</ul>
<p>这里使用portainer作为容器的 GUI 管理方案。</p>
<p>官方地址：<a href="https://portainer.io/install.html">https://portainer.io/install.html</a></p>
<p>安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create portainer_data</span><br><span class="line">docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br></pre></td></tr></table></figure>

<blockquote>
<p>创建容器是添加 -–restart=always 选项，保证docker服务启动时，容器会自动运行</p>
</blockquote>
<p>访问你的 IP:9000 即可进入容器管理页面。</p>
<p>自定义密码:12345678</p>
<p>如下：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170218.png" alt="image-20210726190630243"></p>
<p>选择本地</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170221.png" alt="在这里插入图片描述"></p>
<h1 id="Docker安装练习"><a href="#Docker安装练习" class="headerlink" title="Docker安装练习"></a>Docker安装练习</h1><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><p>下载镜像 pull</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170224.png" alt="image-20210727143420294"></p>
<p>下载成功</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170226.png" alt="image-20210727143509636"></p>
<p>启动nginx</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d       后台运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name   给容器命名</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p       宿主机端口：容器内部端口  如用主机的3344端口访问Nginx的801端口</span></span><br><span class="line">[root@localhost ~]# docker run -d --name nginx01 -p 3344:80 nginx</span><br><span class="line">4ae0cfe4a49e0112ac8f33ce00d159eb9679678affb68a026583ca7fe769312a</span><br></pre></td></tr></table></figure>

<p>验证</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170229.png" alt="image-20210727143928182"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170231.png" alt="image-20210727144543093"></p>
<h2 id="安装-tomcat"><a href="#安装-tomcat" class="headerlink" title="安装 tomcat"></a>安装 tomcat</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">官方的使用</span></span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们之前的启动都是后台，停止了容器之后，容器还是可以查到</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run -it --<span class="built_in">rm</span>, 一般用来测试，停止后容器自动删除 docker ps -a 里面也没有这个容器</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载再启动</span></span><br><span class="line">docker pull tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动运行</span></span><br><span class="line">docker run -it --rm -p 8888:8080 --name tomcat01 tomcat</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试访问没有问题 localhost:8888</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">会出现404 官方文档里面说明了</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器</span></span><br><span class="line">[root@AlibabaECS ~]# docker exec -it tomcat01 /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发现问题：1、linux命令少了，2、没有webapps; 阿里云镜像的原因，默认是最小的镜像，所以没必要都剔除掉</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保证最小可运行的环境</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将webapps.dist全部复制到webapps目录下  就能外网访问8888 进入熟悉的tomcat首页</span></span><br><span class="line">root@98f7b369cb09:/usr/local/tomcat# cp -r  webapps.dist/*  webapps</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170235.png" alt="image-20210727152331683"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170238.png" alt="image-20210727153037938"></p>
<h2 id="安装ES"><a href="#安装ES" class="headerlink" title="安装ES"></a>安装ES</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 暴露的端口很多</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 十分的耗内存</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 的数据一般需要放置到安全目录！ 挂载</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">安装 可选 因为 下方的运行会先去查找本地,本地找不到就自动下载了</span></span><br><span class="line">docker pull elasticsearch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网络配置</span></span><br><span class="line">docker network create somenetwork</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 没有太多环境参数配置</span></span><br><span class="line">docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">测试</span></span><br><span class="line">curl localhost:9200</span><br></pre></td></tr></table></figure>

<p>ES启动成功</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170242.png" alt="image-20210727155403519"></p>
<p>查看docker 的内存状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170244.png" alt="image-20210727160152881"></p>
<p>上图是已经停止了ES,否则虚拟机就卡死了.</p>
<p>设置内存大小,携带参数 运行ES</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">携带参数 运行ES</span></span><br><span class="line">docker run -d --name elasticsearch --net somenetwork -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170247.png" alt="image-20210727160614719"></p>
<p>此时ES占用的内存就会很小,之前不设置java内存大小的话,会特别站内存</p>
<h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p>官网安装指导,并解释了如何连接ES</p>
<p><img src="typora/20210727192801.png" alt="image-20210727162838652"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">拉取镜像</span></span><br><span class="line">docker pull kibana</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自定义网络(安装ES时已经定义过的 此步可忽略,否则会提示 Error response from daemon: network with name somenetwork already exists)</span></span><br><span class="line">docker network create somenetwork</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行</span></span><br><span class="line">docker run -d --name kibana --net somenetwork -p 5601:5601 kibana</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动成功</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170250.png" alt="image-20210727162549826"></p>
<p>访问</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170252.png" alt="image-20210727162518461"></p>
<p>使用kibana连接es? 思考网络如何才能连接过去？</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170254.png" alt="在这里插入图片描述"></p>
<h1 id="端口暴露概念"><a href="#端口暴露概念" class="headerlink" title="端口暴露概念"></a>端口暴露概念</h1><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170300.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>【Docker】2. 运行镜像的流程、docker工作原理</title>
    <url>/posts/eeccfe7c3f9b/</url>
    <content><![CDATA[<h1 id="【Docker】2-运行镜像的流程、docker工作原理"><a href="#【Docker】2-运行镜像的流程、docker工作原理" class="headerlink" title="【Docker】2. 运行镜像的流程、docker工作原理"></a>【Docker】2. 运行镜像的流程、docker工作原理</h1><h1 id="一、运行镜像的流程"><a href="#一、运行镜像的流程" class="headerlink" title="一、运行镜像的流程"></a>一、运行镜像的流程</h1><p>输入命令<code>docker run hello-world</code>，运行hello-world镜像。那么docker运行镜像是经过了如下流程的：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325165952.png" alt="img"></p>
<blockquote>
<p>先在本地找镜像，没找到就去远程仓库找，找到了就下载到本地，然后运行。</p>
</blockquote>
<h1 id="二、docker工作原理"><a href="#二、docker工作原理" class="headerlink" title="二、docker工作原理"></a>二、docker工作原理</h1><p>docker也是一个Client-Server的结构，docker的守护进程运行在主机上，通过socket从客户端访问。<br>docker-server接收到docker-client后，去执行这个命令。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170007.png" alt="img"></p>
<h1 id="三、docker为什么比VM快"><a href="#三、docker为什么比VM快" class="headerlink" title="三、docker为什么比VM快"></a>三、docker为什么比VM快</h1><p>网上找了个对比图先。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170020.png" alt="img"></p>
<p>从图上可以看出：</p>
<p>docker比VM有更少的抽象层。<br>docker利用宿主机的内核，vm则是利用Guest OS，也就是你安装到虚拟机的系统。<br>当新建一个容器的时候，docker直接利用宿主机的操作系统，省略了像在VM中，重新加载虚拟系统的复杂过程，大幅提高启动速度。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>【Docker】5. 镜像-加载原理、分层原理、commit镜像</title>
    <url>/posts/8ec129df33fd/</url>
    <content><![CDATA[<h1 id="【Docker】5-镜像-加载原理、分层原理、commit镜像"><a href="#【Docker】5-镜像-加载原理、分层原理、commit镜像" class="headerlink" title="【Docker】5. 镜像-加载原理、分层原理、commit镜像"></a>【Docker】5. 镜像-加载原理、分层原理、commit镜像</h1><h2 id="一、什么是镜像"><a href="#一、什么是镜像" class="headerlink" title="一、什么是镜像"></a>一、什么是镜像</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件。</p>
<p>它包含运行某个软件所需的所有内容，包括代码、运行时环境、库、环境变量和配置文件。</p>
<p>所有的应用，直接打包成docker镜像，就可以直接跑起来。</p>
<p>如何得到镜像：</p>
<ul>
<li>从远程仓库下载</li>
<li>从其他地方copy</li>
<li>自己制作一个镜像 DockerFile</li>
</ul>
<h2 id="二、docker镜像加载原理"><a href="#二、docker镜像加载原理" class="headerlink" title="二、docker镜像加载原理"></a>二、docker镜像加载原理</h2><h3 id="1-联合文件系统UnionFS"><a href="#1-联合文件系统UnionFS" class="headerlink" title="1. 联合文件系统UnionFS"></a>1. 联合文件系统UnionFS</h3><p>UnionFS是一种分层、轻量级并且高性能的文件系统。支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。这个在我们下载镜像的时候，就可以看到这样的效果。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170341.png" alt="img"></p>
<p>比如有涉及到相同的文件，那么就可以共用了，极大节省资源。</p>
<p>UnionFS是docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以<br>制作各种具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p>
<h3 id="2-镜像加载原理"><a href="#2-镜像加载原理" class="headerlink" title="2. 镜像加载原理"></a>2. 镜像加载原理</h3><p>docker的镜像实际上由一层一层的文件系统组成，这种层级文件系统就是上述的UnionFS。接着，在内部又分为2部分：</p>
<ul>
<li>bootfs(boot file system)：docker镜像的最底层是bootfs，主要包含bootloader（加载器）和kernel（内核）。<br>  bootloader主要是引导加载kernel，linux刚启动时会加载bootfs文件系统。这一层与典型的linux/Unix系统一样，包含bootloader和kernel。<br>  当boot加载完成后，整个内核就在内存中了，此时内存的使用权已由bootfs转交给了内核，此时系统也会卸载bootfs。<br>  这里的加载，可以理解为，我们windows电脑开机时候，从黑屏到进入操作系统的过程。</li>
<li>rootfs(root file system)：在bootfs之上，包含的就是典型linux系统中的<code>/dev、/proc、/bin、/etc</code>等标准目录和文件。<br>  rootfs就是各种不同的操作系统发行版，比如Ubuntu、Centos等等。</li>
</ul>
<p>如图所示：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170345.png" alt="img"></p>
<p>图中以debian系统为例，从左到右，分为3个过程:</p>
<ul>
<li>图1，开始的状态，下载了一个debian系统。</li>
<li>图2，安装了一个emacs，这时候可以看到在图1基础上，加了一层Image。</li>
<li>图3，又装了一个Apache，此时在图2的基础上再加了一层Image。</li>
</ul>
<p>说明了docker的镜像实际上是由一层一层的文件系统组成的。对于不同的的linux发行版本，bootfs基本是一致的，rootfs会有差别，所以不同的发行版可以共用bootfs。</p>
<p>另外，在docker上的操作系统通常都是精简版的，在VM上安装个centos镜像大小几个G，而在docker上的centos镜像只有几百M大小。</p>
<p>因为底层直接用主机的内核，自己只需要提供rootfs就行了，所以rootfs可以很小，只需要包含最基本的命令、工具和程序库即可。</p>
<p>这样一来，启动速度也快了，因为最浪费时间的==引导加载过程==没了。</p>
<h2 id="三、分层原理"><a href="#三、分层原理" class="headerlink" title="三、分层原理"></a>三、分层原理</h2><p>知道了镜像的加载原理，不妨再回头看下镜像分层的原理。之前提过，镜像下载的时候是分层下载的，有些层如果已经存在了，就无需再次下载。<br>比如我下载一个redis的镜像。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170348.png" alt="img"></p>
<p>这种方式最大的好处就在于资源共享。比如有多个镜像都从相同的BASE镜像构建来的，那么宿主机只需要在磁盘上保留1份BASE镜像，同时内存中也只需要加载一份BASE镜像，这样所有的容器都可以使用。另外，镜像的每一层都是可以共享的。</p>
<p>可以通过<code>docker image inspect</code>来查看镜像的分层，比如查看刚才下载的redis镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker image inspect redis:latest </span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170350.png" alt="img"></p>
<p>所有的docker镜像都起始于一个==基础镜像层==，当进行修改或者增加新的内容时，就会在当前镜像层之上，创建新的镜像层。比如：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170352.png" alt="img"></p>
<p>我现在要制作一个镜像。</p>
<ol>
<li>这个镜像基于Ubuntu linux 16.04，这也是镜像的第一层。</li>
<li>继续还要安装python包，就会在第一层之上创建第二个镜像层。</li>
<li>继续打补丁的话，还会再创建第三个镜像层。</li>
</ol>
<p>要<strong>注意</strong>的是：在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170354.png" alt="img"></p>
<p>这里每个镜像层包含了3个文件，而镜像则是包含了来自2个镜像层的6个文件。</p>
<p>现在，如果第二层中的 文件5 需要升级版本。这时候上层镜像中的文件会覆盖底层镜像中对应的文件，使得文件里更新版本作为一个新镜像层添加到镜像当中。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170356.png" alt="img"></p>
<p>docker 通过==存储引擎==的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170358.png" alt="img"></p>
<h2 id="四、commit镜像"><a href="#四、commit镜像" class="headerlink" title="四、commit镜像"></a>四、commit镜像</h2><p>通过上面的了解，现在已经知道镜像的结构原理，那么我们自己就可以制作一个镜像。</p>
<p>比如之前pull的tomcat镜像，运行后发现404，然后进入到webapps下，发现是没有项目的，因为是阉割版。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170400.png" alt="img"></p>
<p>现在我把webapps.dist下的所有内容copy到webapps下。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170403.png" alt="img"></p>
<p>现在我用ip:8080就可以访问到项目了。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170405.png" alt="img"></p>
<p>现在我在tomcat容器里做了一些我自己的改动，我觉得这些改动很好，镜像变得更好用了。那么我需要来保存这个容器的状态，通过commit命令，提交镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker commit -m=&quot;提交描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名称:版本标签</span><br><span class="line">docker commit -m=&quot;pingguo first commit image&quot; -a=&quot;pingguo&quot; 03844ff66434 tomcatpingguo:1.0</span><br></pre></td></tr></table></figure>

<p>提交成功后，<code>docker images</code>查看镜像，发现已经保存在本地。<br><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170408.png" alt="img"></p>
<p>通过自己的提交镜像操作，再回过来体会下镜像的分层，是不是理解更深刻了些？</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>【Docker】6. 容器数据卷</title>
    <url>/posts/fd20d32db7e5/</url>
    <content><![CDATA[<h1 id="【Docker】6-容器数据卷"><a href="#【Docker】6-容器数据卷" class="headerlink" title="【Docker】6. 容器数据卷"></a>【Docker】6. 容器数据卷</h1><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170428.png" alt="20201208183759"></p>
<h2 id="一、卷技术介绍"><a href="#一、卷技术介绍" class="headerlink" title="一、卷技术介绍"></a>一、卷技术介绍</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p><strong>一句话：有点类似我们Redis里面的rdb和aof文件</strong></p>
<p>先来看看Docker的理念：</p>
<ul>
<li><p>将运用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的</p>
</li>
<li><p>容器之间希望有可能共享数据</p>
</li>
</ul>
<p>Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了。</p>
<p>为了能保存数据在docker中我们使用卷。</p>
<h3 id="能干嘛"><a href="#能干嘛" class="headerlink" title="能干嘛"></a>能干嘛</h3><ol>
<li><strong>容器的持久化</strong></li>
<li><strong>容器间继承+共享数据</strong></li>
</ol>
<p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：</p>
<p> 卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p>
<p>特点：</p>
<ul>
<li>1：数据卷可在容器之间共享或重用数据</li>
<li>2：卷中的更改可以直接生效</li>
<li>3：数据卷中的更改不会包含在镜像的更新中</li>
<li>4：数据卷的生命周期一直持续到没有容器使用它为止</li>
</ul>
<p>举例：如图所示，将容器里的<code>/usr/mysql</code>挂载到外部linux下的<code>/home/mysql</code>。现在不仅mysql容器可以使用，其他的2个容器同样可以使用，实现了数据共享。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170432.png" alt="img"></p>
<p>所以，卷技术的关键词：==持久化、同步、数据共享==。</p>
<h2 id="二、使用数据卷"><a href="#二、使用数据卷" class="headerlink" title="二、使用数据卷"></a>二、使用数据卷</h2><h3 id="直接命令添加"><a href="#直接命令添加" class="headerlink" title="直接命令添加"></a>直接命令添加</h3><p>使用命令<code>-v</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器目录</span><br></pre></td></tr></table></figure>

<p>现在我要启动centos镜像，并且把容器内的<code>/home</code>目录，挂载到主机的<code>/home/test/</code>目录下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -v /home/test:/home centos /bin/bash</span><br></pre></td></tr></table></figure>

<p>可以看到启动容器成功，为了方便，我多开一个窗口。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170435.png" alt="img"></p>
<h4 id="1、查看数据卷是否挂在成功"><a href="#1、查看数据卷是否挂在成功" class="headerlink" title="1、查看数据卷是否挂在成功"></a>1、查看数据卷是否挂在成功</h4><p>这时候用<code>docker inspect</code>命令来查看容器，可以看到挂载情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect 370ff4e87083</span><br></pre></td></tr></table></figure>

<p>找到<code>Mounts</code>，可以看到具体绑定明细。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170437.png" alt="img"></p>
<h4 id="2、容器与宿主机的数据共享"><a href="#2、容器与宿主机的数据共享" class="headerlink" title="2、容器与宿主机的数据共享"></a>2、容器与宿主机的数据共享</h4><p>现在容器内的<code>/home</code>目录下是空的，对应的主机的<code>/home/test/</code>下也是空的。</p>
<p>接着，我在容器内的/home下新建个文件<code>new.txt</code>，然后查看主机下的<code>/home</code>目录，发现文件已经同步。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170439.png" alt="img"></p>
<p><strong>反向操作</strong></p>
<p>上面是从容器内到容器外，现在反过来，从主机目录下再增加一个文件<code>second.txt</code>，然后再到容器内查看，也是同步的。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170442.png" alt="img"></p>
<h4 id="3、容器停止退出后，主机修改后的数据是否同步"><a href="#3、容器停止退出后，主机修改后的数据是否同步" class="headerlink" title="3、容器停止退出后，主机修改后的数据是否同步"></a>3、容器停止退出后，主机修改后的数据是否同步</h4><p><strong>停止容器</strong></p>
<p>容器停止了，我在宿主机把文件都删掉了</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170444.png" alt="img"></p>
<p>重启容器，进入容器的/home下查看，也是空的。说明宿主机与容器是==完全同步==</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170446.png" alt="img"></p>
<p>相信现在应该可以体会到容器卷的作用了，比如有些容器里涉及需要改配置的，那么挂载到主机目录下之后，就不需要进入容器修改了，直接在外面修改，容器内自动同步。</p>
<h3 id="DockerFile添加（常用）"><a href="#DockerFile添加（常用）" class="headerlink" title="DockerFile添加（常用）"></a>DockerFile添加（常用）</h3><h4 id="1、创建dockerfile文件"><a href="#1、创建dockerfile文件" class="headerlink" title="1、创建dockerfile文件"></a>1、创建dockerfile文件</h4><p>/root目录下新建mydocker文件夹并进入 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /root/mydocker &amp;&amp; cd /root/mydocker </span><br></pre></td></tr></table></figure>

<p>/root/mydocker 目录下创建名为 dockerfile 的文件</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170449.png" alt="image-20210728154012003"></p>
<p>编辑文件，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># volume test</span></span><br><span class="line"></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [<span class="string">&quot;/dataVolumeContainer1&quot;</span>,<span class="string">&quot;/dataVolumeContainer2&quot;</span>] <span class="comment"># 匿名挂载</span></span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;finished,--------success1&quot;</span></span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170451.png" alt="image-20210728161133887"></p>
<p>说明：可在Dockerfile中使用VOLUME指令来给镜像添加一个或多个数据卷VOLUME[“/dataVolumeContainer”,”/dataVolumeContainer2”,”/dataVolumeContainer3”]，但是出于可移植和分享的考虑，用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。</p>
<p>因为宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。</p>
<h4 id="2、根据dockerfile构建镜像"><a href="#2、根据dockerfile构建镜像" class="headerlink" title="2、根据dockerfile构建镜像"></a>2、根据dockerfile构建镜像</h4><p>build后生成镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -f /root/mydocker/dockerfile -t lidalong/centos:1.0 .</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-f 后面跟的是刚刚写的文件路径，最后那个 . 是生成的镜像存放位置 </p>
</blockquote>
<p>构建成功</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170454.png" alt="image-20210728160318738"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170456.png" alt="image-20210728160424399"></p>
<h4 id="3、run容器"><a href="#3、run容器" class="headerlink" title="3、run容器"></a>3、run容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --name lidalong-contos lidalong/centos:1.0</span><br></pre></td></tr></table></figure>



<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170458.png" alt="image-20210728161600450"></p>
<h4 id="4、查看数据卷"><a href="#4、查看数据卷" class="headerlink" title="4、查看数据卷"></a>4、查看数据卷</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure>



<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170501.png" alt="image-20210728161834712"></p>
<blockquote>
<p>Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied</p>
<p>解决办法：在挂载目录后多加一个–privileged=true参数即可</p>
</blockquote>
<h2 id="三、容器数据持久化"><a href="#三、容器数据持久化" class="headerlink" title="三、容器数据持久化"></a>三、容器数据持久化</h2><p>安装MySQL</p>
<p>官网仓库给出的使用说明</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170503.png" alt="image-20210728135812347"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">获取镜像</span></span><br><span class="line">[root@AlibabaECS home]# docker pull mysql:5.7</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行容器,需要做数据挂载！ <span class="comment"># 安装启动mysql, 需要配置密码的，这是要注意的点！</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参考官网hub</span> </span><br><span class="line">docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动我们自己的mysql</span></span><br><span class="line">-d 后台运行</span><br><span class="line">-p 端口映射</span><br><span class="line">-v 卷挂载</span><br><span class="line">-e 环境配置</span><br><span class="line">--name 容器名字</span><br><span class="line">--network somenetwork 使用指定网络（可选）</span><br><span class="line"></span><br><span class="line">docker run -d --name mysql -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动成功之后，我们使用本地Navicat连接测试，并新建一个数据库名叫 test</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170507.png" alt="image-20210728141136820"></p>
<p>进入到mysql容器内查看数据是否存在，发现已经有了test。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170510.png" alt="image-20210728141535126"></p>
<p>进入到主机查看数据是否存在，发现也有了test。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170513.png" alt="image-20210728141701831"></p>
<p>这样假设我们将容器删除了，我们挂载到本地的数据卷是不会丢失的，这就实现了容器数据持久化功能。</p>
<p>如果在启动mysql 的时候就没有配置挂载点的话，mysql容器被删除之后就会数据就没啦。</p>
<h2 id="四、匿名挂载与具名挂载"><a href="#四、匿名挂载与具名挂载" class="headerlink" title="四、匿名挂载与具名挂载"></a>四、匿名挂载与具名挂载</h2><h3 id="匿名挂载"><a href="#匿名挂载" class="headerlink" title="匿名挂载"></a>匿名挂载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匿名挂载</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 -v 容器内路径</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-P 随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 指定要映射的IP和端口，但是在一个指定端口上只可以绑定一个容器。</span></span><br><span class="line"></span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有的volume的情况</span></span><br><span class="line">➜  ~ docker volume ls    </span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               33ae588fae6d34f511a769948f0d3d123c9d45c442ac7728cb85599c2657e50d</span><br><span class="line">local            </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写卷名！</span></span><br></pre></td></tr></table></figure>

<h3 id="具名挂载"><a href="#具名挂载" class="headerlink" title="具名挂载"></a>具名挂载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具名挂载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 -v 卷名：容器内路径</span></span><br><span class="line">➜  ~ docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class="line">➜  ~ docker volume ls                  </span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               juming-nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170516.png" alt="image-20210728143122136"></p>
<h3 id="查看指定卷名的-数据卷"><a href="#查看指定卷名的-数据卷" class="headerlink" title="查看指定卷名的 数据卷"></a>查看指定卷名的 数据卷</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看指定卷名的 数据卷</span></span><br><span class="line">docker volume inspect juming-nginx</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170518.png" alt="image-20210728143225667"></p>
<p>所有的docker容器内的卷，没有指定目录的情况下都是在/var/lib/docker/volumes/xxxx/_data下<br>我们可以通过具名挂载方便的找到一个卷，大多情况下在使用具名挂载</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170520.png" alt="image-20210728144143197"></p>
<h3 id="设置数据卷读写权限"><a href="#设置数据卷读写权限" class="headerlink" title="设置数据卷读写权限"></a>设置数据卷读写权限</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 -v 容器内路径： ro rw 改变读写权限</span></span><br><span class="line">ro #readonly 只读</span><br><span class="line">rw #readwrite 可读可写</span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</p>
</blockquote>
<h2 id="五、数据卷容器"><a href="#五、数据卷容器" class="headerlink" title="五、数据卷容器"></a>五、数据卷容器</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>命名的容器挂载数据卷，其它容器通过挂载这个(父容器)实现数据共享，<code>挂载数据卷的容器</code>称之为数据卷容器</p>
<h3 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h3><p>1、以上一步新建的镜像镜像为模板并运行容器 lidalong/centos</p>
<p>2、它们已经具有容器卷</p>
<ul>
<li>/dataVolumeContainer1</li>
<li>/dataVolumeContainer2</li>
</ul>
<h3 id="容器间传递共享-–volumes-from"><a href="#容器间传递共享-–volumes-from" class="headerlink" title="容器间传递共享(–volumes-from)"></a>容器间传递共享(–volumes-from)</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170523.png" alt="在这里插入图片描述"></p>
<p>1、先启动一个父容器dc01，在dataVolumeContainer2新增文件</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170525.png" alt="image-20210728163139511"></p>
<p>2、dc02/dc03继承自dc01</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name dc02 --volumes-from dc01 lidalong/centos:1.0</span><br><span class="line">docker run -d --name dc03 --volumes-from dc01 lidalong/centos:1.0</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170528.png" alt="image-20210728163358285"></p>
<p>dc02/dc03分别在dataVolumeContainer2各自新增内容</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170530.png" alt="img"></p>
<p>3、回到dc01可以看到02/03各自添加的都能共享了</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170538.png" alt="img"></p>
<p>4、删除dc01，dc02修改后dc03可否访问（可以）</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170541.png" alt="img"></p>
<p><strong>结论：</strong></p>
<p>容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。</p>
<p>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>【Docker】7. Dockerfile</title>
    <url>/posts/cb90ace2bccc/</url>
    <content><![CDATA[<h1 id="【Docker】7-Dockerfile"><a href="#【Docker】7-Dockerfile" class="headerlink" title="【Docker】7. Dockerfile"></a>【Docker】7. Dockerfile</h1><h2 id="Dockerfile是什么"><a href="#Dockerfile是什么" class="headerlink" title="Dockerfile是什么"></a>Dockerfile是什么</h2><p>Dockerfile是用来构建docker镜像的文件</p>
<h2 id="Dockerfile命令"><a href="#Dockerfile命令" class="headerlink" title="Dockerfile命令"></a>Dockerfile命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>FROM</td>
<td>基础镜像：Centos/Ubuntu</td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像作者+邮箱</td>
</tr>
<tr>
<td>RUN</td>
<td>镜像构建的时候需要运行的命令</td>
</tr>
<tr>
<td>ADD</td>
<td>为镜像添加内容（压缩包）</td>
</tr>
<tr>
<td>WORKDIR</td>
<td>镜像工作目录（进入容器时的目录）</td>
</tr>
<tr>
<td>VOLUME</td>
<td>挂载的目录</td>
</tr>
<tr>
<td>EXPOSE</td>
<td>暴露端口配置</td>
</tr>
<tr>
<td>CMD/ENTRYPOINT</td>
<td>指定这个容器启动时要运行的命令（CMD替代先前命令，ENTRYPOINT在先前命令后追加）</td>
</tr>
<tr>
<td>COPY</td>
<td>类似于ADD，将文件拷贝到镜像中</td>
</tr>
<tr>
<td>ENV</td>
<td>构建时设置环境变量</td>
</tr>
</tbody></table>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170608.png" alt="在这里插入图片描述"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170611.png" alt="在这里插入图片描述"></p>
<h2 id="构建步骤"><a href="#构建步骤" class="headerlink" title="构建步骤"></a>构建步骤</h2><p>编写一个dockerfile文件, 随后运行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -f 文件路径 -t 标签 .  <span class="comment"># 文件名为Dockerfile时可省略且最后的.不要忽略</span></span><br><span class="line">docker run     <span class="comment"># 运行镜像</span></span><br><span class="line">docker push    <span class="comment"># 发布镜像</span></span><br></pre></td></tr></table></figure>

<h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><ul>
<li>每个保留关键字（指令）都必须是大写字母</li>
<li>从上到下顺序执行</li>
<li>“#” 表示注释</li>
<li>每一个指令都会创建提交一个新的镜像层并提交</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170616.png" alt="在这里插入图片描述"></p>
<p>dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！<br>Docker镜像逐渐成为企业交付的标准，必须要掌握！</p>
<p>DockerFile : 构建文件，定义了一切的步骤，源代码</p>
<p>DockerImages ： 通过DokerFile构建生成的镜像，是最终发布和运行的产品</p>
<p>Docker容器：容器就是镜像运行起来提供服务器</p>
<h2 id="创建一个自己的centos"><a href="#创建一个自己的centos" class="headerlink" title="创建一个自己的centos"></a>创建一个自己的centos</h2><p><a href="https://www.yuque.com/lixiaolong-hb05p/mhmsdg/rdcyym#8d74dba7">【Docker】6. 容器数据卷 · 语雀 (yuque.com)</a>  这一节有讲</p>
<p>官网：docker hub中  几乎所有的镜像都是在FROM scratch 基础上构建的</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170619.png" alt="img"></p>
<h3 id="1、编写Dockerfile的文件"><a href="#1、编写Dockerfile的文件" class="headerlink" title="1、编写Dockerfile的文件"></a>1、编写Dockerfile的文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.编写Dockerfile的文件</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER lidalong&lt;az757078252@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR $MYPATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUM yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MYPATH</span><br><span class="line">CMD echo &quot;-----end-----&quot;</span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2、通过这个文件构建镜像"><a href="#2、通过这个文件构建镜像" class="headerlink" title="2、通过这个文件构建镜像"></a>2、通过这个文件构建镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2.通过这个文件构建镜像</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker build -f 文件路径 -t 镜像名:[tag] .</span></span><br><span class="line">docker build -f ./dockerfile -t mycentos:0.1 .</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170626.png" alt="在这里插入图片描述"></p>
<h3 id="3、测试运行"><a href="#3、测试运行" class="headerlink" title="3、测试运行"></a>3、测试运行</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170629.png" alt=" "></p>
<h3 id="4、对比"><a href="#4、对比" class="headerlink" title="4、对比"></a>4、对比</h3><p>原来的</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170640.png" alt="原来的"></p>
<p>我们的镜像</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170642.png" alt="我们的镜像"></p>
<p>我们可以列出本地进行的变更历史</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170645.png" alt="在这里插入图片描述"></p>
<h3 id="5、CMD-和-ENTRYPOINT区别"><a href="#5、CMD-和-ENTRYPOINT区别" class="headerlink" title="5、CMD 和 ENTRYPOINT区别"></a>5、CMD 和 ENTRYPOINT区别</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CMD					# 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。</span><br><span class="line">ENTRYPOINT			# 指定这个容器启动的时候要运行的命令，可以追加命令 </span><br></pre></td></tr></table></figure>



<h2 id="发布自己的镜像"><a href="#发布自己的镜像" class="headerlink" title="发布自己的镜像"></a>发布自己的镜像</h2><p>基于<strong>阿里云镜像服务器</strong></p>
<p>找到容器镜像服务–创建命名空间</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170649.png" alt="image-20210728191757616"></p>
<p>创建容器镜像</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170652.png" alt="image-20210728191820753"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170654.png" alt="image-20210728191841071"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170657.png" alt="image-20210728191905615"></p>
<p>点击创建好的镜像仓库，根据操作指南一步步操作就可以了</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170700.png" alt="image-20210728191945164"></p>
<p>发布成功之后点击 镜像版本</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/docker/20220325170703.png" alt="image-20210728192118470"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>【Docker】8. Docker网络</title>
    <url>/posts/0c4926b40074/</url>
    <content><![CDATA[<h1 id="【Docker】8-Docker网络"><a href="#【Docker】8-Docker网络" class="headerlink" title="【Docker】8. Docker网络"></a>【Docker】8. Docker网络</h1><p>宿主机 ip a</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112347.png" alt=" "></p>
<p>docker 是如何处理容器网络访问的？</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112352.png" alt="在这里插入图片描述"></p>
<p>查看容器的内部网络地址 ip addr , 发现容器启动的时候会得到一个 eth0@if60 ip地址，docker分配的</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112356.png" alt="image-20210728194019965"></p>
<p>思考：linux能不能 ping 通容器内部？ （能）</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112400.png" alt="image-20210728194659314"></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我们每启动一个docker容器，docker就会给docker容器分配一个ip，我们只要安装了docker，就会有一个网卡docker0,桥接模式，使用的技术是evth-pair技术！</p>
<p>再次测试ip add</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112403.png" alt="在这里插入图片描述"></p>
<p>再启动一个容器 发现又多了一对网卡</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112407.png" alt="在这里插入图片描述"></p>
<p>我们发现这个容器带来网卡，都是一对对的（宿主机的网卡）</p>
<p>veth-pair 就是一对的虚拟设备接口，他们都是成对出现的，一端连着协&gt;议，一端彼此相连<br>正因为有这个特性 veth-pair 充当一个桥梁，连接各种虚拟网络设备的OpenStac,Docker容器之间的连接，OVS的连接，都是使用evth-pair技术</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112412.png" alt="在这里插入图片描述"></p>
<p>tomcat01 和 tomcat02 是共用一个路由器，docker0。</p>
<p>所有的容器不指定网络的情况下，都是通过docker0路由的，docker会给我们的容器分配一个默认的可用IP</p>
<p>所以容器和容器之间是可以互相ping通的：==容器1→Docker0→容器2==</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112417.png" alt="20210131140833"></p>
<blockquote>
<p>docker中的所有网络接口都是虚拟的 ，转发效率高。删除容器后，对应的网桥也随之删除。</p>
</blockquote>
<h2 id="自定义网络-推荐"><a href="#自定义网络-推荐" class="headerlink" title="自定义网络(推荐)"></a>自定义网络(推荐)</h2><p>查看所有的docker网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112422.png" alt="image-20210728195841557"></p>
<p>网络模式</p>
<ul>
<li><p>bridge ：桥接 docker（默认，自己创建也是用bridge模式）</p>
</li>
<li><p>none ：不配置网络，一般不用</p>
</li>
<li><p>host ：和宿主机共享网络</p>
</li>
<li><p>container ：容器网络连通（用得少！局限很大）</p>
</li>
</ul>
<p><strong>docker run</strong> 命令默认带有一个参数–net bridge，此处的bridge指的就是docker0。如果我们不想使用docker0，那如何创建一个新的网络呢？</p>
<p>创建新的网络，这个在安装ES的时候有提到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker  network create --driver 网络模式 --subnet 子网ip --gateway 网关 网络名      </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112428.png" alt="image-20210728195841557"></p>
<p>查看网络详细信息</p>
<p>我们不仅在<strong>docker network ls</strong>命令下发现了这个新创建的网络newnet，还可以使用<strong>docker network inspect</strong>命令查看其详细信息，包括了我们创建时定义的子网ip和网关：</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112431.png" alt="image-20210728201008123"></p>
<p>只要两个容器启动时都通过 <strong>–net</strong>，选用了同一个已创建的网络，不同容器间即可通过ip地址或容器名/id连通:</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112435.png" alt="20201212203023"></p>
<h3 id="网络联通"><a href="#网络联通" class="headerlink" title="网络联通"></a>网络联通</h3><p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112829.png" alt="20201212204434"></p>
<p>对于建立在不同网络下(docker0, newnet)的两个容器tomcat01和tomcat02，他们的网段不同，因此是无法彼此ping通容器内部的：</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112439.png" alt="20201212204311"></p>
<p>这时我们需要通过<strong>docker network connect</strong>命令打通容器与网络之间的连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network connect 网络名 容器名/id</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112443.png" alt="20201212203803"></p>
<p>这个功能类似于将一个容器赋予多个ip地址，同样可以用<strong>docker network inspect</strong>命令查看网络连通后，该网络的变化：</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112446.png" alt="20201212204235"></p>
<p>原本newnet网络中只含有tomcat02，现在增加了tomcat01，因此可以连通。</p>
<p>我们自定义的网络，docker为我们维护好了对应的关系，推荐我们平时这样使用网络！</p>
<p>好处：</p>
<p>redis - 不同的集群使用不同的网络，保证集群是健康和安全的</p>
<p>mysql - 不同的集群使用不同的网络，保证集群是健康安全的</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112451.png" alt="在这里插入图片描述"></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729112453.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
  </entry>
  <entry>
    <title>【Docker】9. Springboot 项目打包Docker镜像</title>
    <url>/posts/06ab33c3e1d1/</url>
    <content><![CDATA[<h1 id="【Docker】9-Springboot-项目打包Docker镜像"><a href="#【Docker】9-Springboot-项目打包Docker镜像" class="headerlink" title="【Docker】9. Springboot 项目打包Docker镜像"></a>【Docker】9. Springboot 项目打包Docker镜像</h1><h2 id="构建Springboot项目"><a href="#构建Springboot项目" class="headerlink" title="构建Springboot项目"></a>构建Springboot项目</h2><p>这就不用多说了吧</p>
<h2 id="创建Dockerfile"><a href="#创建Dockerfile" class="headerlink" title="创建Dockerfile"></a>创建Dockerfile</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM openjdk:8u252-jre		#jdk版本</span><br><span class="line">COPY *.jar /app.jar			#拷贝当前路径瞎所有jar 到 app.jar</span><br><span class="line">CMD [&quot;--- server.port=8092 ---&quot;]</span><br><span class="line">EXPOSE 8092					#开放的端口</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="文件上传服务器到同一个路径下"><a href="#文件上传服务器到同一个路径下" class="headerlink" title="文件上传服务器到同一个路径下"></a>文件上传服务器到同一个路径下</h2><p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729111923.png" alt="在这里插入图片描述"></p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729111926.png" alt="在这里插入图片描述"></p>
<h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t jacobyang-web .</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：jacobyang-web 这就是随意起个镜像名</p>
</blockquote>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729111928.png" alt="在这里插入图片描述"></p>
<h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729111932.png" alt="在这里插入图片描述"></p>
<h2 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -P --name xapp01 jacobyang-web</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：xapp01 我起的容器名 jacobyang-web 上面起的镜像名</p>
</blockquote>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20210729111935.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis笔记</title>
    <url>/posts/4272f6f61b90/</url>
    <content><![CDATA[<h1 id="mybatis笔记"><a href="#mybatis笔记" class="headerlink" title="mybatis笔记"></a>mybatis笔记</h1><p><a href="https://mybatis.org/mybatis-3/zh/getting-started.html">mybatis</a></p>
<h1 id="项目层级"><a href="#项目层级" class="headerlink" title="项目层级"></a>项目层级</h1><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222633.jpg" alt="img"></p>
<h1 id="1-idea创建maven项目"><a href="#1-idea创建maven项目" class="headerlink" title="1.idea创建maven项目"></a>1.idea创建maven项目</h1><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222639.png" alt="img"></p>
<p><strong>左侧选择maven，右侧选择jdk版本，然后下方next</strong></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222642.png" alt="img"></p>
<p><strong>输入GroupId等信息，然后next</strong></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222649.png" alt="img"></p>
<p><strong>然后项目名，项目所在路径，maven等信息，然后finish。一般这一步都不做任何更改，直接finish</strong></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222654.png" alt="img"></p>
<h1 id="2-修改父pom文件，添加mybatis等相关依赖"><a href="#2-修改父pom文件，添加mybatis等相关依赖" class="headerlink" title="2.修改父pom文件，添加mybatis等相关依赖"></a>2.修改父pom文件，添加mybatis等相关依赖</h1><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222700.jpg" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mysql驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--junit 单元测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="3-创建maven子项目"><a href="#3-创建maven子项目" class="headerlink" title="3.创建maven子项目"></a>3.创建maven子项目</h1><h2 id="3-1在父项目名上右键-new-Module"><a href="#3-1在父项目名上右键-new-Module" class="headerlink" title="3.1在父项目名上右键-new-Module"></a>3.1在父项目名上右键-new-Module</h2><p>剩下的操作类似新建maven项目</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222727.png" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222733.png" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222743.png" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222748.png" alt="img"></p>
<h2 id="3-2修改子项目的pom文件"><a href="#3-2修改子项目的pom文件" class="headerlink" title="3.2修改子项目的pom文件"></a><strong>3.2修改子项目的pom文件</strong></h2><p>引入了Lombok 用来简化get set 等方法</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222752.jpg" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="4-子项目中resources中创建mybatis-config-xml文件-配置数据库等信息"><a href="#4-子项目中resources中创建mybatis-config-xml文件-配置数据库等信息" class="headerlink" title="4.子项目中resources中创建mybatis-config.xml文件 配置数据库等信息"></a>4.子项目中resources中创建<strong>mybatis-config.xml</strong>文件 配置数据库等信息</h1><p>我的mysql是5.7版本，如果mysql是8.0的 驱动这块需要注意，具体区别可自行度娘</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis 配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--环境1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--事务管理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--数据源 可从其他配置文件中读取--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8<span class="symbol">&amp;amp;</span>useSSL=false<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--mapper 扫描路径--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="5-编写MybatisUtils工具类，获取SqlSession"><a href="#5-编写MybatisUtils工具类，获取SqlSession" class="headerlink" title="5.编写MybatisUtils工具类，获取SqlSession"></a>5.编写MybatisUtils工具类，获取<strong>SqlSession</strong></h1><p>SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> utils;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="comment">// SqlSessionFactory 工厂模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisUtils</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    从 XML 中构建 SqlSessionFactory</span></span><br><span class="line"><span class="comment">    每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。</span></span><br><span class="line"><span class="comment">    而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。</span></span><br><span class="line"><span class="comment">    建议使用类路径下的资源文件进行配置。 但也可以使用任意的输入流（InputStream）实例，比如用文件路径字符串或 file:// URL 构造的输入流。</span></span><br><span class="line"><span class="comment">    MyBatis 包含一个名叫 Resources 的工具类，它包含一些实用方法，使得从类路径或其它位置加载资源文件更加容易。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//读取配置文件 获取SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。</span></span><br><span class="line"><span class="comment">    SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title function_">getSqlSession</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-编写操作数据库的mapper接口"><a href="#6-编写操作数据库的mapper接口" class="headerlink" title="6.编写操作数据库的mapper接口"></a>6.编写操作数据库的mapper接口</h1><p>示例 查询数据库的用户表，获取到部分用户，</p>
<h2 id="6-1创建实体类"><a href="#6-1创建实体类" class="headerlink" title="6.1创建实体类"></a>6.1创建实体类</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222808.jpg" alt="img"></p>
<h2 id="6-2创建mapper接口，该接口中编写操作数据库的方法-例如：查询20条用户信息"><a href="#6-2创建mapper接口，该接口中编写操作数据库的方法-例如：查询20条用户信息" class="headerlink" title="6.2创建mapper接口，该接口中编写操作数据库的方法 例如：查询20条用户信息"></a>6.2创建mapper接口，该接口中编写操作数据库的方法 例如：查询20条用户信息</h2><p>当然也可以通过创建TmsUserListMapper.xml的方式来编写sql语句，不过个人习惯是使用注解，感觉通过XML来编写的话还得会多写一些代码，考虑到能简则简。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222814.jpg" alt="img"></p>
<h1 id="7-编写测试类，调用mapper中的方法来测试"><a href="#7-编写测试类，调用mapper中的方法来测试" class="headerlink" title="7.编写测试类，调用mapper中的方法来测试"></a>7.编写测试类，调用mapper中的方法来测试</h1><h2 id="方式一、"><a href="#方式一、" class="headerlink" title="方式一、"></a>方式一、</h2><p>通过加载.class对象获取到 TmsUserListMapper.java接口实例，然后调用接口中的方法来执行sql语句获取到结果</p>
<h2 id="方式二、"><a href="#方式二、" class="headerlink" title="方式二、"></a>方式二、</h2><p>通过方法的全路径名直接调用方法来执行sql语句获取到结果</p>
<h2 id="推荐使用方式一、官网也是推荐使用方式一"><a href="#推荐使用方式一、官网也是推荐使用方式一" class="headerlink" title="推荐使用方式一、官网也是推荐使用方式一"></a><strong>推荐使用方式一、官网也是推荐使用方式一</strong></h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222819.jpg" alt="img"></p>
<p>最后forEach输出</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222823.jpg" alt="img"></p>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a><a href="https://mybatis.org/mybatis-3/zh/configuration.html">配置</a></h1><p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：</p>
<p>configuration（配置）<a href="https://mybatis.org/mybatis-3/zh/configuration.html#properties">properties（属性）</a><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings">settings（设置）</a><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases">typeAliases（类型别名）</a><a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers">typeHandlers（类型处理器）</a><a href="https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory">objectFactory（对象工厂）</a><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">plugins（插件）</a><a href="https://mybatis.org/mybatis-3/zh/configuration.html#environments">environments（环境配置）</a>environment（环境变量）transactionManager（事务管理器）dataSource（数据源）<a href="https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider">databaseIdProvider（数据库厂商标识）</a><a href="https://mybatis.org/mybatis-3/zh/configuration.html#mappers">mappers（映射器）</a></p>
<p>这是我项目的配置文件，一般mybatis的配置文件都叫 mybatis-config.xml</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222829.jpg" alt="img"></p>
<h2 id="属性（properties）"><a href="#属性（properties）" class="headerlink" title="属性（properties）"></a>属性（properties）</h2><p>可以外部配置，也可以内部配置，我的配置文件中用的是内外都有，仅仅是为了测试展示，正常情况都是外部配置。</p>
<p>${driver} 匹配key。获取的是key对应的value，</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222838.jpg" alt="img"></p>
<p>也可以在 SqlSessionFactoryBuilder.build() 方法中传入属性值。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, props);</span><br><span class="line"><span class="comment">// ... 或者 ...</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment, props);</span><br></pre></td></tr></table></figure>

<p>但是我的项目中没弄这个方法传入属性值</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222845.jpg" alt="img"></p>
<h3 id="关于-这三种方式的获取顺序和优先级"><a href="#关于-这三种方式的获取顺序和优先级" class="headerlink" title="关于 这三种方式的获取顺序和优先级"></a>关于 这三种方式的获取顺序和优先级</h3><p>如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载：</p>
<p><strong>首先</strong>读取在 properties <strong>标签体内</strong>指定的属性。</p>
<p><strong>然后</strong>根据 properties 元素中的 resource 属性<strong>读取类路径下属性文件</strong>，或根据 url 属性指定的路径读取属性文件，<strong>并覆盖之前</strong>读取过的同名属性。</p>
<p><strong>最后</strong>读取作为<strong>方法参数传递</strong>的属性，并覆盖之前读取过的同名属性。</p>
<p>因此，通过<strong>方法参数传递&gt;resource/url &gt;</strong> <strong>properties 标签体内</strong></p>
<h2 id="环境配置（environments）"><a href="#环境配置（environments）" class="headerlink" title="环境配置（environments）"></a>环境配置（environments）</h2><p>可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中，方便多数据源开发</p>
<p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p>
<p>所以，如果你想连接两个数据库，就需要创建两个 SqlSessionFactory 实例，每个数据库对应一个。而如果是三个数据库，就需要三个实例，依此类推，记起来很简单：<strong>每个数据库对应一个 SqlSessionFactory 实例</strong></p>
<p>为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。可以接受环境配置的两个方法签名是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader, environment, properties);</span><br></pre></td></tr></table></figure>

<p>如果忽略了环境参数，那么将会加载默认环境。</p>
<p>我这里弄得if判断不严谨，一般都是用枚举类 或者在配置文件中获取到运行的环境，然后去设置用哪个数据源</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325222851.jpg" alt="img"></p>
<p>事务管理器（transactionManager）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）：</p>
<p>JDBC 有提交回滚等事务的功能</p>
<p>MANAGED 从不提交或者回滚，而是让容器来管理事务的生命周期</p>
<h3 id="数据源（dataSource）"><a href="#数据源（dataSource）" class="headerlink" title="数据源（dataSource）"></a>数据源（dataSource）</h3><p>使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--数据源 可从其他配置文件中读取--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>UNPOOLED</strong> 这个数据源的实现会每次请求时打开和关闭连接</p>
<p><strong>POOLED</strong> 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 </p>
<p>这种处理方式很流行，能使并发 Web 应用快速响应请求。<strong>也是默认的方式</strong></p>
<p><strong>JNDI</strong> 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。</p>
<h2 id="映射器（mappers）"><a href="#映射器（mappers）" class="headerlink" title="映射器（mappers）"></a>映射器（mappers）</h2><p>配置mybatis 的扫描路径，这些配置会告诉 MyBatis 去哪里找映射文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/builder/PostMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.AuthorMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.builder.PostMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 多数时候是用包扫描 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;org.mybatis.builder&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;field1 != null and field1 != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="choose-when-otherwise"><a href="#choose-when-otherwise" class="headerlink" title="choose (when, otherwise)"></a>choose (when, otherwise)</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title != null&quot;</span>&gt;</span></span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="trim-where-set"><a href="#trim-where-set" class="headerlink" title="trim (where, set)"></a>trim (where, set)</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&#x27;values (&#x27;</span> <span class="attr">suffix</span>=<span class="string">&#x27;)&#x27;</span> <span class="attr">suffixOverrides</span>=<span class="string">&#x27;,&#x27;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author != null and author.name != null&quot;</span>&gt;</span></span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateAuthorIfNecessary&quot;</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;bio != null&quot;</span>&gt;</span>bio=#&#123;bio&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPostIn&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;domain.blog.Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM POST P WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&quot;item&quot;</span> <span class="attr">index</span>=<span class="string">&quot;index&quot;</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="script"><a href="#script" class="headerlink" title="script"></a>script</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@Delete(&quot;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">&quot; +</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    &quot;DELETE FROM tms_common_address WHERE id IN &quot; +</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    &quot;<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">&#x27;id&#x27;</span> <span class="attr">collection</span>=<span class="string">&#x27;ids&#x27;</span> <span class="attr">open</span>=<span class="string">&#x27;(&#x27;</span> <span class="attr">separator</span>=<span class="string">&#x27;,&#x27;</span> <span class="attr">close</span>=<span class="string">&#x27;)&#x27;</span>&gt;</span>&quot; +</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    &quot; #&#123;id&#125; &quot; +</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    &quot;<span class="tag">&lt;/<span class="name">foreach</span>&gt;</span>;&quot; +</span></span></span><br><span class="line"><span class="language-xml"><span class="language-handlebars">    &quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>&quot;)</span><br><span class="line">int remove(@Param(&quot;ids&quot;) List<span class="tag">&lt;<span class="name">String</span>&gt;</span> ids);</span><br></pre></td></tr></table></figure>

<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlogsLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">&quot;pattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&#x27;%&#x27; + _parameter.getTitle() + &#x27;%&#x27;&quot;</span> /&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE title LIKE #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>更多内容可以去mybatis官网去查看，推荐一个中文的网站 <a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>MVCC详解</title>
    <url>/posts/893cfd1c2f85/</url>
    <content><![CDATA[<h1 id="MVCC详解"><a href="#MVCC详解" class="headerlink" title="MVCC详解"></a>MVCC详解</h1><p>多版本并发控制，就是为了解决并发情况下<code>读写冲突</code></p>
<p>待学习</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MVCC%E8%AF%A6%E8%A7%A3/20220325223201.png" alt="image-20220311152440024"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MVCC%E8%AF%A6%E8%A7%A3/20220325223205.png" alt="image-20220311152429410"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MVCC%E8%AF%A6%E8%A7%A3/20220325223214.png" alt="image-20220311152418388"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
  </entry>
  <entry>
    <title>VMware16安装CentOS7.X(并配置网络)</title>
    <url>/posts/84c94f982080/</url>
    <content><![CDATA[<h1 id="VMware16-安装CentOS7-X-并配置网络"><a href="#VMware16-安装CentOS7-X-并配置网络" class="headerlink" title="VMware16 安装CentOS7.X(并配置网络)"></a>VMware16 安装CentOS7.X(并配置网络)</h1><h1 id="一、CentOS7-9-镜像下载"><a href="#一、CentOS7-9-镜像下载" class="headerlink" title="一、CentOS7.9 镜像下载"></a>一、CentOS7.9 镜像下载</h1><p>官网下载地址：<a href="https://www.centos.org/download/%EF%BC%8C%E9%80%89%E6%8B%A9%E6%88%91%E4%BB%AC%E5%87%86%E5%A4%87%E5%AE%89%E8%A3%85%E7%9A%84%E6%98%AF%E7%89%88%E6%9C%AC7%E9%9D%A2%E6%9D%BF%E3%80%82">https://www.centos.org/download/，选择我们准备安装的是版本7面板。</a></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142816.png" alt="img"></p>
<p>选择我们熟悉的阿里云的镜像地址下载(文件有点大，4个多G)。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142614.png" alt="img"></p>
<h1 id="二、使用VMware创建虚拟机"><a href="#二、使用VMware创建虚拟机" class="headerlink" title="二、使用VMware创建虚拟机"></a>二、使用VMware创建虚拟机</h1><p>在主页界面选择“创建新的虚拟机”，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142913.png" alt="img"></p>
<p>接着，选择弹出“新建虚拟机向导”界面的“自定义高级”选项，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142918.png" alt="img"></p>
<p>继续“下一步”，默认选择，如下图：</p>
<p>接着，选择“售后安装操作系统”选项，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142922.png" alt="img"></p>
<p>下一步，选择“Linux”并选择“Centos 7 64位”，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142926.png" alt="img"></p>
<p>下一步，填写虚拟机名称、保存位置，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142928.png" alt="img"></p>
<p>继续，选择处理器的配置和内存的配置。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142931.png" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142933.png" alt="img"></p>
<p>接着，配置网络，如下图选项：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142936.png" alt="img"></p>
<p>后面，继续默认推荐的选择，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142938.png" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142940.png" alt="img"></p>
<p>选择磁盘时，勾选“创建虚拟磁盘”，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142943.png" alt="img"></p>
<p>在“指定磁盘容量”配置(磁盘大小自己设置)，勾选“将虚拟磁盘存储为单个文件”，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142945.png" alt="img"></p>
<p>下一步，默认不动：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142948.png" alt="img"></p>
<p>到“已准备好创建虚拟机”的界面时，需要配置下，点击“自定义硬件”，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142950.png" alt="img"></p>
<p>选择“新 CD/DV(IDE)”，勾选右边的使用ISO映像文件“”，并指定本地centos的镜像文件后，点击“关闭”按钮。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142952.png" alt="img"></p>
<p>回到到“已准备好创建虚拟机”的界面后，点击“完成”，停顿几秒后。VMware的“我的计算机”面板出现了自己命名的虚拟机，表示已经配置好了，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142955.png" alt="img"></p>
<h1 id="三、安装CentOS7-X过程"><a href="#三、安装CentOS7-X过程" class="headerlink" title="三、安装CentOS7.X过程"></a>三、安装CentOS7.X过程</h1><p>继续，双击“我的计算机”面板中刚安装的虚拟机，启动安装(回车确认选择，默认选择中间“Test this media &amp; install CentoOS 7”)，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325142958.png" alt="image-20210726135023073"></p>
<p>界面自动跳动，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143000.png" alt="img"></p>
<p> 回车，确认开始，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143003.png" alt="image-20210726135004798"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143305.png" alt="image-20210726134939732"></p>
<p>接着，弹出选择系统语言界面，选择“中文”，如下图:</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143010.png" alt="20190818165751864"></p>
<p>“Continue”之后，弹出界面“安装位置”, 其中有红色感叹号的需要操作下（指定系统安装磁盘位置），鼠标点击选择，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143350.png" alt="image-20210726134717836"></p>
<p>之后，选择弹出的界面中唯一的“Local Standard Disks”,本地标准磁盘, 确定“Done”完成，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143611.png" alt="img"></p>
<p>之后，回到“INSTALLATION SUMMARY”界面，选择“Begin installation”开始初始化，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143030.png" alt="img"></p>
<p>开始初始化时，提示设置下管理员的密码、创建非管理员账号，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143033.png" alt="img"></p>
<p>设置管理员密码，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143036.png" alt="img"></p>
<p>创建非管理员的账号(可选)，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143038.png" alt="img"></p>
<p>创建好后管理员密码和非管理员之后，回到初始化进度页面，等待片刻，出现初始化成功提示，表示安装成功，点击“ReBoot”重启, 如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143040.png" alt="img"></p>
<h1 id="四、配置CentOS网络"><a href="#四、配置CentOS网络" class="headerlink" title="四、配置CentOS网络"></a>四、配置CentOS网络</h1><p>重启后，让系统自己进入登录页面，中间人工无需任何操作，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143043.png" alt="img"></p>
<p>输入root账户和密码，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143045.png" alt="img"></p>
<p>使用命令“ping <a href="http://www.baidu.com”/">www.baidu.com”</a>, 检查网络是否通，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143048.png" alt="img"></p>
<p>网不通，使用命令“ip addr”检查是否有网卡(ens33存在表示有网卡)，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143050.png" alt="img"></p>
<p>ens33存在表示有网卡，使用命令“nmcli connection show”,查看网络连接信息（DEVICE栏里是 ‘–’ ,表示没有启用），如下图:</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143053.png" alt="img"></p>
<blockquote>
<p>备注：nmcli命令是redhat7或者centos7之后的命令,该命令可以完成网卡上所有的配置工作,并且可以写入配置文件,永久生效。</p>
</blockquote>
<p>进入目录/etc/sysconfig/network-scripts/，编辑ifcfg-ens33文件的配置ONBOOT,改成“yes”.重启。<br>输入 vi ifcfg-ens33，然后看到如下信息，需要注意的是如果是自动获取的话，BOOTPROTO那里要改成dhcp，如果你是静态IP的话，这里要改成static（当然静态IP还要填写IPADDR等信息）。最重要的是要把最后一项ONBOOT=no改成ONBOOT=yes，如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143058.png" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143100.png" alt="img"></p>
<p>最后输入 “service network restart” 重启网络服务，再次使用命令“nmcli connection show”查看网络连接状况，最后重新“ping <a href="http://www.baidu.com”/">www.baidu.com”</a>, 有数据包接收表示配置成功。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143102.png" alt="img"></p>
<h1 id="五、安装ifconfig命令"><a href="#五、安装ifconfig命令" class="headerlink" title="五、安装ifconfig命令"></a>五、安装ifconfig命令</h1><p>使用ifconfig命令查看本机ip, 结果报没有这个命令。</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143107.png" alt="img" style="zoom: 200%;" />

<p>通过命令列出安装包：ifconfig的安装包是net-tools，如下：<br>$: yum list 文件名  </p>
<p>或模糊匹配</p>
<p>$: yum list 文件名*</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143109.png" alt="img"></p>
<p>通过命令安装net-tools安装包，如下：</p>
<p>$: yum install net-tools.x86-64</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143112.png" alt="img"></p>
<p>再次使用ifconfig命令查看ip地址：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143114.png" alt="img"></p>
<p>此时在ping <a href="http://www.baidu.com,有数据接收/">www.baidu.com,有数据接收</a> 说明虚拟机已经联网</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/VMware/20220325143117.png" alt="image-20210726115818273"></p>
]]></content>
      <categories>
        <category>VMware16</category>
      </categories>
  </entry>
  <entry>
    <title>一条SQL插入Blob类型数据</title>
    <url>/posts/ea29204a6a4b/</url>
    <content><![CDATA[<h1 id="一条SQL插入Blob类型数据"><a href="#一条SQL插入Blob类型数据" class="headerlink" title="一条SQL插入Blob类型数据"></a>一条SQL插入Blob类型数据</h1><p>网上查询的往oracle插入blob数据大多都是</p>
<ul>
<li>先<code>insert</code>一个空对象</li>
<li>然后再select出来，获取blob对象之后在往里面写数据</li>
</ul>
<p>经过一段时间的搜索找到一种方式可以和普通字段一样直接插入blob类型数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;url&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="string">&quot;登陆名&quot;</span>;<span class="comment">// 登陆名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;密码&quot;</span>;<span class="comment">// 密码</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//加载驱动</span></span><br><span class="line">    Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line">    <span class="comment">//创建数据库连接</span></span><br><span class="line">    conn = DriverManager.getConnection(url, userName, password);</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into test(testblob,blob2) values(?,?)&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">pres</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">    <span class="comment">//往数据库创建一个临时Blob</span></span><br><span class="line">    <span class="type">Blob</span> <span class="variable">blob</span> <span class="operator">=</span> oracle.sql.BLOB.createTemporary(conn, <span class="literal">true</span>, BLOB.DURATION_SESSION);</span><br><span class="line">    <span class="comment">//往临时Blob写入数据</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> blob.setBinaryStream(<span class="number">1L</span>);  </span><br><span class="line">    os.write(readToByte(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\1.jpg&quot;</span>)));</span><br><span class="line">    os.flush();</span><br><span class="line">    <span class="comment">//设置参数执行sql</span></span><br><span class="line">    pres.setBlob(<span class="number">1</span>, blob);</span><br><span class="line">    pres.setBlob(<span class="number">2</span>, blob);</span><br><span class="line">    pres.executeUpdate();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试，这种方式对于update也是一样适用的，核心在于创建这个Blob对象，就是调用oracle驱动的Blob类来创建一个Blob对象，只要创建出来这个对象，那就和我们操作普通的字段一样了。</p>
<p><strong>后来又研究了一下，发现其实很很很很很很很很很很简单，<code>直接插入了一个流</code>就可以啦！但是注意了，这样操作，每个流只能用一次，因为流只能读一次，除非重置。记得关闭流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into test(testblob,blob2) values(?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pres</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">//创建两个流</span></span><br><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(readToByte(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\1.jpg&quot;</span>)));</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\1.jpg&quot;</span>);</span><br><span class="line"><span class="comment">//直接setBlob完工</span></span><br><span class="line">pres.setBlob(<span class="number">1</span>, in);</span><br><span class="line">pres.setBlob(<span class="number">2</span>, in2);</span><br><span class="line">pres.executeUpdate();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：没事多看看JAVA api源码，里面的很多思想都特别<code>妙</code></p>
</blockquote>
]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>千万别再说redis是单线程了</title>
    <url>/posts/7a9e447fda95/</url>
    <content><![CDATA[<h1 id="千万别再说redis是单线程了"><a href="#千万别再说redis是单线程了" class="headerlink" title="千万别再说redis是单线程了"></a>千万别再说redis是单线程了</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis 6.0已经发布了两年多，而6.0的发布在IT圈犹如一颗惊雷一般，因为这是redis最大的一次改版，首次加入了<strong>多线程</strong>。</p>
<p>作者Antirez在RC1版本发布时在他的博客写下：</p>
<blockquote>
<p>the most “enterprise” Redis version to date // 最”企业级”的</p>
<p>the largest release of Redis ever as far as I can tell // 最大的</p>
<p>the one where the biggest amount of people participated // 参与人数最多的</p>
</blockquote>
<p>那么Redis 6.0 之前的版本真的是单线程吗？</p>
<h2 id="Redis-6-0-之前的版本真的是单线程吗"><a href="#Redis-6-0-之前的版本真的是单线程吗" class="headerlink" title="Redis 6.0 之前的版本真的是单线程吗"></a>Redis 6.0 之前的版本真的是单线程吗</h2><p>在 Redis 6.0 中，非常受关注的一个新特性就是多线程。这是因为Redis 一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用<strong>后台线程或子进程</strong>执行（比如数据删除、快照生成、AOF 重写），但是，<strong>从网络 IO 处理到实际的读写命令处理，都是由单个线程完成的</strong>。Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为文件事件处理器。它的组成结构为4部分：多个套接字、IO多路复用程序、文件事件分派器、事件处理器。因为文件事件分派器队列的消费是单线程的，所以Redis才叫单线程模型。</p>
<h3 id="Redis文件事件处理器"><a href="#Redis文件事件处理器" class="headerlink" title="Redis文件事件处理器"></a>Redis文件事件处理器</h3><p>Redis 文件事件处理器由四个部分组成：套接字、I/O多路复用程序、文件时间分派器（dispatcher）、事件处理器。</p>
<p>文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答（accept）、写入（write）、读取（read）、关闭（close）等操作时，就会相应产生一个文件事件。</p>
<p>I/O多路复用器负责通过loop循环监听多个套接字，同时将一系列套接字按循序存储到一个队列中，由队列向文件事件分派器传送队列中套接字。这个队列中套接字是有序的，它会当一个套接字事件被处理完毕后，会立马向文件事件分配器传送下一个套接字。</p>
<p>文件事件分配器接受队列中的套接字并根据套接字产生的事件类型，相应调用不同的事件处理器。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/redis202208271551351.png" alt="图1 Redis 文件事件处理器过程 "></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/redis202208271551180.png" alt="图2 I/O多路复用程序通过队列向文件事件分派器传送套接字 "></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/redis202208271551889.png" alt="图3 Redis I/O 多路复用调用的多路复用库"></p>
<h2 id="Redis-6-0-多线程的实现机制？"><a href="#Redis-6-0-多线程的实现机制？" class="headerlink" title="Redis 6.0 多线程的实现机制？"></a>Redis 6.0 多线程的实现机制？</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/redis202208271551668.jpg" alt="redis多线程实现机制"></p>
<p><strong>流程简述如下：</strong></p>
<ol>
<li>主线程负责接收建立连接请求，获取 Socket 放入全局等待读处理队列。</li>
<li>主线程处理完读事件之后，通过 RR（Round Robin）将这些连接分配给这些 IO 线程。</li>
<li>主线程阻塞等待 IO 线程读取 Socket 完毕。</li>
<li>主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行。</li>
<li>主线程阻塞等待 IO 线程将数据回写 Socket 完毕。</li>
<li>解除绑定，清空等待队列。</li>
</ol>
<p>思路：<strong>将主线程 IO 读写任务拆分出来给一组独立的线程处理，使得多个 socket 读写可以并行化，但是 Redis 命令还是主线程串行执行。</strong></p>
<p><strong>该设计有如下特点：</strong></p>
<ul>
<li>IO 线程要么同时在读 Socket，要么同时在写，不会同时读或写。</li>
<li>IO 线程只负责读写 Socket 解析命令，不负责命令处理。</li>
</ul>
<h2 id="Redis-6-0-之前为什么一直不使用多线程"><a href="#Redis-6-0-之前为什么一直不使用多线程" class="headerlink" title="Redis 6.0 之前为什么一直不使用多线程"></a>Redis 6.0 之前为什么一直不使用多线程</h2><p>使用了单线程后，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。</p>
<p>Redis 通过 AE 事件模型以及 IO 多路复用等技术，处理性能非常高，因此没有必要使用多线程。</p>
<p>单线程机制使得 Redis 内部实现的复杂度大大降低，Hash 的惰性 Rehash、Lpush 等等 “线程不安全” 的命令都可以无锁进行。</p>
<h2 id="Redis-6-0-为什么要引入多线程呢？"><a href="#Redis-6-0-为什么要引入多线程呢？" class="headerlink" title="Redis 6.0 为什么要引入多线程呢？"></a>Redis 6.0 为什么要引入多线程呢？</h2><p>Redis 的瓶颈并不在 CPU，而在内存和网络。</p>
<p>内存不够的话，可以加内存或者做数据结构优化和其他优化等，但网络的性能优化才是大头，网络 IO 的读写在 Redis 整个执行期间占用了大部分的 CPU 时间，如果把网络处理这部分做成多线程处理方式，那对整个 Redis 的性能会有很大的提升。</p>
<p>优化方向：</p>
<p>提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式。<br>使用多线程充分利用多核，典型的实现比如 Memcached。</p>
<h2 id="Redis-6-0-默认是否开启了多线程？"><a href="#Redis-6-0-默认是否开启了多线程？" class="headerlink" title="Redis 6.0 默认是否开启了多线程？"></a>Redis 6.0 默认是否开启了多线程？</h2><p>否，在conf文件进行配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">io-threads-do-reads yes</span><br><span class="line">io-threads 线程数</span><br></pre></td></tr></table></figure>

<p>官方建议：4 核的机器建议设置为 2 或 3 个线程，8 核的建议设置为 6 个线程，线程数一定要小于机器核数，尽量不超过8个。</p>
<h2 id="开启多线程后，是否会存在线程并发安全问题？"><a href="#开启多线程后，是否会存在线程并发安全问题？" class="headerlink" title="开启多线程后，是否会存在线程并发安全问题？"></a>开启多线程后，是否会存在线程并发安全问题？</h2><p>不会，Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。</p>
<p><strong>Redis 线程中经常提到 IO 多路复用，如何理解？</strong><br>这是 IO 模型的一种，即经典的 Reactor 设计模式，有时也称为异步阻塞 IO。</p>
<p>多路指的是多个 Socket 连接，复用指的是复用一个线程。多路复用主要有三种技术：Select，Poll，Epoll。</p>
<p>Epoll 是最新的也是目前最好的多路复用技术。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了 Redis 具有很高的吞吐量。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>所以总结起来，Redis 支持多线程主要就是两个原因：</p>
<ul>
<li>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核。</li>
<li>多线程任务可以分摊 Redis 同步 IO 读写负荷。</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot注解方式实现接口防刷功能</title>
    <url>/posts/e17f07a87c3e/</url>
    <content><![CDATA[<h1 id="springboot注解方式实现接口防刷功能"><a href="#springboot注解方式实现接口防刷功能" class="headerlink" title="springboot注解方式实现接口防刷功能"></a>springboot注解方式实现接口防刷功能</h1><p>如果一些项目没有的熔断限流机制的话，很有可能会出现某一个接口短时间内大量被请求的现象，这样就导致该服务的cpu一直在处理该接口的业务，只是其他接口效率降低，甚至导致整个服务都崩溃。为了防止这样的攻击，往往服务会有熔断限流机制。<br>在不引入其他分布式组件的情况下，我们仅仅使用java本身的代码和redis就可以实现接口限流功能。</p>
<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>项目中用到的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 添加redis支持--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- fastjson --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="AccessLimit注解完整代码"><a href="#AccessLimit注解完整代码" class="headerlink" title="AccessLimit注解完整代码"></a>AccessLimit注解完整代码</h2><p>自定义一个注解，用来修饰方法，设置接口单位时间内最大次数 和 时间单位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.METHOD;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.RetentionPolicy.RUNTIME;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口防刷的注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022年02月09日 22:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AccessLimit &#123;</span><br><span class="line">    <span class="comment">// 时间单位</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">seconds</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 单位时间内最大次数</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxCount</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="AccessLimitInterceptor接口限流拦截器"><a href="#AccessLimitInterceptor接口限流拦截器" class="headerlink" title="AccessLimitInterceptor接口限流拦截器"></a>AccessLimitInterceptor接口限流拦截器</h2><p>防刷拦截器，重点就在这个拦截器里面，通过拦截请求，然后分析判断是否达到接口拦截限制，来进行拦截或者放行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.example.springbootaccesslimit.anno.AccessLimit;</span><br><span class="line"><span class="keyword">import</span> com.example.springbootaccesslimit.entry.Result;</span><br><span class="line"><span class="keyword">import</span> com.example.springbootaccesslimit.enums.CodeMsg;</span><br><span class="line"><span class="keyword">import</span> com.example.springbootaccesslimit.utils.RedisUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.method.HandlerMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防刷拦截器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022年02月09日 22:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccessLimitInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisUtil redisUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方法请求拦截</span></span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">HandlerMethod</span> <span class="variable">hm</span> <span class="operator">=</span> (HandlerMethod) handler;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取方法中的AccessLimit注解</span></span><br><span class="line">            <span class="type">AccessLimit</span> <span class="variable">accessLimit</span> <span class="operator">=</span> hm.getMethodAnnotation(AccessLimit.class);</span><br><span class="line">            <span class="keyword">if</span> (accessLimit == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">seconds</span> <span class="operator">=</span> accessLimit.seconds();</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> accessLimit.maxCount();</span><br><span class="line">            <span class="type">String</span> <span class="variable">uri</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">            <span class="comment">//这里简单用用户名代替，建议用通过校验的token</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> <span class="string">&quot;username&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> token + uri;</span><br><span class="line">            <span class="comment">//从redis中获取用户访问的次数</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">count</span> <span class="operator">=</span> redisUtil.get(key);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//第一次访问</span></span><br><span class="line">                redisUtil.set(key, <span class="number">1</span>, (<span class="type">long</span>) seconds, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(count.toString()) &lt; maxCount) &#123;</span><br><span class="line">                <span class="comment">//加1</span></span><br><span class="line">                redisUtil.incr(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//超出访问次数</span></span><br><span class="line">                render(response);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超出访问次数 给出提示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">render</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        response.setContentType(<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> JSON.toJSONString(Result.codeMsg(CodeMsg.ACCESS_LIMIT_REACHED));</span><br><span class="line">        out.write(str.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="InterceptorConfig-拦截器配置"><a href="#InterceptorConfig-拦截器配置" class="headerlink" title="InterceptorConfig 拦截器配置"></a>InterceptorConfig 拦截器配置</h2><p>配置springboot的拦截器，将接口限流拦截器加入到springboot中，使之生效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.springbootaccesslimit.interceptor.AccessLimitInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截器配置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022年02月09日 22:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AccessLimitInterceptor <span class="title function_">getAccessLimitInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AccessLimitInterceptor</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(getAccessLimitInterceptor());<span class="comment">// 将接口限流拦截器加入到springboot中，使之生效</span></span><br><span class="line">        <span class="built_in">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RedisUtil类"><a href="#RedisUtil类" class="headerlink" title="RedisUtil类"></a>RedisUtil类</h2><p>对redis的一些操作方法的封装</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.ValueOperations;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis操作基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除对应的value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keys</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="keyword">final</span> String... keys)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pattern</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removePattern</span><span class="params">(<span class="keyword">final</span> String pattern)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; keys = redisTemplate.keys(pattern);</span><br><span class="line">        <span class="keyword">if</span> (keys.size() &gt; <span class="number">0</span>)</span><br><span class="line">            redisTemplate.delete(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">removeSet</span><span class="params">(Set&lt;String&gt; set)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.delete(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除对应的value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="keyword">final</span> String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (exists(key)) &#123;</span><br><span class="line">            redisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">expire</span><span class="params">(<span class="keyword">final</span> String key, <span class="type">long</span> time, TimeUnit unit)</span> &#123;</span><br><span class="line">        redisTemplate.expire(key, time, unit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断缓存中是否有对应的value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">(<span class="keyword">final</span> String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="keyword">final</span> String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">gets</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops = <span class="built_in">this</span>.template.opsForValue();</span><br><span class="line">        <span class="keyword">return</span> ops.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(<span class="keyword">final</span> String key, Object value)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(<span class="keyword">final</span> String key, Object value, Long expireTime, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            redisTemplate.expire(key, expireTime, timeUnit);</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">increment</span><span class="params">(<span class="keyword">final</span> String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().increment(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRedisTemplate</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set <span class="title function_">keys</span><span class="params">(String pattern)</span> &#123;</span><br><span class="line">        <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> redisTemplate.keys(pattern);</span><br><span class="line">        <span class="keyword">return</span> set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * redis分布式锁实现，同时利用expire设置过期时间</span></span><br><span class="line"><span class="comment">     * 返回true就是设置成功</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">setNX</span><span class="params">(String key, String value, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isExit</span> <span class="operator">=</span> <span class="built_in">this</span>.redisTemplate.getConnectionFactory().getConnection().setNX(key.getBytes(), value.getBytes());</span><br><span class="line">        <span class="comment">//如果设置成功，要设置其过期时间</span></span><br><span class="line">        <span class="keyword">if</span> (isExit) &#123;</span><br><span class="line">            redisTemplate.expire(key, timeout, unit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isExit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="HelloController"><a href="#HelloController" class="headerlink" title="HelloController"></a>HelloController</h2><p>编写controller 进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.springbootaccesslimit.anno.AccessLimit;</span><br><span class="line"><span class="keyword">import</span> com.example.springbootaccesslimit.entry.Result;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AccessLimit(seconds = 5, maxCount = 5)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testAccessLimit&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result&lt;Map&lt;String, String&gt;&gt; <span class="title function_">testAccessLimit</span><span class="params">()</span> &#123;</span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;ok~~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.success(map);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>访问 <a href="http://localhost:8080/testAccessLimit">http://localhost:8080/testAccessLimit</a>  连续快速点击几次之后就会出现如下结果</p>
<blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;code&quot;</span><span class="punctuation">:</span><span class="number">403</span><span class="punctuation">,</span><span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span><span class="string">&quot;已达到访问限制&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>至此，我们在尽可能少的修改controller的基础上，实现了接口的防刷功能</p>
<p>本文中那些Result、CodeMsg 等通用类没提供，完整版代码在此：<a href="https://gitee.com/lixiaogou/springbootdemo/tree/master/SpringbootAccessLimit">SpringbootAccessLimit</a>)</p>
<h2 id="更多精彩内容，扫码订阅，获得第一手资料！"><a href="#更多精彩内容，扫码订阅，获得第一手资料！" class="headerlink" title="更多精彩内容，扫码订阅，获得第一手资料！"></a>更多精彩内容，扫码订阅，获得第一手资料！</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/pictures/%E5%85%AC%E4%BC%97%E5%8F%B78x8.jpg" alt="公众号"></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>spring事务传播和事务隔离</title>
    <url>/posts/057e464831e9/</url>
    <content><![CDATA[<h1 id="spring事务传播和事务隔离"><a href="#spring事务传播和事务隔离" class="headerlink" title="spring事务传播和事务隔离"></a>spring事务传播和事务隔离</h1><h2 id="事务传播-propagation"><a href="#事务传播-propagation" class="headerlink" title="事务传播 propagation()"></a>事务传播 propagation()</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163612.png" alt="image-20210220140349214"></p>
<h3 id="1、REQUIRED-默认值"><a href="#1、REQUIRED-默认值" class="headerlink" title="1、REQUIRED 默认值"></a>1、REQUIRED 默认值</h3><p>是最常用的，支持当前事务，若当前没事务，就新建一个事务。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163617.png" alt="image-20210220140637518"></p>
<blockquote>
<p>经测试，左侧的事务注解必须得添加，右侧的可加可不加  这俩insert事务合并成一个事务了</p>
</blockquote>
<h3 id="2、SUPPORTS"><a href="#2、SUPPORTS" class="headerlink" title="2、SUPPORTS"></a>2、SUPPORTS</h3><p>支持当前事务，若当前没事务，就以非事务方式执行。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163619.png" alt="image-20210220140953220"></p>
<blockquote>
<p>上图：A调B，A有事务，B事务用SUPPORTS，AB合并为一个事务了。AB都会回滚 </p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163622.png" alt="image-20210220141149188"></p>
<blockquote>
<p>上图：A调B，A无事务，B事务用SUPPORTS，则AB都没有事务，AB都不回滚</p>
</blockquote>
<h3 id="3、MANDATORY"><a href="#3、MANDATORY" class="headerlink" title="3、MANDATORY"></a>3、MANDATORY</h3><p>支持当前事务，若当前没事务，就抛出异常。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163624.png" alt="image-20210220141904499"></p>
<blockquote>
<p>上图：A调B，A有事务，B事务用MANDATORY，AB合并为一个事务了。AB都会回滚</p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163627.png" alt="image-20210220142034489"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163629.png" alt="image-20210220142254690"></p>
<blockquote>
<p>上图：A调B，A没事务，B事务用MANDATORY，进入B方法就会报错，A不回滚，B不执行</p>
</blockquote>
<h3 id="4、REQUIRES-NEW"><a href="#4、REQUIRES-NEW" class="headerlink" title="4、REQUIRES_NEW"></a>4、REQUIRES_NEW</h3><p>新建事务，若当前有事务，就把当前事务挂起。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163632.png" alt="image-20210220142350709"></p>
<blockquote>
<p>上图：A调B，A有事务，B事务用REQUIRES_NEW，A事务挂起，B会新建一个事务。AB都会回滚</p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163634.png" alt="image-20210220142417933"></p>
<blockquote>
<p>上图：A调B，A没事务，B事务用REQUIRES_NEW，B新建一个事务了。A不回滚，B会回滚</p>
</blockquote>
<h3 id="5、NOT-SUPPORTED"><a href="#5、NOT-SUPPORTED" class="headerlink" title="5、NOT_SUPPORTED"></a>5、NOT_SUPPORTED</h3><p>以非事务方式执行，若当前有事务，就把当前事务挂起。</p>
<ul>
<li><p>A调B，A有事务，B事务用NOT_SUPPORTED，A事务被挂起，B以非事务运行，若B出错，A会回滚，B不会回滚</p>
</li>
<li><p>A调B，A没事务，B事务用NOT_SUPPORTED，AB都不回滚</p>
</li>
</ul>
<h3 id="6、NEVER"><a href="#6、NEVER" class="headerlink" title="6、NEVER"></a>6、NEVER</h3><p>以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163637.png" alt="image-20210220142628062"></p>
<blockquote>
<p>上图：A调B，A有事务，B事务用NEVER，B走不到方法里，进入B方法就会报错，A回滚，B不执行</p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163639.png" alt="image-20210220151129313"></p>
<blockquote>
<p>上图：A调B，A没事务，B事务用NEVER，AB都不回滚</p>
</blockquote>
<h3 id="7、NESTED"><a href="#7、NESTED" class="headerlink" title="7、NESTED"></a>7、NESTED</h3><p>若当前有事务，则在嵌套事务中执行，如果当前没有事务，则按REQUIRED属性执行</p>
<ul>
<li><p>A调B，A有事务，B事务用NESTED，AB都回滚</p>
</li>
<li><p>A调B，A没事务，B事务用NESTED，A不回滚，B回滚</p>
</li>
</ul>
<h2 id="事务隔离-isolation"><a href="#事务隔离-isolation" class="headerlink" title="事务隔离 isolation()"></a>事务隔离 isolation()</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163649.png" alt="image-20210220140528968"></p>
<h3 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h3><h3 id="未提交读-READ-UNCOMMITTED"><a href="#未提交读-READ-UNCOMMITTED" class="headerlink" title="未提交读 READ_UNCOMMITTED"></a>未提交读 READ_UNCOMMITTED</h3><ul>
<li>在这种隔离级别下，所有事务能够读取其他事务未提交的数据。</li>
<li>脏读、不可重复读和幻读。</li>
<li>那么怎么解决脏读呢？那就是使用已提交读</li>
</ul>
<h3 id="已提交读-READ-COMMITTED"><a href="#已提交读-READ-COMMITTED" class="headerlink" title="已提交读 READ_COMMITTED"></a>已提交读 READ_COMMITTED</h3><ul>
<li>这是大多数数据库系统默认的隔离级别，例如Oracle和SQL Server</li>
<li>在这种隔离级别下，所有事务只能读取其他事务已经提交的内容。</li>
<li>不可重复读，幻读。</li>
<li>怎么解决不可重复读的现象，我们可以使用可重复读。</li>
</ul>
<h3 id="可重复读-REPEATABLE-READ"><a href="#可重复读-REPEATABLE-READ" class="headerlink" title="可重复读 REPEATABLE_READ"></a>可重复读 REPEATABLE_READ</h3><ul>
<li><p>mysql默认</p>
</li>
<li><p>所有事务前后多次的读取到的数据内容是不变的</p>
</li>
<li><p>产生幻读</p>
<ul>
<li>也就是某个事务在执行的过程中，不允许其他事务进行update操作，但允许其他事务进行add操作，造成某个事务前后多次读取到的数据总量不一致的现象</li>
</ul>
</li>
<li><p>怎么解决幻读的现象，可以使用串行化来解决。</p>
</li>
</ul>
<h3 id="可串行化-SERIALIZABLE"><a href="#可串行化-SERIALIZABLE" class="headerlink" title="可串行化 SERIALIZABLE"></a>可串行化 SERIALIZABLE</h3><ul>
<li>所有的事务顺序执行，不存在冲突，有效地解决脏读、不可重复读和幻读的现象。</li>
<li>但是会导致大量的操作超时和锁竞争，大大降低数据库的性能，一般不使用该隔离级别</li>
</ul>
<h3 id="用一张表格来表示他们能够解决的问题"><a href="#用一张表格来表示他们能够解决的问题" class="headerlink" title="用一张表格来表示他们能够解决的问题"></a>用一张表格来表示他们能够解决的问题</h3><p>可能：√ 不可能： ×</p>
<table>
<thead>
<tr>
<th><strong>隔离级别</strong></th>
<th><strong>脏读</strong></th>
<th><strong>不可重复读</strong></th>
<th><strong>幻读</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>未提交读</strong>（Read uncommitted）</td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
</tr>
<tr>
<td><strong>已提交读</strong>（Read committed）</td>
<td></td>
<td><strong>√</strong></td>
<td><strong>√</strong></td>
</tr>
<tr>
<td><strong>可重复读</strong>（Repeatable read）</td>
<td></td>
<td></td>
<td><strong>√</strong></td>
</tr>
<tr>
<td><strong>可串行化</strong>（Serializable）</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/spring/20220325163654.jpg" alt="img"></p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p><strong>脏读</strong>：<strong>读取未提交数据</strong></p>
<p>  A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。</p>
<table>
<thead>
<tr>
<th>时间顺序</th>
<th>转账事务</th>
<th>取款事务</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>2</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>查询账户余额为2000元</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>取款1000元，余额被更改为1000元</td>
</tr>
<tr>
<td>5</td>
<td>查询账户余额为1000元（产生脏读）</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>取款操作发生未知错误，事务回滚，余额变更为2000元</td>
</tr>
<tr>
<td>7</td>
<td>转入2000元，余额被更改为3000元（脏读的1000+2000）</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>提交事务</td>
<td></td>
</tr>
<tr>
<td>备注</td>
<td>按照正确逻辑，此时账户余额应该为4000元</td>
<td></td>
</tr>
</tbody></table>
<p><strong>不可重复读</strong>：<strong>前后多次读取，数据内容不一致</strong></p>
<p>  事务A在执行读取操作，多次读取同一条数据时结果数据不一样 。</p>
<p>  例如：事务A第一次读取数据，读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，然后事务A再次读取小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了。</p>
<table>
<thead>
<tr>
<th>时间顺序</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>第一次查询，小明的年龄为20岁</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>4</td>
<td>其他操作</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>更改小明的年龄为30岁</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>7</td>
<td>第二次查询，小明的年龄为30岁</td>
<td></td>
</tr>
<tr>
<td>备注</td>
<td>按照正确逻辑，事务A前后两次读取到的数据应该一致</td>
<td></td>
</tr>
</tbody></table>
<p><strong>幻读：前后多次读取，数据总量不一致</strong></p>
<p>​    事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，称为幻读。</p>
<table>
<thead>
<tr>
<th>时间顺序</th>
<th>事务A</th>
<th>事务B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>开始事务</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>第一次查询，数据总量为100条</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>开始事务</td>
</tr>
<tr>
<td>4</td>
<td>其他操作</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>新增100条数据</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>提交事务</td>
</tr>
<tr>
<td>7</td>
<td>第二次查询，数据总量为200条</td>
<td></td>
</tr>
<tr>
<td>备注</td>
<td>按照正确逻辑，事务A前后两次读取到的数据总量应该一致</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/posts/0207dc17c3c9/</url>
    <content><![CDATA[<h1 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h1><p>解决缓存穿透的办法之一，就是<code>布隆过滤器</code></p>
<p><code>缓存穿透</code>：指缓存和数据库中都没有的数据，而用户不断发起请求，如发起id为“-1”的数据或id为其他不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<h1 id="布隆过滤器（Bloom-Filter）"><a href="#布隆过滤器（Bloom-Filter）" class="headerlink" title="布隆过滤器（Bloom Filter）"></a>布隆过滤器（Bloom Filter）</h1><p>布隆过滤器（Bloom Filter）是1970年，由一个叫布隆的小伙子提出的。</p>
<p>它实际上是一个很长的二进制向量和一系列随机映射函数，二进制存储的数据不是0就是1，默认是0。</p>
<p>主要用于判断某个数据是否在一个集合中，0代表<code>不存在</code>，1代表<code>存在</code>。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325215412.png" alt="二进制向量"></p>
<h2 id="布隆过滤器用途"><a href="#布隆过滤器用途" class="headerlink" title="布隆过滤器用途"></a>布隆过滤器用途</h2><ul>
<li><p>解决Redis缓存穿透（此篇重点讲解）</p>
</li>
<li><p>在爬虫时，对爬虫网址进行过滤，已经存在布隆中的网址，不在爬取。</p>
</li>
<li><p>垃圾邮件过滤，对每一个发送邮件的地址进行判断是否在布隆的<code>黑名单</code>中，如果在就判断为垃圾邮件。</p>
</li>
<li><p>……</p>
</li>
</ul>
<h2 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h2><h3 id="存入过程"><a href="#存入过程" class="headerlink" title="存入过程"></a>存入过程</h3><p>当一个数据加入这个集合时，经历如下洗礼（这里有缺点，下面会讲）：</p>
<ul>
<li>通过K个哈希函数计算该数据，返回K个计算出的hash值</li>
<li>这些K个hash值映射到对应的K个二进制的数组下标</li>
<li>将K个下标对应的二进制数据改成1。</li>
</ul>
<p>例如，第一个哈希函数返回x，第二个第三个哈希函数返回y与z，那么：X、Y、Z对应的二进制改成1。<strong>如图所示：</strong></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325215424.png" alt="布隆过滤器存入过程"></p>
<h3 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h3><p>布隆过滤器主要作用就是<code>查询</code>一个数据，在不在这个二进制的集合中，查询过程如下：</p>
<ul>
<li><p>通过K个哈希函数计算该数据，对应计算出的K个hash值</p>
</li>
<li><p>通过hash值找到对应的二进制的数组下标</p>
</li>
<li><p>判断：如果有个下标对应的二进制数据是0，那么该数据不存在。如果都是1，该数据存在集合中。（这里有缺点，下面会讲）</p>
<blockquote>
<p>可以通过乘法判断是否有二进制数据为0的。</p>
</blockquote>
</li>
</ul>
<h3 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h3><p>一般不能删除布隆过滤器里的数据，这是一个缺点之一，我们下面会分析。</p>
<h2 id="布隆过滤器的优缺点"><a href="#布隆过滤器的优缺点" class="headerlink" title="布隆过滤器的优缺点"></a>布隆过滤器的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>由于存储的是二进制数据，所以占用的空间很小</li>
<li>它的插入和查询速度是非常快的，时间复杂度是O（K），可以联想一下HashMap的过程</li>
<li>保密性很好，因为本身不存储任何原始数据，只有二进制数据</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>添加数据是通过计算数据的hash值，那么很有可能存在这种情况：两个不同的数据计算得到相同的hash值。hash冲突。</p>
<p>例如图中的“<code>你好</code>”和“<code>hello</code>”，假如最终算出hash值相同，那么他们会将同一个下标的二进制数据改为1。这个时候，你就不知道下标为2的二进制，到底是代表“<code>你好</code>”还是“<code>hello</code>”。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325215430.png" alt="hash冲突">    </p>
<ul>
<li>存在误判：假如上面的图没有存”<code>hello</code>“，只存了”<code>你好</code>“，那么用”<code>hello</code>“来查询的时候，会判断”<code>hello</code>“存在集合中。因为“<code>你好</code>”和“<code>hello</code>”的hash值是相同的，通过相同的hash值，找到的二进制数据也是一样的，都是1。</li>
<li>删除困难：因为“<code>你好</code>”和“<code>hello</code>”的hash值相同，对应的数组下标也是一样的。这时候如果想去删除“<code>你好</code>”，将下标为2里的二进制数据，由1改成了0。结果我们连“<code>hello</code>”都一起删了呀。（0代表有这个数据，1代表没有这个数据）</li>
</ul>
<h1 id="实现布隆过滤器"><a href="#实现布隆过滤器" class="headerlink" title="实现布隆过滤器"></a>实现布隆过滤器</h1><p>有很多种实现方式，其中一种就是<code>Guava</code>提供的实现方式。</p>
<h2 id="一、引入Guava-pom配置"><a href="#一、引入Guava-pom配置" class="headerlink" title="一、引入Guava pom配置"></a>一、引入Guava pom配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="二、代码实现"><a href="#二、代码实现" class="headerlink" title="二、代码实现"></a>二、代码实现</h2><blockquote>
<p>注意：布隆过滤器存在误判率，可以手动设置，误判率越小，占用内存和hash计算耗时越大</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.www.bloomfilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.BloomFilter;</span><br><span class="line"><span class="keyword">import</span> com.google.common.hash.Funnels;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilterCase</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 预计要存入多少数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 期望的误判率</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">fpp</span> <span class="operator">=</span> <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 布隆过滤器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Integer&gt; bloomFilter = BloomFilter.create(Funnels.integerFunnel(), size, fpp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入100万条样本数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            bloomFilter.put(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用另外10万测试误判率</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> total; i &lt; total+<span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bloomFilter.mightContain(i))&#123;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(i+<span class="string">&quot;误判了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;总误判数:&quot;</span>+count);</span><br><span class="line">        System.out.println(<span class="string">&quot;fpp：&quot;</span> + <span class="number">1.0</span> * count / <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325215456.png" alt="误判"></p>
<p>​    10万数据里有947个误判，约等于我们代码里设置的误判率：fpp = 0.01。</p>
<h2 id="深入分析代码"><a href="#深入分析代码" class="headerlink" title="深入分析代码"></a>深入分析代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; BloomFilter&lt;T&gt; <span class="title function_">create</span><span class="params">(Funnel&lt;? <span class="built_in">super</span> T&gt; funnel, <span class="type">long</span> expectedInsertions, </span></span><br><span class="line"><span class="params">                                 <span class="type">double</span> fpp, BloomFilter.Strategy strategy)</span> &#123;</span><br><span class="line">    Preconditions.checkNotNull(funnel);</span><br><span class="line">    Preconditions.checkArgument(expectedInsertions &gt;= <span class="number">0L</span>, <span class="string">&quot;Expected insertions (%s) must be &gt;= 0&quot;</span>, expectedInsertions);</span><br><span class="line">    Preconditions.checkArgument(fpp &gt; <span class="number">0.0D</span>, <span class="string">&quot;False positive probability (%s) must be &gt; 0.0&quot;</span>, fpp);</span><br><span class="line">    Preconditions.checkArgument(fpp &lt; <span class="number">1.0D</span>, <span class="string">&quot;False positive probability (%s) must be &lt; 1.0&quot;</span>, fpp);</span><br><span class="line">    Preconditions.checkNotNull(strategy);</span><br><span class="line">    <span class="keyword">if</span> (expectedInsertions == <span class="number">0L</span>) &#123;</span><br><span class="line">        expectedInsertions = <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">numBits</span> <span class="operator">=</span> optimalNumOfBits(expectedInsertions, fpp);</span><br><span class="line">    <span class="type">int</span> <span class="variable">numHashFunctions</span> <span class="operator">=</span> optimalNumOfHashFunctions(expectedInsertions, numBits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BloomFilter</span>(<span class="keyword">new</span> <span class="title class_">LockFreeBitArray</span>(numBits), numHashFunctions, funnel, strategy);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Could not create BloomFilter of &quot;</span> + numBits + <span class="string">&quot; bits&quot;</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里有四个参数：</strong></p>
<ul>
<li><code>funnel</code>：数据类型(一般是调用Funnels工具类中的)</li>
<li><code>expectedInsertions</code>：期望插入的值的个数</li>
<li><code>fpp</code>：误判率(默认值为0.03)</li>
<li><code>strategy</code>：哈希算法</li>
</ul>
<p>我们重点讲一下<code>fpp</code>参数</p>
<h3 id="fpp误判率"><a href="#fpp误判率" class="headerlink" title="fpp误判率"></a>fpp误判率</h3><h4 id="情景一：fpp-0-01"><a href="#情景一：fpp-0-01" class="headerlink" title="情景一：fpp = 0.01"></a>情景一：<code>fpp = 0.01</code></h4><ul>
<li><p>误判个数：947</p>
</li>
<li><p>占内存大小：9585058位数</p>
<p>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325215507.png" alt="0.01误判率"></p>
</li>
</ul>
<h4 id="情景二：fpp-0-03（默认参数）"><a href="#情景二：fpp-0-03（默认参数）" class="headerlink" title="情景二：fpp = 0.03（默认参数）"></a>情景二：<code>fpp = 0.03</code>（默认参数）</h4><ul>
<li><p>误判个数：3033</p>
</li>
<li><p>占内存大小：7298440位数</p>
<p>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325215510.png" alt="image-20201018230820646">    </p>
<p>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325215514.png" alt="image-20201018230750013"></p>
</li>
</ul>
<h4 id="情景总结"><a href="#情景总结" class="headerlink" title="情景总结"></a>情景总结</h4><ul>
<li>误判率可以通过<code>fpp</code>参数进行调节</li>
<li>fpp越小，需要的内存空间就越大：0.01需要900多万位数，0.03需要700多万位数。</li>
<li>fpp越小，集合添加数据时，就需要更多的hash函数运算更多的hash值，去存储到对应的数组下标里。（忘了去看上面的布隆过滤存入数据的过程）</li>
</ul>
<p>上面的<code>numBits</code>，表示存一百万个int类型数字，需要的位数为7298440，700多万位。理论上存一百万个数，一个int是4字节32位，需要481000000=3200万位。如果使用HashMap去存，按HashMap50%的存储效率，需要6400万位。可以看出BloomFilter的存储空间很小，只有HashMap的1/10左右</p>
<p>上面的<code>numHashFunctions</code>表示需要几个hash函数运算，去映射不同的下标存这些数字是否存在（0 or 1）。</p>
<h1 id="解决Redis缓存雪崩"><a href="#解决Redis缓存雪崩" class="headerlink" title="解决Redis缓存雪崩"></a>解决Redis缓存雪崩</h1><p>上面使用Guava实现的布隆过滤器是把数据放在了本地内存中。分布式的场景中就不合适了，无法共享内存。</p>
<p>我们还可以用Redis来实现布隆过滤器，这里使用Redis封装好的客户端工具Redisson。</p>
<p>其底层是使用数据结构bitMap，大家就把它理解成上面说的二进制结构。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>pom配置：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>java代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.www.bloomfilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RBloomFilter;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"><span class="keyword">import</span> org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonBloomFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:2020&quot;</span>);</span><br><span class="line">        config.useSingleServer().setPassword(<span class="string">&quot;yiguan789&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造redis</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redissonClient</span> <span class="operator">=</span> Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取布隆过滤器，并给该过滤器起一个名字，叫做 nickNameList</span></span><br><span class="line">        RBloomFilter&lt;Object&gt; bloomFilter = redissonClient.getBloomFilter(<span class="string">&quot;nickNameList&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化该过滤器，预计元素为 100万，误差率为3%  默认是3%</span></span><br><span class="line">        bloomFilter.tryInit(<span class="number">1000000</span>, <span class="number">0.03</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将昵称 &quot;蹬杆老王子&quot; 插入到过滤器中</span></span><br><span class="line">        bloomFilter.add(<span class="string">&quot;蹬杆老王子&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断下面昵称是否在布隆过滤器中</span></span><br><span class="line">        <span class="comment">//输出false</span></span><br><span class="line">        System.out.println(bloomFilter.contains(<span class="string">&quot;卡特机长&quot;</span>));</span><br><span class="line">        <span class="comment">//输出true</span></span><br><span class="line">        System.out.println(bloomFilter.contains(<span class="string">&quot;蹬杆老王子&quot;</span>));</span><br><span class="line"></span><br><span class="line">        redissonClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>布隆过滤器</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>第 11 章 树结构实际应用【2、赫夫曼树】</title>
    <url>/posts/b49eca6a0782/</url>
    <content><![CDATA[<h2 id="2、赫夫曼树"><a href="#2、赫夫曼树" class="headerlink" title="2、赫夫曼树"></a>2、赫夫曼树</h2><h3 id="2-1、赫夫曼树基本介绍"><a href="#2-1、赫夫曼树基本介绍" class="headerlink" title="2.1、赫夫曼树基本介绍"></a>2.1、赫夫曼树基本介绍</h3><ul>
<li>给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)，还有的书翻译为霍夫曼树。</li>
<li>赫夫曼树是<strong>带权路径长度最短的树，权值较大的结点离根较近</strong></li>
</ul>
<h3 id="2-2、赫夫曼树重要概念"><a href="#2-2、赫夫曼树重要概念" class="headerlink" title="2.2、赫夫曼树重要概念"></a>2.2、赫夫曼树重要概念</h3><ul>
<li>路径和路径长度：在一棵树中，<strong>从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径</strong>。通路中分支的数目称为路径长度。若规定根结点的层数为 1 ，则从根结点到第 L 层结点的路径长度为 L-1</li>
<li>结点的权及带权路径长度：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。<strong>结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积</strong></li>
<li>树的带权路径长度：树的带权路径长度规定为<strong>所有叶子结点的带权路径长度之和</strong>，记为WPL(weighted path length) ，<strong>权值越大的结点离根结点越近的二叉树才是最优二叉树。WPL 最小的就是赫夫曼树</strong></li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/34c7eeb9e4337099eab9bf1cdc15dd8c.png" alt="image-20200718173420817"></p>
<h3 id="2-3、赫夫曼树创建思路图解"><a href="#2-3、赫夫曼树创建思路图解" class="headerlink" title="2.3、赫夫曼树创建思路图解"></a>2.3、赫夫曼树创建思路图解</h3><ul>
<li><p>创建赫夫曼树的流程</p>
<ul>
<li>核心思想：<strong>让权值小的节点远离根节点，让权值大的节点靠近根节点</strong></li>
<li>从小到大进行排序，将每一个数据， 每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树（左右节点都为空的二叉树）</li>
<li>取出根节点权值最小的两颗二叉树，组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和</li>
<li>再将这颗新的二叉树， 以根节点的权值大小再次排序， 不断重复以上的步骤， 直到数列中， 所有的数据都被处理， 就得到一颗赫夫曼树</li>
</ul>
</li>
<li><p>以数组 { 13, 7, 8, 3, 29, 6, 1 } 为例，排序后的数组为 { 1, 3, 6, 7, 8, 13, 29 }</p>
<ul>
<li>取出最小的两颗二叉树： 1 和 3 ，组成一棵二叉树，其根节点权值为 1+ 3 = 4 ，将权值为 4 的二叉树放回原数组中，重新进行排序，得到 { 4, 6, 7, 8, 13, 29 }</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2dd8496d68a026fb205ea85bf7d074e7.png" alt="image-20200718192411494"></p>
<ul>
<li>取出最小的两颗二叉树： 4 和 6 ，组成一棵二叉树，其根节点权值为 4+ 6 = 10 ，将权值为 10 的二叉树放回原数组中，重新进行排序，得到 { 7, 8, 10, 13, 29 }</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/20b3d2830dccef426fe9636d27dc53a8.png" alt="image-20200718192538028"></p>
<ul>
<li>继续取出最小的两颗二叉树： 7 和 8，组成一棵二叉树，其根节点权值为 7+ 8= 15，将权值为 15 的二叉树放回原数组中，重新进行排序，得到 { 10, 15, 13, 29 }</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/06b6058496408ff2f7dad9e179d97d03.png" alt="image-20200718193010628"></p>
<ul>
<li>以此类推，直至最后一个根节点，将得到如下结果：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/79b5fcdf2cfec2bbe440230e0000f07d.png" alt="image-20200718193102112"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/14f9346d50223f8748e5f4c4b8f67303.png" alt="image-20200718194347867"></p>
</li>
<li><p>编码思路：</p>
<ul>
<li>将集合中的二叉树排序，从中取两个最权值最低的二叉树组成新的二叉树</li>
<li><strong>将新的二叉树放回集合中，再从中取两个最权值最低的二叉树组成新的二叉树</strong></li>
<li>如此往复 …</li>
<li>何时结束？集合中只剩一个元素时，即为整棵赫夫曼树的根节点</li>
</ul>
</li>
</ul>
<h3 id="2-4、赫夫曼树代码实现"><a href="#2-4、赫夫曼树代码实现" class="headerlink" title="2.4、赫夫曼树代码实现"></a>2.4、赫夫曼树代码实现</h3><ul>
<li>树节点的定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建结点类</span></span><br><span class="line"><span class="comment">// 为了让Node 对象支持排序：Collections集合排序</span></span><br><span class="line"><span class="comment">// 让Node 实现Comparable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 结点权值</span></span><br><span class="line">    Node left; <span class="comment">// 指向左子结点</span></span><br><span class="line">    Node right; <span class="comment">// 指向右子结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node [value=&quot;</span> + value + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="comment">// 表示从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>创建赫夫曼树</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建赫夫曼树的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr 需要创建成哈夫曼树的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 创建好后的赫夫曼树的root结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(<span class="type">int</span>[]arr)</span>&#123;</span><br><span class="line">        <span class="comment">// 第一步为了操作方便</span></span><br><span class="line">        <span class="comment">// 1. 遍历 arr 数组</span></span><br><span class="line">        <span class="comment">// 2. 将arr的每个元素构成成一个Node</span></span><br><span class="line">        <span class="comment">// 3. 将Node 放入到ArrayList中</span></span><br><span class="line">        List&lt;Node&gt; nodes=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> value:arr)&#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们处理的过程是一个循环的过程</span></span><br><span class="line">        <span class="keyword">while</span>(nodes.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 排序 从小到大</span></span><br><span class="line">        Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出根节点权值最小的两颗二叉树</span></span><br><span class="line">        <span class="comment">// (1) 取出权值最小的结点（二叉树）</span></span><br><span class="line">        Node leftNode=nodes.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// (2) 取出权值第二小的结点（二叉树）</span></span><br><span class="line">        Node rightNode=nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (3)构建一颗新的二叉树</span></span><br><span class="line">        Node parent=<span class="keyword">new</span> <span class="title class_">Node</span>(leftNode.value+rightNode.value);</span><br><span class="line">        parent.left=leftNode;</span><br><span class="line">        parent.right=rightNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">        nodes.remove(leftNode);</span><br><span class="line">        nodes.remove(rightNode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (5)将parent加入到nodes</span></span><br><span class="line">        nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回哈夫曼树的root结点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> arr[]=&#123;<span class="number">13</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">29</span>,<span class="number">6</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        Node root=createHuffmanTree(arr);</span><br><span class="line">        preOrder(root);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编写一个前序遍历的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">        root.preOrder();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;是空树，不能遍历~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node[value=<span class="number">67</span>]</span><br><span class="line">        Node[value=<span class="number">29</span>]</span><br><span class="line">        Node[value=<span class="number">38</span>]</span><br><span class="line">        Node[value=<span class="number">15</span>]</span><br><span class="line">        Node[value=<span class="number">7</span>]</span><br><span class="line">        Node[value=<span class="number">8</span>]</span><br><span class="line">        Node[value=<span class="number">23</span>]</span><br><span class="line">        Node[value=<span class="number">10</span>]</span><br><span class="line">        Node[value=<span class="number">4</span>]</span><br><span class="line">        Node[value=<span class="number">1</span>]</span><br><span class="line">        Node[value=<span class="number">3</span>]</span><br><span class="line">        Node[value=<span class="number">6</span>]</span><br><span class="line">        Node[value=<span class="number">13</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-5、赫夫曼树全部代码"><a href="#2-5、赫夫曼树全部代码" class="headerlink" title="2.5、赫夫曼树全部代码"></a>2.5、赫夫曼树全部代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> createHuffmanTree(arr);</span><br><span class="line">        preOrder(root);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写一个前序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;是空树，不能遍历~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建赫夫曼树的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 需要创建成哈夫曼树的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 创建好后的赫夫曼树的root结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 第一步为了操作方便</span></span><br><span class="line">        <span class="comment">// 1. 遍历 arr 数组</span></span><br><span class="line">        <span class="comment">// 2. 将arr的每个元素构成成一个Node</span></span><br><span class="line">        <span class="comment">// 3. 将Node 放入到ArrayList中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Node&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们处理的过程是一个循环的过程</span></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 排序 从小到大</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 取出根节点权值最小的两颗二叉树</span></span><br><span class="line">            <span class="comment">// (1) 取出权值最小的结点（二叉树）</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// (2) 取出权值第二小的结点（二叉树）</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// (3)构建一颗新的二叉树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(leftNode.value + rightNode.value);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// (4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// (5)将parent加入到nodes</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回哈夫曼树的root结点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建结点类</span></span><br><span class="line"><span class="comment">// 为了让Node 对象支持排序：Collections集合排序</span></span><br><span class="line"><span class="comment">// 让Node 实现Comparable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value; <span class="comment">// 结点权值</span></span><br><span class="line">    Node left; <span class="comment">// 指向左子结点</span></span><br><span class="line">    Node right; <span class="comment">// 指向右子结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node [value=&quot;</span> + value + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="comment">// 表示从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>第 11 章 树结构实际应用【5、平衡二叉树】</title>
    <url>/posts/1d78c31b697a/</url>
    <content><![CDATA[<h1 id="第-11-章-树结构实际应用【5、平衡二叉树】"><a href="#第-11-章-树结构实际应用【5、平衡二叉树】" class="headerlink" title="第 11 章 树结构实际应用【5、平衡二叉树】"></a>第 11 章 树结构实际应用【5、平衡二叉树】</h1><h2 id="5、平衡二叉树-AVL-树"><a href="#5、平衡二叉树-AVL-树" class="headerlink" title="5、平衡二叉树(AVL 树)"></a>5、平衡二叉树(AVL 树)</h2><h3 id="5-1、二叉排序树的问题"><a href="#5-1、二叉排序树的问题" class="headerlink" title="5.1、二叉排序树的问题"></a>5.1、二叉排序树的问题</h3><ul>
<li>看一个案例(说明二叉排序树可能的问题)，给你一个数列{ 1,2,3,4,5,6 } ，要求创建一颗二叉排序树(BST)，并分析问题所在<ul>
<li>左子树全部为空，从形式上看，更像一个单链表</li>
<li>插入速度没有影响</li>
<li>查询速度明显降低(因为需要依次比较)，不能发挥BST 的优势，因为每次还需要比较左子，其<strong>查询速度比单链表还慢</strong></li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/61f8f8bb9500cb32ac3ec87f93c7cf16.png" alt="image-20200719231104780"></p>
<ul>
<li>解决方案-平衡二叉树(AVL)</li>
</ul>
<h3 id="5-2、平衡二叉树基本介绍"><a href="#5-2、平衡二叉树基本介绍" class="headerlink" title="5.2、平衡二叉树基本介绍"></a>5.2、平衡二叉树基本介绍</h3><ul>
<li>平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。</li>
<li>平衡二叉树具有以下特点：<strong>它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1</strong>，并且左右两个子树都是一棵平衡二叉树。</li>
<li>平衡二叉树的常用实现方法有<strong>红黑树</strong>、AVL、替罪羊树、Treap、伸展树等。</li>
<li>注意：平衡二叉树一定是二叉排序树！！！</li>
<li>举例说明，看看下面哪些AVL树, 为什么?</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/57940b163466cdf6ef180123543bd3c1.png" alt="image-20200719231213387"></p>
<h3 id="5-3、平衡二叉树思路分析"><a href="#5-3、平衡二叉树思路分析" class="headerlink" title="5.3、平衡二叉树思路分析"></a>5.3、平衡二叉树思路分析</h3><h4 id="5-3-1、计算子树高度"><a href="#5-3-1、计算子树高度" class="headerlink" title="5.3.1、计算子树高度"></a>5.3.1、计算子树高度</h4><ul>
<li>其实计算子树高度这个递归还挺难理解的，我想了想，可以这样来理解：<ul>
<li><code>left == null ? 0 : left.height()</code> 是求左子树的高度</li>
<li><code>right == null ? 0 : right.height()</code>是求右子树的高度</li>
<li>所以如上两个表达式取最大值，即为当前子树的高度</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回 以该结点为根结点的树的高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(left == <span class="literal">null</span> ? <span class="number">0</span> : left.height(), right == <span class="literal">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>画了个图来说明计算子树高度的递归顺序和递归回溯过程</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8ab7f19cd6af876947efd8191d29eb4a.png" alt="image-20200813162755684"></p>
<h4 id="5-3-2、左旋转"><a href="#5-3-2、左旋转" class="headerlink" title="5.3.2、左旋转"></a>5.3.2、左旋转</h4><ul>
<li>问题：当插入8 时，<code>rightHeight() - leftHeight() &gt; 1</code> 成立，此时，不再是一颗 AVL树了</li>
<li>怎么处理–进行左旋转（就是降低右子树的高度）<ul>
<li>创建一个新的节点 newNode (以4这个值创建)，创建一个新的节点，值等于当前根节点的值</li>
<li>把新节点的左子树设置了当前节点的左子树：<code>newNode.left = left</code></li>
<li>把新节点的右子树设置为当前节点的右子树的左子树：<code>newNode.right =right.left;</code></li>
<li>把当前节点的值换为右子节点的值：<code>value=right.value;</code></li>
<li>把当前节点的右子树设置成右子树的右子树：<code>right=right.right;</code></li>
<li>把当前节点的左子树设置为新节点：<code>left=newNode;</code></li>
</ul>
</li>
<li>想想为啥是上面的的步骤？<ul>
<li>插入节点 8 后，整棵树不再是 AVL 树，节点 4 的右子树高度 &gt; 节点 4 的左子树高度，需要进行左旋</li>
<li>问题来了：什么是左旋？怎么进行左旋？还是以下面的图为例：不就是把节点 6 往上提，把根节点 4 往左下沉，然后再把节点 5 挂在节点 4 的右边</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4445b655d8774379aa17b8b227aeb6fc.png" alt="image-20200719232438091"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/216fbeeb614187cd56441701e13c5b91.gif" alt="image-20200719232620534"></p>
<h4 id="5-3-3、右旋转"><a href="#5-3-3、右旋转" class="headerlink" title="5.3.3、右旋转"></a>5.3.3、右旋转</h4><ul>
<li>问题：当插入6 时，<code>leftHeight() - rightHeight() &gt; 1</code> 成立，此时，不再是一颗 AVL树了</li>
<li>怎么处理–进行右旋转（就是降低左子树的高度） 这里是将 9 这个节点，通过右旋转，到右子树<ul>
<li>创建一个新的节点 newNode (以10这个值创建) ，创建一个新的节点，值等于当前根节点的值</li>
<li>把新节点的右子树设置了当前节点的右子树：<code>newNode.right = right;</code></li>
<li>把新节点的左子树设置为当前节点的左子树的右子树：<code>newNode.left =left.right;</code></li>
<li>把当前节点的值换为左子节点的值：<code>value=left.value;</code></li>
<li>把当前节点的左子树设置成左子树的左子树：<code>left=left.left;</code></li>
<li>把当前节点的右子树设置为新节点：<code>right=newNode;</code></li>
</ul>
</li>
</ul>
<p>想想为啥是上面的的步骤？</p>
<ul>
<li>插入节点 6 后，整棵树不再是 AVL 树，节点 10 的左子树高度 &gt; 节点 10 的右子树高度，需要进行右旋</li>
<li>问题来了：什么是右旋？怎么进行右旋？还是以下面的图为例：不就是把节点 8 往上提，把根节点 10 往右下沉，然后把节点 9 挂在节点 10 的左边</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e8ba79b191ebe4a65948781f0c431c9b.png" alt="image-20200719232450426"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6cb5a1626df75cc98a629a54389d04d2.gif" alt="image-20200719232827795"></p>
<h4 id="5-3-4、双旋转"><a href="#5-3-4、双旋转" class="headerlink" title="5.3.4、双旋转"></a>5.3.4、双旋转</h4><ul>
<li><p>问题分析</p>
</li>
<li><p>如下不平衡二叉树满足右旋条件，根节点 10 的左子树高度 &gt; 根节点的右子树高度</p>
<ul>
<li>但不巧的是：根节点 10 的左子树的右子树高度 &gt; 根节点 10 的左子树的左子树高度，那么在进行右旋后，还是棵不平衡二叉树</li>
</ul>
</li>
<li><p>那不就是因为节点 7 的右子树太长了，进行右旋后，挂到右边去会导致整棵树的右子树过高</p>
</li>
<li><p>怎么解决？</p>
<ul>
<li>目标：把节点 7 的右子树的高度降低，即对节点 7 进行左旋</li>
<li>我先把以节点 7 为根节点的树搞成 AVL 树（对节点 7 进行左旋），再对节点 10 进行右旋，就行啦~</li>
<li>即先对当前结点的左节点进行左旋转，再对当前结点进行右旋转的操作即可</li>
</ul>
</li>
<li><p>编码思路：假设当前节点为 curNode</p>
<ul>
<li><p>如果</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curNode.rightHeight() - curNode.leftHeight() &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  ：需进行左旋</p>
<ul>
<li><p>如果</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curNode.left.leftHeight() &gt; curNode.left.rightHeight()</span><br></pre></td></tr></table></figure>

<ul>
<li>先对 <code>curNode.left</code> 进行右旋：<code>curNode.left.rightRotate()</code></li>
<li>再对 <code>curNode</code> 进行左旋：<code>curNode.leftRotate()</code></li>
</ul>
</li>
<li><p>否则直接进行左旋：<code>curNode.leftRotate()</code></p>
</li>
</ul>
</li>
<li><p>如果</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curNode.leftHeight() - curNode.rightHeight() &gt; <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>  ：需进行右旋</p>
<ul>
<li><p>如果</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">curNode.left.rightHeight() &gt; curNode.left.leftHeight()</span><br></pre></td></tr></table></figure>

<ul>
<li>先对 <code>curNode.left</code>进行左旋：<code>curNode.left.leftHeight()</code></li>
<li>再对 curNode 进行右旋：<code>curNode.rightRotate()</code></li>
</ul>
</li>
<li><p>否则直接进行右旋：<code>curNode.rightRotate()</code></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/68324bed4ba99e0bd2af55fdde466ae3.png" alt="image-20200719232918646"></p>
<ul>
<li>图有点难看，有时间再重新画吧。。。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/18b698d945171d3d8ea4bb11512978ab.png" alt="image-20200719233037671"></p>
<h3 id="5-4、平衡二叉树代码"><a href="#5-4、平衡二叉树代码" class="headerlink" title="5.4、平衡二叉树代码"></a>5.4、平衡二叉树代码</h3><h4 id="5-4-1、树节点的定义"><a href="#5-4-1、树节点的定义" class="headerlink" title="5.4.1、树节点的定义"></a>5.4.1、树节点的定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Node结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回左子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leftHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回右子树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rightHeight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 以该结点为根结点的树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">height</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="literal">null</span> ? <span class="number">0</span> : left.height(), right == <span class="literal">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋转方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建新的结点，以当前根结点的值</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        <span class="comment">// 把新的结点的左子树设置成当前结点的左子树</span></span><br><span class="line">        newNode.left = left;</span><br><span class="line">        <span class="comment">// 把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">        newNode.right = right.left;</span><br><span class="line">        <span class="comment">// 把当前结点的值替换成右子结点的值</span></span><br><span class="line">        value = right.value;</span><br><span class="line">        <span class="comment">// 把当前结点的右子树设置成当前结点右子树的右子树</span></span><br><span class="line">        right = right.right;</span><br><span class="line">        <span class="comment">// 把当前结点的左子树(左子结点)设置成新的结点</span></span><br><span class="line">        left = newNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右旋转</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(value);</span><br><span class="line">        newNode.right = right;</span><br><span class="line">        newNode.left = left.right;</span><br><span class="line">        value = left.value;</span><br><span class="line">        left = left.left;</span><br><span class="line">        right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node [value=&quot;</span> + value + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加结点的方法</span></span><br><span class="line">    <span class="comment">// 递归的形式添加结点，注意需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断传入的结点的值，和当前子树的根结点的值关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">// 如果当前结点左子结点为null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 递归的向左子树添加</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 添加的结点的值大于 当前结点的值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 递归的向右子树添加</span></span><br><span class="line">                <span class="built_in">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当添加完一个结点后，如果: (右子树的高度-左子树的高度) &gt; 1 , 左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123;</span><br><span class="line">                <span class="comment">// 先对右子结点进行右旋转</span></span><br><span class="line">                right.rightRotate();</span><br><span class="line">                <span class="comment">// 然后在对当前结点进行左旋转</span></span><br><span class="line">                leftRotate(); <span class="comment">// 左旋转..</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 直接进行左旋转即可</span></span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 必须要!!!</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当添加完一个结点后，如果 (左子树的高度 - 右子树的高度) &gt; 1, 右旋转</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果它的左子树的右子树高度大于它的左子树的高度</span></span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123;</span><br><span class="line">                <span class="comment">// 先对当前结点的左结点(左子树)-&gt;左旋转</span></span><br><span class="line">                left.leftRotate();</span><br><span class="line">                <span class="comment">// 再对当前结点进行右旋转</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 直接进行右旋转即可</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-4-2、平衡二叉树的定义"><a href="#5-4-2、平衡二叉树的定义" class="headerlink" title="5.4.2、平衡二叉树的定义"></a>5.4.2、平衡二叉树的定义</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建AVLTree</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLTree</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> Node <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加结点的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">			root = node;<span class="comment">// 如果root为空则直接让root指向node</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			root.add(node);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 中序遍历</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">			root.infixOrder();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;二叉排序树为空，不能遍历&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-4-3、代码测试"><a href="#5-4-3、代码测试" class="headerlink" title="5.4.3、代码测试"></a>5.4.3、代码测试</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="comment">// 创建一个 AVLTree对象</span></span><br><span class="line">    <span class="type">AVLTree</span> <span class="variable">avlTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AVLTree</span>();</span><br><span class="line">    <span class="comment">// 添加结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        avlTree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">    avlTree.infixOrder();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;平衡处理后~~&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;树的高度=&quot;</span> + avlTree.getRoot().height()); <span class="comment">// 3</span></span><br><span class="line">    System.out.println(<span class="string">&quot;树的左子树高度=&quot;</span> + avlTree.getRoot().leftHeight()); <span class="comment">// 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;树的右子树高度=&quot;</span> + avlTree.getRoot().rightHeight()); <span class="comment">// 2</span></span><br><span class="line">    System.out.println(<span class="string">&quot;当前的根结点=&quot;</span> + avlTree.getRoot());<span class="comment">// 8</span></span><br><span class="line">    System.out.println(<span class="string">&quot;根节点的左结点=&quot;</span> + avlTree.getRoot().left);<span class="comment">// 7</span></span><br><span class="line">    System.out.println(<span class="string">&quot;根节点的右结点=&quot;</span> + avlTree.getRoot().right);<span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">中序遍历</span><br><span class="line">Node [value=<span class="number">6</span>]</span><br><span class="line">Node [value=<span class="number">7</span>]</span><br><span class="line">Node [value=<span class="number">8</span>]</span><br><span class="line">Node [value=<span class="number">9</span>]</span><br><span class="line">Node [value=<span class="number">10</span>]</span><br><span class="line">Node [value=<span class="number">11</span>]</span><br><span class="line">平衡处理后~~</span><br><span class="line">树的高度=<span class="number">3</span></span><br><span class="line">树的左子树高度=<span class="number">2</span></span><br><span class="line">树的右子树高度=<span class="number">2</span></span><br><span class="line">当前的根结点=Node [value=<span class="number">8</span>]</span><br><span class="line">根节点的左结点=Node [value=<span class="number">7</span>]</span><br><span class="line">根节点的右结点=Node [value=<span class="number">10</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>第 12 章 多路查找树</title>
    <url>/posts/e9fffbf006f3/</url>
    <content><![CDATA[<h1 id="第-12-章-多路查找树"><a href="#第-12-章-多路查找树" class="headerlink" title="第 12 章 多路查找树"></a>第 12 章 多路查找树</h1><h2 id="1、二叉树与-B-树"><a href="#1、二叉树与-B-树" class="headerlink" title="1、二叉树与 B 树"></a>1、二叉树与 B 树</h2><h3 id="1-1、二叉树存在的问题"><a href="#1-1、二叉树存在的问题" class="headerlink" title="1.1、二叉树存在的问题"></a>1.1、二叉树存在的问题</h3><ul>
<li>二叉树的操作效率较高，但是也存在问题, 请看下面的二叉树</li>
<li>二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如1亿)， 就存在如下问题:<ul>
<li>问题1：<strong>在构建二叉树时，需要多次进行i/o操作</strong>(海量数据存在数据库或文件中)，节点海量，构建二叉树时，速度有影响</li>
<li>问题2：节点海量，也会造成<strong>二叉树的高度很大，会降低操作速度</strong></li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTI0ODE2MDc3LnBuZw?x-oss-process=image/format,png" alt="image-20200720124816077"></p>
<h3 id="1-2、多叉树的基本介绍"><a href="#1-2、多叉树的基本介绍" class="headerlink" title="1.2、多叉树的基本介绍"></a>1.2、多叉树的基本介绍</h3><ul>
<li>在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）</li>
<li>后面我们讲解的2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，<strong>减少树的高度</strong>，能对二叉树进行优化</li>
<li>举例说明(下面2-3树就是一颗多叉树)</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTI1MDExMzkwLnBuZw?x-oss-process=image/format,png" alt="image-20200720125011390"></p>
<h3 id="1-3、B-树的基本介绍"><a href="#1-3、B-树的基本介绍" class="headerlink" title="1.3、B 树的基本介绍"></a>1.3、B 树的基本介绍</h3><ul>
<li>B树通过重新组织节点，<strong>降低树的高度，并且减少i/o读写次数来提升效率</strong>。</li>
<li>如图B树通过重新组织节点， 降低了树的高度。</li>
<li>文件系统及数据库系统的设计者利用了<strong>磁盘预读原理</strong>，<strong>将一个节点的大小设为等于一个页(页的大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入</strong></li>
<li>将树的度M设置为1024，在600亿个元素中最多只需要4次I/O操作就可以读取到想要的元素，<strong>B树(B+)广泛应用于文件存储系统以及数据库系统中</strong></li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTI1MTU3NjI0LnBuZw?x-oss-process=image/format,png" alt="image-20200720125157624"></p>
<h2 id="2、2-3-树基本介绍"><a href="#2、2-3-树基本介绍" class="headerlink" title="2、2-3 树基本介绍"></a>2、2-3 树基本介绍</h2><h3 id="2-1、2-3-应用案例"><a href="#2-1、2-3-应用案例" class="headerlink" title="2.1、2-3 应用案例"></a>2.1、2-3 应用案例</h3><ul>
<li><p>2-3树是最简单的B树结构，具有如下特点:</p>
<ul>
<li><strong>2-3树的所有叶子节点都在同一层</strong>(只要是B树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，<strong>二节点要么没有子节点，要么有两个子节点</strong></li>
<li>有三个子节点的节点叫三节点，<strong>三节点要么没有子节点，要么有三个子节点</strong></li>
</ul>
</li>
<li><p>2-3树是由二节点和三节点构成的树。</p>
</li>
<li><p>2-3 树插入规则:</p>
<ul>
<li>2-3树的所有叶子节点都在同一层(只要是B树都满足这个条件)</li>
<li>有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点</li>
<li>有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点</li>
<li>当按照规则插入一个数到某个节点时，<strong>不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件</strong>。</li>
<li>对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则</li>
</ul>
</li>
<li><p>将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成2-3树，并保证数据插入的大小顺序，演示一下构建2-3树的过程</p>
<ul>
<li><p>插入 24 时，构成二节点</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTI1NDU3NTY0LnBuZw?x-oss-process=image/format,png" alt="image-20200720125457564"></p>
</li>
<li><p>插入 12 时</p>
<ul>
<li>不能将其放在 16 的左边，这样就是四节点了。。。</li>
<li>不能直接挂在 16 的左下位置，这样就不满足【2-3树的所有叶子节点都在同一层】这个条件</li>
<li>所以需要拆掉上一层的节点，将其重新组合成 2-3 树</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTI1NTQwMzgyLnBuZw?x-oss-process=image/format,png" alt="image-20200720125540382"></p>
<ul>
<li>插入 32 时，可直接放在 24 的右边，构成一个三节点</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTI1NzM5MzQxLnBuZw?x-oss-process=image/format,png" alt="image-20200720125739341"></p>
<ul>
<li>插入 26 时<ul>
<li>不能将其放在 24 的右边，这样就是四节点了。。。</li>
<li>不能直接挂在 24 的右下位置，这样就不满足 B 树的条件</li>
<li>所以需要拆掉上一层的节点，将其重新组合成 2-3 树</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTI1OTE3NDcxLnBuZw?x-oss-process=image/format,png" alt="image-20200720125917471"></p>
<ul>
<li>插入 34 时</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTMwNDA5NTE0LnBuZw?x-oss-process=image/format,png" alt="image-20200720130409514"></p>
<ul>
<li>插入 10 时<ul>
<li>当插入10时，应当在 10 - 12 -14 这个位置，但是这时满了，因此向上层看， 16-26 也满了</li>
<li>因此将 10-12-14 拆 成 10 &lt;-12-&gt;14 ，因为其它拆法，并不能满足 二节点或三节点的要求</li>
<li>但是这时，叶子节点没有全部在同一层，需要调整 26 这个值到下面(如图)</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTMwOTEyMTU0LnBuZw?x-oss-process=image/format,png" alt="image-20200720130912154"></p>
<ul>
<li>插入 8 时</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTMwOTU1NDg5LnBuZw?x-oss-process=image/format,png" alt="image-20200720130955489"></p>
<ul>
<li>插入 28 时</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTMxMDM2MjAwLnBuZw?x-oss-process=image/format,png" alt="image-20200720131036200"></p>
<ul>
<li>插入 38 时</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTMxMTQzMTY4LnBuZw?x-oss-process=image/format,png" alt="image-20200720131143168"></p>
<ul>
<li>插入 20 时</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTMxMTU1NTA1LnBuZw?x-oss-process=image/format,png" alt="image-20200720131155505"></p>
</li>
</ul>
<h3 id="2-2、其他说明"><a href="#2-2、其他说明" class="headerlink" title="2.2、其他说明"></a>2.2、其他说明</h3><ul>
<li>除了2-3 树，还有 2-3-4 树等，概念和 2-3 树类似，也是一种B树。 如图:</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTMxMzE0ODU4LnBuZw?x-oss-process=image/format,png" alt="image-20200720131314858"></p>
<h2 id="3、B-树、B-树和B-树"><a href="#3、B-树、B-树和B-树" class="headerlink" title="3、B 树、B+树和B*树"></a>3、B 树、B+树和B*树</h2><h3 id="3-1、B树的介绍"><a href="#3-1、B树的介绍" class="headerlink" title="3.1、B树的介绍"></a>3.1、B树的介绍</h3><ul>
<li>B-tree 树即 B 树，B 即 Balanced ，平衡的意思。有人把B-tree 翻译成 B- 树，容易让人 产生误解。会以为 B- 树是一种树，而 B 树又是另一种树。实际上，B-tree 就是指的 B 树。</li>
<li>前面已经介绍了2-3树和2-3-4树，他们就是B树(英语：B-tree 也写成B-树)，这里我们再做一个说明，我们在学习Mysql时，经常听到说某种类型的索引是基于B树或者B+树的，如图</li>
<li>B树的说明：<ul>
<li><strong>B树的阶</strong>（度）：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4</li>
<li>B树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点</li>
<li><strong>关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据</strong></li>
<li>搜索有可能在非叶子结点结束</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTMxNDI4NzM0LnBuZw?x-oss-process=image/format,png" alt="image-20200720131428734"></p>
<h3 id="3-2、B-树的介绍"><a href="#3-2、B-树的介绍" class="headerlink" title="3.2、B+ 树的介绍"></a>3.2、B+ 树的介绍</h3><ul>
<li>B+树是B树的变体，也是一种多路搜索树。</li>
<li>B+树的说明：<ul>
<li>B+树的搜索与B树也基本相同，区别是<strong>B+树只有达到叶子结点才命中</strong>（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找</li>
<li><strong>所有关键字都出现在叶子结点的链表中</strong>（即数据只能在叶子节点【也叫<strong>稠密索引</strong>】），且链表中的关键字(数据)恰好是有序的。</li>
<li>不可能在非叶子结点命中</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层</li>
<li>B+树的<strong>所有叶结点构成一个有序链表</strong>，可以按照关键码排序的次序遍历全部记录</li>
<li>B+树更适合<strong>文件索引系统</strong>，B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTMxNjMzOTAwLnBuZw?x-oss-process=image/format,png" alt="image-20200720131633900"></p>
<ul>
<li>自己对 B+ 树的理解：<ul>
<li>就拿有序数列 { 8, 10, 12, 14, 16, 20, 24, 26, 28, 32, 34, 38 } 来说，如果链表形式存储，搜索效率肯定低得一匹</li>
<li>但是有没有什么方法可以改进呢？一种就是前面所说的二叉树，还有一种就是现在说的 B+ 树</li>
<li>B+ 树到底是什么个意思？比如说我们想要查找 28 这个数，从前面挨个往后查找肯定是不行滴，但是我们知道 28 肯定是在 26 和 38 之间，有这个思路就可以了</li>
<li>我们手动将 { 8, 10, 12, 14, 16, 20, 24, 26, 28, 32, 34, 38 } 分成几个区间，查找 28 时，直接去他所在区间查不就快得多了吗？这个所谓的区间，也就是我们常说的索引</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTMzMDIwMzYwLnBuZw?x-oss-process=image/format,png" alt="image-20200720133020360"></p>
<h3 id="3-3、B-树的介绍"><a href="#3-3、B-树的介绍" class="headerlink" title="3.3、B* 树的介绍"></a>3.3、B* 树的介绍</h3><ul>
<li>B* 树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针。</li>
<li>B* 树的说明：<ul>
<li>B* 树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。</li>
<li>从第1个特点我们可以看出，B* 树分配新结点的概率比B+树要低，空间使用率更高</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzIwMTMxODUyODUyLnBuZw?x-oss-process=image/format,png" alt="image-20200720131852852"></p>
]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的13个原子操作类</title>
    <url>/posts/a89a1d05d043/</url>
    <content><![CDATA[<h1 id="Java中的13个原子操作类"><a href="#Java中的13个原子操作类" class="headerlink" title="Java中的13个原子操作类"></a>Java中的13个原子操作类</h1><p>为保证多线程不会同时更新变量，Java从JDK 1.5开始提供了java.util.concurrent.atomic包（以下简称Atomic包），这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。</p>
<p>因为变量的类型有很多种，所以在Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。Atomic包里的类基本都是使用Unsafe实现的包装类。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作（atomic operation），是指不可被中断的一个或一系列的操作 。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>处理器使用基于<strong>对缓存加锁或总线加锁</strong>的方式来实现多处理器之间的原子操作。</p>
<p>Java 中可通过锁和自旋 CAS 的方式来实现原子操作。 CAS 操作：Compare And Set，或是 Compare And Swap，如今几乎所有的 CPU 指令都支持 CAS 的原子操作。</p>
<h2 id="特点作用"><a href="#特点作用" class="headerlink" title="特点作用"></a>特点作用</h2><p>原子操作，是一个不受其他操作影响的操作任务单元。</p>
<p>原子操作，是在多线程环境下避免数据不一致必要手段。</p>
<h2 id="java-util-concurrent包"><a href="#java-util-concurrent包" class="headerlink" title="java.util.concurrent包"></a>java.util.concurrent包</h2><p>包里提供一组原子类，多线程环境下，多个线程同时执行类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个线程进入，这只是一种逻辑上的理解。</p>
<h2 id="原子更新基本类型类"><a href="#原子更新基本类型类" class="headerlink" title="原子更新基本类型类"></a>原子更新基本类型类</h2><p>使用原子的方式更新基本类型，Atomic包提供了以下3个类。</p>
<ol>
<li>AtomicBoolean：原子更新布尔类型。</li>
<li>AtomicInteger：原子更新整型。</li>
<li>AtomicLong：原子更新长整型。</li>
</ol>
<p>以上3个类提供的方法几乎一模一样，所以这里仅以AtomicInteger为例进行讲解。</p>
<p>AtomicInteger的常用方法如下。</p>
<ul>
<li>int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</li>
<li>boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</li>
<li>int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。</li>
<li>void lazySet（int newValue）：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</li>
<li>int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。</li>
</ul>
<p>AtomicInteger示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerTest</span> &#123;</span><br><span class="line">		<span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">ai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   			 System.out.println(ai.getAndIncrement()); System.out.println(ai.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<blockquote>
<p>1<br>2</p>
</blockquote>
<p>那么getAndIncrement是如何实现原子操作的呢？让我们一起分析其实现原理，</p>
<p>getAndIncrement的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> get(); <span class="comment">//第一步</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + <span class="number">1</span>;<span class="comment">//第二步</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSet(current, next)) <span class="comment">//第三步</span></span><br><span class="line">          <span class="keyword">return</span> current;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中for循环体内</p>
<ol>
<li>第一步先取得AtomicInteger里存储的数值，</li>
<li>第二步对AtomicInteger的当前数值进行加1操作，</li>
<li>第三步调用compareAndSet方法来进行原子更新操作</li>
</ol>
<p>compareAndSet方法先检查当前数值是否等于current，</p>
<p>等于意味着AtomicInteger的值没有被其他线程修改过，则将AtomicInteger的当前数值更新成next的值，</p>
<p>如果不等compareAndSet方法会返回false，程序会进入for循环重新进行compareAndSet操作。</p>
<p>Atomic包提供了3种基本类型的原子更新，但是Java的基本类型里还有char、float和double等。那么问题来了，如何原子的更新其他的基本类型呢？Atomic包里的类基本都是使用Unsafe实现的，让我们一起看一下Unsafe的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 如果当前数值是expected，则原子的将Java变量更新成x </span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 如果更新成功则返回true </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o,  <span class="type">long</span> offset, Object expected, Object x)</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset,  <span class="type">int</span> expected, <span class="type">int</span> x)</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset,  <span class="type">long</span> expected, <span class="type">long</span> x)</span>;  </span><br></pre></td></tr></table></figure>

<p>通过代码，我们发现Unsafe只提供了3种CAS方法：compareAndSwapObject、compare- AndSwapInt和compareAndSwapLong，再看AtomicBoolean源码，发现它是先把Boolean转换成整型，再使用compareAndSwapInt进行CAS，所以原子更新char、float和double变量也可以用类似的思路来实现。</p>
<h2 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h2><p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下3个类。</p>
<ol>
<li>AtomicIntegerArray：原子更新整型数组里的元素。</li>
<li>AtomicLongArray：原子更新长整型数组里的元素。</li>
<li>AtomicReferenceArray：原子更新引用类型数组里的元素。</li>
</ol>
<p>以上几个类提供的方法几乎一样，所以这里仅以AtomicIntegerArray为例进行讲解，</p>
<p>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型，其常用方法如下。</p>
<ul>
<li>int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。</li>
<li>boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</li>
</ul>
<p>AtomicIntegerArray的使用实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerArrayTest</span> &#123;  </span><br><span class="line">		<span class="keyword">static</span> <span class="type">int</span>[] value = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">1</span>， <span class="number">2</span> &#125;;  </span><br><span class="line">		<span class="keyword">static</span> <span class="type">AtomicIntegerArray</span> <span class="variable">ai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(value); </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">      ai.getAndSet(<span class="number">0</span>， <span class="number">3</span>);  </span><br><span class="line">      System.out.println(ai.get(<span class="number">0</span>)); System.out.println(value[<span class="number">0</span>]);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>以下是输出的结果。</p>
<blockquote>
<p>3<br>1</p>
</blockquote>
<p>需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p>
<h2 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h2><p>原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p>
<ol>
<li>AtomicReference：原子更新引用类型。</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型里的字段。</li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，boolean initialMark）。</li>
</ol>
<p>以上几个类提供的方法几乎一样，所以本节仅以AtomicReference为例进行讲解，</p>
<p>AtomicReference的使用示例代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AtomicReference&lt;user&gt; atomicUserRef = <span class="keyword">new</span> AtomicReference&lt;user&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;conan&quot;</span>， <span class="number">15</span>); atomicUserRef.<span class="keyword">set</span>(user);</span><br><span class="line">        User updateUser = <span class="keyword">new</span> User(<span class="string">&quot;Shinichi&quot;</span>， <span class="number">17</span>); atomicUserRef.compareAndSet(user， updateUser);</span><br><span class="line">        System.<span class="keyword">out</span>.println(atomicUserRef.<span class="keyword">get</span>().getName());</span><br><span class="line">        System.<span class="keyword">out</span>.println(atomicUserRef.<span class="keyword">get</span>().getOld());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">User</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> old;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span>(<span class="params">String name， <span class="built_in">int</span> old</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">getOld</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中首先构建一个user对象，然后把user对象设置进AtomicReferenc中，最后调用compareAndSet方法进行原子更新操作，实现原理同AtomicInteger里的compareAndSet方法。代码执行后输出结果如下。</p>
<blockquote>
<p>Shinichi</p>
<p>17</p>
</blockquote>
<h2 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h2><p>如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p>
<ol>
<li><p>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。</p>
</li>
<li><p>AtomicLongFieldUpdater：原子更新长整型字段的更新器。</p>
</li>
<li><p>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于原子的更新数据和数据的版本号，可以解决使用CAS进行原子更新时可能出现的ABA问题。</p>
</li>
</ol>
<p>要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</p>
<p>以上3个类提供的方法几乎一样，所以本节仅以AstomicIntegerFieldUpdater为例进行讲解，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 创建原子更新器，并设置需要更新的对象类和对象的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class， <span class="string">&quot;old&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 设置柯南的年龄是10岁</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">conan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;conan&quot;</span>， <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 柯南长了一岁，但是仍然会输出旧的年龄</span></span><br><span class="line">        System.out.println(a.getAndIncrement(conan));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 输出柯南现在的年龄</span></span><br><span class="line">        System.out.println(a.get(conan));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="type">int</span> old;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name， <span class="type">int</span> old)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.old = old;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOld</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码执行后输出如下。</p>
<blockquote>
<p>10</p>
<p>11</p>
</blockquote>
]]></content>
      <categories>
        <category>并发多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发容器和框架</title>
    <url>/posts/cf4ad7ff29a0/</url>
    <content><![CDATA[<h1 id="Java并发容器和框架"><a href="#Java并发容器和框架" class="headerlink" title="Java并发容器和框架"></a>Java并发容器和框架</h1><h2 id="java1-7-ConcurrentHashMap的实现原理与使用"><a href="#java1-7-ConcurrentHashMap的实现原理与使用" class="headerlink" title="java1.7 ConcurrentHashMap的实现原理与使用"></a>java1.7 ConcurrentHashMap的实现原理与使用</h2><p>ConcurrentHashMap是线程安全且高效的HashMap</p>
<p>多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。resize()方法</p>
<p>线程安全的HashTable效率非常低（synchroniezd标记方法如put）</p>
<h3 id="锁分段技术"><a href="#锁分段技术" class="headerlink" title="锁分段技术"></a>锁分段技术</h3><p>ConcurrentHashMap的锁分段技术可有效提升并发访问率</p>
<p>首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<h3 id="ConcurrentHashMap的结构"><a href="#ConcurrentHashMap的结构" class="headerlink" title="ConcurrentHashMap的结构"></a>ConcurrentHashMap的结构</h3><p>ConcurrentHashMap是由<code>Segment数组</code>结构和<code>HashEntry数组</code>结构构成。</p>
<ul>
<li>Segment是一种可重入锁。Segment的结构和HashMap类似，是一种数组和链表结构</li>
<li>HashEntry是用于存储键值对数据。</li>
</ul>
<p>一个ConcurrentHashMap有一个Segment数组，每个Segment数组中又有一个HashEntry数组，每个HashEntry是一个链表。 </p>
<p>每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212712.png" alt="image-20210926184512223"></p>
<h3 id="ConcurrentHashMap的操作"><a href="#ConcurrentHashMap的操作" class="headerlink" title="ConcurrentHashMap的操作"></a>ConcurrentHashMap的操作</h3><p><strong>get()</strong></p>
<p>先进行一次再散列，然后使用这个散列值通过散列运算定位到Segment。get操作不需要加锁，所以高效，这需要将get里面使用的共享变量都定义为volatile类型。对volatile字段的写操作先于读操作。</p>
<p>定位Segment是hashcode再散列之后值的高位，而定位HashEntry是直接使用再散列之后的值。</p>
<p>(hash&gt;&gt;&gt; sgementShift ) &amp; segmentMask<br>hash &amp; (tab.length - 1)</p>
<p><strong>put()</strong></p>
<p>定位Segment之后</p>
<ul>
<li>判断是否需要对HashEntry数组扩容</li>
</ul>
<p>Segment是在插入元素之前判断，HashMap是在插入之后判断。创建一个两倍的数组，在散列插入新数组，只对某个segment扩容</p>
<ul>
<li>定位添加元素的位置，放进去</li>
</ul>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a><strong>ConcurrentLinkedQueue</strong></h2><p>先进先出</p>
<p>实现线程安全队列的两种方式，阻塞方式（用锁），非阻塞方式(CAS)</p>
<p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列。</p>
<h3 id="ConcurrentLinkedQueue的结构"><a href="#ConcurrentLinkedQueue的结构" class="headerlink" title="ConcurrentLinkedQueue的结构"></a>ConcurrentLinkedQueue的结构</h3><p>ConcurrentLinkedQueue由head节点和tail节点组成，head和tail都是Node类型的，每个Node类型又是由节点元素（item）和指向下一个节点的引用（next）组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。</p>
<p>默认情况下head节点存储的元素为空，tail节点等于head节点。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212722.png" alt="image-20210926190436312"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212727.png" alt="image-20210926190414757"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212734.png" alt="image-20210926190617688"></p>
<p>默认情况下head节点存储的元素为空，tail节点等于head节点。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212739.png" alt="image-20210927111226046"></p>
<h3 id="入队列"><a href="#入队列" class="headerlink" title="入队列"></a>入队列</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212747.png" alt="image-20210927111325013"></p>
<p>上图所示的元素添加过程如下：</p>
<ul>
<li>添加元素1：队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。</li>
<li>添加元素2：队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。</li>
<li>添加元素3：设置tail节点的next节点为元素3节点。</li>
<li>添加元素4：设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。</li>
</ul>
<p>入队节点添加到队列的尾部。</p>
<ul>
<li><strong>第一步将<code>入队节点</code>设置为当前队列尾节点的下一个节点。</strong></li>
<li><strong>第二步更新tail。</strong><ul>
<li><strong>如果tail节点的next为空，则将<code>入队节点</code>设置成tail的next节点，</strong></li>
<li><strong>如果tail节点的next不为空，则将入队节点设置成tail节点，</strong></li>
</ul>
</li>
</ul>
<p><em>所以tail节点不总是尾节点，理解这一点很重要。需要通过tail节点来找到尾节点</em>。 tail和尾节点的长度大于常量HOPS的值（默认等于1）才更新。</p>
<p>这种设计是通过增加对volatile节点的读操作，减少了写操作，写操作开销大，所以入队效率高。CAS</p>
<p>上面的分析让我们从单线程入队的角度来理解入队过程，但是多个线程同时进行入队情况就变得更加复杂，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。</p>
<p>ConcurrentLinkedQueue的add(E e)入队方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果e为null，则直接抛出NullPointerException异常</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 创建入队节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 循环CAS直到入队成功</span></span><br><span class="line">    <span class="comment">// 1、根据tail节点定位出尾节点（last node）；2、将新节点置为尾节点的下一个节点；3、casTail更新尾节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，初始情况下等于tail节点</span></span><br><span class="line">        <span class="comment">// q是p的next节点</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="comment">// 判断p是不是尾节点，tail节点不一定是尾节点，判断是不是尾节点的依据是该节点的next是不是null</span></span><br><span class="line">        <span class="comment">// 如果p是尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="comment">// 设置p节点的下一个节点为新节点，设置成功则casNext返回true；否则返回false，说明有其他线程更新过尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="literal">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become &quot;live&quot;.</span></span><br><span class="line">                <span class="comment">// 如果p != t，则将入队节点设置成tail节点，更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 多线程操作时候，由于poll时候会把旧的head变为自引用，然后将head的next设置为新的head</span></span><br><span class="line">        <span class="comment">// 所以这里需要重新找新的head，因为新的head后面的节点才是激活的节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">            <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">            <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">            <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="comment">// 寻找尾节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcurrentLinkedQueue的入队操作整体逻辑如下图所示：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212814.png" alt="img"></p>
<p>从源代码角度来看整个入队过程主要做两件事情：</p>
<p>第一步定位尾节点。tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点，尾节点可能就是tail节点，也可能是tail节点的next节点。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是<code>p节点等于q节点</code>的情况，出现这种情况的原因我们后续再来介绍。</p>
<p>第二步设置入队节点为尾节点。p.casNext(null, newNode)方法用于将入队节点设置为当前队列尾节点的next节点，q如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</p>
<h3 id="出队列"><a href="#出队列" class="headerlink" title="出队列"></a>出队列</h3><p>出队列的就是从队列头返回一个节点元素，并清空该节点对元素的引用。让我们通过每个节点出队的快照来观察下head节点的变化：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212826.png" alt="img"></p>
<p>从上图可知，并不是每次出队时都更新head节点。</p>
<p><strong>当head节点里有元素时，直接弹出head节点里的元素，不更新head节点。</strong></p>
<p><strong>只有当head节点里没有元素时，出队操作才会更新head节点。</strong></p>
<p>采用这种方式也是为了减少使用CAS更新head节点的消耗，从而提高出队效率。</p>
<p>让我们再通过源码来深入分析下出队过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// p节点表示首节点，即需要出队的节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="type">E</span> <span class="variable">item</span> <span class="operator">=</span> p.item;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 如果p节点的元素不为null，则通过CAS来设置p节点引用的元素为null，如果成功则返回p节点的元素</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="literal">null</span> &amp;&amp; p.casItem(item, <span class="literal">null</span>)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                <span class="comment">// 如果p != h，则更新head</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="literal">null</span>) ? q : p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外一个线程修改了。</span></span><br><span class="line">            <span class="comment">// 那么获取p节点的下一个节点，如果p节点的下一节点为null，则表明队列已经空了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 更新头结点</span></span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p == q，则使用新的head重新开始</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Java中的阻塞队列"><a href="#Java中的阻塞队列" class="headerlink" title="Java中的阻塞队列"></a>Java中的阻塞队列</h2><p>阻塞队列（BlockingQueue）是一个支持两个<code>附加操作</code>的队列。这两个附加的操作支持阻塞的插入和移除方法。</p>
<p>1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</p>
<p>2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</p>
<p>阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。</p>
<p>java里的阻塞队列：</p>
<ul>
<li>ArrayBlockingQueue，一个由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue，一个由链表组成的有界阻塞队列</li>
<li>PriortyBlockingQueue，一个支持优先级排序的无界阻塞队列</li>
<li>DealyQueue，使用优先级队列实现的无界阻塞队列</li>
<li>SynchronousQueue，不存储元素的阻塞队列</li>
<li>LinkedTransferQueue，由链表组成的无界阻塞队列</li>
<li>LinkedBlockingDeque，由链表组成的双向阻塞队列</li>
</ul>
<h2 id="Fork-Join框架"><a href="#Fork-Join框架" class="headerlink" title="Fork/Join框架"></a>Fork/Join框架</h2><p>Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。</p>
<p>比如计算1+2+…+10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。Fork/Join的运行流程如图6-6所示。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212835.png" alt="image-20210927151202031"></p>
<h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212855.png" alt="image-20210927151743375"></p>
<h3 id="Fork-Join框架的设计"><a href="#Fork-Join框架的设计" class="headerlink" title="Fork/Join框架的设计"></a>Fork/Join框架的设计</h3><p>Fork/Join使用两个类来完成任务分割和结果合并。</p>
<p>①ForkJoinTask：通常情况下，我们不需要直接继承ForkJoinTask类，只需要<code>继承它的子类</code>，Fork/Join框架提供了以下两个子类。</p>
<ul>
<li>RecursiveAction：用于没有返回结果的任务。</li>
<li>RecursiveTask：用于有返回结果的任务。</li>
</ul>
<p>②ForkJoinPool：ForkJoinTask需要通过ForkJoinPool来执行。</p>
<p>使用示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Join/Fork计算过程，将1—1001数字相加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestForkJoinPool</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyForkJoinTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">        <span class="comment">// 子任务开始计算的值</span></span><br><span class="line">        <span class="keyword">private</span> Integer startValue;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 子任务结束计算的值</span></span><br><span class="line">        <span class="keyword">private</span> Integer endValue;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyForkJoinTask</span><span class="params">(Integer startValue , Integer endValue)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.startValue = startValue;</span><br><span class="line">            <span class="built_in">this</span>.endValue = endValue;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 如果条件成立，说明这个任务所需要计算的数值分为足够小了</span></span><br><span class="line">            <span class="comment">// 可以正式进行累加计算了</span></span><br><span class="line">            <span class="keyword">if</span>(endValue - startValue &lt; MAX) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始计算的部分：startValue = &quot;</span> + startValue + <span class="string">&quot;;endValue = &quot;</span> + endValue);</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">totalValue</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="built_in">this</span>.startValue ; index &lt;= <span class="built_in">this</span>.endValue  ; index++) &#123;</span><br><span class="line">                    totalValue += index;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> totalValue;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则再进行任务拆分，拆分成两个任务</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">MyForkJoinTask</span> <span class="variable">subTask1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyForkJoinTask</span>(startValue, (startValue + endValue) / <span class="number">2</span>);</span><br><span class="line">                subTask1.fork();</span><br><span class="line">                <span class="type">MyForkJoinTask</span> <span class="variable">subTask2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyForkJoinTask</span>((startValue + endValue) / <span class="number">2</span> + <span class="number">1</span> , endValue);</span><br><span class="line">                subTask2.fork();</span><br><span class="line">                <span class="keyword">return</span> subTask1.join() + subTask2.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 这是Fork/Join框架的线程池</span></span><br><span class="line">        <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; taskFuture =  pool.submit(<span class="keyword">new</span> <span class="title class_">MyForkJoinTask</span>(<span class="number">1</span>,<span class="number">1001</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> taskFuture.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace(System.out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212908.png" alt="这里写图片描述"></p>
<p>图中最顶层的任务使用submit方式被提交到Fork/Join框架中，后者将前者放入到某个线程中运行，工作任务中的compute方法的代码开始对这个任务T1进行分析。如果当前任务需要累加的数字范围过大（代码中设定的是大于200），则将这个计算任务拆分成两个子任务（T1.1和T1.2），每个子任务各自负责计算一半的数据累加，请参见代码中的fork方法。如果当前子任务中需要累加的数字范围足够小（小于等于200），就进行累加然后返回到上层任务中。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213042.jpg" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>并发多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal作用、场景、原理</title>
    <url>/posts/7344f528bbd2/</url>
    <content><![CDATA[<h1 id="ThreadLocal-Random"><a href="#ThreadLocal-Random" class="headerlink" title="ThreadLocal Random"></a>ThreadLocal Random</h1><h2 id="Random-是如何生成随机数的？"><a href="#Random-是如何生成随机数的？" class="headerlink" title="Random 是如何生成随机数的？"></a>Random 是如何生成随机数的？</h2><p>首先需要一个种子，可通过构造函数指定。如果不指定则会在构造函数内部生成一个默认的</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214016.png" alt="image-20210817110154301"></p>
<p>生成新的随机数需要两步</p>
<ul>
<li>首先根据老的种子生成新的种子</li>
<li>根据新的种子来计算新的随机数</li>
</ul>
<p>单线程情况下，每次根据老的种子计算出新的种子，但是在多线程情况下有可能多个线程拿到同一个老的种子。这样步骤四计算出的新种子就是一样的，由于步骤5是固定算法，所以会产生相同的随机数。</p>
<p>如何解决这种问题呢？Random使用的是<code>原子变量</code>和CAS</p>
<p>要保证原子性，也就是说当多个线程根据同一个老种子计算新种子时， 第一个线程的新种子被计算出来后，第二个线程要丢弃自己老的种子，而使用第一个线程的新种子来计算自己的新种子，依此类推，只有保证了这个，才能保证在多线程下产生的随机数是随机的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> bits)</span> &#123;</span><br><span class="line">    <span class="type">long</span> oldseed, nextseed;</span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="built_in">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 6 获取当前原子变量种子的值。</span></span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        <span class="comment">// 7 根据当前种子值计算新的种子。</span></span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">        <span class="comment">// 8 使用CAS 操作，它使用新的种子去更新老的种子</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="comment">// 9 使用固定算法根据新的种子计算随机数</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点来看一下 步骤8，使用CAS 操作，它使用新的种子去更新老的种子，多线程下可能多个线程都同时执行到了代码（ 6 ） ，多个线程可能拿到的当前种子的值是同一个，执行代码（7）得到的新种子也是一样的，但是代码（8） 的CAS操作会保证只有一个线程可以将老的种子更新为新的，失败的线程会通过循环重新获取其他线程更新后的种子作为老的种子去计算新的种子，这就解决了刚刚提到的多线程下得到相同随机数的问题。</p>
<h2 id="Random的缺点"><a href="#Random的缺点" class="headerlink" title="Random的缺点"></a>Random的缺点</h2><p>那么既然Random已经解决了多线程情况下相同随机数的问题，为什么还要讲ThreadLocalRandom呢？</p>
<p>因为多线程情况下多个线程会竞争同一个原子变量的更新操作，由于原子变量的更新是CAS操作，同一时间点只允许一个线程更新成功，就会造成<code>大量线程的自旋重试，降低了并发性能</code>。</p>
<h2 id="ThreadlocalRandom"><a href="#ThreadlocalRandom" class="headerlink" title="ThreadlocalRandom"></a>ThreadlocalRandom</h2><p>在JUC包下。1.7之后增加的，使用如下吗，ThreadLocalRandom不是直接用new实例化，而是第一次使用其静态方法current()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadLocalRandom</span> <span class="variable">random</span> <span class="operator">=</span> ThreadLocalRandom.current();</span><br></pre></td></tr></table></figure>

<p>如何做到的呢，ThreadLocalRandom使用ThreadLocal的原理，让每个线程内持有一个本地的种子变量，该种子变量只有在使用随机数时候才会被初始化，多线程下计算新种子时候是根据自己线程内维护的种子变量进行更新，从而避免了竞争。</p>
<p>特点</p>
<ul>
<li><p>不再有从多个线程访问同一个随机数生成器实例的争夺。</p>
</li>
<li><p>取代以前每个随机变量实例化一个随机数生成器实例，我们可以每个线程实例化一个。</p>
</li>
<li><p>ThreadLocalRandom同样继承了Random类；</p>
</li>
<li><p>ThreadLocalRandom同样重写了setSeed和next(int bits)方法，另外对产生随机数的方法nextInt、nextLong等方法也都进行了重新，因为他们的核心代码由nextSeed方法实现。</p>
</li>
<li><p>增加了8个缓存行填充字段解决“伪共享”的问题，使每个线程的ThreadLocalRandom实例位于不同的缓存行，避免了竞争。</p>
</li>
</ul>
<p>由于具体的种子是存放到Thread类里面的，所以ThreadLocalRandom的实例里面只是与线程无关的通用算法，所以是线程安全的。</p>
<p>ThreadLocalRandom 类就是个工具类，线程调用ThreadLoca!Random 的cu汀ent 方法时，ThreadLocalRandom 负责初始化调用线程的threadLocalRandomSeed变量，也就是初始化种子。</p>
<blockquote>
<p>threadLoca!RandomS eed 变量就是Thread 类里面的一个普通long 变量，它并不是原子性变量.</p>
</blockquote>
<p>部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadLocalRandom</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalRandom</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize Thread fields for the current thread.  Called only</span></span><br><span class="line"><span class="comment">     * when Thread.threadLocalRandomProbe is zero, indicating that a</span></span><br><span class="line"><span class="comment">     * thread local seed value needs to be generated. Note that even</span></span><br><span class="line"><span class="comment">     * though the initialization is purely thread-local, we need to</span></span><br><span class="line"><span class="comment">     * rely on (static) atomic generators to initialize the values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">localInit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">        <span class="type">int</span> <span class="variable">probe</span> <span class="operator">=</span> (p == <span class="number">0</span>) ? <span class="number">1</span> : p; <span class="comment">// skip 0</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">seed</span> <span class="operator">=</span> mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        UNSAFE.putLong(t, SEED, seed);</span><br><span class="line">        UNSAFE.putInt(t, PROBE, probe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the current thread&#x27;s &#123;<span class="doctag">@code</span> ThreadLocalRandom&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current thread&#x27;s &#123;<span class="doctag">@code</span> ThreadLocalRandom&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalRandom <span class="title function_">current</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.getInt(Thread.currentThread(), PROBE) == <span class="number">0</span>)</span><br><span class="line">            localInit();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新 种子数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">nextSeed</span><span class="params">()</span> &#123;</span><br><span class="line">        Thread t; <span class="type">long</span> r; <span class="comment">// read and update per-thread seed</span></span><br><span class="line">        UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">                       r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>并发多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql什么时候建索引、什么时候不适合建索引</title>
    <url>/posts/44a63d0c34b5/</url>
    <content><![CDATA[<h1 id="Mysql什么时候建索引、什么时候不适合建索引"><a href="#Mysql什么时候建索引、什么时候不适合建索引" class="headerlink" title="Mysql什么时候建索引、什么时候不适合建索引"></a>Mysql什么时候建索引、什么时候不适合建索引</h1><h2 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h2><ul>
<li>主键自动建立唯 一 索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中与其它表关联的字段，外键关系建立索引</li>
<li>单键和组和索引的选择问题，who? 在高并发下优先组合索引</li>
<li>查询中排序的字段，排序字段若通过索引访问将大大提高排序速度</li>
<li>查询中统计或者分组字段</li>
</ul>
<h2 id="哪些情况下不要建立索引"><a href="#哪些情况下不要建立索引" class="headerlink" title="哪些情况下不要建立索引"></a>哪些情况下不要建立索引</h2><p><strong>表记录太少</strong></p>
<blockquote>
<p>Why:提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE.</p>
</blockquote>
<p><strong>经常增删改的表</strong></p>
<blockquote>
<p>Why:因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引。</p>
</blockquote>
<p>注意，如果某个数据列包含许多<code>重复</code>的内容，为它建立索弓|就没有太大的实际效果。</p>
<h2 id="哪些形况下索引失效"><a href="#哪些形况下索引失效" class="headerlink" title="哪些形况下索引失效"></a>哪些形况下索引失效</h2><ol>
<li>查询条件使用函数在索引列上，或者对索引列进行运算，运算包括(+，-，*，/，! 等)</li>
<li>对小表查询</li>
<li>隐式转换导致索引失效</li>
<li>字符型字段为数字时在where条件里不添加引号</li>
<li>对索引列进行运算.需要建立函数索引.</li>
<li>not in ,not exist,or</li>
<li>随着表的增长，where条件出来的数据太多，大于15%，使得索引失效（CBO计算走索引花费大于走全表）</li>
<li>如果MySQL估计使用索引比全表扫描更慢，则不使用索引</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
        <category>索引</category>
      </categories>
  </entry>
  <entry>
    <title>回表查询、覆盖索引、索引下推、最左匹配原则</title>
    <url>/posts/358b5e50cc98/</url>
    <content><![CDATA[<h1 id="回表查询、覆盖索引、索引下推、最左匹配原则"><a href="#回表查询、覆盖索引、索引下推、最左匹配原则" class="headerlink" title="回表查询、覆盖索引、索引下推、最左匹配原则"></a>回表查询、覆盖索引、索引下推、最左匹配原则</h1><p>在讲索引覆盖之前，需要先知道什么是聚簇索引和非聚簇索引。</p>
<h2 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h2><p>先通过普通索引的值定位聚簇索引值，再通过聚簇索引的值定位行记录数据，需要扫描两次索引B+树，它的性能较扫一遍索引树更低。这种走两次索引去获取数据的行为就叫做回表查询。</p>
<h2 id="覆盖索引（covering-index）"><a href="#覆盖索引（covering-index）" class="headerlink" title="覆盖索引（covering index）"></a>覆盖索引（covering index）</h2><blockquote>
<p>简单来说就是只走一次索引数就获取到了想要的数据。</p>
</blockquote>
<p>指一个查询语句的执行只需从索引中就能够取得想要的数据，不必从数据表中读取。也可以称之为实现了索引覆盖。</p>
<blockquote>
<p>注意该数据不一定是整行完整数据，可能想要的数据只是某几个字段，而这几个字段刚好可以通过索引获取到。</p>
</blockquote>
<p>结合图片更容易理解：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>张三</td>
<td>30</td>
</tr>
<tr>
<td>2</td>
<td>李四</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>王五</td>
<td>40</td>
</tr>
<tr>
<td>4</td>
<td>刘八</td>
<td>10</td>
</tr>
</tbody></table>
<p>id 是主键，是聚簇索引，</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225231.jpg" alt="img"></p>
<p>age 是普通索引（二级索引）</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225239.jpg" alt="img"></p>
<p>使用该语句就可以实现索引覆盖，因为只走二级索引就获取到了对应的age 和 id。不会再根据id在查找聚簇索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,age <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>



<h3 id="如何实现覆盖索引"><a href="#如何实现覆盖索引" class="headerlink" title="如何实现覆盖索引"></a>如何实现覆盖索引</h3><p>常见的方法是：将被查询的字段，建立到联合索引里去。</p>
<p>1、如实现：select id,age from user where age = 10;</p>
<blockquote>
<p>explain分析：因为age是普通索引，使用到了age索引，通过一次扫描B+树即可查询到相应的结果，这样就实现了覆盖索引。</p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225246.png" alt="img"></p>
<p>2、实现：select id,age,name from user where age = 10;</p>
<blockquote>
<p>explain分析：age是普通索引，但name列不在索引树上，所以通过age索引在查询到id和age的值后，需要进行回表再查询name的值。此时的Extra列的NULL表示进行了回表查询。</p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225254.png" alt="img"></p>
<p>3、为了实现索引覆盖，需要建组合索引idx_age_name(age,name)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index idx_age <span class="keyword">on</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="keyword">create</span> index idx_age_name <span class="keyword">on</span> <span class="keyword">user</span>(`age`,`name`);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>explain分析：此时字段age和name是组合索引idx_age_name，查询的字段id、age、name的值刚刚都在索引树上，只需扫描一次组合索引B+树即可，这就是实现了索引覆盖，此时的Extra字段为Using index表示使用了索引覆盖。</p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225300.png" alt="img"></p>
<h3 id="哪些场景适合使用索引覆盖来优化SQL"><a href="#哪些场景适合使用索引覆盖来优化SQL" class="headerlink" title="哪些场景适合使用索引覆盖来优化SQL"></a>哪些场景适合使用索引覆盖来优化SQL</h3><p><strong>场景1：全表count查询优化</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">     id <span class="type">int</span>(<span class="number">10</span>) auto_increment,</span><br><span class="line">     name <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">     age tinyint(<span class="number">4</span>),</span><br><span class="line">     <span class="keyword">primary</span> key (id),</span><br><span class="line">     )engine<span class="operator">=</span>innodb charset<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>

<p>例如：select count(age) from user;</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225303.png" alt="img"></p>
<p>使用索引覆盖优化：创建age字段索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_age <span class="keyword">on</span> <span class="keyword">user</span>(age);</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225316.png" alt="img"></p>
<p><strong>场景2：列查询回表优化</strong></p>
<p>前文在描述索引覆盖使用的例子就是 select id,age,name from user where age = 10;</p>
<p>使用索引覆盖：建组合索引idx_age_name(age,name)即可</p>
<p><strong>场景3：分页查询</strong></p>
<p>例如：select id,age,name from user order by age limit 100,2;</p>
<p>因为name字段不是索引，所以在分页查询需要进行回表查询，此时Extra为Using filesort文件排序，查询性能低下。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225320.png" alt="img"></p>
<p>使用索引覆盖：建组合索引idx_age_name(age,name)</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225326.png" alt="img"></p>
<h2 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h2><p>谓词下推</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225331.png" alt="image-20220311111632184"></p>
<blockquote>
<p>2速度快，因为先取出sql中用到的4个字段（俩name和俩id），然后在俩id字段关联查询，最后返回俩name字段。</p>
<p>1中取到的关联数据可不止四个字段，而是两个表的所有字段，然后再从所有字段中取出来俩name字段</p>
</blockquote>
<p>索引条件下推(Index Condition Pushdown),简称ICP。MySQL5.6新添加，用于优化数据的查询。</p>
<p>当你不使用ICP,通过使用普通索引进行查询时，存储引擎通过索引检索数据，然后返回给MySQL服务器，服务器再判断是否符合条件。</p>
<blockquote>
<p>中间会有多次回表查询操作。</p>
</blockquote>
<p>使用ICP，当存在索引的列做为判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。</p>
<blockquote>
<p>中间减少了回表查询的次数，因为不符合的索引被剔除了，不会进行回表查询。</p>
</blockquote>
<p>结合图片更容易理解：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysq<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tuser <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;张 %&#x27;</span> <span class="keyword">and</span> age<span class="operator">=</span><span class="number">10</span> <span class="keyword">and</span> ismale<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>根据<code>最左前缀原则</code>，该语句在搜索索引树的时候，只能匹配到名字第一个字是‘张’的记录，接下来是是从ID3开始，逐个回表，到主键索引上找出相应的记录，再比对age和ismale这两个字段的值是否符合。如下图，<strong>这个过程 InnoDB 并不会去看 age 的值</strong>，只是按顺序把“name 第一个字是’张’”的记录一条条取出来回表。因此，需要回表 4 次</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225340.png" alt="image-20220311102350281"></p>
<p>但是！MySQL 5.6引入了索引下推优化，可以在索引遍历过程中，<strong>对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数</strong>。InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据，只需要回表 2 次。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225345.png" alt="image-20220311102523598"></p>
<blockquote>
<p>如果没有索引下推优化（或称ICP优化），当进行索引查询时，<strong>首先根据索引来查找记录，然后再根据where条件来过滤记录</strong>；在支持ICP优化后，MySQL会在取出索引的同时，<strong>进行部分where条件过滤再进行索引查询</strong>，可以减少回表次数，提升整体性能。</p>
</blockquote>
<p><strong>任何需要下推到底层存储层的操作一般都有诸多限制，MySQL ICP 也不例外，ICP 限制如下：</strong></p>
<p>1.ICP 仅用于需要访问基表所有记录时使用，适用的访问方法为：range、ref、eq_ref、ref_or_null。ICP 尤其是对联合索引的部分列模糊查找非常有效。</p>
<p>2.ICP 同样适用于分区表。</p>
<p>3.ICP 的目标是减少全行记录读取，从而减少 I/O 操作，仅用于二级索引。主键索引本身即是表数据，不存在下推操作。</p>
<p>4.ICP 不支持基于虚拟列上建立的索引，比如函数索引。</p>
<p>5.ICP 不支持引用子查询的条件。</p>
<h2 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h2><h3 id="最左匹配原则的概念"><a href="#最左匹配原则的概念" class="headerlink" title="最左匹配原则的概念"></a>最左匹配原则的概念</h3><p><strong>1、mysql会一直向右匹配直到遇到范围查询</strong></p>
<p>（&gt;、&lt;、between、like）就停止匹配</p>
<p>建立联合索引（a,b,c,d），如果查询a=3 and b=4 and c&gt;5 and d=6，d是用不到做索引的</p>
<p>但是如果建立（a,b,d,c），则都可以用到，abd的顺序可以任意调整</p>
<p><strong>2、= 和 in 可以乱序</strong></p>
<p>比如a = 1 and b = 2 and c=3 建立（a,b,c）索引，索引中abc可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>
<p>mysql 建立联合索引有最左前缀的原则，即最左优先，如：</p>
<p>如果有一个 2 列的索引 (col1, col2)，则相当于已经对 (col1)、(col1, col2) 上建立了索引；</p>
<p>如果有一个 3 列索引 (col1, col2, col3)，则相当于已经对 (col1)、(col1, col2)、(col1, col3)、(col1, col2, col3) 上建立了索引；</p>
<p>只要有最左侧那个字段存在，即使跳过了中间的索引，也是可以使用到索引去查询。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>b+ 树的数据项是复合的数据结构，比如 (name,age,sex) 的时候，b+ 树是按照从左到右的顺序来建立搜索树的，比如当 (张三,20,F) 这样的数据来检索的时候，b+ 树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据；但当 (20,F) 这样的没有 name 的数据来的时候，b+ 树就不知道第一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。</li>
<li>比如当 (张三, F) 这样的数据来检索时，b+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了， 这个是非常重要的性质，即索引的最左匹配特性。（这种情况无法用到联合索引）</li>
</ul>
<h3 id="mysql-查询优化器"><a href="#mysql-查询优化器" class="headerlink" title="mysql 查询优化器"></a>mysql 查询优化器</h3><p>如果建的索引是 (name, cid)。而查询的语句是 cid=1 AND name=’小红’。为什么还能利用到索引？</p>
<p>当按照索引中所有列进行精确匹配（“=” 或 “IN”）时，索引可以被用到，并且 type 为 const。理论上索引对顺序是敏感的，但是由于 MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引，所以 MySQL 不存在 where 子句的顺序问题而造成索引失效</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol>
<li>范围查询<br>  mysql 会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配。<strong>范围列可以用到索引，但是范围列后面的列无法用到索引</strong>。</li>
<li>like 语句的索引问题<br>  如果通配符 % 不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀<br>  在 like “value%” 可以使用索引，但是 like “%value%” 不会使用索引，走的是全表扫描</li>
<li>不要在列上进行运算<br>  如果查询条件中含有函数或表达式，将导致索引失效而进行全表扫描<br>  例如 select * from user where YEAR(birthday) &lt; 1990<br>  可以改造成 select * from users where birthday &lt;’1990-01-01′</li>
<li>索引不会包含有 NULL 值的列<br>  只要列中包含有 NULL 值都将不会被包含在索引中，复合索引中只要有一列含有 NULL 值，那么这一列对于此复合索引就是无效的。所以在数据库设计时不要让字段的默认值为 NULL</li>
<li>尽量选择区分度高的列作为索引，区分度的公式是 count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是 1，而一些状态、性别字段可能在大数据面前区分度就是 0。一般需要 join 的字段都要求区分度 0.1 以上，即平均 1 条扫描 10 条记录</li>
<li>有时候会出现某个查询不符合最左匹配原则不会触发组合索引，但是却符合索引覆盖，会出现type：index。如果是触发了组合索引的话会出现type：ref</li>
</ol>
<h2 id="总结图"><a href="#总结图" class="headerlink" title="总结图"></a>总结图</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225352.png" alt="image-20220311111445962"></p>
]]></content>
      <categories>
        <category>mysql</category>
        <category>索引</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 10- I. 斐波那契数列</title>
    <url>/posts/e0fc265ccf17/</url>
    <content><![CDATA[<h1 id="10-I-斐波那契数列"><a href="#10-I-斐波那契数列" class="headerlink" title="10- I. 斐波那契数列"></a><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">10- I. 斐波那契数列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个函数，输入 <code>n</code> ，求斐波那契（Fibonacci）数列的第 <code>n</code> 项（即 <code>F(N)</code>）。斐波那契数列的定义如下：</p>

<pre>
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.</pre>

<p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>

<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>

<p> </p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 2
<strong>输出：</strong>1
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 5
<strong>输出：</strong>5
</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 <= n <= 100</code></li>
</ul>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>动态规划。</p>
<!-- tabs:start -->

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><p>方法1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2，单独处理 0和1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 单独处理 0 1</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">fn</span> <span class="operator">=</span> (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = fn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>动态规划（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 42. 连续子数组的最大和</title>
    <url>/posts/a2481acbdf0a/</url>
    <content><![CDATA[<h1 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">42. 连续子数组的最大和</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>

<p>要求时间复杂度为O(n)。</p>

<p>&nbsp;</p>

<p><strong>示例1:</strong></p>

<pre><strong>输入:</strong> nums = [-2,1,-3,4,-1,2,1,-5,4]
<strong>输出:</strong> 6
<strong>解释:</strong>&nbsp;连续子数组&nbsp;[4,-1,2,1] 的和最大，为&nbsp;6。</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;=&nbsp;arr.length &lt;= 10^5</code></li>
    <li><code>-100 &lt;= arr[i] &lt;= 100</code></li>
</ul>

<p>注意：本题与主站 53 题相同：<a href="https://leetcode.cn/problems/maximum-subarray/">https://leetcode.cn/problems/maximum-subarray/</a></p>

<p>&nbsp;</p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>设 dp[i] 表示 <code>[0..i]</code> 中，以 <code>nums[i]</code> 结尾的最大子数组和，状态转移方程 <code>dp[i] = nums[i] + max(dp[i - 1], 0)</code>。</p>
<p>由于 <code>dp[i]</code> 只与子问题 <code>dp[i-1]</code> 有关，故可以用一个变量 f 来表示。</p>
<!-- tabs:start -->

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = f = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            f = nums[i] + <span class="built_in">max</span>(f, <span class="number">0</span>)</span><br><span class="line">            res = <span class="built_in">max</span>(res, f)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>], f = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, n = nums.length; i &lt; n; ++i) &#123;</span><br><span class="line">            f = nums[i] + Math.max(f, <span class="number">0</span>);</span><br><span class="line">            res = Math.max(res, f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法改变了原数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] += Math.max(nums[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">            res = Math.max(res, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>动态规划（中等）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>聚簇索引与非聚簇索引</title>
    <url>/posts/932905d88fff/</url>
    <content><![CDATA[<h1 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h1><h2 id="聚簇索引-聚集索引"><a href="#聚簇索引-聚集索引" class="headerlink" title="聚簇索引(聚集索引)"></a>聚簇索引(聚集索引)</h2><p>聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是行记录数据，也将聚集索引的叶子节点称为数据页。<br>innodb存储引擎在进行数据插入的时候，数据值必须要跟某一个索引字段绑定在一起，如果表有主键，那么使用主键，如果没有主键，那么选择唯一键，没有唯一键，系统会自动生成一个6字节的rowid来供数据使用。</p>
<blockquote>
<p>主键通常建议使用自增id</p>
</blockquote>
<h2 id="非聚簇索引（辅助索引）"><a href="#非聚簇索引（辅助索引）" class="headerlink" title="非聚簇索引（辅助索引）"></a>非聚簇索引（辅助索引）</h2><p>Innodb引擎下咱们自己添加的索引都是辅助索引，也就是非聚簇索引。</p>
<p>在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。<br>通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。</p>
<p>Innodb辅助索引的叶子节点并不包含行记录的全部数据，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。<br>辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在innodb中有时也称辅助索引为二级索引。</p>
<p><strong>结合图更容易理解：</strong></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225428.png" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225433.png" alt="image-20220310171755109"></p>
<ul>
<li>若使用”where id = 14”进行条件搜索，则只查询主键索引即可查找到对应的叶节点，之后获得行数据。只有绿色线。</li>
<li>若使用”where Name = ‘Ellison’”进行条件搜索，则需要两个步骤：第一步在辅助索引中检索Name = ‘Ellison’，找到叶子节点对应的主键。第二步使用主键在主索引中再执行一次检索操作，最终到达叶子节点获取到整行数据。</li>
</ul>
<p>MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325225437.png" alt="image-20220310175829339"></p>
<h2 id="聚簇索引的优缺点"><a href="#聚簇索引的优缺点" class="headerlink" title="聚簇索引的优缺点"></a>聚簇索引的优缺点</h2><p>优点：</p>
<p>​    1.数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</p>
<p>​    2.聚簇索引对于主键的排序查找和范围查找速度非常快<br>　　缺点：</p>
<p>​    1.插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong></p>
<p>​    2.<strong>更新主键的代价很高</strong>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。<br>　　    3.二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
<h2 id="聚簇索引和非聚簇索引的区别"><a href="#聚簇索引和非聚簇索引的区别" class="headerlink" title="聚簇索引和非聚簇索引的区别"></a>聚簇索引和非聚簇索引的区别</h2><p>聚簇索引的叶子节点存放的是主键值和数据行，支持<strong>覆盖索引</strong>；二级索引的叶子节点存放的是主键值或指向数据行的指针。</p>
<p>由于节子节点(数据页)只能按照一颗B+树排序，故<strong>一张表只能有一个聚簇索引</strong>。辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引</p>
<blockquote>
<p>覆盖索引（covering index）指一个查询语句的执行只需从索引中就能够取得想要的数据，注意该数据不一定是整行数据，不必从数据表中读取。</p>
</blockquote>
]]></content>
      <categories>
        <category>mysql</category>
        <category>索引</category>
      </categories>
  </entry>
  <entry>
    <title>剑指 Offer 10- II. 青蛙跳台阶问题</title>
    <url>/posts/5400ea250071/</url>
    <content><![CDATA[<h1 id="10-II-青蛙跳台阶问题"><a href="#10-II-青蛙跳台阶问题" class="headerlink" title="10- II. 青蛙跳台阶问题"></a><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">10- II. 青蛙跳台阶问题</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 <code>n</code>&nbsp;级的台阶总共有多少种跳法。</p>

<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>n = 2
<strong>输出：</strong>2
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>n = 7
<strong>输出：</strong>21
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>n = 0
<strong>输出：</strong>1</pre>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 &lt;= n &lt;= 100</code></li>
</ul>

<p>注意：本题与主站 70 题相同：<a href="https://leetcode.cn/problems/climbing-stairs/">https://leetcode.cn/problems/climbing-stairs/</a></p>

<p>&nbsp;</p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>青蛙想上第 <code>n</code> 级台阶，可从第 <code>n-1</code> 级台阶跳一级上去，也可从第 <code>n-2</code> 级台阶跳两级上去，即：<code>f(n) = f(n-1) + f(n-2)</code>。递推求解即可。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><blockquote>
<p>此类求 多少种可能性 的题目一般都有 递推性质 ，即 f(n) 和 f(n−1)…f(1) 之间是有联系的。</p>
</blockquote>
<ul>
<li><p>设跳上 <em>n</em> 级台阶有 <em>f</em>(<em>n</em>) 种跳法。在所有跳法中，青蛙的最后一步只有两种情况： <strong>跳上 1 级或 2 级台阶</strong>。</p>
<ul>
<li><strong>当为 1 级台阶：</strong> 剩 <em>n</em>−1 个台阶，此情况共有 <em>f</em>(<em>n</em>−1) 种跳法；</li>
<li><strong>当为 2 级台阶：</strong> 剩 <em>n</em>−2 个台阶，此情况共有 <em>f</em>(<em>n</em>−2) 种跳法。</li>
</ul>
</li>
<li><p>*f(n)*为以上两种情况之和，即 <em>f(n)=f(n-1)+f(n-2)</em> ，以上递推性质为斐波那契数列。本题可转化为 <strong>求斐波那契数列第 n 项的值</strong> ，与 面试题10- I. 斐波那契数列 等价，唯一的不同在于起始数字不同。</p>
<ul>
<li>青蛙跳台阶问题： <em>f(0)=1 , f(1)=1 , f(2)=2</em> ；</li>
<li>斐波那契数列问题： <em>f(0)=0 , f(1)=1 , f(2)=1</em> 。</li>
</ul>
</li>
</ul>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800580.png" alt="Picture13.png" style="zoom:50%;" />

<blockquote>
<p>斐波那契数列的定义是 <em>f</em>(<em>n</em>+1)=<em>f</em>(<em>n</em>)+<em>f</em>(<em>n</em>−1) ，生成第 <em>n</em> 项的做法有以下几种：</p>
<ol>
<li>递归法：<ul>
<li><strong>原理：</strong> 把 <em>f</em>(<em>n</em>) 问题的计算拆分成 <em>f</em>(<em>n</em>−1) 和 <em>f</em>(<em>n</em>−2) 两个子问题的计算，并递归，以 <em>f</em>(0) 和 <em>f</em>(1) 为终止条件。</li>
<li><strong>缺点：</strong> 大量重复的递归计算，例如 <em>f</em>(<em>n</em>) 和 <em>f</em>(<em>n</em>−1) 两者向下递归都需要计算 <em>f</em>(<em>n</em>−2) 的值。</li>
</ul>
</li>
<li>记忆化递归法：<ul>
<li><strong>原理：</strong> 在递归法的基础上，新建一个长度为 <em>n</em> 的数组，用于在递归时存储 <em>f</em>(0) 至 <em>f</em>(<em>n</em>) 的数字值，重复遇到某数字时则直接从数组取用，避免了重复的递归计算。</li>
<li><strong>缺点：</strong> 记忆化存储的数组需要使用 <em>O</em>(<em>N</em>) 的额外空间。</li>
</ul>
</li>
<li>动态规划：<ul>
<li><strong>原理：</strong> 以斐波那契数列性质 <em>f</em>(<em>n</em>+1)=<em>f</em>(<em>n</em>)+<em>f</em>(<em>n</em>−1) 为转移方程。</li>
<li>从计算效率、空间复杂度上看，动态规划是本题的最佳解法。</li>
</ul>
</li>
</ol>
</blockquote>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800997.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800071.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800105.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800471.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800084.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800767.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800575.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800931.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800523.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800935.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800087.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211800471.png" alt="img" style="zoom:50%;" />

<p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(N) ：</strong> 计算 <em>f</em>(<em>n</em>) 需循环 <em>n</em> 次，每轮循环内计算操作使用 <em>O</em>(1) 。</li>
<li><strong>空间复杂度 O(N) ：</strong> 几个标志变量使用常数大小的额外空间。</li>
</ul>
<!-- tabs:start -->

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><p>由于 Python 中整形数字的大小限制 <em>取决计算机的内存</em> （可理解为无限大），因此可不考虑大数越界问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numWays</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> b % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>动态规划（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 63. 股票的最大利润</title>
    <url>/posts/c2a73c5ce56d/</url>
    <content><![CDATA[<h1 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63. 股票的最大利润"></a><a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">63. 股票的最大利润</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre><strong>输入:</strong> [7,1,5,3,6,4]
<strong>输出:</strong> 5
<strong>解释: </strong>在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
</pre>

<p><strong>示例 2:</strong></p>

<pre><strong>输入:</strong> [7,6,4,3,1]
<strong>输出:</strong> 0
<strong>解释: </strong>在这种情况下, 没有交易完成, 所以最大利润为 0。</pre>

<p>&nbsp;</p>

<p><strong>限制：</strong></p>

<p><code>0 &lt;= 数组长度 &lt;= 10^5</code></p>

<p>&nbsp;</p>

<p><strong>注意：</strong>本题与主站 121 题相同：<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>纯粹的说，此题是在数组当中寻找最大值与最小值，但存在一个限制条件，最大值必须在最小值的后面（相对数组中的存储位置）。</p>
<ul>
<li>暴力解法<ul>
<li>双指针遍历，记录两数最大差值。  <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">for i = 0 in arr.length - 1</span><br><span class="line">    for j = i in arr.length</span><br><span class="line">        r = max(r, arr[j] - arr[i])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>动态规划<ul>
<li>  准备一变量记录最大差值，初始化为 0；一变量记录最小值，初始化为无限大。</li>
<li>遍历数组，计算当前遍历元素与最小值的差值，并更新最大差值；再更新最小值。  <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">r = 0</span><br><span class="line">m = ∞</span><br><span class="line">for i = 0 in arr.length</span><br><span class="line">    r = max(r, arr[i] - m)</span><br><span class="line">    m = min(m, arr[i])</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<!-- tabs:start -->

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(prices) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mi = prices[<span class="number">0</span>]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> prices[<span class="number">1</span>:]:</span><br><span class="line">            res = <span class="built_in">max</span>(res, val - mi)</span><br><span class="line">            mi = <span class="built_in">min</span>(mi, val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">// 0~i 天里面的进价最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 0~i 天里面的利润最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 第 i 天 的价格</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> prices[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第 i 天 时，0~i 天里面的进价最小值</span></span><br><span class="line">            min = Math.min(min, price);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第 i 天 时，0~i 天里面的利润最大值</span></span><br><span class="line">            <span class="comment">// 找到前一天时候的利润最大值，与今天利润比较，取大，得到 0~i 天里面的利润最大值</span></span><br><span class="line">            max = Math.max(max, price - min);</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;天时：min=&quot;</span> + min + <span class="string">&quot;，max=&quot;</span> + max);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>动态规划（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 58 - II. 左旋转字符串</title>
    <url>/posts/34924738a71f/</url>
    <content><![CDATA[<h1 id="58-II-左旋转字符串"><a href="#58-II-左旋转字符串" class="headerlink" title="58 - II. 左旋转字符串"></a><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">58 - II. 左旋转字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入:</strong> s = &quot;abcdefg&quot;, k = 2
<strong>输出:&nbsp;</strong>&quot;cdefgab&quot;
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入:</strong> s = &quot;lrloseumgh&quot;, k = 6
<strong>输出:&nbsp;</strong>&quot;umghlrlose&quot;
</pre>

<p>&nbsp;</p>

<p><strong>限制：</strong></p>

<ul>
    <li><code>1 &lt;= k &lt; s.length &lt;= 10000</code></li>
</ul>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><!-- tabs:start -->
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &lt; s.length(); i++) &#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>substring 效率更高一些</p>
</blockquote>
<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseLeftWords</span>(<span class="params">self, s: <span class="built_in">str</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> s[n:] + s[:n]</span><br></pre></td></tr></table></figure>



<h3 id="C"><a href="#C" class="headerlink" title="C++"></a><strong>C++</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(n) + s.<span class="built_in">substr</span>(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">begin</span>() + n);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + n, s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><strong>JavaScript</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseLeftWords = <span class="keyword">function</span> (<span class="params">s, n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">substring</span>(n) + s.<span class="title function_">substring</span>(<span class="number">0</span>, n);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a><strong>Go</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseLeftWords</span><span class="params">(s <span class="type">string</span>, n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[n:] + s[:n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a><strong>Rust</strong></h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">reverse_left_words</span>(s: <span class="type">String</span>, n: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">n</span> = n <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        <span class="type">String</span>::<span class="title function_ invoke__">from</span>(&amp;s[n..]) + &amp;s[..n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a><strong>C#</strong></h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ReverseLeftWords</span>(<span class="params"><span class="built_in">string</span> s, <span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.Substring(n) + s.Substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="…"><a href="#…" class="headerlink" title="…"></a><strong>…</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>字符串（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 47. 礼物的最大价值</title>
    <url>/posts/1a8947346e68/</url>
    <content><![CDATA[<h1 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47. 礼物的最大价值"></a><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/">47. 礼物的最大价值</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre><strong>输入:</strong> 
<code>[
&nbsp; [1,3,1],
&nbsp; [1,5,1],
&nbsp; [4,2,1]
]</code>
<strong>输出:</strong> <code>12
</code><strong>解释:</strong> 路径 1&rarr;3&rarr;5&rarr;2&rarr;1 可以拿到最多价值的礼物</pre>

<p>&nbsp;</p>

<p>提示：</p>

<ul>
    <li><code>0 &lt; grid.length &lt;= 200</code></li>
    <li><code>0 &lt; grid[0].length &lt;= 200</code></li>
</ul>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>动态规划法。</p>
<p>我们假设 <code>dp[i][j]</code> 表示走到格子 <code>(i, j)</code> 的礼物最大累计价值，则 <code>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i - 1][j - 1]</code>。</p>
<!-- tabs:start -->

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxValue</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>动态规划（中等）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 05. 替换空格</title>
    <url>/posts/c35b3afe2e66/</url>
    <content><![CDATA[<h1 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05. 替换空格"></a><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">05. 替换空格</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成&quot;%20&quot;。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>s = &quot;We are happy.&quot;
<strong>输出：</strong>&quot;We%20are%20happy.&quot;</pre>

<p>&nbsp;</p>

<p><strong>限制：</strong></p>

<p><code>0 &lt;= s 的长度 &lt;= 10000</code></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>  使用 <code>replace()</code> 替换。</li>
<li>  遍历添加。</li>
</ul>
<!-- tabs:start -->

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><h4 id="1、使用-replaceAll"><a href="#1、使用-replaceAll" class="headerlink" title="1、使用 replaceAll"></a>1、使用 replaceAll</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、使用-StringBuilder"><a href="#2、使用-StringBuilder" class="headerlink" title="2、使用 StringBuilder"></a>2、使用 StringBuilder</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123;</span><br><span class="line">            sb.append(c == <span class="string">&#x27; &#x27;</span> ? <span class="string">&quot;%20&quot;</span> : c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相比较，<strong>StringBuilder</strong>效率更高</p>
</blockquote>
<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">replaceSpace</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;%20&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><strong>JavaScript</strong></h3><p>使用字符串内置方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">s</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>).<span class="title function_">join</span>(<span class="string">&#x27;%20&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>双指针：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> replaceSpace = <span class="keyword">function</span> (<span class="params">s</span>) &#123;</span><br><span class="line">    s = s.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> emptyNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] === <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            emptyNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> p1 = s.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> p2 = p1 + <span class="number">2</span> * emptyNum;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> &amp;&amp; p2 &gt; p1) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[p1] === <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            s[p2] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            s[--p2] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            s[--p2] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s[p2] = s[p1];</span><br><span class="line">        &#125;</span><br><span class="line">        p1--;</span><br><span class="line">        p2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a><strong>Go</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> strings.Replace(s, <span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C++"></a><strong>C++</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                ans += <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a><strong>TypeScript</strong></h3><p>使用 <code>replace()</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceSpace</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="title function_">replace</span>(<span class="regexp">/\s/g</span>, <span class="string">&#x27;%20&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历添加：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">replaceSpace</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> strArr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> c <span class="keyword">of</span> s) &#123;</span><br><span class="line">        strArr.<span class="title function_">push</span>(c === <span class="string">&#x27; &#x27;</span> ? <span class="string">&#x27;%20&#x27;</span> : c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strArr.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a><strong>Rust</strong></h3><p>使用 <code>replace()</code>：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">replace_space</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        s.<span class="title function_ invoke__">replace</span>(<span class="string">&#x27; &#x27;</span>, <span class="string">&quot;%20&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历添加：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">replace_space</span>(s: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">                result.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result.<span class="title function_ invoke__">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a><strong>C#</strong></h3><p>使用 <code>Replace()</code>：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ReplaceSpace</span>(<span class="params"><span class="built_in">string</span> s</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.Replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;%20&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历添加：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">ReplaceSpace</span>(<span class="params"><span class="built_in">string</span> s</span>)</span> &#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> c <span class="keyword">in</span> s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                res.Append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.Append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="…"><a href="#…" class="headerlink" title="…"></a><strong>…</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>字符串（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 27. 二叉树的镜像</title>
    <url>/posts/44140daf99d4/</url>
    <content><![CDATA[<h1 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27. 二叉树的镜像"></a><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">27. 二叉树的镜像</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>

<p>例如输入：</p>

<p><code>&nbsp; &nbsp; &nbsp;4<br>
&nbsp; &nbsp;/ &nbsp; \<br>
&nbsp; 2 &nbsp; &nbsp; 7<br>
&nbsp;/ \ &nbsp; / \<br>
1 &nbsp; 3 6 &nbsp; 9</code><br>
镜像输出：</p>

<p><code>&nbsp; &nbsp; &nbsp;4<br>
&nbsp; &nbsp;/ &nbsp; \<br>
&nbsp; 7 &nbsp; &nbsp; 2<br>
&nbsp;/ \ &nbsp; / \<br>
9 &nbsp; 6 3&nbsp; &nbsp;1</code></p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>root = [4,2,7,1,3,6,9]
<strong>输出：</strong>[4,7,2,9,6,3,1]
</pre>

<p>&nbsp;</p>

<p><strong>限制：</strong></p>

<p><code>0 &lt;= 节点个数 &lt;= 1000</code></p>

<p>注意：本题与主站 226 题相同：<a href="https://leetcode.cn/problems/invert-binary-tree/">https://leetcode.cn/problems/invert-binary-tree/</a></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><!-- tabs:start -->

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法一 递归</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line">        root.right = mirrorTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法二 栈</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> node.left;</span><br><span class="line">            node.left = node.right;</span><br><span class="line">            node.right = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法三 前序遍历，然后交换左右节点，二叉树的镜像其实就是交换每个节点的左右子树，那么久使用二叉树前序遍历的方式，按照中左右的顺序遍历，在中间的时候进行交换操作，交换左右子树。</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        qianxu(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">qianxu</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        exchange(root);<span class="comment">//根</span></span><br><span class="line">        qianxu(root.left);<span class="comment">//左</span></span><br><span class="line">        qianxu(root.right);<span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交换左右子树</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exchange</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>搜索与回溯算法（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 26. 树的子结构</title>
    <url>/posts/f6574d3b0cb9/</url>
    <content><![CDATA[<h1 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26. 树的子结构"></a><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/">26. 树的子结构</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>

<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>

<p>例如:<br>
给定的树 A:</p>
<p><code>&nbsp; &nbsp; &nbsp;3<br>
&nbsp; &nbsp; / \<br>
&nbsp; &nbsp;4 &nbsp; 5<br>
&nbsp; / \<br>
&nbsp;1 &nbsp; 2</code><br>
给定的树 B：</p>

<p><code>&nbsp; &nbsp;4&nbsp;<br>
&nbsp; /<br>
&nbsp;1</code><br>
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</p>


<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>A = [1,2,3], B = [3,1]
<strong>输出：</strong>false
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>A = [3,4,5,1,2], B = [4,1]
<strong>输出：</strong>true</pre>

<p><strong>限制：</strong></p>

<p><code>0 &lt;= 节点个数 &lt;= 10000</code></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><!-- tabs:start -->
<p>要判断B是否是A的子结构，像下面这样，我们只需要从根节点开始判断，通过递归的方式比较他的每一个子节点即可，所以代码也很容易写。</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211814489.png" alt="image.png" style="zoom:50%;" />

<p>但实际上<code>B</code>如果是<code>A</code>的子结构的话，不一定是从根节点开始的，也可能是下面这样。</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211814005.png" alt="image.png" style="zoom:50%;" />

<p>也就是说B不光有可能是A的子结构，也有可能是A左子树的子结构或者右子树的子结构，所以如果从根节点判断B不是A的子结构，还要继续判断B是不是A左子树的子结构和右子树的子结构，代码如下</p>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || B == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先从根节点判断B是不是A的子结构，如果不是再分别从左右两个子树判断，</span></span><br><span class="line">        <span class="comment">//只要有一个为true，就说明B是A的子结构</span></span><br><span class="line">        <span class="keyword">return</span> dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="comment">//这里如果B为空，说明B已经访问完了，确定是A的子结构</span></span><br><span class="line">        <span class="keyword">if</span> (B == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果B不为空A为空，或者这两个节点值不同，说明B树不是A的子结构，直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.val != B.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点比较完之后还要继续判断左右子节点</span></span><br><span class="line">        <span class="keyword">return</span> dfs(A.left, B.left) &amp;&amp; dfs(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>搜索与回溯算法（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 18. 删除链表的节点</title>
    <url>/posts/8dce48a31f5f/</url>
    <content><![CDATA[<h1 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a><a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/">18. 删除链表的节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p>

<p>返回删除后的链表的头节点。</p>

<p><strong>注意：</strong>此题对比原题有改动</p>

<p><strong>示例 1:</strong></p>

<pre><strong>输入:</strong> head = [4,5,1,9], val = 5
<strong>输出:</strong> [4,1,9]
<strong>解释: </strong>给定你链表中值为&nbsp;5&nbsp;的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.
</pre>

<p><strong>示例 2:</strong></p>

<pre><strong>输入:</strong> head = [4,5,1,9], val = 1
<strong>输出:</strong> [4,5,9]
<strong>解释: </strong>给定你链表中值为&nbsp;1&nbsp;的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.
</pre>

<p>&nbsp;</p>

<p><strong>说明：</strong></p>

<ul>
    <li>题目保证链表中节点的值互不相同</li>
    <li>若使用 C 或 C++ 语言，你不需要 <code>free</code> 或 <code>delete</code> 被删除的节点</li>
</ul>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>定义一个虚拟头节点 <code>dummy</code> 指向 <code>head</code>，<code>pre</code> 指针初始指向 <code>dummy</code>。</p>
<p>循环遍历链表，<code>pre</code> 往后移动。当指针 <code>pre.next</code> 指向的节点的值等于 <code>val</code> 时退出循环，将 <code>pre.next</code> 指向 <code>pre.next.next</code>，然后返回 <code>dummy.next</code>。</p>
<!-- tabs:start -->

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteNode</span>(<span class="params">self, head: ListNode, val: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        pre = dummy = ListNode(<span class="built_in">next</span>=head)</span><br><span class="line">        <span class="keyword">while</span> pre.<span class="built_in">next</span> <span class="keyword">and</span> pre.<span class="built_in">next</span>.val != val:</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = <span class="literal">None</span> <span class="keyword">if</span> <span class="keyword">not</span> pre.<span class="built_in">next</span> <span class="keyword">else</span> pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 添加哨兵节点，方便后面不在对head单独处理</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (pre.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.next.val == val) &#123;</span><br><span class="line">                pre.next = pre.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = pre.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单独处理头节点</span></span><br><span class="line">        <span class="keyword">if</span> (head.val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.val == val) &#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>双指针（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 28. 对称的二叉树</title>
    <url>/posts/6d2865e8c7c9/</url>
    <content><![CDATA[<h1 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28. 对称的二叉树"></a><a href="https://leetcode.cn/problems/dui-cheng-de-er-cha-shu-lcof/">28. 对称的二叉树</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>

<p>例如，二叉树&nbsp;[1,2,2,3,4,4,3] 是对称的。</p>

<p><code>&nbsp; &nbsp; 1<br>
&nbsp; &nbsp;/ \<br>
&nbsp; 2 &nbsp; 2<br>
&nbsp;/ \ / \<br>
3 &nbsp;4 4 &nbsp;3</code><br>
但是下面这个&nbsp;[1,2,2,null,3,null,3] 则不是镜像对称的:</p>

<p><code>&nbsp; &nbsp; 1<br>
&nbsp; &nbsp;/ \<br>
&nbsp; 2 &nbsp; 2<br>
&nbsp; &nbsp;\ &nbsp; \<br>
&nbsp; &nbsp;3 &nbsp; &nbsp;3</code></p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>root = [1,2,2,3,4,4,3]
<strong>输出：</strong>true
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>root = [1,2,2,null,3,null,3]
<strong>输出：</strong>false</pre>

<p>&nbsp;</p>

<p><strong>限制：</strong></p>

<p><code>0 &lt;= 节点个数 &lt;= 1000</code></p>

<p>注意：本题与主站 101 题相同：<a href="https://leetcode.cn/problems/symmetric-tree/">https://leetcode.cn/problems/symmetric-tree/</a></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><ul>
<li><strong>对称二叉树定义</strong>： 对于树中 任意两个对称节点 <em>L</em> 和 <em>R</em> ，一定有：<ul>
<li><em>L.val = R.val</em> ：即此两对称节点值相等。</li>
<li><em>L.left.val = R.right.val</em> ：即 L 的 左子节点 和 R 的 右子节点 对称；</li>
<li>L.right.val = R.left.val ：即 L 的 右子节点 和 R 的 左子节点 对称。</li>
</ul>
</li>
<li>根据以上规律，考虑从顶至底递归，判断每对节点是否对称，从而判断树是否为对称二叉树。</li>
</ul>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815246.png" alt="Picture1.png" style="zoom:50%;" />

<h5 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h5><p><strong><code>isSymmetric(root)</code> ：</strong></p>
<ul>
<li><strong>特例处理：</strong> 若根节点 <code>root</code> 为空，则直接返回 <em>t<strong>r</strong>u**e</em> 。</li>
<li><strong>返回值：</strong> 即 <code>recur(root.left, root.right)</code> ;</li>
</ul>
<p><strong><code>recur(L, R)</code> ：</strong></p>
<ul>
<li><p><strong>终止条件</strong>：</p>
<ul>
<li>当 <em>L</em> 和 <em>R</em> 同时越过叶节点： 此树从顶至底的节点都对称，因此返回 <em>true</em> ；</li>
<li>当 <em>L</em> 或 <em>R</em> 中只有一个越过叶节点： 此树不对称，因此返回 <em>false</em> ；</li>
<li>当节点 <em>L</em> 值 != 节点 <em>R</em> 值： 此树不对称，因此返回 <em>false</em> ；</li>
</ul>
</li>
<li><p><strong>递推工作：</strong></p>
<ul>
<li>判断两节点 <em>L.left</em> 和 <em>R.right</em> 是否对称，即 <code>recur(L.left, R.right)</code> ；</li>
<li>判断两节点 <em>L.right</em> 和 <em>R.left</em> 是否对称，即 <code>recur(L.right, R.left)</code> ；</li>
</ul>
<p><strong>返回值：</strong> 两对节点都对称时，才是对称树，因此用与逻辑符 <code>&amp;&amp;</code> 连接。</p>
</li>
</ul>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815143.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815849.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815749.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815381.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815989.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815553.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815990.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815458.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815460.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815832.png" alt="img" style="zoom:50%;" />

<p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 <em>O(N)</em> ：</strong> 其中 <em>N</em> 为二叉树的节点数量，每次执行 <code>recur()</code> 可以判断一对节点是否对称，因此最多调用 <em>N</em>/2 次 <code>recur()</code> 方法。</li>
<li><strong>空间复杂度 <em>O(N)</em> ：</strong> 最差情况下（见下图），二叉树退化为链表，系统使用 <em>O</em>(<em>N</em>) 大小的栈空间。</li>
</ul>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815329.png" alt="Picture12.png" style="zoom:50%;" />









<!-- tabs:start -->


<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">null</span> ? <span class="literal">true</span> : dfs(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode L, TreeNode R)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历结束了</span></span><br><span class="line">        <span class="keyword">if</span> (L == <span class="literal">null</span> &amp;&amp; R == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是镜像的时候 肯定会有一个值不相等。或者左右高度不一样</span></span><br><span class="line">        <span class="keyword">if</span> (L == <span class="literal">null</span> || R == <span class="literal">null</span> || L.val != R.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 继续比对下一层</span></span><br><span class="line">        <span class="keyword">return</span> dfs(L.left, R.right) &amp;&amp; dfs(L.right, R.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>搜索与回溯算法（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</title>
    <url>/posts/e05cc7e722c9/</url>
    <content><![CDATA[<h1 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">21. 调整数组顺序使奇数位于偶数前面</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。</p>
<p><strong>示例：</strong></p>

<pre>
<strong>输入：</strong>nums =&nbsp;[1,2,3,4]
<strong>输出：</strong>[1,3,2,4] 
<strong>注：</strong>[3,1,2,4] 也是正确的答案之一。</pre>


<p><strong>提示：</strong></p>

<ol>
    <li><code>0 &lt;= nums.length &lt;= 50000</code></li>
    <li><code>0 &lt;= nums[i] &lt;= 10000</code></li>
</ol>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>考虑定义双指针 <em>i</em> , <em>j</em> 分列数组左右两端，循环执行：</p>
<ol>
<li>指针 <em>i</em> 从左向右寻找偶数；</li>
<li>指针 <em>j</em> 从右向左寻找奇数；</li>
<li>将 偶数 <em>nums[i]</em> 和 奇数 <em>nums[j]</em> 交换。</li>
</ol>
<p>可始终保证： 指针 <em>i</em> 左边都是奇数，指针 <em>j</em> 右边都是偶数 。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212231104199.gif" alt="img"></p>
<h4 id="快慢双指针"><a href="#快慢双指针" class="headerlink" title="快慢双指针"></a>快慢双指针</h4><ul>
<li>定义快慢双指针 <em>fast</em> 和 <em>low</em> ，<em>fast</em> 在前， <em>low</em> 在后 .</li>
<li><em>fast</em> 的作用是向前搜索奇数位置，<em>low</em> 的作用是指向下一个奇数应当存放的位置</li>
<li><em>fast</em> 向前移动，当它搜索到奇数时，将它和 <em>nums[low]</em> 交换，此时 <em>low</em> 向前移动一个位置 .</li>
<li>重复上述操作，直到 <em>fast</em> 指向数组末尾 .</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212231105184.gif" alt="img"></p>
<!-- tabs:start -->

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exchange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> nums[i] &amp; <span class="number">1</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> (nums[j] &amp; <span class="number">1</span>) == <span class="number">0</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><p>双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// l 从左到右找偶数</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; (nums[l] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到奇数则移动一位</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// r 从有到左找奇数</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; (nums[r] &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 遇到偶数则移动一位</span></span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当l和r相等时 已经找到中间那个元素了</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">                nums[l] = nums[l] ^ nums[r];</span><br><span class="line">                nums[r] = nums[l] ^ nums[r];</span><br><span class="line">                nums[l] = nums[l] ^ nums[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快慢指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fast &lt; nums.length) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到奇数</span></span><br><span class="line">            <span class="keyword">if</span> ((nums[fast] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (low != fast) &#123;</span><br><span class="line">                    nums[low] = nums[low] ^ nums[fast];</span><br><span class="line">                    nums[fast] = nums[low] ^ nums[fast];</span><br><span class="line">                    nums[low] = nums[low] ^ nums[fast];</span><br><span class="line">                &#125;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>双指针（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 22. 链表中倒数第k个节点</title>
    <url>/posts/44b373277d07/</url>
    <content><![CDATA[<h1 id="22-链表中倒数第-k-个节点"><a href="#22-链表中倒数第-k-个节点" class="headerlink" title="22. 链表中倒数第 k 个节点"></a><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">22. 链表中倒数第 k 个节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。</p>

<p>例如，一个链表有 <code>6</code> 个节点，从头节点开始，它们的值依次是 <code>1、2、3、4、5、6</code>。这个链表的倒数第 <code>3</code> 个节点是值为 <code>4</code> 的节点。</p>

<p> </p>

<p><strong>示例：</strong></p>

<pre>
给定一个链表: <strong>1->2->3->4->5</strong>, 和 <em>k </em><strong>= 2</strong>.

返回链表 4<strong>->5</strong>.</pre>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>定义快慢指针 <code>slow</code>、<code>fast</code>，初始指向 <code>head</code>。双指针则可以不用统计链表长度。</p>
<p><code>fast</code> 先向前走 <code>k</code> 步，接着 <code>slow</code>、<code>fast</code> 同时向前走，当 <code>fast</code> 指向 <code>null</code> 时，<code>slow</code> 指向的节点即为链表的倒数第 <code>k</code> 个节点。</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221135664.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221135961.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221135426.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221135399.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221136012.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221136569.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221136420.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221136779.png" alt="img" style="zoom:50%;" />

<h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><ul>
<li><strong>时间复杂度 <em>O(N)</em> ：</strong> <em>N</em> 为链表长度；总体看， <code>former</code> 走了 <em>N</em> 步， <code>latter</code> 走了 (<em>N</em>−<em>k</em>) 步。</li>
<li><strong>空间复杂度 <em>O(1)</em> ：</strong> 双指针 <code>former</code> , <code>latter</code> 使用常数大小的额外空间。</li>
<li></li>
</ul>
<!-- tabs:start -->

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getKthFromEnd</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        slow = fast = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><h4 id="快慢指针法"><a href="#快慢指针法" class="headerlink" title="快慢指针法"></a>快慢指针法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (k-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h4><p>先遍历统计链表长度，记为 count ；<br>设置一个指针走 (count-k) 步，即可找到链表倒数第 k 个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 普通遍历，先找到总个数，然后再遍历一次到指定截取位置</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count - k; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>双指针（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 32 - II. 从上到下打印二叉树 II</title>
    <url>/posts/9340bb2f10f8/</url>
    <content><![CDATA[<h1 id="32-II-从上到下打印二叉树-II"><a href="#32-II-从上到下打印二叉树-II" class="headerlink" title="32 - II. 从上到下打印二叉树 II"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">32 - II. 从上到下打印二叉树 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。</p>

<p>&nbsp;</p>

<p>例如:<br>
给定二叉树:&nbsp;<code>[3,9,20,null,null,15,7]</code>,</p>

<pre>    3
   / \
  9  20
    /  \
   15   7
</pre>

<p>返回其层次遍历结果：</p>

<pre>[
  [3],
  [9,20],
  [15,7]
]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ol>
    <li><code>节点总数 &lt;= 1000</code></li>
</ol>

<p>注意：本题与主站 102 题相同：<a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">https://leetcode.cn/problems/binary-tree-level-order-traversal/</a></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><blockquote>
<p>建议先做 <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/solution/mian-shi-ti-32-i-cong-shang-dao-xia-da-yin-er-ch-4/">面试题32 - I. 从上到下打印二叉树</a> 再做此题，两题仅有微小区别，即本题需将 <strong>每一层打印到一行</strong> 。</p>
</blockquote>
<p><strong>I. 按层打印：</strong> 题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</p>
<p><strong>II. 每层打印到一行：</strong> 将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211817828.png" alt="Picture1.png" style="zoom:50%;" />

<h5 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h5><ol>
<li><strong>特例处理：</strong> 当根节点为空，则返回空列表 <code>[]</code> ；</li>
<li><strong>初始化：</strong> 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root]</code> ；</li>
<li>BFS 循环：当队列 <code>queue</code> 为空时跳出；<ol>
<li>新建一个临时列表 <code>tmp</code> ，用于存储当前层打印结果；</li>
<li>当前层打印循环： 循环次数为当前层节点数（即队列 <code>queue</code>长度）；<ol>
<li><strong>出队：</strong> 队首元素出队，记为 <code>node</code>；</li>
<li><strong>打印：</strong> 将 <code>node.val</code> 添加至 <code>tmp</code> 尾部；</li>
<li><strong>添加子节点：</strong> 若 <code>node</code> 的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code> ；</li>
</ol>
</li>
<li>将当前层结果 <code>tmp</code> 添加入 <code>res</code> 。</li>
</ol>
</li>
<li><strong>返回值：</strong> 返回打印结果列表 <code>res</code> 即可。</li>
</ol>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211817409.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211817060.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211817536.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211817129.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211817536.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211817578.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211817871.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211817268.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211817933.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211817550.png" alt="img" style="zoom:50%;" />

<h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><ul>
<li><strong>时间复杂度 <em>O(N)</em> ：</strong> <em>N</em> 为二叉树的节点数量，即 BFS 需循环 <em>N</em> 次。</li>
<li><strong>空间复杂度 <em>O(N)</em> ：</strong> 最差情况下，即当树为平衡二叉树时，最多有 <em>N</em>/2 个树节点<strong>同时</strong>在 <code>queue</code> 中，使用 <em>O</em>(<em>N</em>) 大小的额外空间。</li>
</ul>
<!-- tabs:start -->

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 借助一个队列，通过 BFS 实现按层遍历二叉树</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 申请一个动态数组 ArrayList 动态添加节点值</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根结点先入队</span></span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 取出当前队首元素</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">// 左子节点入队</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右子节点入队</span></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>搜索与回溯算法（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 32 - I. 从上到下打印二叉树</title>
    <url>/posts/214abcc6222a/</url>
    <content><![CDATA[<h1 id="32-I-从上到下打印二叉树"><a href="#32-I-从上到下打印二叉树" class="headerlink" title="32 - I. 从上到下打印二叉树"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">32 - I. 从上到下打印二叉树</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>

<p>&nbsp;</p>

<p>例如:<br>
给定二叉树:&nbsp;<code>[3,9,20,null,null,15,7]</code>,</p>

<pre>    3
   / \
  9  20
    /  \
   15   7
</pre>

<p>返回：</p>

<pre>[3,9,20,15,7]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ol>
    <li><code>节点总数 &lt;= 1000</code></li>
</ol>
## 解法

<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ul>
<li>题目要求的二叉树的 <strong>从上至下</strong> 打印（即按层打印），又称为二叉树的 <strong>广度优先搜索</strong>（BFS）。</li>
<li>BFS 通常借助 <strong>队列</strong> 的先入先出特性来实现。</li>
</ul>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815840.png" alt="Picture0.png" style="zoom:50%;" />



<h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h3><ol>
<li><strong>特例处理：</strong> 当树的根节点为空，则直接返回空列表 <code>[]</code> ；</li>
<li><strong>初始化：</strong> 打印结果列表 <code>res = []</code> ，包含根节点的队列 <code>queue = [root]</code> ；</li>
<li>BFS 循环：当队列 <code>queue</code> 为空时跳出；<ol>
<li><strong>出队：</strong> 队首元素出队，记为 <code>node</code>；</li>
<li><strong>打印：</strong> 将 <code>node.val</code> 添加至列表 <code>tmp</code> 尾部；</li>
<li><strong>添加子节点：</strong> 若 <code>node</code> 的左（右）子节点不为空，则将左（右）子节点加入队列 <code>queue</code> ；</li>
</ol>
</li>
<li><strong>返回值：</strong> 返回打印结果列表 <code>res</code> 即可</li>
</ol>
<p>将根节点存入队列，</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211815629.png" alt="img" style="zoom:50%;" />

<p>开始BFS 循环：当队列 <code>queue</code> 为空时跳出。</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816207.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816233.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816151.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816760.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816436.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816355.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816995.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816779.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816412.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816032.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816550.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816010.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816463.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816005.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816663.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211816407.png" alt="img" style="zoom:50%;" />

<h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><ul>
<li><strong>时间复杂度 *O*(*N*) ：</strong> <em>N</em> 为二叉树的节点数量，即 BFS 需循环 <em>N</em> 次。</li>
<li><strong>空间复杂度 *O*(*N*) ：</strong> 最差情况下，即当树为平衡二叉树时，最多有 <em>N</em>/2 个树节点<strong>同时</strong>在 <code>queue</code> 中，使用 <em>O</em>(<em>N</em>) 大小的额外空间。</li>
</ul>
<!-- tabs:start -->

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// 空树则返回空数组</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 借助一个队列，通过 BFS 实现按层遍历二叉树</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 申请一个动态数组 ArrayList 动态添加节点值</span></span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根结点先入队</span></span><br><span class="line">        q.offer(root); </span><br><span class="line">        <span class="keyword">while</span> (q.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 取出当前队首元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll(); </span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="comment">// 左子节点入队</span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右子节点入队</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 ArrayList 转为 int数组并返回</span></span><br><span class="line">        <span class="keyword">return</span> list.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>搜索与回溯算法（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 25. 合并两个排序的链表</title>
    <url>/posts/58239c5dd394/</url>
    <content><![CDATA[<h1 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25. 合并两个排序的链表"></a><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">25. 合并两个排序的链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>

<p><strong>示例1：</strong></p>

<pre><strong>输入：</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4
<strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</pre>

<p><strong>限制：</strong></p>

<p><code>0 &lt;= 链表长度 &lt;= 1000</code></p>

<p>注意：本题与主站 21 题相同：<a href="https://leetcode.cn/problems/merge-two-sorted-lists/">https://leetcode.cn/problems/merge-two-sorted-lists/</a></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>同时遍历两个链表，归并插入新链表中即可。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><ul>
<li>根据题目描述， 链表 <em>l1</em> , <em>l2</em> 是 <strong>递增</strong> 的，因此容易想到使用双指针 <em>l1</em> , <em>l2</em> 遍历两链表，根据 <em>l1.val</em> 和 <em>l2.val</em> 的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。</li>
<li><strong>引入伪头节点：</strong> 由于初始状态合并链表中无节点，因此循环第一轮时无法将节点添加到合并链表中。解决方案：初始化一个辅助节点 <em>dum</em> 作为合并链表的伪头节点，将各节点添加至 <em>dum</em> 之后。</li>
</ul>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221338194.png" alt="Picture17.png" style="zoom:50%;" />





<h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h3><ol>
<li><p><strong>初始化：</strong> 伪头节点 <em>dum</em> ，节点 <em>cur</em> 指向 <em>dum</em> 。</p>
</li>
<li><p>循环合并：当 <em>l1</em> 或者 <em>l2</em> 为空时跳出；</p>
<ol>
<li>当 <em>l1.val &lt; l2.val</em> 时： <em>cur</em> 的后继节点指定为 <em>l1</em> ，并 <em>l1</em> 向前走一步；</li>
<li>当 <em>l1.val ≥ l2.val</em> 时： <em>cur</em> 的后继节点指定为 <em>l2</em> ，并 <em>l2</em> 向前走一步 ；</li>
<li>节点 <em>cur</em> 向前走一步，即 <em>cur = cur.next</em> 。</li>
</ol>
</li>
<li><p>合并剩余尾部：跳出时有两种情况，即 <em>l1</em> 为空或 <em>l2</em> 为空。</p>
<ol>
<li>若 <em>l1 != null</em> ： 遍历剩余 <em>l1</em> 添加至节点 <em>cur</em> 之后；</li>
<li>否则： 遍历剩余 <em>l2</em> 添加至节点 <em>cur</em> 之后。</li>
</ol>
</li>
<li><p><strong>返回值：</strong> 合并链表在伪头节点 <em>dum</em> 之后，因此返回 <em>dum.next</em> 即可。</p>
</li>
</ol>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221346708.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221346965.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221347339.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221347272.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221347962.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221347257.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221347125.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221347242.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221348252.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221348835.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221348676.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221348050.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221348092.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221348217.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221349316.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221349556.png" alt="img" style="zoom:50%;" />



<h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><ul>
<li><strong>时间复杂度 O(M+N) ：</strong> <em>M</em>,<em>N</em> 分别为链表 <em>l1</em>, <em>l2</em> 的长度，合并操作需遍历两链表。</li>
<li><strong>空间复杂度 O(1) ：</strong> 节点引用 <em>dum</em> , <em>cur</em> 使用常数大小的额外空间。</li>
</ul>
<!-- tabs:start -->

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTwoLists</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        p = dummy</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                p.<span class="built_in">next</span> = l1</span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                p.<span class="built_in">next</span> = l2</span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = l1 <span class="keyword">or</span> l2</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><p>该方法改变了原列表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                p.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法不改变原链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dump</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dump;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp1</span> <span class="operator">=</span> l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp2</span> <span class="operator">=</span> l2;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环合并 当l1或者l2为空时跳出</span></span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="literal">null</span> &amp;&amp; temp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 若l1小就将l1追加到 cur,l1后移1位</span></span><br><span class="line">            <span class="keyword">if</span> (temp1.val &lt; temp2.val) &#123;</span><br><span class="line">                cur.next = temp1;</span><br><span class="line">                temp1 = temp1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若l2小就将l2追加到 cur,l2后移1位</span></span><br><span class="line">                cur.next = temp2;</span><br><span class="line">                temp2 = temp2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cur 后移</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理剩余节点 因为链表长度不一样，所以可能一个走到头了，另一个没走到头</span></span><br><span class="line">        <span class="comment">// 处理l1剩余节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp1 != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next = temp1;</span><br><span class="line">            temp1 = temp1.next;</span><br><span class="line">            <span class="comment">// cur 后移</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理l2剩余节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur.next = temp2;</span><br><span class="line">            temp2 = temp2.next;</span><br><span class="line">            <span class="comment">// cur 后移</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>双指针（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字</title>
    <url>/posts/080cd170905d/</url>
    <content><![CDATA[<h1 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03. 数组中重复的数字"></a><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">03. 数组中重复的数字</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>找出数组中重复的数字。</p>

<p><br>
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>
[2, 3, 1, 0, 2, 5, 3]
<strong>输出：</strong>2 或 3 
</pre>

<p>&nbsp;</p>

<p><strong>限制：</strong></p>

<p><code>2 &lt;= n &lt;= 100000</code></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>四种方式</p>
<ol>
<li><p>排序</p>
<blockquote>
<p>先排序，将相同的数字聚集到一起。</p>
<p>再遍历，当位于 <code>i</code> 与 <code>i + 1</code> 的数字相等时，返回该数字。</p>
</blockquote>
</li>
<li><p>哈希表</p>
<blockquote>
<p>存入哈希表，存入之前判断如果已经包含了这个数字，说明该数字重复了，则直接返回该数字。</p>
</blockquote>
</li>
<li><p>Set</p>
<blockquote>
<p>存入Set，存入失败则表示该数字重复了，则直接返回该数字</p>
</blockquote>
</li>
</ol>
<p><strong>复杂度分析</strong> 哈希表、Set</p>
<ul>
<li>时间复杂度 O(N) ： 遍历数组使用 O(N) ，HashSet 添加与查找元素皆为 O(1) 。</li>
<li>空间复杂度 O(N) ： HashSet 占用 O(N) 大小的额外空间。</li>
</ul>
<ol start="4">
<li><p>原地交换 <em>效率最快</em></p>
<blockquote>
<p>0 ～ n-1 范围内的数，分别还原到对应的位置上，如：数字 2 交换到下标为 2 的位置。</p>
<p>若交换过程中发现*nums[i] == nums[nums[i]]*，则直接返回 *nums[i]*。</p>
</blockquote>
</li>
</ol>
<p><strong>复杂度分析</strong> 原地交换</p>
<ul>
<li>时间复杂度 <em>O(N)</em> ： 遍历数组使用 <em>O(N)</em> ，每轮遍历的判断和交换操作使用 <em>O(1)</em> 。</li>
<li>空间复杂度 <em>O(1)</em> ： 使用常数复杂度的额外空间。</li>
</ul>
<p>题目说明尚未被充分使用，即 <code>在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内</code> 。 此说明含义：数组元素的 <strong>索引</strong> 和 <strong>值</strong> 是 <strong>一对多</strong> 的关系。<br>因此，可遍历数组并通过交换操作，使元素的 <strong>索引</strong> 与 <strong>值</strong> 一一对应（即 <em>nums[i]=i</em> ）。因而，就能通过索引映射对应的值，起到与字典等价的作用。</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211752379.png" alt="Picture0.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211752282.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211752960.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211752742.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211753634.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211753787.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211753816.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211753873.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211753700.png" alt="img" style="zoom:50%;" />



<!-- tabs:start -->

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="原地交换"><a href="#原地交换" class="headerlink" title="原地交换"></a>原地交换</h4><p><em>效率最快</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, n = nums.length; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[nums[i]]) <span class="keyword">return</span> nums[i];</span><br><span class="line">                swap(nums, i, nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>查找算法（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
    <url>/posts/e60f1873c6b0/</url>
    <content><![CDATA[<h1 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点"></a><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">52. 两个链表的第一个公共节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共节点。</p>

<p>如下面的两个链表<strong>：</strong></p>

<img alt="" src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221407659.png"  >

<p>在节点 c1 开始相交。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221409346.png" alt="img"  />

<pre><strong>输入：</strong>intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
<strong>输出：</strong>Reference of the node with value = 8
<strong>输入解释：</strong>相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
</pre>
<p>&nbsp;</p>

<p><strong>示例&nbsp;2：</strong></p>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221409912.png" alt="img"></p>
<pre><strong>输入：</strong>intersectVal&nbsp;= 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
<strong>输出：</strong>Reference of the node with value = 2
<strong>输入解释：</strong>相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
</pre>
<p>&nbsp;</p>

<p><strong>示例&nbsp;3：</strong></p>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221409030.png" alt="img"></p>
<pre><strong>输入：</strong>intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
<strong>输出：</strong>null
<strong>输入解释：</strong>从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
<strong>解释：</strong>这两个链表不相交，因此返回 null。
</pre>
<p><strong>注意：</strong></p>

<ul>
    <li>如果两个链表没有交点，返回 <code>null</code>.</li>
    <li>在返回结果后，两个链表仍须保持原有的结构。</li>
    <li>可假定整个链表结构中没有循环。</li>
    <li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li>
    <li>本题与主站 160 题相同：<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">https://leetcode.cn/problems/intersection-of-two-linked-lists/</a></li>
</ul>


<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>使用两个指针 <code>cur1</code>, <code>cur2</code> 分别指向两个链表 <code>headA</code>, <code>headB</code>。</p>
<p>同时遍历链表，当 <code>cur1</code> 到达链表 <code>headA</code> 的末尾时，重新定位到链表 <code>headB</code> 的头节点；当 <code>cur2</code> 到达链表 <code>headB</code> 的末尾时，重新定位到链表 <code>headA</code> 的头节点。</p>
<p>若两指针相遇，所指向的结点就是第一个公共节点。若没相遇，说明两链表无公共节点，此时两个指针都指向 <code>null</code>。</p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>设「第一个公共节点」为 <code>node</code> ，「链表 <code>headA</code>」的节点数量为 <em>a</em> ，「链表 <code>headB</code>」的节点数量为 <em>b</em> ，「两链表的公共尾部」的节点数量为 <em>c</em> ，则有：</p>
<ul>
<li>头节点 <code>headA</code> 到 <code>node</code> 前，共有 <em>a</em>−<em>c</em> 个节点；</li>
<li>头节点 <code>headB</code> 到 <code>node</code> 前，共有 <em>b</em>−<em>c</em> 个节点；</li>
</ul>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221405534.png" alt="Picture1.png" style="zoom:50%;" />

<p>考虑构建两个节点指针 <code>A</code> , <code>B</code> 分别指向两链表头节点 <code>headA</code> , <code>headB</code> ，做如下操作：</p>
<ul>
<li>指针 <code>A</code> 先遍历完链表 <code>headA</code> ，再开始遍历链表 <code>headB</code> ，当走到 <code>node</code> 时，共走步数为：</li>
</ul>
<p><em>a</em>+(<em>b</em>−<em>c</em>)</p>
<ul>
<li>指针 <code>B</code> 先遍历完链表 <code>headB</code> ，再开始遍历链表 <code>headA</code> ，当走到 <code>node</code> 时，共走步数为：</li>
</ul>
<p><em>b</em>+(<em>a</em>−<em>c</em>)</p>
<p>如下式所示，此时指针 <code>A</code> , <code>B</code> 重合，并有两种情况：</p>
<p><em>a</em>+(<em>b</em>−<em>c</em>)=<em>b</em>+(<em>a</em>−<em>c</em>)</p>
<ol>
<li>若两链表 <strong>有</strong> 公共尾部 (即 <em>c</em>&gt;0 ) ：指针 <code>A</code> , <code>B</code> 同时指向「第一个公共节点」<code>node</code> 。</li>
<li>若两链表 <strong>无</strong> 公共尾部 (即 <em>c</em>=0 ) ：指针 <code>A</code> , <code>B</code> 同时指向 <em>n<strong>u</strong>ll</em> 。</li>
</ol>
<p>因此返回 <code>A</code> 即可。</p>
<blockquote>
<p>如下图所示，为 <em>a</em>=5 , <em>b</em>=3 , <em>c</em>=2 示例的算法执行过程。</p>
</blockquote>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221410242.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221425480.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221410567.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221413943.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221426110.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221414876.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221415511.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212221416130.png" alt="img" style="zoom:50%;" />



<h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><ul>
<li><strong>时间复杂度 O(a+b) ：</strong> 最差情况下（即 ∣<em>a</em>−<em>b</em>∣=1 , <em>c</em>=0 ），此时需遍历 <em>a</em>+<em>b</em> 个节点。</li>
<li><strong>空间复杂度 O(1) ：</strong> 节点指针 <code>A</code> , <code>B</code> 使用常数大小的额外空间。</li>
</ul>
<!-- tabs:start -->

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        cur1, cur2 = headA, headB</span><br><span class="line">        <span class="keyword">while</span> cur1 != cur2:</span><br><span class="line">            cur1 = headB <span class="keyword">if</span> cur1 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> cur1.<span class="built_in">next</span></span><br><span class="line">            cur2 = headA <span class="keyword">if</span> cur2 <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> cur2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> cur1</span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> headA, cur2 = headB;</span><br><span class="line">        <span class="keyword">while</span> (cur1 != cur2) &#123;</span><br><span class="line">            cur1 = cur1 == <span class="literal">null</span> ? headB : cur1.next;</span><br><span class="line">            cur2 = cur2 == <span class="literal">null</span> ? headA : cur2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>双指针（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 04. 二维数组中的查找</title>
    <url>/posts/6bf1266db447/</url>
    <content><![CDATA[<h1 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04. 二维数组中的查找"></a><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">04. 二维数组中的查找</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>

<p> </p>

<p><strong>示例:</strong></p>

<p>现有矩阵 matrix 如下：</p>

<pre>
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
</pre>

<p>给定 target = <code>5</code>，返回 <code>true</code>。</p>

<p>给定 target = <code>20</code>，返回 <code>false</code>。</p>

<p> </p>

<p><strong>限制：</strong></p>

<p><code>0 <= n <= 1000</code></p>

<p><code>0 <= m <= 1000</code></p>

<p> </p>

<p><strong>注意：</strong>本题与主站 240 题相同：<a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">https://leetcode.cn/problems/search-a-2d-matrix-ii/</a></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>  换一种观察角度，以右上角位置为基点，往左数值逐渐变小，往下数值逐渐变大。</li>
<li>  且该角度放在数组任意位置都成立，相当于模拟了一棵<strong>二叉搜索树（Binary Search Tree）</strong>。</li>
<li>  根据二叉搜索树特点，从右上角（或左下角）开始查找即可。</li>
</ul>
<p>如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 <strong>二叉搜索树</strong> ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 <code>target</code> 大的元素就向左，反之向右，即可找到目标值 <code>target</code> 。</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211755410.png" alt="Picture1.png" style="zoom:50%;" />

<p>“根节点” 对应的是矩阵的 “左下角” 和 “右上角” 元素，本文称之为 <strong>标志数</strong> ，以 <code>matrix</code> 中的 <strong>左下角元素</strong> 为标志数 <code>flag</code> ，则有:</p>
<ol>
<li>若 <code>flag &gt; target</code> ，则 <code>target</code> 一定在 <code>flag</code> 所在 <strong>行的上方</strong> ，即 <code>flag</code> 所在行可被消去。</li>
<li>若 <code>flag &lt; target</code> ，则 <code>target</code> 一定在 <code>flag</code> 所在 <strong>列的右方</strong> ，即 <code>flag</code> 所在列可被消去。</li>
</ol>
<h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a><strong>算法流程：</strong></h3><ol>
<li>从矩阵 <code>matrix</code> 左下角元素（索引设为 <code>(i, j)</code> ）开始遍历，并与目标值对比：<ul>
<li>当 <code>matrix[i][j] &gt; target</code> 时，执行 <code>i--</code> ，即消去第 <code>i</code> 行元素；</li>
<li>当 <code>matrix[i][j] &lt; target</code> 时，执行 <code>j++</code> ，即消去第 <code>j</code> 列元素；</li>
<li>当 <code>matrix[i][j] = target</code> 时，返回 <em>true</em> ，代表找到目标值。</li>
</ul>
</li>
<li>若行索引或列索引越界（也就是扫描完毕），则代表矩阵中无目标值，返回 <em>false</em></li>
</ol>
<blockquote>
<p>每轮 <code>i</code> 或 <code>j</code> 移动后，相当于生成了“消去一行（列）的新矩阵”， 索引<code>(i,j)</code> 指向新矩阵的左下角元素（标志数），因此可重复使用以上性质消去行（列）。</p>
</blockquote>
<h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><ul>
<li>时间复杂度 <em>O</em>(<em>M</em>+<em>N</em>) ：其中，<em>N</em> 和 <em>M</em> 分别为矩阵行数和列数，此算法最多循环 <em>M</em>+<em>N</em> 次。</li>
<li>空间复杂度 <em>O</em>(1) : <code>i</code>, <code>j</code> 指针使用常数大小额外空间。</li>
</ul>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211755891.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211756258.png" alt="img" style="zoom: 50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211756101.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211756710.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211756312.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211756563.png" alt="img" style="zoom:50%;" />



<!-- tabs:start -->

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><h4 id="类似于二叉搜索树"><a href="#类似于二叉搜索树" class="headerlink" title="类似于二叉搜索树"></a>类似于二叉搜索树</h4><p>以左下角为<em>标志数</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从第i行的第一个元素开始，左下角那个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> matrix.length - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; -<span class="number">1</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="comment">// 如果左下角那个元素大于目标，则扫描上一行，i--</span></span><br><span class="line">            <span class="comment">// 如果左下角那个元素小于目标，则扫描后一列，j++</span></span><br><span class="line">            <span class="comment">// 如果相等，直接返回true;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以右上角为<em>标志数</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右上角元素开始，第一行的最后一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; matrix.length  &amp;&amp; j &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果右上角那个元素小于目标，则扫描下一行，i++</span></span><br><span class="line">            <span class="comment">// 如果右下角那个元素大于目标，则扫描前一列，j--</span></span><br><span class="line">            <span class="comment">// 如果相等，直接返回true;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>复杂度为 n*log(m)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二分查找，复杂度为n*log(m)，每个数组都进行二分查找，共n个数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] nums : matrix) &#123;</span><br><span class="line">            <span class="keyword">if</span> (binarySearch(nums, target)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 二分查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>查找算法（中等）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
    <url>/posts/362f2274d4a3/</url>
    <content><![CDATA[<h1 id="32-III-从上到下打印二叉树-III"><a href="#32-III-从上到下打印二叉树-III" class="headerlink" title="32 - III. 从上到下打印二叉树 III"></a><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">32 - III. 从上到下打印二叉树 III</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>

<p>&nbsp;</p>

<p>例如:<br>
给定二叉树:&nbsp;<code>[3,9,20,null,null,15,7]</code>,</p>

<pre>    3
   / \
  9  20
    /  \
   15   7
</pre>

<p>返回其层次遍历结果：</p>

<pre>[
  [3],
  [20,9],
  [15,7]
]
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ol>
    <li><code>节点总数 &lt;= 1000</code></li>
</ol>
## 解法

<h4 id="方法一：层序遍历-双端队列"><a href="#方法一：层序遍历-双端队列" class="headerlink" title="方法一：层序遍历 + 双端队列"></a>方法一：层序遍历 + 双端队列</h4><ul>
<li>利用双端队列的两端皆可添加元素的特性，设打印列表（双端队列）<code>tmp</code>，并规定：<ul>
<li>奇数层 则添加至 <code>tmp</code> <strong>尾部</strong> ，</li>
<li>偶数层 则添加至 <code>tmp</code> <strong>头部</strong> 。</li>
</ul>
</li>
</ul>
<h4 id="方法二：层序遍历-倒序"><a href="#方法二：层序遍历-倒序" class="headerlink" title="方法二：层序遍历 + 倒序"></a>方法二：层序遍历 + 倒序</h4><ul>
<li>记录行数，奇数层不变，偶数层 <code>tmp</code> 倒叙</li>
</ul>
<!-- tabs:start -->

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><p>方法1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 借助一个队列，通过 BFS 实现按层遍历二叉树</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 申请一个动态数组 ArrayList 动态添加节点值</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根结点先入队</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = queue.size(); i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 取出当前队首元素</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 用list.size()来记录行数</span></span><br><span class="line">                <span class="keyword">if</span> (list.size() % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 奇数层 -&gt; 尾部追加,等同于 add正常插入</span></span><br><span class="line">                    tmp.addLast(node.val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 偶数层 -&gt; 从左侧插入，反向插入</span></span><br><span class="line">                    tmp.addFirst(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左子节点入队</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右子节点入队</span></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * TreeNode left;</span></span><br><span class="line"><span class="comment"> * TreeNode right;</span></span><br><span class="line"><span class="comment"> * TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 借助一个队列，通过 BFS 实现按层遍历二叉树</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 申请一个动态数组 ArrayList 动态添加节点值</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根结点先入队</span></span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            queue.add(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, len = queue.size(); i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 取出当前队首元素</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="comment">// 左子节点入队</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右子节点入队</span></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 用list.size()来记录,偶数层</span></span><br><span class="line">            <span class="keyword">if</span> (list.size() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                Collections.reverse(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>搜索与回溯算法（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 53 - I. 在排序数组中查找数字 I</title>
    <url>/posts/d2e95d65d861/</url>
    <content><![CDATA[<h1 id="53-I-在排序数组中查找数字-I"><a href="#53-I-在排序数组中查找数字-I" class="headerlink" title="53 - I. 在排序数组中查找数字 I"></a><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/">53 - I. 在排序数组中查找数字 I</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。</p>

<p> </p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 8
<strong>输出:</strong> 2</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> nums = [<code>5,7,7,8,8,10]</code>, target = 6
<strong>输出:</strong> 0</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>0 <= nums.length <= 10<sup>5</sup></code></li>
    <li><code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code></li>
    <li><code>nums</code> 是一个非递减数组</li>
    <li><code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code></li>
</ul>

<p> </p>

<p><strong>注意：</strong>本题与主站 34 题相同（仅返回值不同）：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>两遍二分，分别查找出左边界和右边界。</p>
<!-- tabs:start -->

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><p>暴力解法，直接遍历整个数组，累加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>左右两边往中间遍历数组，也是累加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l++] == target) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[r--] == target) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当数组长度为奇数的时候，最终左右指针会指向最中间那个</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] == target) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左右两边往中间遍历数组，由于数组已经排序了 所以可以利用一下这个特点，找到就立马break；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 从左往右找第一次出现的位置</span></span><br><span class="line">        <span class="keyword">for</span> (; l &lt; nums.length; l++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] == target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组不包含target</span></span><br><span class="line">        <span class="keyword">if</span> (l == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右往左找最后一次出现的位置</span></span><br><span class="line">        <span class="keyword">for</span> (; r &gt; -<span class="number">1</span>; r--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[r] == target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        result = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找 <em>效率最高</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearch(nums, target) - binarySearch(nums, target - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找目标元素的右边界</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt;= target) &#123;</span><br><span class="line">                i = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>查找算法（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 24. 反转链表</title>
    <url>/posts/2ac1c865d901/</url>
    <content><![CDATA[<h1 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/">24. 反转链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212141802365.png" alt="Picture1.png" style="zoom:50%;" />

<p><strong>示例:</strong></p>

<pre><strong>输入:</strong> 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
<strong>输出:</strong> 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</pre>

<p>&nbsp;</p>

<p><strong>限制：</strong></p>

<p><code>0 &lt;= 节点个数 &lt;= 5000</code></p>

<p>&nbsp;</p>

<p><strong>注意</strong>：本题与主站 206 题相同：<a href="https://leetcode.cn/problems/reverse-linked-list/">https://leetcode.cn/problems/reverse-linked-list/</a></p>



<h2 id="解法一：迭代（双指针）"><a href="#解法一：迭代（双指针）" class="headerlink" title="解法一：迭代（双指针）"></a>解法一：迭代（双指针）</h2><p>考虑遍历链表，并在访问各节点时修改 <code>next</code> 引用指向，算法流程见注释。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度 *O*(*N*) ：</strong> 遍历链表使用线性大小时间。</li>
<li><strong>空间复杂度 *O*(1) ：</strong> 变量 <code>pre</code> 和 <code>cur</code> 使用常数大小额外空间。</li>
</ul>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142119683.png" alt="Picture2.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212141809045.png" alt="Picture2.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142120418.png" alt="Picture3.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142120991.png" alt="Picture4.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142120641.png" alt="Picture5.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142120414.png" alt="Picture6.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142120572.png" alt="Picture7.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142120140.png" alt="Picture8.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142121552.png" alt="Picture9.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142121572.png" alt="Picture10.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142121836.png" alt="Picture11.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142121685.png" alt="Picture12.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142121011.png" alt="Picture13.png" style="zoom:50%;" />



<h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a><strong>Python</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        cur, pre = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.<span class="built_in">next</span> <span class="comment"># 暂存后继节点 cur.next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre <span class="comment"># 修改 next 引用指向</span></span><br><span class="line">            pre = cur      <span class="comment"># pre 暂存 cur</span></span><br><span class="line">            cur = tmp      <span class="comment"># cur 访问下一节点</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<p>利用 Python 语言的平行赋值语法，可以进一步简化代码（但可读性下降）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        cur, pre = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cur.<span class="built_in">next</span>, pre, cur = pre, cur, cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next; <span class="comment">// 暂存后继节点</span></span><br><span class="line">            cur.next = pre; <span class="comment">// 修改引用指向</span></span><br><span class="line">            pre = cur; <span class="comment">// 暂存当前节点，后移之后就变成前一个节点了</span></span><br><span class="line">            cur = temp; <span class="comment">// 访问下一个节点，也就是节点后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="解法二：递归"><a href="#解法二：递归" class="headerlink" title="解法二：递归"></a>解法二：递归</h2><p>考虑使用递归法遍历链表，当越过尾节点后终止递归，在回溯时修改各节点的 <code>next</code> 引用指向。</p>
<p><code>recur(cur, pre)</code> 递归函数：</p>
<ol>
<li>终止条件：当 <code>cur</code> 为空，则返回尾节点 <code>pre</code> （即反转链表的头节点）；</li>
<li>递归后继节点，记录返回值（即反转链表的头节点）为 <code>res</code> ；</li>
<li>修改当前节点 <code>cur</code> 引用指向前驱节点 <code>pre</code> ；</li>
<li>返回反转链表的头节点 <code>res</code> ；</li>
</ol>
<p><code>reverseList(head)</code> 函数：</p>
<p>调用并返回 <code>recur(head, null)</code> 。传入 <code>null</code> 是因为反转链表后， <code>head</code> 节点指向 <code>null</code> ；</p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度 *O*(*N*) ：</strong> 遍历链表使用线性大小时间。</li>
<li><strong>空间复杂度 *O*(*N*) ：</strong> 遍历链表的递归深度达到 <em>N</em> ，系统使用 <em>O</em>(<em>N</em>) 大小额外空间。</li>
</ul>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142128759.png" alt="Picture14.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142128953.png" alt="Picture15.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142128495.png" alt="Picture16.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142128931.png" alt="Picture17.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142128635.png" alt="Picture18.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142128734.png" alt="Picture19.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142128377.png" alt="Picture20.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142129053.png" alt="Picture21.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142129498.png" alt="Picture22.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142129872.png" alt="Picture23.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142129925.png" alt="Picture24.png" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212142130717.png" alt="Picture25.png" style="zoom:50%;" />

<h3 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a><strong>Python</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">recur</span>(<span class="params">cur, pre</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> pre     <span class="comment"># 终止条件</span></span><br><span class="line">            res = recur(cur.<span class="built_in">next</span>, cur) <span class="comment"># 递归后继节点</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre             <span class="comment"># 修改节点引用指向</span></span><br><span class="line">            <span class="keyword">return</span> res                 <span class="comment"># 返回反转链表的头节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> recur(head, <span class="literal">None</span>)       <span class="comment"># 调用递归并返回</span></span><br></pre></td></tr></table></figure>

<h3 id="Java-1"><a href="#Java-1" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> recur(head, <span class="literal">null</span>);    <span class="comment">// 调用递归并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">recur</span><span class="params">(ListNode cur, ListNode pre)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span> pre; <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> recur(cur.next, cur);  <span class="comment">// 递归后继节点</span></span><br><span class="line">        cur.next = pre;              <span class="comment">// 修改节点引用指向</span></span><br><span class="line">        <span class="keyword">return</span> res;                  <span class="comment">// 返回反转链表的头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>链表（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 11. 旋转数组的最小数字</title>
    <url>/posts/24641d137663/</url>
    <content><![CDATA[<h1 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a><a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">11. 旋转数组的最小数字</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>

<p>给你一个可能存在&nbsp;<strong>重复</strong>&nbsp;元素值的数组&nbsp;<code>numbers</code>&nbsp;，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组&nbsp;<code>[3,4,5,1,2]</code> 为 <code>[1,2,3,4,5]</code> 的一次旋转，该数组的最小值为1。&nbsp;&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>[3,4,5,1,2]
<strong>输出：</strong>1
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>[2,2,2,0,1]
<strong>输出：</strong>0
</pre>

<p>注意：本题与主站 154 题相同：<a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/</a></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>如下图所示，寻找旋转数组的最小元素即为寻找 <strong>右排序数组</strong> 的首个元素 <em>nums[x]</em> ，称 <em>x</em> 为 <strong>旋转点</strong> 。</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211757006.png" alt="Picture1.png" style="zoom:50%;" />

<p>排序数组的查找问题首先考虑使用 <strong>二分法</strong> 解决，其可将 <strong>遍历法</strong> 的 <strong>线性级别</strong> 时间复杂度降低至 <strong>对数级别</strong> </p>
<h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h3><ol>
<li><strong>初始化：</strong> 声明 l, r双指针分别指向 numbers 数组左右两端；</li>
<li><strong>循环二分：</strong> 设 <em>m</em>=(<em>l</em>+<em>r</em>)/2 为每次二分的中点（ “<code>/</code>“ 代表向下取整除法，因此恒有 <em>l≤m&lt;r</em> ），可分为以下三种情况：<ol>
<li><strong>当 numbers[m] &gt; numbers[r]时：</strong> <em>m</em> 一定在 左排序数组 中，即旋转点 <em>x</em> 一定在 [<em>m</em>+1,<em>r</em>] 闭区间内，因此执行 <em>l</em>=<em>m</em>+1；</li>
<li><strong>当 numbers[m] &lt; numbers[r] 时：</strong> <em>m</em> 一定在 右排序数组 中，即旋转点 <em>x</em> 一定在[<em>l</em>,<em>m</em>] 闭区间内，因此执行 <em>r</em>=<em>m</em>；</li>
<li><strong>当 numbers[m] = numbers[r] 时：</strong> 无法判断 <em>m</em> 在哪个排序数组中，即无法判断旋转点 <em>x</em> 在 [<em>l</em>,<em>m</em>] 还是 [<em>m</em>+1,<em>r</em>] 区间中。<strong>解决方案：</strong> 执行 <em>r–</em> 缩小右侧判断范围。</li>
</ol>
</li>
<li><strong>返回值：</strong> 当 <em>l=r</em> 时跳出二分循环，并返回 <strong>旋转点的值</strong> <em>numbers[l]</em> 即可。</li>
</ol>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211757867.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211757164.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211757321.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211757589.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211757223.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211757489.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211757584.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211757885.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211757147.png" alt="img" style="zoom:50%;" />



<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h3><ul>
<li>时间复杂度：平均时间复杂度为 *O(logn)*，其中 <em>n</em> 是数组 <em>numbers</em> 的长度。如果数组是随机生成的，那么数组中包含相同元素的概率很低，在二分查找的过程中，大部分情况都会忽略一半的区间。而在最坏情况下，如果数组中的元素完全相同，那么 while 循环就需要执行 <em>n</em> 次，每次忽略区间的右端点，时间复杂度为 <em>O</em>(<em>n</em>)。</li>
<li>空间复杂度：<em>O</em>(1)。</li>
</ul>
<!-- tabs:start -->

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><p>二分法。O(logn)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (numbers[m] &gt; numbers[r]) &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numbers[m] &lt; numbers[r]) &#123;</span><br><span class="line">                r = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针查找，也类似于暴力法了，只不过暴力法是全部从头到尾比较。这个是两端同时比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 假设第一个是最小的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            min = Math.min(min, Math.min(numbers[l++], numbers[r--]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>查找算法（中等）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 06. 从尾到头打印链表</title>
    <url>/posts/b98a71611496/</url>
    <content><![CDATA[<h1 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06. 从尾到头打印链表"></a><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">06. 从尾到头打印链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>head = [1,3,2]
<strong>输出：</strong>[2,3,1]</pre>

<p>&nbsp;</p>

<p><strong>限制：</strong></p>

<p><code>0 &lt;= 链表长度 &lt;= 10000</code></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>该题需要将链表转换为数组，且需要反向。由于目标是链表，无法第一时间得知长度，声明等长数组。</p>
<p>解题方案：</p>
<ul>
<li>遍历<ul>
<li>  从头到尾遍链表，获取链表长度，声明等长数组；</li>
<li>  再次遍历并放入数组当中，在数组中的放置顺序是从尾到头。</li>
</ul>
</li>
<li>递归<ul>
<li>  记录深度，递归到链表尾部；</li>
<li>  将深度化为数组长度，将回溯结果正序放入数组当中。</li>
</ul>
</li>
<li>动态数组<ul>
<li>  遍历链表，将元素放入数组当中；</li>
<li>  遍历结束，将数组倒置后返回（<code>reverse()</code>）。</li>
</ul>
</li>
</ul>
<!-- tabs:start -->

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            ans.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> ans[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><p>栈实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (; head != <span class="literal">null</span>; head = head.next) &#123;</span><br><span class="line">            stk.push(head.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[stk.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk.isEmpty()) &#123;</span><br><span class="line">            ans[i++] = stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组实现：</p>
<p>先计算链表长度 n，然后创建一个长度为 n 的结果数组。最后遍历链表，依次将节点值存放在数组上（从后往前）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算元素个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; cur != <span class="literal">null</span>; cur = cur.next, ++n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个长度为 n 的结果数组</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后遍历链表，依次将节点值从后往前存放在数组上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head; cur != <span class="literal">null</span>; cur = cur.next) &#123;</span><br><span class="line">            ans[--n] = cur.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>链表（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 30. 包含 min 函数的栈</title>
    <url>/posts/8990a14182a5/</url>
    <content><![CDATA[<h1 id="30-包含-min-函数的栈"><a href="#30-包含-min-函数的栈" class="headerlink" title="30. 包含 min 函数的栈"></a><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/">30. 包含 min 函数的栈</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>

<p>&nbsp;</p>

<p><strong>示例:</strong></p>

<pre>MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --&gt; 返回 -3.
minStack.pop();
minStack.top();      --&gt; 返回 0.
minStack.min();   --&gt; 返回 -2.
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ol>
    <li>各函数的调用总次数不超过 20000 次</li>
</ol>

<p>&nbsp;</p>

<p>注意：本题与主站 155 题相同：<a href="https://leetcode.cn/problems/min-stack/">https://leetcode.cn/problems/min-stack/</a></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p><strong>方法一：双栈</strong></p>
<p>我们用两个栈来实现，其中<code>stk1</code> 用来存储数据，<code>stk2</code> 用来存储当前栈中的最小值。初始时，<code>stk2</code> 中存储一个极大值。</p>
<ul>
<li>  当我们向栈中压入一个元素 <code>x</code> 时，我们将 <code>x</code> 压入 <code>stk1</code>，并将 <code>min(x, stk2[-1])</code> 压入 <code>stk2</code>。</li>
<li>  当我们从栈中弹出一个元素时，我们将 <code>stk1</code> 和 <code>stk2</code> 的栈顶元素都弹出。</li>
<li>  当我们要获取当前栈中的栈顶元素时，我们只需要返回 <code>stk1</code> 的栈顶元素即可。</li>
<li>  当我们要获取当前栈中的最小值时，我们只需要返回 <code>stk2</code> 的栈顶元素即可。</li>
</ul>
<p>时间复杂度：对于每个操作，时间复杂度均为 $O(1)$，空间复杂度 $O(n)$。</p>
<!-- tabs:start -->
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><!-- 这里可写当前语言的特殊实现逻辑 -->

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正的存数据</span></span><br><span class="line">    Deque&lt;Integer&gt; xStack;</span><br><span class="line">    <span class="comment">// 存最小值</span></span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * initialize your data structure here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        xStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 默认存最小值的那个栈里有一个初始值。</span></span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次push 的时候都要xStack里存数据，</span></span><br><span class="line">    <span class="comment">// 同时也要往minStack里存数据，存的时候比较一下与上一个数据的大小，取小的存入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        xStack.push(x);</span><br><span class="line">        minStack.push(Math.min(minStack.peek(), x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时pop</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        xStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> xStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><!-- 这里可写当前语言的特殊实现逻辑 -->

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.s = []</span><br><span class="line">        self.mins = [inf]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.s.append(val)</span><br><span class="line">        self.mins.append(<span class="built_in">min</span>(self.mins[-<span class="number">1</span>], val))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.s.pop()</span><br><span class="line">        self.mins.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.s[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMin</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.mins[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(val)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.getMin()</span></span><br></pre></td></tr></table></figure>


<h3 id="C"><a href="#C" class="headerlink" title="C++"></a><strong>C++</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        stk2.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stk1.<span class="built_in">push</span>(x);</span><br><span class="line">        stk2.<span class="built_in">push</span>(<span class="built_in">min</span>(x, stk2.<span class="built_in">top</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk1.<span class="built_in">pop</span>();</span><br><span class="line">        stk2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk1.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk2.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack* obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj-&gt;getMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a><strong>TypeScript</strong></h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="attr">stack</span>: <span class="built_in">number</span>[];</span><br><span class="line">    <span class="attr">mins</span>: <span class="built_in">number</span>[];</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">mins</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">push</span>(<span class="attr">x</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">push</span>(x);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">mins</span>.<span class="title function_">push</span>(<span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="variable language_">this</span>.<span class="title function_">getMin</span>(), x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">pop</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack</span>.<span class="title function_">pop</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">mins</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">top</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack</span>[<span class="variable language_">this</span>.<span class="property">stack</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getMin</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">mins</span>.<span class="property">length</span> == <span class="number">0</span></span><br><span class="line">            ? <span class="title class_">Infinity</span></span><br><span class="line">            : <span class="variable language_">this</span>.<span class="property">mins</span>[<span class="variable language_">this</span>.<span class="property">mins</span>.<span class="property">length</span> - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MinStack()</span></span><br><span class="line"><span class="comment"> * obj.push(x)</span></span><br><span class="line"><span class="comment"> * obj.pop()</span></span><br><span class="line"><span class="comment"> * var param_3 = obj.top()</span></span><br><span class="line"><span class="comment"> * var param_4 = obj.getMin()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a><strong>Go</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	stk1 []<span class="type">int</span></span><br><span class="line">	stk2 []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MinStack &#123;</span><br><span class="line">	<span class="keyword">return</span> MinStack&#123;[]<span class="type">int</span>&#123;&#125;, []<span class="type">int</span>&#123;math.MaxInt32&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">	this.stk1 = <span class="built_in">append</span>(this.stk1, x)</span><br><span class="line">	this.stk2 = <span class="built_in">append</span>(this.stk2, min(x, this.stk2[<span class="built_in">len</span>(this.stk2)<span class="number">-1</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Pop() &#123;</span><br><span class="line">	this.stk1 = this.stk1[:<span class="built_in">len</span>(this.stk1)<span class="number">-1</span>]</span><br><span class="line">	this.stk2 = this.stk2[:<span class="built_in">len</span>(this.stk2)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.stk1[<span class="built_in">len</span>(this.stk1)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> GetMin() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.stk2[<span class="built_in">len</span>(this.stk2)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Top();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.GetMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a><strong>Rust</strong></h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::VecDeque;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    stack: VecDeque&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">    min_stack: VecDeque&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `&amp;self` means the method takes an immutable reference.</span></span><br><span class="line"><span class="comment"> * If you need a mutable reference, change it to `&amp;mut self` instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; stack: VecDeque::<span class="title function_ invoke__">new</span>(), min_stack: VecDeque::<span class="title function_ invoke__">new</span>() &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">push</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, x: <span class="type">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.stack.<span class="title function_ invoke__">push_back</span>(x);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.min_stack.<span class="title function_ invoke__">is_empty</span>() || *<span class="keyword">self</span>.min_stack.<span class="title function_ invoke__">back</span>().<span class="title function_ invoke__">unwrap</span>() &gt;= x &#123;</span><br><span class="line">            <span class="keyword">self</span>.min_stack.<span class="title function_ invoke__">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">pop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">val</span> = <span class="keyword">self</span>.stack.<span class="title function_ invoke__">pop_back</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> *<span class="keyword">self</span>.min_stack.<span class="title function_ invoke__">back</span>().<span class="title function_ invoke__">unwrap</span>() == val &#123;</span><br><span class="line">            <span class="keyword">self</span>.min_stack.<span class="title function_ invoke__">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">top</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        *<span class="keyword">self</span>.stack.<span class="title function_ invoke__">back</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_min</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        *<span class="keyword">self</span>.min_stack.<span class="title function_ invoke__">back</span>().<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * let obj = MinStack::new();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * obj.pop();</span></span><br><span class="line"><span class="comment"> * let ret_3: i32 = obj.top();</span></span><br><span class="line"><span class="comment"> * let ret_4: i32 = obj.get_min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a><strong>C#</strong></h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;<span class="built_in">int</span>&gt; stk1 = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;<span class="built_in">int</span>&gt; stk2 = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span>()</span> &#123;</span><br><span class="line">        stk2.Push(<span class="built_in">int</span>.MaxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params"><span class="built_in">int</span> x</span>)</span> &#123;</span><br><span class="line">        stk1.Push(x);</span><br><span class="line">        stk2.Push(Math.Min(x, GetMin()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Pop</span>()</span> &#123;</span><br><span class="line">        stk1.Pop();</span><br><span class="line">        stk2.Pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Top</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stk1.Peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">GetMin</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stk2.Peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MinStack obj = new MinStack();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * obj.Pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.Top();</span></span><br><span class="line"><span class="comment"> * int param_4 = obj.GetMin();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="…"><a href="#…" class="headerlink" title="…"></a><strong>…</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>栈与队列（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 50. 第一个只出现一次的字符</title>
    <url>/posts/b5656c44341b/</url>
    <content><![CDATA[<h1 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50. 第一个只出现一次的字符"></a><a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/">50. 第一个只出现一次的字符</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>

<p><strong>示例 1:</strong></p>

<pre>
输入：s = "abaccdeff"
输出：'b'
</pre>

<p><strong>示例 2:</strong></p>

<pre>
输入：s = "" 
输出：' '
</pre>

<p>&nbsp;</p>

<p><strong>限制：</strong></p>

<p><code>0 &lt;= s 的长度 &lt;= 50000</code></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>对字符串进行两次遍历：</p>
<p>第一遍，使用 hash 表（或数组）统计字符串中每个字符出现的次数。</p>
<p>第二遍，只要遍历到一个只出现一次的字符，那么就返回该字符，否则在遍历结束后，返回 <code>&#39; &#39;</code>。</p>
<p>三种方式：</p>
<ol>
<li>普通哈希表</li>
<li>有序哈希表</li>
<li>数组+集合 <em>效率最快</em></li>
</ol>
<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><h4 id="普通哈希表"><a href="#普通哈希表" class="headerlink" title="普通哈希表"></a>普通哈希表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sc) &#123;</span><br><span class="line">            map.put(c, !map.containsKey(c));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="有序哈希表"><a href="#有序哈希表" class="headerlink" title="有序哈希表"></a>有序哈希表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 有序哈希表，</span></span><br><span class="line">        Map&lt;Character, Boolean&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="comment">// 第一遍记录 每个元素是否只出现一次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sc) &#123;</span><br><span class="line">            map.put(c, !map.containsKey(c));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到第一个出现1次的</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Boolean&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue()) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="数组-集合-效率最快"><a href="#数组-集合-效率最快" class="headerlink" title="数组+集合 效率最快"></a>数组+集合 <em>效率最快</em></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 数组 + 集合</span></span><br><span class="line">        <span class="type">int</span>[] letters = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 如果是第一次出现，就加入到集合中，</span></span><br><span class="line">            <span class="keyword">if</span> (letters[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                list.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 出现次数+1</span></span><br><span class="line">            letters[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Character c : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (letters[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>查找算法（中等）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 35. 复杂链表的复制</title>
    <url>/posts/e1b7ae9b2bdb/</url>
    <content><![CDATA[<h1 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制"></a><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/">35. 复杂链表的复制</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><!-- 这里写题目描述 -->

<p>请实现 <code>copyRandomList</code> 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 <code>next</code> 指针指向下一个节点，还有一个 <code>random</code> 指针指向链表中的任意节点或者 <code>null</code>。</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211812767.png" style="zoom:50%;" />

<pre><strong>输入：</strong>head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
<strong>输出：</strong>[[7,null],[13,0],[11,4],[10,2],[1,0]]
</pre>
<p><strong>示例 2：</strong></p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211812814.png" style="zoom:50%;" />

<pre><strong>输入：</strong>head = [[1,1],[2,1]]
<strong>输出：</strong>[[1,1],[2,1]]
</pre>
<p><strong>示例 3：</strong></p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211812551.png" style="zoom:50%;" />

<pre><strong>输入：</strong>head = [[3,null],[3,0],[3,null]]
<strong>输出：</strong>[[3,null],[3,0],[3,null]]
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>head = []
<strong>输出：</strong>[]
<strong>解释：</strong>给定的链表为空（空指针），因此返回 null。
</pre>

<p>&nbsp;</p>

<p><strong>提示：</strong></p>

<ul>
    <li><code>-10000 &lt;= Node.val &lt;= 10000</code></li>
    <li><code>Node.random</code>&nbsp;为空（null）或指向链表中的节点。</li>
    <li>节点数目不超过 1000 。</li>
</ul>

<p>&nbsp;</p>

<p><strong>注意：</strong>本题与主站 138 题相同：<a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">https://leetcode.cn/problems/copy-list-with-random-pointer/</a></p>

<p>&nbsp;</p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>  相比正常的克隆链表，多了一步操作，克隆随机指针。</li>
<li>  随机指针并不是读取时进行随机指向，而是没有规律。但可以确定的是，随机指向的对象都是现存的节点或 <code>null</code>。</li>
<li>  而难点在于克隆随机指针，如克隆链表头节点时，随机指针指向链尾，而链尾还未创造出来。</li>
<li>  对此，需要先完成链表的基础克隆，再回头关注随机指针。</li>
</ul>
<h2 id="方法一：遍历-哈希表"><a href="#方法一：遍历-哈希表" class="headerlink" title="方法一：遍历 + 哈希表"></a>方法一：遍历 + 哈希表</h2><ul>
<li>  使用哈希表记录所有节点， <code>key</code> 为原节点，<code>value</code> 为克隆节点。</li>
<li>  遍历链表，完成旧节点与新节点的对应关系，哈希表中新节点暂时只克隆 <code>val</code>。</li>
<li>  再次遍历，完善新节点的 <code>next</code> 与 <code>random</code>。</li>
</ul>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>时间复杂度：*O(n)*，其中 <em>n</em> 是链表的长度。对于每个节点，我们至多访问其「后继节点」和「随机指针指向的节点」各一次，均摊每个点至多被访问两次。</p>
<p>空间复杂度：*O(n)*，其中 <em>n</em> 是链表的长度。为哈希表的空间开销。</p>
<p>第一步：遍历链表，记录新旧节点映射</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211812731.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211813719.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211813718.png" alt="img" style="zoom:50%;" />

<p>省略……</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211813101.png" alt="img" style="zoom:50%;" />

<p>第二步：完善新节点的next和random</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211813828.png" alt="img" style="zoom:50%;" />

<p>省略……</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211813880.png" alt="img" style="zoom:50%;" />

<p>第三步：返回新链表</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211813223.png" alt="img" style="zoom:50%;" />



<!-- tabs:start -->



<h3 id="java"><a href="#java" class="headerlink" title="java"></a><strong>java</strong></h3><h4 id="递归-哈希表"><a href="#递归-哈希表" class="headerlink" title="递归+哈希表"></a>递归+哈希表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Node, Node&gt; cachedNode = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!cachedNode.containsKey(head)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">headNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">            cachedNode.put(head, headNew);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            headNew.next = copyRandomList(head.next);</span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            headNew.random = copyRandomList(head.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cachedNode.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="遍历-哈希表"><a href="#遍历-哈希表" class="headerlink" title="遍历+哈希表"></a>遍历+哈希表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Node, Node&gt; copy = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立新旧链表节点映射</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            copy.put(temp, <span class="keyword">new</span> <span class="title class_">Node</span>(temp.val));</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建新链表的 next 和 random 指向</span></span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            copy.get(temp).next = copy.get(temp.next);</span><br><span class="line">            copy.get(temp).random = copy.get(temp.random);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回新链表的头节点</span></span><br><span class="line">        <span class="keyword">return</span> copy.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->

<h2 id="方法二：迭代-节点拆分"><a href="#方法二：迭代-节点拆分" class="headerlink" title="方法二：迭代 + 节点拆分"></a>方法二：迭代 + 节点拆分</h2><ul>
<li><p>首先，遍历链表，完成对每个旧节点的复制。</p>
</li>
<li><blockquote>
<p>A -&gt; B -&gt; C -&gt; D -&gt; null</p>
<p>=&gt;</p>
<p>A -&gt; A1 -&gt; B -&gt; B1 -&gt; C -&gt; C1 -&gt; D -&gt; D1 -&gt; null</p>
</blockquote>
</li>
<li><p>接着设置新节点的 <code>random</code> 指针。</p>
</li>
<li><p>然后遍历链表，修改旧节点和新节点的指向，将旧节点指向下一个旧节点，而新节点指向下一个新节点。</p>
</li>
<li><p>最后返回第一个新节点即可。</p>
</li>
</ul>
<h3 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p>时间复杂度 <em>O(N)</em> ： 三轮遍历链表，使用 <em>O(N)</em> 时间。</p>
<p>空间复杂度 <em>O(1)</em> ： 节点引用变量使用常数大小的额外空间。</p>
<p>第一步：遍历链表，完成对每个旧节点的复制。</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211813041.png" alt="img" style="zoom:50%;" />

<p>第二步：设置新节点的 <code>random</code> 指针。</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211813296.png" alt="img" style="zoom:50%;" />

<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211813700.png" alt="img" style="zoom:50%;" />

<p>省略……</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211813883.png" alt="img" style="zoom:50%;" />

<p>第三步：遍历链表，修改旧节点和新节点的指向，将旧节点指向下一个旧节点，而新节点指向下一个新节点。实现拆分</p>
<img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/202212211813218.png" alt="img" style="zoom:50%;" />



<!-- tabs:start -->

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 1. 复制各节点，并构建拼接链表</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val);<span class="comment">// 创建一个新节点，val等于当前cur</span></span><br><span class="line">            <span class="comment">// 将新节点插入到cur节点和cur.next节点之间，这两部之后就变成了 cur-&gt;tmp-&gt;next</span></span><br><span class="line">            tmp.next = cur.next;</span><br><span class="line">            cur.next = tmp;</span><br><span class="line">            <span class="comment">// 当前节点后移，移动到它原本的下一个节点处，也就是现在tmp.next</span></span><br><span class="line">            cur = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 构建各新节点的 random 指向</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 每一个cur.next 就是新节点，</span></span><br><span class="line">            <span class="keyword">if</span>(cur.random != <span class="literal">null</span>)</span><br><span class="line">                cur.next.random = cur.random.next;</span><br><span class="line">            cur = cur.next.next;<span class="comment">// 当前节点后移，移动到它原本的下一个节点处</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 拆分两链表</span></span><br><span class="line">        cur = head.next; <span class="comment">// 此时的cur就是新节点，</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> head, res = head.next;<span class="comment">// pre是旧节点，res是新节点的头</span></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span>) &#123;<span class="comment">// 判断还有旧节点，</span></span><br><span class="line">            pre.next = pre.next.next;<span class="comment">// 旧节点依旧指向旧节点</span></span><br><span class="line">            cur.next = cur.next.next;<span class="comment">// 新节点指向新节点</span></span><br><span class="line">            <span class="comment">// 新旧节点都往后移</span></span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = <span class="literal">null</span>; <span class="comment">// 单独处理原链表尾节点</span></span><br><span class="line">        <span class="keyword">return</span> res;      <span class="comment">// 返回新链表头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>链表（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 09. 用两个栈实现队列</title>
    <url>/posts/e2f731180db2/</url>
    <content><![CDATA[<h1 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09. 用两个栈实现队列"></a><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">09. 用两个栈实现队列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code> ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，<code>deleteHead</code>&nbsp;操作返回 -1 )</p>

<p>&nbsp;</p>

<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>
[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]
[[],[3],[],[]]
<strong>输出：</strong>[null,null,3,-1]
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>
[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]
[[],[],[5],[2],[],[]]
<strong>输出：</strong>[null,-1,null,null,5,2]
</pre>

<p><strong>提示：</strong></p>

<ul>
    <li><code>1 &lt;= values &lt;= 10000</code></li>
    <li><code>最多会对&nbsp;appendTail、deleteHead 进行&nbsp;10000&nbsp;次调用</code></li>
</ul>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ul>
<li>  两个栈，一个负责<strong>输入</strong>，一个负责<strong>输出</strong>；</li>
<li>  执行输入时，只放入输入栈中；</li>
<li>  执行输出时，将输入栈的所有元素依次出栈，放入输出栈中；</li>
<li>  根据栈的特点，处于输入栈<strong>栈底</strong>的元素，在输出栈中便是<strong>栈顶</strong>；</li>
<li>  只有输出栈中没有元素时才进行倒放，而非每一次。</li>
</ul>
<!-- tabs:start -->

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    <span class="comment">// 负责进</span></span><br><span class="line">    Deque&lt;Integer&gt; s1;</span><br><span class="line">    <span class="comment">// 负责出</span></span><br><span class="line">    Deque&lt;Integer&gt; s2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        s1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        s2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        s1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果s2没数据，就将s1里的数据取出放到s2中，</span></span><br><span class="line">        <span class="keyword">if</span> (s2.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// s1里面也是空的，说明从没添加过元素，所以返回-1</span></span><br><span class="line">            <span class="keyword">if</span> (s1.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将s1里的数据取出放到s2中;</span></span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty()) &#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 然后s2.pop()</span></span><br><span class="line">        <span class="keyword">return</span> s2.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.stk1 = []</span><br><span class="line">        self.stk2 = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">appendTail</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.stk1.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteHead</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stk2:</span><br><span class="line">            <span class="keyword">while</span> self.stk1:</span><br><span class="line">                self.stk2.append(self.stk1.pop())</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> self.stk2 <span class="keyword">else</span> self.stk2.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = CQueue()</span></span><br><span class="line"><span class="comment"># obj.appendTail(value)</span></span><br><span class="line"><span class="comment"># param_2 = obj.deleteHead()</span></span><br></pre></td></tr></table></figure>


<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><strong>JavaScript</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CQueue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stk1</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stk2</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">CQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">appendTail</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stk1</span>.<span class="title function_">push</span>(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">CQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">deleteHead</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">stk2</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">stk1</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">stk2</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">stk1</span>.<span class="title function_">pop</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stk2</span>.<span class="property">length</span> ? <span class="variable language_">this</span>.<span class="property">stk2</span>.<span class="title function_">pop</span>() : -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new CQueue()</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.deleteHead()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a><strong>Go</strong></h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	stk1 []<span class="type">int</span></span><br><span class="line">	stk2 []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> CQueue &#123;</span><br><span class="line">	<span class="keyword">return</span> CQueue&#123;stk1: []<span class="type">int</span>&#123;&#125;, stk2: []<span class="type">int</span>&#123;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CQueue)</span></span> AppendTail(value <span class="type">int</span>) &#123;</span><br><span class="line">	this.stk1 = <span class="built_in">append</span>(this.stk1, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CQueue)</span></span> DeleteHead() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(this.stk2) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(this.stk1) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			this.stk2 = <span class="built_in">append</span>(this.stk2, this.stk1[<span class="built_in">len</span>(this.stk1)<span class="number">-1</span>])</span><br><span class="line">			this.stk1 = this.stk1[<span class="number">0</span> : <span class="built_in">len</span>(this.stk1)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(this.stk2) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	ans := this.stk2[<span class="built_in">len</span>(this.stk2)<span class="number">-1</span>]</span><br><span class="line">	this.stk2 = this.stk2[<span class="number">0</span> : <span class="built_in">len</span>(this.stk2)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.AppendTail(value);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.DeleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C++"></a><strong>C++</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> head = s2.<span class="built_in">top</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a><strong>TypeScript</strong></h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">stack1</span>: <span class="built_in">number</span>[];</span><br><span class="line">    <span class="keyword">private</span> <span class="attr">stack2</span>: <span class="built_in">number</span>[];</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack1</span> = [];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack2</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">appendTail</span>(<span class="attr">value</span>: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="title function_">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">move</span>(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="property">length</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">stack1</span>.<span class="title function_">pop</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">deleteHead</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="property">length</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">move</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="property">length</span> == <span class="number">0</span> ? -<span class="number">1</span> : <span class="variable language_">this</span>.<span class="property">stack2</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new CQueue()</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.deleteHead()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a><strong>Rust</strong></h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    s1: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;,</span><br><span class="line">    s2: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * `&amp;self` means the method takes an immutable reference.</span></span><br><span class="line"><span class="comment"> * If you need a mutable reference, change it to `&amp;mut self` instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        CQueue &#123;</span><br><span class="line">            s1: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            s2: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">append_tail</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="type">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.s1.<span class="title function_ invoke__">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">delete_head</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.s2.<span class="title function_ invoke__">pop</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(value) =&gt; value,</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                <span class="keyword">while</span> !<span class="keyword">self</span>.s1.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">                    <span class="keyword">self</span>.s2.<span class="title function_ invoke__">push</span>(<span class="keyword">self</span>.s1.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">self</span>.s2.<span class="title function_ invoke__">pop</span>().<span class="title function_ invoke__">unwrap_or</span>(-<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * let obj = CQueue::new();</span></span><br><span class="line"><span class="comment"> * obj.append_tail(value);</span></span><br><span class="line"><span class="comment"> * let ret_2: i32 = obj.delete_head();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a><strong>C#</strong></h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;<span class="built_in">int</span>&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;<span class="built_in">int</span>&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span>()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AppendTail</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">        stack1.Push(<span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">DeleteHead</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.Count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack1.Count != <span class="number">0</span>) &#123;</span><br><span class="line">                stack2.Push(stack1.Pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.Count == <span class="number">0</span> ? <span class="number">-1</span> : stack2.Pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.AppendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.DeleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="…"><a href="#…" class="headerlink" title="…"></a><strong>…</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>栈与队列（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 53 - II. 0～n-1中缺失的数字</title>
    <url>/posts/a3f28eeb7714/</url>
    <content><![CDATA[<h1 id="面试题-53-II-0-～-n-1-中缺失的数字"><a href="#面试题-53-II-0-～-n-1-中缺失的数字" class="headerlink" title="面试题 53 - II. 0 ～ n-1 中缺失的数字"></a><a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">面试题 53 - II. 0 ～ n-1 中缺失的数字</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>

<p>&nbsp;</p>

<p><strong>示例 1:</strong></p>

<pre><strong>输入:</strong> [0,1,3]
<strong>输出:</strong> 2
</pre>

<p><strong>示例&nbsp;2:</strong></p>

<pre><strong>输入:</strong> [0,1,2,3,4,5,6,7,9]
<strong>输出:</strong> 8</pre>

<p>&nbsp;</p>

<p><strong>限制：</strong></p>

<p><code>1 &lt;= 数组长度 &lt;= 10000</code></p>

<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>二分法。</p>
<!-- tabs:start -->

<h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a><strong>Java</strong></h3><p>暴力法，遍历数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 从左到右依次遍历比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 只要不相等，肯定是左边出了问题，因为从左往右是升序，</span></span><br><span class="line">            <span class="keyword">if</span> (nums[m] != m) &#123;</span><br><span class="line">                r = m - <span class="number">1</span>; <span class="comment">// 将右边界左移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>; <span class="comment">// 将左边界右移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Python3"><a href="#Python3" class="headerlink" title="Python3"></a><strong>Python3</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">missingNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">0</span> <span class="keyword">or</span> nums[<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] ^ <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[r] == r:</span><br><span class="line">            <span class="keyword">return</span> r + <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r - l &gt; <span class="number">1</span>:</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == m:</span><br><span class="line">                l = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m</span><br><span class="line">        <span class="keyword">return</span> nums[r] - <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a><strong>JavaScript</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> missingNumber = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums || !nums.<span class="property">length</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + ~~((right - left) / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] !== mid) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left] === left ? nums.<span class="property">length</span> : left;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="C"><a href="#C" class="headerlink" title="C++"></a><strong>C++</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">missingNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == mid) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a><strong>Rust</strong></h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">missing_number</span>(nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">n</span> = nums.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sum</span> = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">num</span> <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            sum -= num;</span><br><span class="line">        &#125;</span><br><span class="line">        sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">missing_number</span>(nums: <span class="type">Vec</span>&lt;<span class="type">i32</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">prev</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> &amp;num <span class="keyword">in</span> nums.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> prev != num &#123;</span><br><span class="line">                <span class="keyword">return</span> prev;</span><br><span class="line">            &#125;</span><br><span class="line">            prev += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prev</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a><strong>C#</strong></h3><figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">MissingNumber</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> l = <span class="number">0</span>, r = nums.Length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span> || nums[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] ^ <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[r] == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="built_in">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == mid) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="…"><a href="#…" class="headerlink" title="…"></a><strong>…</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<!-- tabs:end -->
]]></content>
      <categories>
        <category>剑指 Offer（第 2 版）</category>
        <category>查找算法（简单）</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>剑指 Offer</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8新特性Stream详细教程</title>
    <url>/posts/a2f79d6fbc4a/</url>
    <content><![CDATA[<h1 id="1-基本特性"><a href="#1-基本特性" class="headerlink" title="1 基本特性"></a>1 基本特性</h1><p>Java8的API中添加了一个新的特性： 流，即stream。stream是将数组或者集合的元素视为流，流在管道中流动过程中，对数据进行筛选、排序和其他操作。</p>
<h2 id="1-1-流的特性"><a href="#1-1-流的特性" class="headerlink" title="1.1 流的特性"></a>1.1 流的特性</h2><ol>
<li><code>stream</code>不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果；</li>
<li><code>stream</code>不会改变数据源，通常情况下会产生一个新的集合；</li>
<li><code>stream</code>具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</li>
<li>对<code>stream</code>操作分为终端操作和中间操作，那么这两者分别代表什么呢？<br> 终端操作：会消费流，这种操作会产生一个结果的，如果一个流被消费过了，那它就不能被重用的。<br> 中间操作：中间操作会产生另一个流。因此中间操作可以用来创建执行一系列动作的管道。一个特别需要注意的点是:中间操作不是立即发生的。相反，当在中间操作创建的新流上执行完终端操作后，中间操作指定的操作才会发生。所以中间操作是延迟发生的，中间操作的延迟行为主要是让流API能够更加高效地执行。</li>
<li><code>stream</code>不可复用，对一个已经进行过终端操作的流再次调用，会抛出异常。</li>
</ol>
<h2 id="1-2-创建Stream"><a href="#1-2-创建Stream" class="headerlink" title="1.2 创建Stream"></a>1.2 创建Stream</h2><p>通过数组创建流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="comment">//1.通过Arrays.stream</span></span><br><span class="line"> <span class="comment">//1.1基本类型</span></span><br><span class="line"> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">IntStream</span> <span class="variable">intStream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line">    <span class="comment">//1.2引用类型</span></span><br><span class="line">    Student[] studentArr = <span class="keyword">new</span> <span class="title class_">Student</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;s1&quot;</span>,<span class="number">29</span>),<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;s2&quot;</span>,<span class="number">27</span>)&#125;;</span><br><span class="line">    Stream&lt;Student&gt; studentStream = Arrays.stream(studentArr);</span><br><span class="line">    <span class="comment">//2.通过Stream.of</span></span><br><span class="line">    Stream&lt;Integer&gt; stream1 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">5</span>,<span class="number">65</span>);</span><br><span class="line">    <span class="comment">//注意生成的是int[]的流</span></span><br><span class="line">    Stream&lt;<span class="type">int</span>[]&gt; stream2 = Stream.of(arr,arr);</span><br><span class="line">    stream2.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过集合创建流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; strs = Arrays.asList(<span class="string">&quot;11212&quot;</span>,<span class="string">&quot;dfd&quot;</span>,<span class="string">&quot;2323&quot;</span>,<span class="string">&quot;dfhgf&quot;</span>);</span><br><span class="line">    <span class="comment">//创建普通流</span></span><br><span class="line">    Stream&lt;String&gt; stream  = strs.stream();</span><br><span class="line">    <span class="comment">//创建并行流</span></span><br><span class="line">    Stream&lt;String&gt; stream1 = strs.parallelStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-流API详述"><a href="#2-流API详述" class="headerlink" title="2 流API详述"></a>2 流API详述</h1><p>BaseStream是最基础的接口，提供了流的基本功能。</p>
<h2 id="2-1-BaseStream详述"><a href="#2-1-BaseStream详述" class="headerlink" title="2.1 BaseStream详述"></a>2.1 BaseStream详述</h2><p>BaseStream接口源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseStream</span>&lt;T, S <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, S&gt;&gt; <span class="keyword">extends</span> <span class="title class_">AutoCloseable</span> &#123;</span><br><span class="line">     Iterator&lt;T&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">     Spliterator&lt;T&gt; <span class="title function_">spliterator</span><span class="params">()</span>;</span><br><span class="line">     <span class="type">boolean</span> <span class="title function_">isParallel</span><span class="params">()</span>;</span><br><span class="line">     S <span class="title function_">sequential</span><span class="params">()</span>;</span><br><span class="line">     S <span class="title function_">parallel</span><span class="params">()</span>;</span><br><span class="line">     S <span class="title function_">unordered</span><span class="params">()</span>;</span><br><span class="line">     S <span class="title function_">onClose</span><span class="params">(Runnable closeHandler)</span>;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法详解：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XAtb9ZwEnOIsxVKsEC1LctN1HlSCZzpnLdVHzB4SgoYj9cbMSiblayqCQickT7TMxPFviaqyqn6QzZ0A/640" alt="图片"></p>
<h2 id="2-2-Stream详述"><a href="#2-2-Stream详述" class="headerlink" title="2.2 Stream详述"></a>2.2 Stream详述</h2><p>Stream接口的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">filter</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line">    &lt;R&gt; Stream&lt;R&gt; <span class="title function_">map</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends R&gt; mapper)</span>;</span><br><span class="line">    IntStream <span class="title function_">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span>;</span><br><span class="line">    LongStream <span class="title function_">mapToLong</span><span class="params">(ToLongFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span>;</span><br><span class="line">    DoubleStream <span class="title function_">mapToDouble</span><span class="params">(ToDoubleFunction&lt;? <span class="built_in">super</span> T&gt; mapper)</span>;</span><br><span class="line">    &lt;R&gt; Stream&lt;R&gt; <span class="title function_">flatMap</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</span>;</span><br><span class="line">    IntStream <span class="title function_">flatMapToInt</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends IntStream&gt; mapper)</span>;</span><br><span class="line">    LongStream <span class="title function_">flatMapToLong</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends LongStream&gt; mapper)</span>;</span><br><span class="line">    DoubleStream <span class="title function_">flatMapToDouble</span><span class="params">(Function&lt;? <span class="built_in">super</span> T, ? extends DoubleStream&gt; mapper)</span>;</span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">distinct</span><span class="params">()</span>;</span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">()</span>;</span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">sorted</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">peek</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">limit</span><span class="params">(<span class="type">long</span> maxSize)</span>;</span><br><span class="line">    Stream&lt;T&gt; <span class="title function_">skip</span><span class="params">(<span class="type">long</span> n)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">forEachOrdered</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span>;</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br><span class="line">    T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">    &lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity,</span></span><br><span class="line"><span class="params">                 BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator,</span></span><br><span class="line"><span class="params">                 BinaryOperator&lt;U&gt; combiner)</span>;</span><br><span class="line">    &lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator,</span></span><br><span class="line"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span>;</span><br><span class="line">    &lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">min</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">max</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> T&gt; comparator)</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">anyMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">allMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">noneMatch</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)</span>;</span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">findFirst</span><span class="params">()</span>;</span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">findAny</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Static factories</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Builder&lt;T&gt; <span class="title function_">builder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Streams</span>.StreamBuilderImpl&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(Spliterators.&lt;T&gt;emptySpliterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(<span class="keyword">new</span> <span class="title class_">Streams</span>.StreamBuilderImpl&lt;&gt;(t), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;varargs&quot;)</span> <span class="comment">// Creating a stream from an array is safe</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">of</span><span class="params">(T... values)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(f);</span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;T&gt; iterator = <span class="keyword">new</span> <span class="title class_">Iterator</span>&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> (T) Streams.NONE;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">return</span> <span class="variable">t</span> <span class="operator">=</span> (t == Streams.NONE) ? seed : f.apply(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(Spliterators.spliteratorUnknownSize(</span><br><span class="line">                iterator,</span><br><span class="line">                Spliterator.ORDERED | Spliterator.IMMUTABLE), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title function_">generate</span><span class="params">(Supplier&lt;T&gt; s)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(s);</span><br><span class="line">        <span class="keyword">return</span> StreamSupport.stream(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">StreamSpliterators</span>.InfiniteSupplyingSpliterator.OfRef&lt;&gt;(Long.MAX_VALUE, s), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Stream&lt;T&gt; <span class="title function_">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(a);</span><br><span class="line">        Objects.requireNonNull(b);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Spliterator&lt;T&gt; split = <span class="keyword">new</span> <span class="title class_">Streams</span>.ConcatSpliterator.OfRef&lt;&gt;(</span><br><span class="line">                (Spliterator&lt;T&gt;) a.spliterator(), (Spliterator&lt;T&gt;) b.spliterator());</span><br><span class="line">        Stream&lt;T&gt; stream = StreamSupport.stream(split, a.isParallel() || b.isParallel());</span><br><span class="line">        <span class="keyword">return</span> stream.onClose(Streams.composedClose(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对上面的一些重要方法进行描述：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XAtb9ZwEnOIsxVKsEC1LctNcmZnlBWYg9iaUX8wBOIJ3bN1hiaKOY1m2aLtNPFMJsV6B6KkpMsLnGlw/640" alt="图片"></p>
<h2 id="3-1-演示所用数据"><a href="#3-1-演示所用数据" class="headerlink" title="3.1 演示所用数据"></a>3.1 演示所用数据</h2><p>下面创建了一个Person实体类，作为后续的演示数据，Person具有两个属性：name和salary。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> salary)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略get与set方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-2-筛选和匹配"><a href="#3-2-筛选和匹配" class="headerlink" title="3.2 筛选和匹配"></a>3.2 筛选和匹配</h2><p>流的筛选，即filter，是按照一定的规则校验流中的元素，将符合条件的元素提取出来的操作。filter通常要配合collect（收集），将筛选结果收集成一个新的集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; intList = Arrays.asList(<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">    List&lt;Integer&gt; collect = intList.stream().filter(x -&gt; x &gt; <span class="number">7</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预期结果：</span></span><br><span class="line">[<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>引用类型筛选</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Person&gt; collect = personList.stream().filter(x -&gt; x.getSalary() &gt; <span class="number">8000</span>).collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 预期结果：符合条件的实体类的集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>流的匹配，与筛选类似，也是按照规则提取元素，不同的是，匹配返回的是单个元素或单个结果。<br>普通类型筛选</p>
<p>匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 匹配第一个</span></span><br><span class="line">    Optional&lt;Integer&gt; findFirst = list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).findFirst();</span><br><span class="line">    <span class="comment">// 匹配任意（适用于并行流）</span></span><br><span class="line">    Optional&lt;Integer&gt; findAny = list.parallelStream().filter(x -&gt; x &gt; <span class="number">6</span>).findAny();</span><br><span class="line">    <span class="comment">// 是否包含</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> list.stream().anyMatch(x -&gt; x &lt; <span class="number">6</span>);</span><br><span class="line">    System.out.println(findFirst);</span><br><span class="line">    System.out.println(findAny);</span><br><span class="line">    System.out.println(anyMatch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预期结果：</span></span><br><span class="line"><span class="comment">// 1、Optional[7]</span></span><br><span class="line"><span class="comment">// 2、并行流处理，结果不确定</span></span><br><span class="line"><span class="comment">// 3、true</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-聚合"><a href="#3-3-聚合" class="headerlink" title="3.3 聚合"></a>3.3 聚合</h2><p>在stream中，针对流进行计算后得出结果，例如求和、求最值等，这样的操作被称为聚合操作。聚合操作在广义上包含了max、min、count等方法和reduce、collect。</p>
<h3 id="3-3-1-max、min和count"><a href="#3-3-1-max、min和count" class="headerlink" title="3.3.1 max、min和count"></a>3.3.1 max、min和count</h3><p>1、获取String集合中最长的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;adnm&quot;</span>,<span class="string">&quot;admmt&quot;</span>,<span class="string">&quot;pot&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Optional&lt;String&gt; max = list.stream().max(Comparator.comparing(String::length));</span><br><span class="line">    System.out.println(max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预期结果：</span></span><br><span class="line">Optional[admmt]</span><br></pre></td></tr></table></figure>

<p>2、获取Integer集合中的最大值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    Optional&lt;Integer&gt; reduce = list.stream().max(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(reduce);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">Optional[<span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>3、对象集合最值（Person见演示数据）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;a&quot;</span>, <span class="number">4</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;b&quot;</span>, <span class="number">4</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;c&quot;</span>, <span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">    Optional&lt;Person&gt; max = list.stream().max(Comparator.comparingInt(Person::getSalary));</span><br><span class="line">    System.out.println(max.get().getSalary());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：6，最小值将max改为min即可</span></span><br></pre></td></tr></table></figure>

<p>4、count</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).count();</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预期结果：2</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-缩减（reduce）"><a href="#3-3-2-缩减（reduce）" class="headerlink" title="3.3.2 缩减（reduce）"></a>3.3.2 缩减（reduce）</h3><p>顾名思义，缩减操作，就是把一个流缩减成一个值，比如对一个集合求和、求乘积等。</p>
<p>Stream流定义了三个reduce:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line"> <span class="comment">// 方法1</span></span><br><span class="line">    T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">    <span class="comment">// 方法2</span></span><br><span class="line">    Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>;</span><br><span class="line">    <span class="comment">// 方法3</span></span><br><span class="line">    &lt;U&gt; U <span class="title function_">reduce</span><span class="params">(U identity,</span></span><br><span class="line"><span class="params">    BiFunction&lt;U, ? <span class="built_in">super</span> T, U&gt; accumulator,</span></span><br><span class="line"><span class="params">    BinaryOperator&lt;U&gt; combiner)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前两种缩减方式：</p>
<p>第一种缩减方法接收一个BinaryOperator accumulator function（二元累加计算函数）和identity（标示值）为参数，返回值是一个T类型（代表流中的元素类型）的对象。accumulator代表<code>操作两个值并得到结果</code>的函数。identity按照accumulator函数的规则参与计算，假如函数是求和运算，那么函数的求和结果加上identity就是最终结果，假如函数是求乘积运算，那么函数结果乘以identity就是最终结果。</p>
<p>第二种缩减方式不同之处是没有identity，返回值是Optional（JDK8新类，可以存放null）。<br>下面用一些示例来演示前两种reduce的用法：</p>
<p>普通集合求和、求最值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顾名思义，缩减操作，就是把一个流缩减成一个值，比如对一个集合求和、求乘积等。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月18日 17:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReduceDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    普通集合求和、求最值</span></span><br><span class="line">        <span class="comment">// 求和 写法1 推荐</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">sum1</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum1 = &quot;</span> + sum1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求和 写法2</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">sum2</span> <span class="operator">=</span> list.stream().reduce(<span class="number">1</span>, (x, y) -&gt; x + y);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum2 = &quot;</span> + sum2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求积 写法1</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">cheng</span> <span class="operator">=</span> list.stream().reduce(<span class="number">1</span>, (x, y) -&gt; x * y);</span><br><span class="line">        System.out.println(<span class="string">&quot;cheng = &quot;</span> + cheng);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最值 写法1 推荐</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">max</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::max);</span><br><span class="line">        System.out.println(<span class="string">&quot;max = &quot;</span> + max);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最值 写法2</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">max2</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, (x, y) -&gt; x &gt;= y ? x : y);</span><br><span class="line">        System.out.println(<span class="string">&quot;max2 = &quot;</span> + max2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象集合求和、求最值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求和</span></span><br><span class="line">        <span class="comment">// 预期结果：Optional[24900]</span></span><br><span class="line">        System.out.println(personList.stream().map(Person::getSalary).reduce(Integer::sum));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求最值-方式1</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personList.stream().reduce((p1, p2) -&gt; p1.getSalary() &gt; p2.getSalary() ? p1 : p2).get();</span><br><span class="line">        <span class="comment">// 预期结果：Lily:9000</span></span><br><span class="line">        System.out.println(person.getName() + <span class="string">&quot;:&quot;</span> + person.getSalary());</span><br><span class="line">        <span class="comment">// 求最值-方式2</span></span><br><span class="line">        <span class="comment">// 预期结果：Optional[9000]</span></span><br><span class="line">        System.out.println(personList.stream().map(Person::getSalary).reduce(Integer::max));</span><br><span class="line">        <span class="comment">// 求最值-方式3：</span></span><br><span class="line">        System.out.println(personList.stream().max(Comparator.comparingInt(Person::getSalary)).get().getSalary());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种缩减操作</p>
<p>第三种缩减操作接收三个参数：标示值（identity）、二元操作累加器（BiFunction accumulator）、二元组合方法（BinaryOperator&lt;.U&gt; combiner）。其中combiner只用在并行<br>下面用对象集合求和和求最大值的实例来演示第三种缩减操作的用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.stream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顾名思义，缩减操作，就是把一个流缩减成一个值，比如对一个集合求和、求乘积等。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月18日 17:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReduceDemo3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//        对象集合求和、求最值：</span></span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">sum1</span> <span class="operator">=</span> list.stream().reduce(<span class="number">1</span>, (x, p) -&gt; x += p.getSalary(), Integer::sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum1 = &quot;</span> + sum1);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">max1</span> <span class="operator">=</span> list.stream().reduce(<span class="number">100000</span>, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(), Integer::max);</span><br><span class="line">        System.out.println(<span class="string">&quot;max1 = &quot;</span> + max1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面验证一下combiner在串行流中不起作用而在并行流中起作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>));</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>));</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证combiner-串行流</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sumSalary</span> <span class="operator">=</span> personList.stream().reduce(<span class="number">0</span>, (sum, p) -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;accumulator: sum=%s; person=%s\n&quot;</span>, sum, p.getName());</span><br><span class="line">        <span class="keyword">return</span> sum + p.getSalary();</span><br><span class="line">        &#125; , (sum1, sum2) -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;combiner: sum1=%s; sum2=%s\n&quot;</span>, sum1, sum2);</span><br><span class="line">        <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;总和：&quot;</span> + sumSalary);</span><br><span class="line">    <span class="comment">// 输出结果：</span></span><br><span class="line">    <span class="comment">// accumulator: sum=0; person=Tom</span></span><br><span class="line">    <span class="comment">// accumulator: sum=8900; person=Jack</span></span><br><span class="line">    <span class="comment">// accumulator: sum=15900; person=Lily</span></span><br><span class="line">    <span class="comment">// 总和：24900</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证combiner-并行流</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sumSalary2</span> <span class="operator">=</span> personList.parallelStream().reduce(<span class="number">0</span>, (sum, p) -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;accumulator: sum=%s; person=%s\n&quot;</span>, sum, p.getName());</span><br><span class="line">        <span class="keyword">return</span> sum + p.getSalary();</span><br><span class="line">        &#125; , (sum1, sum2) -&gt; &#123;</span><br><span class="line">        System.out.format(<span class="string">&quot;combiner: sum1=%s; sum2=%s\n&quot;</span>, sum1, sum2);</span><br><span class="line">        <span class="keyword">return</span> sum1 + sum2;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">&quot;总和：&quot;</span> + sumSalary2);</span><br><span class="line">    <span class="comment">// 输出结果：</span></span><br><span class="line">    <span class="comment">// accumulator: sum=0; person=Jack</span></span><br><span class="line">    <span class="comment">// accumulator: sum=0; person=Tom</span></span><br><span class="line">    <span class="comment">// accumulator: sum=0; person=Lily</span></span><br><span class="line">    <span class="comment">// combiner: sum1=7000; sum2=9000</span></span><br><span class="line">    <span class="comment">// combiner: sum1=8900; sum2=16000</span></span><br><span class="line">    <span class="comment">// 总和：24900</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面输出结果可见，并行流中，combiner方法被调用，将并行的累加器分别获得的结果组合起来得到最终结果。</p>
<h3 id="3-3-3-收集（collect）"><a href="#3-3-3-收集（collect）" class="headerlink" title="3.3.3 收集（collect）"></a>3.3.3 收集（collect）</h3><p>collect操作可以接受各种方法作为参数，将流中的元素汇集，得到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Stream</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">BaseStream</span>&lt;T, Stream&lt;T&gt;&gt; &#123;</span><br><span class="line">    &lt;R&gt; R <span class="title function_">collect</span><span class="params">(Supplier&lt;R&gt; supplier,BiConsumer&lt;R, ? <span class="built_in">super</span> T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner)</span>;</span><br><span class="line">    &lt;R, A&gt; R <span class="title function_">collect</span><span class="params">(Collector&lt;? <span class="built_in">super</span> T, A, R&gt; collector)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察上面接口定义可知，collect使用Collector作为参数，Collector包含四种不同的操作：supplier（初始构造器）, accumulator（累加器）, combiner（组合器）， finisher（终结者）。实际上，Collectors类内置了很多收集操作。</p>
<h4 id="1、averaging系列"><a href="#1、averaging系列" class="headerlink" title="1、averaging系列"></a>1、averaging系列</h4><p>averagingDouble、averagingInt、averagingLong三个方法处理过程是相同的，都是返回stream的平均值，只是返回结果的类型不同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月19日 11:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SummarizingDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">DoubleSummaryStatistics</span> <span class="variable">sum1</span> <span class="operator">=</span> list.stream().collect(Collectors.summarizingDouble(Person::getSalary));</span><br><span class="line">        System.out.println(<span class="string">&quot;sum1 = &quot;</span> + sum1);</span><br><span class="line"></span><br><span class="line">        <span class="type">IntSummaryStatistics</span> <span class="variable">sum2</span> <span class="operator">=</span> list.stream().collect(Collectors.summarizingInt(Person::getSalary));</span><br><span class="line">        System.out.println(<span class="string">&quot;sum2 = &quot;</span> + sum2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">LongSummaryStatistics</span> <span class="variable">sum3</span> <span class="operator">=</span> list.stream().collect(Collectors.summarizingLong(Person::getSalary));</span><br><span class="line">        System.out.println(<span class="string">&quot;sum3 = &quot;</span> + sum3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2、summarizing系列"><a href="#2、summarizing系列" class="headerlink" title="2、summarizing系列"></a>2、summarizing系列</h4><p>summarizingDouble、summarizingInt、summarizingLong三个方法可以返回stream的一个统计结果map，不同之处也是结果map中的value类型不一样，分别是double、int、long类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>));</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>));</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">DoubleSummaryStatistics</span> <span class="variable">collect</span> <span class="operator">=</span> personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">    <span class="comment">// 输出结果：</span></span><br><span class="line">    <span class="comment">// DoubleSummaryStatistics&#123;count=3, sum=24900.000000, min=7000.000000, average=8300.000000, max=9000.000000&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、joining"><a href="#3、joining" class="headerlink" title="3、joining"></a>3、joining</h4><p>joining可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collector;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月19日 14:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoiningDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">nameJoin1</span> <span class="operator">=</span> list.stream().map(Person::getName).collect(Collectors.joining());</span><br><span class="line">        System.out.println(<span class="string">&quot;nameJoin1 = &quot;</span> + nameJoin1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">nameJoin2</span> <span class="operator">=</span> list.stream().map(Person::getName).collect(Collectors.joining(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;nameJoin2 = &quot;</span> + nameJoin2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">nameJoin3</span> <span class="operator">=</span> list.stream().map(Person::getName).collect(Collectors.joining(<span class="string">&quot;--&quot;</span>, <span class="string">&quot;姓名：&quot;</span>, <span class="string">&quot;。&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;nameJoin3 = &quot;</span> + nameJoin3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4、reduce"><a href="#4、reduce" class="headerlink" title="4、reduce"></a>4、reduce</h4><p>Collectors内置reduce，可以完成自定义归约，如下面例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>));</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>));</span><br><span class="line">    personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sumSalary</span> <span class="operator">=</span> personList.stream().collect(Collectors.reducing(<span class="number">0</span>, Person::getSalary, (i, j) -&gt; i + j));</span><br><span class="line">    System.out.println(sumSalary);  <span class="comment">// 结果：24900</span></span><br><span class="line">    </span><br><span class="line">    Optional&lt;Integer&gt; sumSalary2 = list.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line">    System.out.println(sumSalary2);  <span class="comment">// Optional[24900]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5、groupingBy"><a href="#5、groupingBy" class="headerlink" title="5、groupingBy"></a>5、groupingBy</h4><p>groupingBy方法可以将stream中的元素按照规则进行分组，类似mysql中groupBy语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月19日 14:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupingByDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; personList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">10000</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">10000</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">10000</span>));</span><br><span class="line">        personList.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">9000</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Map&lt;String, List&lt;Person&gt;&gt; group1 = personList.stream().collect(Collectors.groupingBy(Person::getName));</span><br><span class="line">        System.out.println(<span class="string">&quot;group1 = &quot;</span> + group1);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Map&lt;Integer, List&lt;Person&gt;&gt;&gt; group2 = personList.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getName, Collectors.groupingBy(Person::getSalary)));</span><br><span class="line">        System.out.println(<span class="string">&quot;group2 = &quot;</span> + group2);</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Map&lt;String, List&lt;Person&gt;&gt;&gt; group3 = personList.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(Person::getSalary, Collectors.groupingBy(Person::getName)));</span><br><span class="line">        System.out.println(<span class="string">&quot;group3 = &quot;</span> + group3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6、toList、toSet、toMap"><a href="#6、toList、toSet、toMap" class="headerlink" title="6、toList、toSet、toMap"></a>6、toList、toSet、toMap</h4><p>Collectors内置的toList等方法可以十分便捷地将stream中的元素收集成想要的集合，是一个非常常用的功能，通常会配合filter、map等方法使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月19日 14:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ToListSetMap</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">9000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">5000</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// toList</span></span><br><span class="line">        List&lt;String&gt; toList = list.stream().map(Person::getName).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;toList = &quot;</span> + toList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// toSet</span></span><br><span class="line">        Set&lt;String&gt; toSet = list.stream().map(Person::getName).collect(Collectors.toSet());</span><br><span class="line">        System.out.println(<span class="string">&quot;toSet = &quot;</span> + toSet);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// toMap key重复会报错</span></span><br><span class="line">        Map&lt;String, Person&gt; toMap = list.stream().collect(Collectors.toMap(Person::getName, p -&gt; p));</span><br><span class="line">        System.out.println(<span class="string">&quot;toMap = &quot;</span> + toMap);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-4-映射（map）"><a href="#3-4-映射（map）" class="headerlink" title="3.4 映射（map）"></a>3.4 映射（map）</h2><p>Stream流中，map可以将一个流的元素按照一定的映射规则映射到另一个流中。</p>
<h4 id="1、数据-gt-gt-数据"><a href="#1、数据-gt-gt-数据" class="headerlink" title="1、数据&gt;&gt;数据"></a>1、数据&gt;&gt;数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] strArr = &#123; <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;bcdd&quot;</span>, <span class="string">&quot;defde&quot;</span>, <span class="string">&quot;ftr&quot;</span> &#125;;</span><br><span class="line">    Arrays.stream(strArr).map(x -&gt; x.toUpperCase()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预期结果：</span></span><br><span class="line">ABCD  BCDD  DEFDE  FTR</span><br></pre></td></tr></table></figure>

<h4 id="2、对象集合-gt-gt-数据"><a href="#2、对象集合-gt-gt-数据" class="headerlink" title="2、对象集合&gt;&gt;数据"></a>2、对象集合&gt;&gt;数据</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 为节省篇幅，personList复用了演示数据中的personList</span></span><br><span class="line">    personList.stream().map(person -&gt; person.getSalary()).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 预期结果：</span></span><br><span class="line">ABCD  BCDD  DEFDE  FTR</span><br></pre></td></tr></table></figure>

<h4 id="3、对象集合-gt-gt-对象集合"><a href="#3、对象集合-gt-gt-对象集合" class="headerlink" title="3、对象集合&gt;&gt;对象集合"></a>3、对象集合&gt;&gt;对象集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月19日 14:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strArr = &#123;<span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;bcdd&quot;</span>, <span class="string">&quot;defde&quot;</span>, <span class="string">&quot;ftr&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(strArr);</span><br><span class="line">        Stream&lt;String&gt; stringStream = Arrays.stream(strArr).map(String::toUpperCase);</span><br><span class="line">        stringStream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        person();</span><br><span class="line"></span><br><span class="line">        person2();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、对象集合&gt;&gt;数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">person</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">9000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">5000</span>));</span><br><span class="line"></span><br><span class="line">        list.stream().map(Person::getName).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、对象集合&gt;&gt;对象集合</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">person2</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">9000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lily&quot;</span>, <span class="number">5000</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; list1 = list.stream().peek(person -&gt; &#123;</span><br><span class="line">            person.setSalary(person.getSalary() + <span class="number">1</span>);</span><br><span class="line">            person.setName(person.getName()+<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;list1 = &quot;</span> + list1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;Person&gt; list2 = list.stream().map(person -&gt; &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">personNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">            personNew.setName(person.getName());</span><br><span class="line">            personNew.setSalary(person.getSalary() + <span class="number">10000</span>);</span><br><span class="line">            <span class="keyword">return</span> personNew;</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;list2 = &quot;</span> + list2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-5-排序（sorted）"><a href="#3-5-排序（sorted）" class="headerlink" title="3.5 排序（sorted）"></a>3.5 排序（sorted）</h2><p>Sorted方法是对流进行排序，并得到一个新的stream流，是一种中间操作。Sorted方法可以使用自然排序或特定比较器。</p>
<p>自然排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月19日 14:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strArr = &#123; <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;m&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;bcd&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; sort1 = Arrays.stream(strArr).sorted().collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;sort1 = &quot;</span> + sort1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] intArr = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">7</span> &#125;;</span><br><span class="line">        Arrays.stream(intArr).sorted().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>自定义排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月19日 14:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] strArr = &#123;<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;m&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;acd&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(strArr);</span><br><span class="line">        <span class="comment">// 1、按长度自然排序，即长度从小到大</span></span><br><span class="line">        List&lt;String&gt; collect = list.stream().sorted(Comparator.comparing(String::length)).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;collect = &quot;</span> + collect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、按长度倒序，即长度从大到小</span></span><br><span class="line">        List&lt;String&gt; collect1 = list.stream().sorted(Comparator.comparing(String::length).reversed()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;collect1 = &quot;</span> + collect1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、首字母自然排序</span></span><br><span class="line">        List&lt;String&gt; collect2 = list.stream().sorted(Comparator.naturalOrder()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;collect2 = &quot;</span> + collect2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、首字母倒序</span></span><br><span class="line">        List&lt;String&gt; collect3 = list.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;collect3 = &quot;</span> + collect3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、先按照首字母排序 之后按照String的长度排序</span></span><br><span class="line">        List&lt;String&gt; collect4 = list.stream().sorted(Comparator.comparing(x -&gt; ((String) x).charAt(<span class="number">0</span>)).thenComparing(x -&gt; ((String) x).length())).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;collect4 = &quot;</span> + collect4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-6-提取流和组合流"><a href="#3-6-提取流和组合流" class="headerlink" title="3.6 提取流和组合流"></a>3.6 提取流和组合流</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月19日 15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IterateDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String[] arr1 = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>&#125;;</span><br><span class="line">        String[] arr2 = &#123;<span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span>&#125;;</span><br><span class="line">        String[] arr3 = &#123;<span class="string">&quot;i&quot;</span>, <span class="string">&quot;j&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;l&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 可以把两个stream合并成一个stream（合并的stream类型必须相同）,只能两两合并</span></span><br><span class="line"><span class="comment">         * 预期结果：a b c d e（为节省篇幅，空格代替换行）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; arr11 = Stream.of(arr1);</span><br><span class="line">        Stream&lt;String&gt; arr21 = Stream.of(arr2);</span><br><span class="line">        List&lt;String&gt; collect = Stream.concat(arr11, arr21).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;collect = &quot;</span> + collect);</span><br><span class="line"></span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(arr1);</span><br><span class="line">        Stream&lt;String&gt; stream2 = Stream.of(arr2);</span><br><span class="line">        List&lt;String&gt; collect1 = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;collect1 = &quot;</span> + collect1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * limit，限制从流中获得前n个数据</span></span><br><span class="line"><span class="comment">         * 预期结果：1 3 5 7 9 11 13 15 17 19</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;Integer&gt; collect2 = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).limit(<span class="number">10</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;collect2 = &quot;</span> + collect2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * skip，跳过前n个数据</span></span><br><span class="line"><span class="comment">         * 预期结果：5 7 9 11 13</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;Integer&gt; collect3 = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).skip(<span class="number">2</span>).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">        System.out.println(<span class="string">&quot;collect3 = &quot;</span> + collect3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<END>]]></content>
      <categories>
        <category>Java8新特性Stream详细教程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ笔记(高级篇)</title>
    <url>/posts/416884f2a501/</url>
    <content><![CDATA[<h1 id="RabbitMQ笔记-高级篇"><a href="#RabbitMQ笔记-高级篇" class="headerlink" title="RabbitMQ笔记(高级篇)"></a>RabbitMQ笔记(高级篇)</h1><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>消息可靠性</p>
<p>消息幂等性</p>
<p>mq高可用</p>
<hr>
<h1 id="代码准备"><a href="#代码准备" class="headerlink" title="代码准备"></a>代码准备</h1><h2 id="1-新建生产者"><a href="#1-新建生产者" class="headerlink" title="1. 新建生产者"></a>1. 新建生产者</h2><p><a href="https://gitee.com/lixiaogou/rabbitmq/tree/master/extensions-spring-rabbitmq-producer">https://gitee.com/lixiaogou/rabbitmq/tree/master/extensions-spring-rabbitmq-producer</a></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155938.png" alt="image-20210204114007877"></p>
<h2 id="2-新建消费者"><a href="#2-新建消费者" class="headerlink" title="2. 新建消费者"></a>2. 新建消费者</h2><p><a href="https://gitee.com/lixiaogou/rabbitmq/tree/master/extensions-spring-rabbitmq-consumer">https://gitee.com/lixiaogou/rabbitmq/tree/master/extensions-spring-rabbitmq-consumer</a></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155944.png" alt="image-20210206085348174"></p>
<hr>
<h1 id="RabbitMQ-高级特性"><a href="#RabbitMQ-高级特性" class="headerlink" title="RabbitMQ 高级特性"></a>RabbitMQ 高级特性</h1><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155947.png" alt="image-20210204110540289"></p>
<h2 id="1-消息的可靠投递☆"><a href="#1-消息的可靠投递☆" class="headerlink" title="1. 消息的可靠投递☆"></a>1. 消息的可靠投递☆</h2><p>在使用 RabbitMQ 的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ 为我们提供了<code>两种</code>方式用来控制消息的投递可靠性模式。</p>
<h3 id="1-1-两种模式"><a href="#1-1-两种模式" class="headerlink" title="1.1 两种模式"></a>1.1 两种模式</h3><ul>
<li>confirm 确认模式 </li>
<li>return 退回模式 </li>
</ul>
<blockquote>
<p>RabbitMQ 整个消息投递的路径为：producer—&gt;rabbitmq broker—&gt;exchange—&gt;queue—&gt;consumer</p>
<ol>
<li>消息从 producer –&gt; exchange 会返回一个 confirmCallback 。</li>
<li>消息从 exchange –&gt; queue 投递失败则会返回一个 returnCallback 。</li>
</ol>
<p>我们将利用这两个==callback== 控制消息的可靠性投递l</p>
</blockquote>
<h3 id="1-2-测试confirm-确认模式"><a href="#1-2-测试confirm-确认模式" class="headerlink" title="1.2 测试confirm 确认模式"></a>1.2 测试confirm 确认模式</h3><p>开启确认模式</p>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20220306191537.png" alt="image-20210204121821805"></p>
<p>定义ConfirmCallBack回调函数</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155951.png" alt="image-20210204160530801"></p>
<p>ConfirmCallBack源码</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155955.png" alt="image-20210204155751064"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155957.png" alt="image-20210204155912410"></p>
<hr>
<h3 id="1-3-测试return-退回模式"><a href="#1-3-测试return-退回模式" class="headerlink" title="1.3 测试return 退回模式"></a>1.3 测试return 退回模式</h3><p>开启回退模式</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160002.png" alt="image-20210204122727962"></p>
<p>定义ReturnCallback回调函数</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160004.png" alt="image-20210204162159769"></p>
<p>ReturnCallback源码</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160007.png" alt="image-20210204162505470"></p>
<h3 id="1-4-小结"><a href="#1-4-小结" class="headerlink" title="1.4 小结"></a>1.4 小结</h3><p><strong>确认模式</strong> </p>
<ul>
<li>消息从 producer –&gt; exchange 会返回一个 confirmCallback 。</li>
<li>设置 ConnectionFactory 的 <code>publisher-confirms=&quot;true&quot;</code> 开启 确认模式</li>
<li>使用 rabbitTemplate.<code>setConfirmCallback</code> 设置回调函数。当消息发送到exchange后回调confirm方法。在方法中判断ack，如果为true，则发送成功，如果为false，则发送失败，需要处理。</li>
</ul>
<p><strong>退回模式</strong></p>
<ul>
<li>消息从 exchange –&gt; queue 投递失败会返回一个 returnCallback 。</li>
<li>设置 ConnectionFactory 的 <code>publisher-returns=&quot;true&quot;</code> 开启 退回模式。</li>
<li>使用rabbitTemplate.<code>setReturnCallback</code>设置退回函数，设置rabbitTemplate.<code>setMandatory(true)</code>参数，当消息从exchange路由到queue失败后，会将消息退回给producer。并执行回调函数returnedMessage。</li>
</ul>
<p><strong>事务</strong></p>
<ul>
<li><p>在RabbitMQ中也提供了事务机制，但是性能较差，此处不做讲解。</p>
</li>
<li><p>使用channel下列方法，完成事务控制：</p>
<ul>
<li>txSelect()，用于将当前channel设置成transaction模式</li>
<li>txCommit()，用于提交事务</li>
<li>txRollback()，用于回滚事务</li>
</ul>
</li>
</ul>
<hr>
<h2 id="2-Consumer-ACK☆"><a href="#2-Consumer-ACK☆" class="headerlink" title="2. Consumer ACK☆"></a>2. Consumer ACK☆</h2><p>ack指Acknowledge，确认。 表示<code>消费端</code>收到消息后的确认方式。</p>
<h3 id="2-1-三种ACK"><a href="#2-1-三种ACK" class="headerlink" title="2.1 三种ACK"></a>2.1 三种ACK</h3><ul>
<li>自动确认：acknowledge=”none” （默认）</li>
</ul>
<blockquote>
<p>当消息一旦被Consumer接收到，则自动确认收到，并将相应消息从 RabbitMQ 的消息缓存中移除。在实际业务处理中，很可能消息接收到，但是业务处理出现异常，而此时消息已经从缓存中移除，那么该消息就会丢失</p>
</blockquote>
<ul>
<li>手动确认：acknowledge=”manual”</li>
</ul>
<blockquote>
<p>在业务处理成功后，调用channel.basicAck()，进行手动签收，如果业务出现异常，则调用channel.basicNack()方法，让生产者自动重新发送消息。</p>
</blockquote>
<ul>
<li>根据异常情况确认：acknowledge=”auto”，（这种方式使用麻烦，<strong>不常用</strong>）</li>
</ul>
<h3 id="2-2-测试手动ACK"><a href="#2-2-测试手动ACK" class="headerlink" title="2.2 测试手动ACK"></a>2.2 测试手动ACK</h3><ol>
<li>生产者配置文件</li>
<li>生产者测试代码</li>
<li>消费者配置文件</li>
<li>消费者监听器</li>
<li>消费者测试类</li>
</ol>
<h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><ul>
<li><code>消费者</code>配置文件中，将rabbit:listener-container标签中设置acknowledge=”manual”</li>
<li>如果在消费端没有异常，则调用channel.basicAck(deliveryTag,false)方法，手动确认签收消息</li>
<li>如果在消费端出现异常，则在catch中调用 basicNack或 basicReject，拒绝消息，让MQ重发消息。</li>
</ul>
<h3 id="2-4-消息可靠性总结"><a href="#2-4-消息可靠性总结" class="headerlink" title="2.4 消息可靠性总结"></a>2.4 消息可靠性总结</h3><ol>
<li><p>持久化</p>
<ul>
<li>exchange要持久化</li>
<li>queue要持久化</li>
<li>message要持久化</li>
</ul>
</li>
<li><p>生产方确认Confirm</p>
<ul>
<li><p>confirm 确认模式</p>
</li>
<li><p>return 退回模式</p>
</li>
</ul>
</li>
<li><p>消费方确认Ack</p>
<ul>
<li>自动确认：acknowledge=”none”</li>
<li>手动确认：acknowledge=”manual”</li>
<li>根据异常情况确认：acknowledge=”auto”</li>
</ul>
</li>
<li><p>Broker高可用（集群）</p>
</li>
</ol>
<h2 id="3-消费端限流"><a href="#3-消费端限流" class="headerlink" title="3. 消费端限流"></a>3. 消费端限流</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160018.png" alt="image-20210204102048057"></p>
<h3 id="测试消费端限流"><a href="#测试消费端限流" class="headerlink" title="测试消费端限流"></a>测试消费端限流</h3><p>消费端配置文件<code>prefetch=&quot;xx&quot;</code></p>
<p>监听器代码</p>
<p>消费端测试类</p>
<p>发送端测试类</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>消费端rabbit:listener-container 中配置 <code>prefetch</code>属性设置消费端一次拉取多少消息</p>
</li>
<li><p>消费端的确认模式一定为<code>手动确认</code>。acknowledge=”manual”</p>
</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160021.png" alt="image-20210204211304237"></p>
<h2 id="4-TTL（Time-To-Live）"><a href="#4-TTL（Time-To-Live）" class="headerlink" title="4. TTL（Time To Live）"></a>4. TTL（Time To Live）</h2><blockquote>
<p>TTL 全称 Time To Live（存活时间/过期时间）。当消息到达存活时间后，还没有被消费，会被自动清除。RabbitMQ可以对<code>消息设置</code>过期时间，也可以对<code>整个队列</code>（Queue）设置过期时间。</p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160023.png" alt="image-20210204102201794"></p>
<h3 id="控制台添加ttl队列"><a href="#控制台添加ttl队列" class="headerlink" title="控制台添加ttl队列"></a>控制台添加ttl队列</h3><p>test_queue_ttl </p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160028.png" alt="image-20210205103535219"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160034.png" alt="image-20210205103638398"></p>
<h3 id="添加交换机"><a href="#添加交换机" class="headerlink" title="添加交换机"></a>添加交换机</h3><p>test_exchange_ttl</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160043.png" alt="image-20210205103956729"></p>
<hr>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160059.png" alt="image-20210205104052071"></p>
<h3 id="绑定交换机和队列"><a href="#绑定交换机和队列" class="headerlink" title="绑定交换机和队列"></a>绑定交换机和队列</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160105.png" alt="image-20210205104310648"></p>
<h3 id="消息发布"><a href="#消息发布" class="headerlink" title="消息发布"></a>消息发布</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160117.png" alt="image-20210205104449730"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160133.png" alt="image-20210205104714490"></p>
<p>等待10秒过了存活时间，消息没有被消费，自动清除</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160135.png" alt="image-20210205104730808"></p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><p>生产者配置文件</p>
<p>生产者发送消息</p>
<p>每次测试之后都查看控制台</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>设置队列过期时间：x-message-ttl，单位：ms(毫秒)，会对整个队列消息统一过期。</li>
<li>设置消息过期时间：expiration。单位：ms(毫秒)，当该消息在队列头部时（消费时），会单独判断这一消息是否过期，根据是否过去决定是否需要移除。</li>
<li>如果两者都进行了设置，以时间短的为准。</li>
</ul>
<h2 id="5-死信队列DLX☆"><a href="#5-死信队列DLX☆" class="headerlink" title="5.死信队列DLX☆"></a>5.死信队列DLX☆</h2><blockquote>
<p>死信队列，英文缩写：DLX 。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。</p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160139.png" alt="image-20210204102346053"></p>
<h3 id="消息成为死信的三种情况☆"><a href="#消息成为死信的三种情况☆" class="headerlink" title="消息成为死信的三种情况☆"></a>消息成为死信的三种情况☆</h3><ol>
<li><p>队列消息长度到达限制；</p>
</li>
<li><p>消费者拒接消费消息，basicNack/basicReject，且消息不重新放入原目标队列，requeue=false；</p>
</li>
<li><p>原队列存在消息过期设置，消息到达过期时间未被消费；</p>
</li>
</ol>
<h3 id="队列绑定死信交换机"><a href="#队列绑定死信交换机" class="headerlink" title="队列绑定死信交换机"></a>队列绑定死信交换机</h3><p>给队列设置参数： x-dead-letter-exchange 和 x-dead-letter-routing-key</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160141.png" alt="image-20210204102456613"></p>
<h3 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h3><p>步骤</p>
<ol>
<li>生产者配置声明死信队列(queue_dlx)和死信交换机(exchange_dlx)</li>
<li>生产者配置声明正常的队列(test_queue_dlx)和交换机(test_exchange_dlx)<ol start="3">
<li>生产者配置正常队列绑定死信交换机 设置两个参数：<ol>
<li>x-dead-letter-exchange：死信交换机名称</li>
<li>x-dead-letter-routing-key：发送给死信交换机的routingkey</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>生产者配置文件</p>
<p>生产者发送消息</p>
<p>消费者配置文件监听死信队列</p>
<h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><ol>
<li><p>发送到正常队列，正常队列消息过期后，消息自动进入到死信队列，死信队列有1条消息</p>
<p> <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160144.png" alt="image-20210205114934864"></p>
</li>
<li><p>正常队列有十条消息，死信队列也有十条，正常队列消息过期后，死信队列有20条消息</p>
</li>
</ol>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160147.png" alt="image-20210205134125290"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160152.png" alt="image-20210205134141849"></p>
<ol>
<li>正常队列有1条消息，然后消费端拒绝接收之后，死信队列就有1条消息</li>
</ol>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160154.png" alt="image-20210205134753666"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160157.png" alt="image-20210205135051824"></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ol>
<li><p>死信交换机、死信队列 和 普通的没有区别</p>
</li>
<li><p>当消息成为死信后，如果该队列绑定了死信交换机，则消息会被死信交换机重新路由到死信队列</p>
</li>
<li><p>消息成为死信的三种情况：</p>
<ol>
<li><p>队列消息长度到达限制；</p>
</li>
<li><p>消费者拒接消费消息，并且不重回队列；</p>
</li>
<li><p>原队列存在消息过期设置，消息到达超时时间未被消费；</p>
</li>
</ol>
</li>
</ol>
<h2 id="6-延迟队列☆"><a href="#6-延迟队列☆" class="headerlink" title="6.延迟队列☆"></a>6.延迟队列☆</h2><blockquote>
<p>延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费。</p>
<ul>
<li><p>需求：</p>
<ol>
<li>下单后，30分钟未支付，取消订单，回滚库存。</li>
<li>新用户注册成功7天后，发送短信问候。</li>
</ol>
</li>
<li><p>实现方式：</p>
<ol>
<li>定时器</li>
<li>延迟队列</li>
</ol>
</li>
</ul>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160203.png" alt="image-20210204102742922"></p>
<p>很可惜，在RabbitMQ中并<code>未提供</code>延迟队列功能。但是可以使用：==TTL+DLX== 实现延迟队列的效果。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160205.png" alt="image-20210204102936049"></p>
<h3 id="代码演示-1"><a href="#代码演示-1" class="headerlink" title="代码演示"></a>代码演示</h3><p>生产者配置文件</p>
<pre><code>       1. 定义死信交换机（order_exchange_dlx）和队列(order_queue_dlx)
       2. 定义正常交换机（order_exchange）和队列(order_queue)
       3. 绑定，设置正常队列过期时间为30分钟
</code></pre>
<p>生产者发送消息</p>
<p>消息发送结果：10秒内位于正常队列中，十秒之后进入死信队列</p>
<p>消费端配置</p>
<p>消费端接收消息</p>
<p>消息接收结果：启动消费端之后，私信队列中的消息都被消费端手动ACK了</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul>
<li>延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费。</li>
<li>在RabbitMQ中并<code>未提供</code>延迟队列功能。但是可以使用：==TTL+DLX== 实现延迟队列的效果。</li>
</ul>
<hr>
<h2 id="7-日志与监控（了解）"><a href="#7-日志与监控（了解）" class="headerlink" title="7.日志与监控（了解）"></a>7.日志与监控（了解）</h2><h3 id="RabbitMQ日志"><a href="#RabbitMQ日志" class="headerlink" title="RabbitMQ日志"></a>RabbitMQ日志</h3><p>RabbitMQ默认日志存放路径： /var/log/rabbitmq/<a href="mailto:&#114;&#97;&#x62;&#98;&#105;&#116;&#x40;&#120;&#120;&#x78;&#46;&#108;&#x6f;&#x67;">&#114;&#97;&#x62;&#98;&#105;&#116;&#x40;&#120;&#120;&#x78;&#46;&#108;&#x6f;&#x67;</a></p>
<p>日志包含了RabbitMQ的版本号、Erlang的版本号、RabbitMQ服务节点名称、cookie的hash值、RabbitMQ配置文件地址、内存限制、磁盘限制、默认账户guest的创建以及权限配置等等。</p>
<h3 id="web管控台监控"><a href="#web管控台监控" class="headerlink" title="web管控台监控"></a>web管控台监控</h3><h3 id="rabbitmqctl管理和监控"><a href="#rabbitmqctl管理和监控" class="headerlink" title="rabbitmqctl管理和监控"></a>rabbitmqctl管理和监控</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看队列</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl list_queues</span></span><br><span class="line">查看exchanges</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl list_exchanges</span></span><br><span class="line">查看用户</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl list_users</span></span><br><span class="line">查看连接</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl list_connections</span></span><br><span class="line">查看消费者信息</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl list_consumers</span></span><br><span class="line">查看环境变量</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl environment</span></span><br><span class="line">查看未被确认的队列</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl list_queues  name messages_unacknowledged</span></span><br><span class="line">查看单个队列的内存使用</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl list_queues name memory</span></span><br><span class="line">查看准备就绪的队列</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">rabbitmqctl list_queues name messages_ready</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-消息追踪"><a href="#8-消息追踪" class="headerlink" title="8.消息追踪"></a>8.消息追踪</h2><p>在使用任何消息中间件的过程中，难免会出现某条消息异常丢失的情况。对于RabbitMQ而言，可能是因为生产者或消费者与RabbitMQ断开了连接，而它们与RabbitMQ又采用了不同的确认机制；也有可能是因为交换器与队列之间不同的转发策略；甚至是交换器并没有与任何队列进行绑定，生产者又不感知或者没有采取相应的措施；另外RabbitMQ本身的集群策略也可能导致消息的丢失。这个时候就需要有一个较好的机制跟踪记录消息的投递过程，以此协助开发和运维人员进行问题的定位。</p>
<p>在RabbitMQ中可以使用Firehose和rabbitmq_tracing插件功能来实现消息追踪。</p>
<h3 id="Firehose"><a href="#Firehose" class="headerlink" title="Firehose"></a>Firehose</h3><p>firehose的机制是将生产者投递给rabbitmq的消息，rabbitmq投递给消费者的消息按照指定的格式发送到默认的exchange上。这个默认的exchange的名称为amq.rabbitmq.trace，它是一个topic类型的exchange。发送到这个exchange上的消息的routing key为 publish.exchangename 和 deliver.queuename。其中exchangename和queuename为实际exchange和queue的名称，分别对应生产者投递到exchange的消息，和消费者从queue上获取的消息。</p>
<blockquote>
<p>注意：打开 trace 会影响消息写入功能，适当打开后请关闭。</p>
<p>rabbitmqctl trace_on：开启Firehose命令</p>
<p>rabbitmqctl trace_off：关闭Firehose命令</p>
</blockquote>
<h3 id="rabbitmq-tracing"><a href="#rabbitmq-tracing" class="headerlink" title="rabbitmq_tracing"></a>rabbitmq_tracing</h3><p>rabbitmq_tracing和Firehose在实现上如出一辙，只不过rabbitmq_tracing的方式比Firehose多了一层GUI的包装，更容易使用和管理。</p>
<blockquote>
<p>启用插件：rabbitmq-plugins enable rabbitmq_tracing</p>
</blockquote>
<hr>
<h1 id="RabbitMQ应用问题☆"><a href="#RabbitMQ应用问题☆" class="headerlink" title="RabbitMQ应用问题☆"></a>RabbitMQ应用问题☆</h1><h2 id="1-消息可靠性保障"><a href="#1-消息可靠性保障" class="headerlink" title="1.消息可靠性保障"></a>1.消息可靠性保障</h2><p>需求：100%确保消息发送成功</p>
<h3 id="消息补偿机制"><a href="#消息补偿机制" class="headerlink" title="消息补偿机制"></a>消息补偿机制</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160210.png" alt="image-20210204105903097"></p>
<p>流程：producer–&gt;1业务数据入库–&gt;</p>
<ul>
<li>2发送消息到Q1–&gt;consumer监听消息Q1、消费Q1、操作consumerDB，consumer发送确认消息到Q2–&gt;回调检查服务监听确认消息Q2、消费Q2、将消息写入MDB数据库</li>
<li>3发送延迟消息到Q3–&gt;回调检查服务–&gt;6监听延迟消息Q3–&gt;消费Q3–&gt;比对MDB中是否有该消息，<ul>
<li>有该消息不做处理，</li>
<li>没有该消息–&gt;8调用producer，重新发送消息，如此循环下去</li>
</ul>
</li>
</ul>
<p>定时检查服务检查数据库数据，重新调用producer发送消息</p>
<h2 id="2-消息幂等性处理"><a href="#2-消息幂等性处理" class="headerlink" title="2.消息幂等性处理"></a>2.消息幂等性处理</h2><p>幂等性指一次和多次请求某一个资源，对于资源本身应该具有同样的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。</p>
<p>在MQ中指，消费多条相同的消息的结果与消费该消息一次的结果相同。</p>
<h3 id="乐观锁解决方案"><a href="#乐观锁解决方案" class="headerlink" title="乐观锁解决方案"></a>乐观锁解决方案</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160213.png" alt="image-20210204110033863"></p>
<hr>
<h1 id="RabbitMQ集群搭建"><a href="#RabbitMQ集群搭建" class="headerlink" title="RabbitMQ集群搭建"></a>RabbitMQ集群搭建</h1><p>摘要：实际生产应用中都会采用消息队列的集群方案，如果选择RabbitMQ那么有必要了解下它的集群方案原理</p>
<p>一般来说，如果只是为了学习RabbitMQ或者验证业务工程的正确性那么在本地环境或者测试环境上使用其单实例部署就可以了，但是出于MQ中间件本身的可靠性、并发性、吞吐量和消息堆积能力等问题的考虑，在生产环境上一般都会考虑使用RabbitMQ的集群方案。</p>
<h2 id="3-1-集群方案的原理"><a href="#3-1-集群方案的原理" class="headerlink" title="3.1 集群方案的原理"></a>3.1 集群方案的原理</h2><p>RabbitMQ这款消息队列中间件产品本身是基于Erlang编写，Erlang语言天生具备分布式特性（通过同步Erlang集群各节点的magic cookie来实现）。因此，RabbitMQ天然支持Clustering。这使得RabbitMQ本身不需要像ActiveMQ、Kafka那样通过ZooKeeper分别来实现HA方案和保存集群的元数据。集群是保证可靠性的一种方式，同时可以通过水平扩展以达到增加消息吞吐量能力的目的。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160216.png" alt="1565245219265"></p>
<h2 id="3-2-单机多实例部署"><a href="#3-2-单机多实例部署" class="headerlink" title="3.2 单机多实例部署"></a>3.2 单机多实例部署</h2><p>由于某些因素的限制，有时候你不得不在一台机器上去搭建一个rabbitmq集群，这个有点类似zookeeper的单机版。真实生成环境还是要配成多机集群的。有关怎么配置多机集群的可以参考其他的资料，这里主要论述如何在单机中配置多个rabbitmq实例。</p>
<p>主要参考官方文档：<a href="https://www.rabbitmq.com/clustering.html">https://www.rabbitmq.com/clustering.html</a></p>
<p>首先确保RabbitMQ运行没有问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@super ~]# rabbitmqctl status</span><br><span class="line">Status of node rabbit@super ...</span><br><span class="line">[&#123;pid,10232&#125;,</span><br><span class="line"> &#123;running_applications,</span><br><span class="line">     [&#123;rabbitmq_management,&quot;RabbitMQ Management Console&quot;,&quot;3.6.5&quot;&#125;,</span><br><span class="line">      &#123;rabbitmq_web_dispatch,&quot;RabbitMQ Web Dispatcher&quot;,&quot;3.6.5&quot;&#125;,</span><br><span class="line">      &#123;webmachine,&quot;webmachine&quot;,&quot;1.10.3&quot;&#125;,</span><br><span class="line">      &#123;mochiweb,&quot;MochiMedia Web Server&quot;,&quot;2.13.1&quot;&#125;,</span><br><span class="line">      &#123;rabbitmq_management_agent,&quot;RabbitMQ Management Agent&quot;,&quot;3.6.5&quot;&#125;,</span><br><span class="line">      &#123;rabbit,&quot;RabbitMQ&quot;,&quot;3.6.5&quot;&#125;,</span><br><span class="line">      &#123;os_mon,&quot;CPO  CXC 138 46&quot;,&quot;2.4&quot;&#125;,</span><br><span class="line">      &#123;syntax_tools,&quot;Syntax tools&quot;,&quot;1.7&quot;&#125;,</span><br><span class="line">      &#123;inets,&quot;INETS  CXC 138 49&quot;,&quot;6.2&quot;&#125;,</span><br><span class="line">      &#123;amqp_client,&quot;RabbitMQ AMQP Client&quot;,&quot;3.6.5&quot;&#125;,</span><br><span class="line">      &#123;rabbit_common,[],&quot;3.6.5&quot;&#125;,</span><br><span class="line">      &#123;ssl,&quot;Erlang/OTP SSL application&quot;,&quot;7.3&quot;&#125;,</span><br><span class="line">      &#123;public_key,&quot;Public key infrastructure&quot;,&quot;1.1.1&quot;&#125;,</span><br><span class="line">      &#123;asn1,&quot;The Erlang ASN1 compiler version 4.0.2&quot;,&quot;4.0.2&quot;&#125;,</span><br><span class="line">      &#123;ranch,&quot;Socket acceptor pool for TCP protocols.&quot;,&quot;1.2.1&quot;&#125;,</span><br><span class="line">      &#123;mnesia,&quot;MNESIA  CXC 138 12&quot;,&quot;4.13.3&quot;&#125;,</span><br><span class="line">      &#123;compiler,&quot;ERTS  CXC 138 10&quot;,&quot;6.0.3&quot;&#125;,</span><br><span class="line">      &#123;crypto,&quot;CRYPTO&quot;,&quot;3.6.3&quot;&#125;,</span><br><span class="line">      &#123;xmerl,&quot;XML parser&quot;,&quot;1.3.10&quot;&#125;,</span><br><span class="line">      &#123;sasl,&quot;SASL  CXC 138 11&quot;,&quot;2.7&quot;&#125;,</span><br><span class="line">      &#123;stdlib,&quot;ERTS  CXC 138 10&quot;,&quot;2.8&quot;&#125;,</span><br><span class="line">      &#123;kernel,&quot;ERTS  CXC 138 10&quot;,&quot;4.2&quot;&#125;]&#125;,</span><br><span class="line"> &#123;os,&#123;unix,linux&#125;&#125;,</span><br><span class="line"> &#123;erlang_version,</span><br><span class="line">     &quot;Erlang/OTP 18 [erts-7.3] [source] [64-bit] [async-threads:64] [hipe] [kernel-poll:true]\n&quot;&#125;,</span><br><span class="line"> &#123;memory,</span><br><span class="line">     [&#123;total,56066752&#125;,</span><br><span class="line">      &#123;connection_readers,0&#125;,</span><br><span class="line">      &#123;connection_writers,0&#125;,</span><br><span class="line">      &#123;connection_channels,0&#125;,</span><br><span class="line">      &#123;connection_other,2680&#125;,</span><br><span class="line">      &#123;queue_procs,268248&#125;,</span><br><span class="line">      &#123;queue_slave_procs,0&#125;,</span><br><span class="line">      &#123;plugins,1131936&#125;,</span><br><span class="line">      &#123;other_proc,18144280&#125;,</span><br><span class="line">      &#123;mnesia,125304&#125;,</span><br><span class="line">      &#123;mgmt_db,921312&#125;,</span><br><span class="line">      &#123;msg_index,69440&#125;,</span><br><span class="line">      &#123;other_ets,1413664&#125;,</span><br><span class="line">      &#123;binary,755736&#125;,</span><br><span class="line">      &#123;code,27824046&#125;,</span><br><span class="line">      &#123;atom,1000601&#125;,</span><br><span class="line">      &#123;other_system,4409505&#125;]&#125;,</span><br><span class="line"> &#123;alarms,[]&#125;,</span><br><span class="line"> &#123;listeners,[&#123;clustering,25672,&quot;::&quot;&#125;,&#123;amqp,5672,&quot;::&quot;&#125;]&#125;,</span><br><span class="line"> &#123;vm_memory_high_watermark,0.4&#125;,</span><br><span class="line"> &#123;vm_memory_limit,411294105&#125;,</span><br><span class="line"> &#123;disk_free_limit,50000000&#125;,</span><br><span class="line"> &#123;disk_free,13270233088&#125;,</span><br><span class="line"> &#123;file_descriptors,</span><br><span class="line">     [&#123;total_limit,924&#125;,&#123;total_used,6&#125;,&#123;sockets_limit,829&#125;,&#123;sockets_used,0&#125;]&#125;,</span><br><span class="line"> &#123;processes,[&#123;limit,1048576&#125;,&#123;used,262&#125;]&#125;,</span><br><span class="line"> &#123;run_queue,0&#125;,</span><br><span class="line"> &#123;uptime,43651&#125;,</span><br><span class="line"> &#123;kernel,&#123;net_ticktime,60&#125;&#125;]</span><br></pre></td></tr></table></figure>

<p>停止rabbitmq服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@super sbin]# service rabbitmq-server stop</span><br><span class="line">Stopping rabbitmq-server: rabbitmq-server.</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>启动第一个节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@super sbin]# RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit1 rabbitmq-server start</span><br><span class="line"></span><br><span class="line">              RabbitMQ 3.6.5. Copyright (C) 2007-2016 Pivotal Software, Inc.</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#  ##      Licensed under the MPL.  See http://www.rabbitmq.com/</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#  ##</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#########  Logs: /var/log/rabbitmq/rabbit1.log</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#####  ##        /var/log/rabbitmq/rabbit1-sasl.log</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#########</span></span></span><br><span class="line">              Starting broker...</span><br><span class="line"> completed with 6 plugins.</span><br></pre></td></tr></table></figure>

<p>启动第二个节点：</p>
<blockquote>
<p>web管理插件端口占用,所以还要指定其web插件占用的端口号。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@super ~]# RABBITMQ_NODE_PORT=5674 RABBITMQ_SERVER_START_ARGS=&quot;-rabbitmq_management listener [&#123;port,15674&#125;]&quot; RABBITMQ_NODENAME=rabbit2 rabbitmq-server start</span><br><span class="line"></span><br><span class="line">              RabbitMQ 3.6.5. Copyright (C) 2007-2016 Pivotal Software, Inc.</span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#  ##      Licensed under the MPL.  See http://www.rabbitmq.com/</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#  ##</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#########  Logs: /var/log/rabbitmq/rabbit2.log</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#####  ##        /var/log/rabbitmq/rabbit2-sasl.log</span></span></span><br><span class="line"><span class="meta prompt_">  #</span><span class="language-bash"><span class="comment">#########</span></span></span><br><span class="line">              Starting broker...</span><br><span class="line"> completed with 6 plugins.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结束命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl -n rabbit1 stop</span><br><span class="line">rabbitmqctl -n rabbit2 stop</span><br></pre></td></tr></table></figure>



<p>rabbit1操作作为主节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@super ~]# rabbitmqctl -n rabbit1 stop_app  </span><br><span class="line">Stopping node rabbit1@super ...</span><br><span class="line">[root@super ~]# rabbitmqctl -n rabbit1 reset	 </span><br><span class="line">Resetting node rabbit1@super ...</span><br><span class="line">[root@super ~]# rabbitmqctl -n rabbit1 start_app</span><br><span class="line">Starting node rabbit1@super ...</span><br><span class="line">[root@super ~]# </span><br></pre></td></tr></table></figure>

<p>rabbit2操作为从节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@super ~]# rabbitmqctl -n rabbit2 stop_app</span><br><span class="line">Stopping node rabbit2@super ...</span><br><span class="line">[root@super ~]# rabbitmqctl -n rabbit2 reset</span><br><span class="line">Resetting node rabbit2@super ...</span><br><span class="line">[root@super ~]# rabbitmqctl -n rabbit2 join_cluster rabbit1@&#x27;super&#x27; ###&#x27;&#x27;内是主机名换成自己的</span><br><span class="line">Clustering node rabbit2@super with rabbit1@super ...</span><br><span class="line">[root@super ~]# rabbitmqctl -n rabbit2 start_app</span><br><span class="line">Starting node rabbit2@super ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看集群状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@super ~]# rabbitmqctl cluster_status -n rabbit1</span><br><span class="line">Cluster status of node rabbit1@super ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit1@super,rabbit2@super]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit2@super,rabbit1@super]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;&quot;rabbit1@super&quot;&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit2@super,[]&#125;,&#123;rabbit1@super,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure>

<p>web监控：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160220.png" alt="1566065096459"></p>
<h2 id="3-3-集群管理"><a href="#3-3-集群管理" class="headerlink" title="3.3 集群管理"></a>3.3 集群管理</h2><p><strong>rabbitmqctl join_cluster {cluster_node} [–ram]</strong><br>将节点加入指定集群中。在这个命令执行前需要停止RabbitMQ应用并重置节点。</p>
<p><strong>rabbitmqctl cluster_status</strong><br>显示集群的状态。</p>
<p><strong>rabbitmqctl change_cluster_node_type {disc|ram}</strong><br>修改集群节点的类型。在这个命令执行前需要停止RabbitMQ应用。</p>
<p><strong>rabbitmqctl forget_cluster_node [–offline]</strong><br>将节点从集群中删除，允许离线执行。</p>
<p><strong>rabbitmqctl update_cluster_nodes {clusternode}</strong></p>
<p>在集群中的节点应用启动前咨询clusternode节点的最新信息，并更新相应的集群信息。这个和join_cluster不同，它不加入集群。考虑这样一种情况，节点A和节点B都在集群中，当节点A离线了，节点C又和节点B组成了一个集群，然后节点B又离开了集群，当A醒来的时候，它会尝试联系节点B，但是这样会失败，因为节点B已经不在集群中了。</p>
<p><strong>rabbitmqctl cancel_sync_queue [-p vhost] {queue}</strong><br>取消队列queue同步镜像的操作。</p>
<p><strong>rabbitmqctl set_cluster_name {name}</strong><br>设置集群名称。集群名称在客户端连接时会通报给客户端。Federation和Shovel插件也会有用到集群名称的地方。集群名称默认是集群中第一个节点的名称，通过这个命令可以重新设置。</p>
<h2 id="3-4-RabbitMQ镜像集群配置"><a href="#3-4-RabbitMQ镜像集群配置" class="headerlink" title="3.4 RabbitMQ镜像集群配置"></a>3.4 RabbitMQ镜像集群配置</h2><blockquote>
<p>上面已经完成RabbitMQ默认集群模式，但并不保证队列的高可用性，尽管交换机、绑定这些可以复制到集群里的任何一个节点，但是队列内容不会复制。虽然该模式解决一项目组节点压力，但队列节点宕机直接导致该队列无法应用，只能等待重启，所以要想在队列节点宕机或故障也能正常应用，就要复制队列内容到集群里的每个节点，必须要创建镜像队列。</p>
<p>镜像队列是基于普通的集群模式的，然后再添加一些策略，所以你还是得先配置普通集群，然后才能设置镜像队列，我们就以上面的集群接着做。</p>
</blockquote>
<p><strong>设置的镜像队列可以通过开启的网页的管理端Admin-&gt;Policies，也可以通过命令。</strong></p>
<blockquote>
<p>rabbitmqctl set_policy my_ha “^” ‘{“ha-mode”:”all”}’</p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325160224.png" alt="1566072300852"></p>
<blockquote>
<ul>
<li>Name:策略名称</li>
<li>Pattern：匹配的规则，如果是匹配所有的队列，是^.</li>
<li>Definition:使用ha-mode模式中的all，也就是同步所有匹配的队列。问号链接帮助文档。</li>
</ul>
</blockquote>
<h2 id="3-5-负载均衡-HAProxy"><a href="#3-5-负载均衡-HAProxy" class="headerlink" title="3.5 负载均衡-HAProxy"></a>3.5 负载均衡-HAProxy</h2><p>HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案,包括Twitter，Reddit，StackOverflow，GitHub在内的多家知名互联网公司在使用。HAProxy实现了一种事件驱动、单一进程模型，此模型支持非常大的并发连接数。</p>
<h3 id="3-5-1-安装HAProxy"><a href="#3-5-1-安装HAProxy" class="headerlink" title="3.5.1  安装HAProxy"></a>3.5.1  安装HAProxy</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//下载依赖包</span><br><span class="line">yum install gcc vim wget</span><br><span class="line">//上传haproxy源码包</span><br><span class="line">//解压</span><br><span class="line">tar -zxvf haproxy-1.6.5.tar.gz -C /usr/local</span><br><span class="line">//进入目录、进行编译、安装</span><br><span class="line">cd /usr/local/haproxy-1.6.5</span><br><span class="line">make TARGET=linux31 PREFIX=/usr/local/haproxy</span><br><span class="line">make install PREFIX=/usr/local/haproxy</span><br><span class="line">mkdir /etc/haproxy</span><br><span class="line">//赋权</span><br><span class="line">groupadd -r -g 149 haproxy</span><br><span class="line">useradd -g haproxy -r -s /sbin/nologin -u 149 haproxy</span><br><span class="line">//创建haproxy配置文件</span><br><span class="line">mkdir /etc/haproxy</span><br><span class="line">vim /etc/haproxy/haproxy.cfg</span><br></pre></td></tr></table></figure>




<h3 id="3-5-2-配置HAProxy"><a href="#3-5-2-配置HAProxy" class="headerlink" title="3.5.2 配置HAProxy"></a>3.5.2 配置HAProxy</h3><p>配置文件路径：/etc/haproxy/haproxy.cfg</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">logging options</span></span><br><span class="line">global</span><br><span class="line">	log 127.0.0.1 local0 info</span><br><span class="line">	maxconn 5120</span><br><span class="line">	chroot /usr/local/haproxy</span><br><span class="line">	uid 99</span><br><span class="line">	gid 99</span><br><span class="line">	daemon</span><br><span class="line">	quiet</span><br><span class="line">	nbproc 20</span><br><span class="line">	pidfile /var/run/haproxy.pid</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">	log global</span><br><span class="line">	</span><br><span class="line">	mode tcp</span><br><span class="line"></span><br><span class="line">	option tcplog</span><br><span class="line">	option dontlognull</span><br><span class="line">	retries 3</span><br><span class="line">	option redispatch</span><br><span class="line">	maxconn 2000</span><br><span class="line">	contimeout 5s</span><br><span class="line">   </span><br><span class="line">     clitimeout 60s</span><br><span class="line"></span><br><span class="line">     srvtimeout 15s	</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">front-end IP <span class="keyword">for</span> consumers and producters</span></span><br><span class="line"></span><br><span class="line">listen rabbitmq_cluster</span><br><span class="line">	bind 0.0.0.0:5672</span><br><span class="line">	</span><br><span class="line">	mode tcp</span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">balance url_param userid</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">balance url_param session_id check_post 64</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">balance hdr(User-Agent)</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">balance hdr(host)</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">balance hdr(Host) use_domain_only</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">balance rdp-cookie</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">balance leastconn</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">balance <span class="built_in">source</span> //ip</span></span><br><span class="line">	</span><br><span class="line">	balance roundrobin</span><br><span class="line">	</span><br><span class="line">        server node1 127.0.0.1:5673 check inter 5000 rise 2 fall 2</span><br><span class="line">        server node2 127.0.0.1:5674 check inter 5000 rise 2 fall 2</span><br><span class="line"></span><br><span class="line">listen stats</span><br><span class="line">	bind 172.16.98.133:8100</span><br><span class="line">	mode http</span><br><span class="line">	option httplog</span><br><span class="line">	stats enable</span><br><span class="line">	stats uri /rabbitmq-stats</span><br><span class="line">	stats refresh 5s</span><br></pre></td></tr></table></figure>

<h3 id="启动HAproxy负载"><a href="#启动HAproxy负载" class="headerlink" title="启动HAproxy负载"></a>启动HAproxy负载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/local/haproxy/sbin/haproxy -f /etc/haproxy/haproxy.cfg</span><br><span class="line">//查看haproxy进程状态</span><br><span class="line">ps -ef | grep haproxy</span><br><span class="line"></span><br><span class="line">访问如下地址对mq节点进行监控</span><br><span class="line">http://172.16.98.133:8100/rabbitmq-stats</span><br></pre></td></tr></table></figure>

<p>代码中访问mq集群地址，则变为访问haproxy地址:5672</p>
<hr>
<h1 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h1>]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码分析</title>
    <url>/posts/33dde6b2c8be/</url>
    <content><![CDATA[<h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><blockquote>
<p>以下代码都是基于java8的版本</p>
</blockquote>
<h2 id="ArrayList简介"><a href="#ArrayList简介" class="headerlink" title="ArrayList简介"></a>ArrayList简介</h2><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ArrayList与Collection的关系如下图，实现代表继承，虚线代表实现接口：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325220522.png" alt="img"></p>
<ol>
<li>ArrayList是一个<strong>数组队列</strong>，相当于<strong>动态数组</strong>。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List，RandomAccess，Cloneable，java.io.Serializable这些接口。</li>
<li>ArrayList继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。</li>
<li>ArrayList实现了RandmoAccess接口，即提供了随机访问的功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。</li>
<li>ArrayList实现了Cloneable接口，即覆盖了函数clone()，能被克隆。</li>
<li>ArrayList实现了java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。</li>
</ol>
<blockquote>
<p><strong>注意：ArrayList中的操作不是线程安全的</strong>！所以，建议在单线程中使用，多线程情况下可以选择<code>CopyOnWriteArrayList</code>或者使用<code>Collections.synchronizedList</code>方法将其包装成一个线程安全的List。</p>
</blockquote>
<h2 id="ArrayList的API"><a href="#ArrayList的API" class="headerlink" title="ArrayList的API"></a>ArrayList的API</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Collection中定义的API</span></span><br><span class="line"><span class="type">boolean</span>             <span class="title function_">add</span><span class="params">(E object)</span></span><br><span class="line"><span class="type">boolean</span>             <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; collection)</span></span><br><span class="line"><span class="keyword">void</span>                <span class="title function_">clear</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span>             <span class="title function_">contains</span><span class="params">(Object object)</span></span><br><span class="line"><span class="type">boolean</span>             <span class="title function_">containsAll</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br><span class="line"><span class="type">boolean</span>             <span class="title function_">equals</span><span class="params">(Object object)</span></span><br><span class="line"><span class="type">int</span>                 <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span>             <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">Iterator&lt;E&gt;         <span class="title function_">iterator</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span>             <span class="title function_">remove</span><span class="params">(Object object)</span></span><br><span class="line"><span class="type">boolean</span>             <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br><span class="line"><span class="type">boolean</span>             <span class="title function_">retainAll</span><span class="params">(Collection&lt;?&gt; collection)</span></span><br><span class="line"><span class="type">int</span>                 <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">&lt;T&gt; T[]             toArray(T[] array)</span><br><span class="line">Object[]            toArray()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// AbstractCollection中定义的API</span></span><br><span class="line"><span class="keyword">void</span>                <span class="title function_">add</span><span class="params">(<span class="type">int</span> location, E object)</span></span><br><span class="line"><span class="type">boolean</span>             <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> location, Collection&lt;? extends E&gt; collection)</span></span><br><span class="line">E                   <span class="title function_">get</span><span class="params">(<span class="type">int</span> location)</span></span><br><span class="line"><span class="type">int</span>                 <span class="title function_">indexOf</span><span class="params">(Object object)</span></span><br><span class="line"><span class="type">int</span>                 <span class="title function_">lastIndexOf</span><span class="params">(Object object)</span></span><br><span class="line">ListIterator&lt;E&gt;     <span class="title function_">listIterator</span><span class="params">(<span class="type">int</span> location)</span></span><br><span class="line">ListIterator&lt;E&gt;     <span class="title function_">listIterator</span><span class="params">()</span></span><br><span class="line">E                   <span class="title function_">remove</span><span class="params">(<span class="type">int</span> location)</span></span><br><span class="line">E                   <span class="title function_">set</span><span class="params">(<span class="type">int</span> location, E object)</span></span><br><span class="line">List&lt;E&gt;             <span class="title function_">subList</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// ArrayList新增的API</span></span><br><span class="line">Object               <span class="title function_">clone</span><span class="params">()</span></span><br><span class="line"><span class="keyword">void</span>                 <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minimumCapacity)</span></span><br><span class="line"><span class="keyword">void</span>                 <span class="title function_">trimToSize</span><span class="params">()</span></span><br><span class="line"><span class="keyword">void</span>                 <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span></span><br></pre></td></tr></table></figure>



<h2 id="ArrayList的属性"><a href="#ArrayList的属性" class="headerlink" title="ArrayList的属性"></a>ArrayList的属性</h2><p>ArrayList的主要属性如下代码所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器默认初始化大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CAPACITY</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个空对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一个空对象，如果使用默认构造函数创建ArrayList，则默认对象内容是该值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList存放对象的容器，后面的添加、删除等操作都是基于该属性来进行操作</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前列表已使用的长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组最大长度（2147483639），</span></span><br><span class="line"><span class="comment">//这里为什么是Integer.MAX_VALUE - 8是因为有些虚拟机在数组中保留了一些头部信息，防止内存溢出</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_ARRAY_SIZE</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是从AbstractList继承过来的，代表ArrayList集合修改的次数</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h3><p>如果不传入参数，则使用默认无参构造方法创建ArrayLisy对象，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten. </span></span><br><span class="line"><span class="comment"> 构造一个初始容量为 10 的空列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：此时我们创建的ArrayList对象中的elementData中的长度是0，size是0，当进行第一次add的时候，elementDate将会变成默认的长度：10。</strong>后文会讲到</p>
</blockquote>
<h3 id="带int类型的构造函数"><a href="#带int类型的构造函数" class="headerlink" title="带int类型的构造函数"></a>带int类型的构造函数</h3><p>如果传入参数，则代表指定ArrayList的初始数组长度；传入参数如果是大于0，则使用用户的参数初始化；如果参数等于0，则用内部的空对象<strong>EMPTY_ELEMENTDATA</strong>的地址直接赋值给elementData；否则抛出异常，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 构造一个具有指定初始容量的空列表。</span></span><br><span class="line"><span class="comment">参数：initialCapacity – 列表的初始容量</span></span><br><span class="line"><span class="comment">抛出：IllegalArgumentException – 如果指定的初始容量为负</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="带Collection对象的构造函数"><a href="#带Collection对象的构造函数" class="headerlink" title="带Collection对象的构造函数"></a>带Collection对象的构造函数</h3><ol>
<li>将Collection对象转换成数组，然后将数组的地址赋值给elementData。</li>
<li>更新size的值，如果size的值等于0直接将内部空对象<strong>EMPTY_ELEMENTDATA</strong>的地址赋值给elementData。</li>
<li>如果size的值大于0，则执行<strong>Arrays.copy</strong>方法，把Collection对象的内容copy(可以理解为深拷贝)到elementData中，并且这些元素是按照该collection的迭代器返回它们的顺序排列的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 按照集合的迭代器返回的顺序构造一个包含指定集合元素的列表。</span></span><br><span class="line"><span class="comment">参数：c – 其元素将被放入此列表的集合</span></span><br><span class="line"><span class="comment">抛出：NullPointerException – 如果指定的集合为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="System-arraycopy和Arrays-copy"><a href="#System-arraycopy和Arrays-copy" class="headerlink" title="System.arraycopy和Arrays.copy"></a>System.arraycopy和Arrays.copy</h2><p>这里介绍下<strong>System.arraycopy</strong>和<strong>Arrays.copy</strong>方法，因为后分析源码时会经常用到。</p>
<p><strong>System.arraycopy方法</strong>：它就是从指定的源数组将元素中复制到目标数组，复制从指定的位置开始，到设定的复制长度结束，然后从目标数组的指定起始位置依次插入。最终会调用native本地方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src 源数组</span></span><br><span class="line"><span class="comment">// srcPos 源数组要复制的起始位置</span></span><br><span class="line"><span class="comment">// dest 要赋值到的目标数组</span></span><br><span class="line"><span class="comment">// destPos 目标数组放置的起始位置</span></span><br><span class="line"><span class="comment">// length 复制的长度</span></span><br><span class="line"><span class="comment">// 使用了native关键字，说明调用的是其他语言写的底层函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">arraycopy</span><span class="params">(Object src,  <span class="type">int</span>  srcPos,</span></span><br><span class="line"><span class="params">                                    Object dest, <span class="type">int</span> destPos,</span></span><br><span class="line"><span class="params">                                    <span class="type">int</span> length)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Arrays.copy方法</strong>：它新建了一个数组并且将原数组的内容拷贝到长度为newLength的新数组中，并且返回该新数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// original 要复制的数组</span></span><br><span class="line"><span class="comment">// newLength 要返回副本的长度</span></span><br><span class="line"><span class="comment">// newwType 要返回的副本类型</span></span><br><span class="line"><span class="comment">// 内部调用了System.arraycopy方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="type">int</span> newLength, Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>区别：</strong></p>
<ol>
<li>System.arraycopy<code>需要目标数组</code>，将原数组拷贝到目标数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置。</li>
<li>Arrays.copyof是系统<code>自动在内部新建一个数组最为目标数组</code>，调用System.arraycopy将原数组的内容拷贝到长度为newLength的目标数组中，并返回新建的目标数组。</li>
</ol>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>ArrayList提供了add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)、set(int index, E element)这个五个方法来实现ArrayList增加。</p>
<h3 id="add-E-e"><a href="#add-E-e" class="headerlink" title="add(E e)"></a>add(E e)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 将指定的元素附加到此列表的末尾。</span></span><br><span class="line"><span class="comment">参数：e - 要附加到此列表的元素</span></span><br><span class="line"><span class="comment">返回：true （由Collection.add指定）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看<strong>ensureCapacityInternal</strong>方法，以及它内部调用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *这个方式是判断当前数组是否是个空数组，</span></span><br><span class="line"><span class="comment"> *如果是就返回默认长度10，否则就返回size+1;</span></span><br><span class="line"><span class="comment"> *也就是说如果你是用无参构造函数初始化ArrayList，那么在第一次调用add方法时，默认长度会变成10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.这个方式是判断当前数组是否是个空数组</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="comment">// 2.如果是就返回默认长度10</span></span><br><span class="line">        <span class="comment">//也就是说如果用 new ArrayList&lt;&gt;()那么，在第一次调用add方法时，默认长度会变成10</span></span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看<strong>ensureExplicitCapacity</strong>方法，以及它内部调用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录修改次数和判断是否需要扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个方法首先将集合修改次数加1，modCount字段在AbstractList类里，</span></span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="comment">//然后判断数组的长度是否能存入下一个元素</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果长度不够会调用grow方法进行扩容</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看<strong>grow</strong>方法，以及它内部调用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个方法首先定义数组新的长度为原来数组长度的1.5倍，</span></span><br><span class="line"><span class="comment">//如果新长度减去所需数组的最小长度小于0，那么新长度就等于所需数组最小长度；</span></span><br><span class="line"><span class="comment">//再下面的判断是如果新长度大于MAX_ARRAY_SIZE(ArrayList内部定义MAX_ARRAY_SIZE的值是：2147483639)就调用</span></span><br><span class="line"><span class="comment">//hugeCapacity方法，最后调用Arrays.copyOf将扩容后的新数组地址赋值给elementData</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">        <span class="comment">//这个方法首先定义数组新的长度为原来数组长度的1.5倍，</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//如果新长度减去所需数组的最小长度小于0，那么新长度就等于所需数组最小长度；</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再下面的判断新的长度是否大于MAX_ARRAY_SIZE(ArrayList内部定义MAX_ARRAY_SIZE的值是：2147483639)</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 调用hugeCapacity方法，设置新的长度</span></span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        <span class="comment">// 最后调用Arrays.copyOf将扩容后的新数组地址赋值给elementData</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看<strong>hugeCapacity</strong>方法，以及它内部调用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置新的长度   </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">    <span class="comment">// 如果扩容长度超过MAX_ARRAY_SIZE，则设置长度为Integer.MAX_VALUE</span></span><br><span class="line">    <span class="comment">// 但不是百分百成功的，这取决于虚拟机。</span></span><br><span class="line">    <span class="comment">//（如果我们在某些虚拟机上可以避免OutOfMemory，我们将另外分配Integer.MAX_VALUE，</span></span><br><span class="line">    <span class="comment">// 如果你很幸运（取决于虚拟机），我们将成功）</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">    MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后总结一下add方法的逻辑：</p>
<ol>
<li>确保数组已使用长度（size）加1后可以存入下一个元素。</li>
<li>修改次数modCount标识自增1，如果当前数组元素个数+1后大于当前数组长度，则调用grow方法，扩容数组，grow方法会将当前数组的容量变为原来容量的1.5倍。</li>
<li>确保新加的元素有地方存储后，则将新元素添加到位于size++的位置上。</li>
<li>返回添加成功的布尔值。</li>
</ol>
<h3 id="add-int-index-E-element"><a href="#add-int-index-E-element" class="headerlink" title="add(int index, E element)"></a>add(int index, E element)</h3><p>这个方法和上面的add类似，该方法可以按照元素的位置，指定新元素位置插入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断索引位置是否正确</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">//2.扩容检测</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//3.对源数组进行复制处理（位移），从index + 1到size - index</span></span><br><span class="line">    <span class="comment">//相当于index和后面的元素往后移动一位</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">//4.在指定的位置赋值</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>接下来我们看<strong>rangeCheckForAdd</strong>方法，以及它内部调用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该方法首先调用rangeCheckForAdd方法判断指定的位置小于当前数组的长度并且大于0，否则抛出异常。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheckForAdd</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二步调用的<strong>ensureCapacityInternal</strong>方法和上面的add方法逻辑一样。</p>
<p>第三步调用<strong>System.arraycopy</strong>方法把<strong>指定下标以及后面的元素全部往后移一位</strong>。</p>
<p>最后将新的元素放到指定位置（index）上，并将size+1。</p>
<h3 id="addAll-Collection-lt-extends-E-gt-c"><a href="#addAll-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(Collection&lt;? extends E&gt; c)"></a>addAll(Collection&lt;? extends E&gt; c)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照指定的Collection迭代器所返回的顺序，依次插入到列表尾部。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 将c转换为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="comment">//扩容处理，大小为size + numNew</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法首先传过来的Collection集合转换为数组，然后做扩容处理，接着使用System.arraycopy把转换后的数组复制到列表尾部。</p>
<h3 id="addAll-int-index-Collection-lt-extends-E-gt-c"><a href="#addAll-int-index-Collection-lt-extends-E-gt-c" class="headerlink" title="addAll(int index, Collection&lt;? extends E&gt; c)"></a>addAll(int index, Collection&lt;? extends E&gt; c)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">//判断索引位置是否正确</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">// 将c转换为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    <span class="comment">//扩容处理，大小为size + numNew</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">//如果插入索引小于列表长度，则将当前索引等于index和大于index的元素往后移numMoved个位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">//将数组添加到列表尾部</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    <span class="comment">//更新列表长度</span></span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">80</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set-int-index-E-element"><a href="#set-int-index-E-element" class="headerlink" title="set(int index, E element)"></a>set(int index, E element)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">//判断插入位置是否正确，如果大于列表长度会抛出异常</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//获取插入位置的当前元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    <span class="comment">//将新的元素替换当前插入位置的元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">//返回插入位置老的值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看<strong>rangeCheck</strong>方法，以及它内部调用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断索引位置是否正确</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rangeCheck</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看<strong>elementData</strong>方法，以及它内部调用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">E <span class="title function_">elementData</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>ArrayList提供了外界remove(int index)、remove(Object o)、removeAll(Collection&lt;?&gt; c)、clear()四个方法进行元素的删除。</p>
<h3 id="remove-int-index"><a href="#remove-int-index" class="headerlink" title="remove(int index)"></a>remove(int index)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 移除此列表中指定位置的元素。 将任何后续元素向左移动（从它们的索引中减去一个）。</span></span><br><span class="line"><span class="comment">参数：index – 要删除的元素的索引</span></span><br><span class="line"><span class="comment">返回：从列表中删除的元素</span></span><br><span class="line"><span class="comment">抛出：IndexOutOfBoundsException –</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//判断删除位置是否正确，如果大于列表长度会抛出异常</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将集合修改次数加1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//获取当前删除位置上的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是否删除的是最后一个元素，</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将删除位置后方的元素向左移numMoved个位置</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将列表最后的元素置为null，等待垃圾收集器收集</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回删除位置老的值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除主要流程：检查索引是否正确，取到索引对应的数值，将数组复制缩容，最后位置置为null，返回刚刚索引对应的数值。</p>
<h3 id="remove-Object-o"><a href="#remove-Object-o" class="headerlink" title="remove(Object o)"></a>remove(Object o)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 从此列表中删除第一次出现的指定元素（如果存在）。 如果列表不包含该元素，则它保持不变。 更正式地，删除具有最低索引i的元素，使得(o==null ? get(i)==null : o.equals(get(i))) （如果这样的元素存在）。 如果此列表包含指定的元素（或等效地，如果此列表因调用而更改），则返回true 。</span></span><br><span class="line"><span class="comment">参数：o - 要从此列表中删除的元素（如果存在）</span></span><br><span class="line"><span class="comment">返回：如果此列表包含指定的元素，则为tru</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">//因为ArrayList允许存在null，所以需要进行null判断</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看<strong>fastRemove</strong>方法，以及它内部调用的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">该方法和remove(int index) 基本一样，只不过该方法跳过边界检查并且不返回移除的值，而且是私有方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//将集合修改次数加1      </span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//判断是否删除的是最后一个元素，</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果不是将删除位置后的元素向左移numMoved个位置</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">//将列表最后的元素置为null，等待垃圾收集器收集</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="removeAll-Collection-lt-gt-c"><a href="#removeAll-Collection-lt-gt-c" class="headerlink" title="removeAll(Collection&lt;?&gt; c)"></a>removeAll(Collection&lt;?&gt; c)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">从此列表中删除包含在指定集合中的所有元素。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">c – 包含要从此列表中删除的元素的集合</span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">如果此列表因调用而更改，则为true</span></span><br><span class="line"><span class="comment">抛出：</span></span><br><span class="line"><span class="comment">ClassCastException – 如果此列表的元素的类与指定的集合不兼容（可选）</span></span><br><span class="line"><span class="comment">NullPointerException – 如果此列表包含空元素并且指定的集合不允许空元素（可选），或者指定的集合为空</span></span><br><span class="line"><span class="comment">也可以看看：</span></span><br><span class="line"><span class="comment">Collection.contains(Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">//进行判断，如果c为null抛出异常</span></span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来我们看batchRemove方法，以及它内部调用的方法。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="type">boolean</span> complement)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">modified</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//遍历数组，并检查这个集合是否包含对应的值，</span></span><br><span class="line">        <span class="comment">//移动要保留的值到数组前面，w最后值为要保留的元素的数量,</span></span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 确保异常抛出前的部分可以完成期望的操作，而被遍历的部分会被接到后面</span></span><br><span class="line">        <span class="comment">//r不等于size表示可能出错了</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">  <span class="comment">//如果w等于size，表示全部元素都保留了，所以也就没有删除操作发生，所以会返回false；反之，返回true，并更改数组</span></span><br><span class="line">  <span class="comment">//而w不等于size的时候，即使try块抛出异常，也能正确处理异常抛出前的操作，因为w始终为要保留的前段部分的长度，数组也不会因此乱序</span></span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="comment">// 下标大于等于w的元素都是需要删除的，因为上面try块中将需要保留的元素都移到的数组前段，也就是下标小于w的那些元素被保留了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 记录数组修改次数，</span></span><br><span class="line">            modCount += size - w;</span><br><span class="line">            <span class="comment">// 设置数组最新元素个数</span></span><br><span class="line">            size = w;</span><br><span class="line">            <span class="comment">// 返回删除成功</span></span><br><span class="line">            modified = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//将集合修改次数加1  </span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//循环将列表中的所有元素置为null，等待垃圾收集器收集</span></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//将列表长度设为0</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h2><p>ArrayList提供了get(int index)用读取ArrayList中的元素。由于ArrayList是动态数组，所以我们完全可以根据下标来获取ArrayList中的元素，而且速度还比较快。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">//判断删除位置是否正确，如果大于列表长度会抛出异常</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//直接返回列表中下标等于index的元素</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断元素是否存在列表中"><a href="#判断元素是否存在列表中" class="headerlink" title="判断元素是否存在列表中"></a>判断元素是否存在列表中</h2><p>ArrayList提供了contains(Object o)用于判断元素是否存在于列表中。</p>
<blockquote>
<p><strong>注意：contains方法会遍历ArrayList。</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//调用indexOf方法判断需要查找的元素在列表中的下标是否大于等于0，小于0则不存在</span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素下标，和remove(Object o) 类似</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//因为ArrayList允许存在null，所以需要进行null判断</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历列表，如果列表存在null值的元素，直接返回其下标位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历列表，使用equals判断是否有相等的元素，有的话直接返回其下标位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//列表中不能存在传进来的元素，返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最小化ArrayList的实际存储量"><a href="#最小化ArrayList的实际存储量" class="headerlink" title="最小化ArrayList的实际存储量"></a>最小化ArrayList的实际存储量</h2><p>ArrayList提供了trimToSize()方法用于将底层数组的容量调整为当前列表保存的实际元素的大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//将集合修改次数加1</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//如果当前ArrayList的实际长度小于内部维护的数组的长度，将内部数组超过size后的空余的空间（包括null值）去除，调用Arrays.cppyof方法拷贝elementData，长度为size</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="截取ArrayList部分内容"><a href="#截取ArrayList部分内容" class="headerlink" title="截取ArrayList部分内容"></a>截取ArrayList部分内容</h2><p>ArrayList提供了subList(int fromIndex, int toIndex)方法来实现部分数据的截取。</p>
<p>可以从源码中看到其实是创建了一个SubList的内部对象，可以理解为是返回当前ArrayList的部分视图，其实指向的存放数据的还是一个地方。<strong>如果修改了subList返回的内容的话，原来的内容也会被修改。</strong></p>
<p>因为sublist的get和set方法什么的 都是直接改的引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        <span class="comment">//检查需要截取的下标位置是否正确</span></span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SubList</span>(<span class="built_in">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subListRangeCheck</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;fromIndex = &quot;</span> + fromIndex);</span><br><span class="line">        <span class="keyword">if</span> (toIndex &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;toIndex = &quot;</span> + toIndex);</span><br><span class="line">        <span class="keyword">if</span> (fromIndex &gt; toIndex)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;fromIndex(&quot;</span> + fromIndex +</span><br><span class="line">                                               <span class="string">&quot;) &gt; toIndex(&quot;</span> + toIndex + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是ArrayList的内部类</span></span><br><span class="line">        SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">                <span class="type">int</span> offset, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex) &#123;</span><br><span class="line">            <span class="built_in">this</span>.parent = parent;</span><br><span class="line">            <span class="built_in">this</span>.parentOffset = fromIndex;</span><br><span class="line">            <span class="built_in">this</span>.offset = offset + fromIndex;</span><br><span class="line">            <span class="built_in">this</span>.size = toIndex - fromIndex;</span><br><span class="line">            <span class="built_in">this</span>.modCount = ArrayList.<span class="built_in">this</span>.modCount;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>ArrayList自己实现了序列化和反序列化，因为它实现了writeObject和readObject方法。</p>
<p>ArrayList基于数组实现，会自动扩容。</p>
<p>添加元素时会自己判断是否需要扩容，最好指定一个大概的大小，防止后面多次扩容带来的内存消耗；删除元素时不会减少容量，删除元素时，将删除掉的位置元素置为null，下次gc就会自动回收这些元素所占的空间。</p>
<p>ArrayList是线程不安全的。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>excel的导入与导出---通用版</title>
    <url>/posts/e0e66d180037/</url>
    <content><![CDATA[<h1 id="excel的导入与导出—通用版"><a href="#excel的导入与导出—通用版" class="headerlink" title="excel的导入与导出—通用版"></a>excel的导入与导出—通用版</h1><blockquote>
<p>web项目关于导入导出的业务场景很常见，最近我就又遇到了这个业务场景。这次将最近半个月做的导入导出总结一下</p>
</blockquote>
<p>使用的pom如下,主要还是阿里巴巴的<code>easyexcel</code>依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.lxiaol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>excel_demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>excel_demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>excel_demo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>11<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--easyExcel--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.67<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>项目结构如下，一个很简单的小demo</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325220305.png" alt="image-20210815145241500"></p>
<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>因为我的业务不只是一个模块用到导入，所以定义了一个泛型类。<code>CommonExcelListener&lt;T&gt;</code>具体代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.excel_demo.common.listeners;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.context.AnalysisContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * T 是读取到的一行数据转换为的目标类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年08月15日 14:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonExcelListener</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AnalysisEventListener</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**存放解析到的数据，给了一个初始容量，为了避免list的频繁扩容带来的性能问题*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;T&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**解析每一行都会执行该方法*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(T data, AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条数据:&quot;</span> + data.toString());</span><br><span class="line">        <span class="built_in">this</span>.list.add(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**解析完成*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAfterAllAnalysed</span><span class="params">(AnalysisContext analysisContext)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析完成:共解析到&#123;&#125;数据&quot;</span>, <span class="built_in">this</span>.list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**解析表头*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invokeHeadMap</span><span class="params">(Map&lt;Integer, String&gt; headMap, AnalysisContext context)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;解析到一条头数据：&#123;&#125;, currentRowHolder: &#123;&#125;&quot;</span>, headMap.toString(), context.readRowHolder().getRowIndex());</span><br><span class="line">        headMap.entrySet().removeIf((h) -&gt; Objects.isNull(h.getValue()) || <span class="string">&quot;&quot;</span>.equals(h.getValue()));</span><br><span class="line">        log.info(<span class="string">&quot;表头列总数：&#123;&#125;,列头为：&#123;&#125;&quot;</span>, headMap.size(), headMap.values());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设我这里是用户的账号和手机号的导入，对应的实体类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.excel_demo.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelIgnore;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年08月15日 14:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserExcelDto</span> &#123;</span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;用户名&quot;, index = 0)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelProperty(value = &quot;手机号&quot;, index = 1)</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExcelIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么该如何使用呢？下面来简单讲一下，so easy~</p>
<p>首先创建导入所需要的controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.excel_demo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.lxiaol.excel_demo.common.listeners.CommonExcelListener;</span><br><span class="line"><span class="keyword">import</span> cn.lxiaol.excel_demo.dto.UserExcelDto;</span><br><span class="line"><span class="keyword">import</span> cn.lxiaol.excel_demo.dto.UserExcelParamDto;</span><br><span class="line"><span class="keyword">import</span> cn.lxiaol.excel_demo.service.ExcelService;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.EasyExcel;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年08月15日 14:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api/excel&quot;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelController</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**导入*/</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/dataImport&quot;, headers = &quot;content-type=multipart/form-data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dataImport</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 实例化对象并传入泛型类型</span></span><br><span class="line">            CommonExcelListener&lt;UserExcelDto&gt; listener = <span class="keyword">new</span> <span class="title class_">CommonExcelListener</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">// 调用easyexcel的方法，传入文件流，目标类型，和read监听器,</span></span><br><span class="line">            <span class="comment">// 设置表头所在行，自动去除空字符，设置读取第几个sheet页，并开始读取</span></span><br><span class="line">            EasyExcel.read(file.getInputStream(), UserExcelDto.class, listener)</span><br><span class="line">                    .headRowNumber(<span class="number">1</span>).autoTrim(<span class="literal">true</span>).sheet(<span class="number">0</span>).doRead();</span><br><span class="line">            <span class="comment">//读取结束，得到读取到的数据</span></span><br><span class="line">            List&lt;UserExcelDto&gt; list = listener.getList();</span><br><span class="line">            <span class="keyword">if</span> (!list.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//.....具体业务逻辑</span></span><br><span class="line">                System.out.println(<span class="string">&quot;读取到数据，进行具体的后续操作&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="string">&quot;excel内容不能为空&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;xxxx导入 报错：&quot;</span>, e);</span><br><span class="line">            result = <span class="string">&quot;excel导入报错，请检查数据是否合规&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单两行代码，就读取完了excel的内容，相比原生的poi操作简单多了，果然是easyexcel</p>
<p>拿到读取来的数据，就可以做具体的业务了。</p>
<h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p>好，下面再看一下导出，因为导出也是多个模块都有，所以也写了公用的工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.excel_demo.common.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.XSSFWorkbook;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年08月15日 14:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelExportUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表头</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="comment">//各个列的表头</span></span><br><span class="line">    <span class="keyword">private</span> String[] heardList;</span><br><span class="line">    <span class="comment">//各个列的元素key值</span></span><br><span class="line">    <span class="keyword">private</span> String[] heardKey;</span><br><span class="line">    <span class="comment">//需要填充的数据信息</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Map&gt; data;</span><br><span class="line">    <span class="comment">//字体大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">fontSize</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line">    <span class="comment">//行高</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">rowHeight</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//列宽</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">columWidth</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="comment">//工作表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">sheetName</span> <span class="operator">=</span> <span class="string">&quot;sheet1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始导出数据信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exportExport</span><span class="params">(HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建工作簿</span></span><br><span class="line">        <span class="type">Workbook</span> <span class="variable">wb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XSSFWorkbook</span>();</span><br><span class="line">        <span class="comment">//创建工作表</span></span><br><span class="line">        <span class="type">Sheet</span> <span class="variable">sheet</span> <span class="operator">=</span> wb.createSheet(<span class="built_in">this</span>.sheetName);</span><br><span class="line">        <span class="comment">//设置默认行宽</span></span><br><span class="line">        sheet.setDefaultColumnWidth(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置表头样式，表头居中</span></span><br><span class="line">        <span class="type">CellStyle</span> <span class="variable">titleStyle</span> <span class="operator">=</span> wb.createCellStyle();</span><br><span class="line">        <span class="comment">//设置字体</span></span><br><span class="line">        <span class="type">Font</span> <span class="variable">titleFont</span> <span class="operator">=</span> wb.createFont();</span><br><span class="line">        titleFont.setFontHeightInPoints((<span class="type">short</span>) <span class="built_in">this</span>.fontSize);</span><br><span class="line">        titleStyle.setFont(titleFont);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在第1行创建rows</span></span><br><span class="line">        <span class="type">Row</span> <span class="variable">titleRow</span> <span class="operator">=</span> sheet.createRow(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//设置列头元素</span></span><br><span class="line">        Cell cellHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; heardList.length; i++) &#123;</span><br><span class="line">            <span class="comment">//背景填充色</span></span><br><span class="line">            titleStyle.setFillForegroundColor(IndexedColors.GREY_40_PERCENT.index);</span><br><span class="line">            titleStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);</span><br><span class="line">            <span class="comment">//边框</span></span><br><span class="line">            titleStyle.setBorderLeft(BorderStyle.THIN);<span class="comment">//左边框</span></span><br><span class="line">            titleStyle.setBorderRight(BorderStyle.THIN);<span class="comment">//右边框</span></span><br><span class="line">            cellHead = titleRow.createCell(i);</span><br><span class="line">            cellHead.setCellValue(heardList[i]);</span><br><span class="line">            cellHead.setCellStyle(titleStyle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始写入实体数据信息</span></span><br><span class="line">        <span class="comment">//设置数据样式</span></span><br><span class="line">        <span class="type">CellStyle</span> <span class="variable">dataStyle</span> <span class="operator">=</span> wb.createCellStyle();</span><br><span class="line">        <span class="comment">//设置字体</span></span><br><span class="line">        <span class="type">Font</span> <span class="variable">dataFont</span> <span class="operator">=</span> wb.createFont();</span><br><span class="line"><span class="comment">//        font.setFontHeightInPoints((short) this.fontSize);</span></span><br><span class="line">        dataFont.setBold(<span class="literal">false</span>);</span><br><span class="line">        dataStyle.setFont(dataFont);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map datum : data) &#123;</span><br><span class="line">            <span class="type">Row</span> <span class="variable">row</span> <span class="operator">=</span> sheet.createRow(count);</span><br><span class="line">            Cell cell;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heardKey.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                cell = row.createCell(j);</span><br><span class="line">                cell.setCellStyle(dataStyle);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">valueObject</span> <span class="operator">=</span> datum.get(heardKey[j]);</span><br><span class="line">                String value;</span><br><span class="line">                <span class="keyword">if</span> (valueObject == <span class="literal">null</span>) &#123;</span><br><span class="line">                    valueObject = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (valueObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    <span class="comment">//取出的数据是字符串直接赋值</span></span><br><span class="line">                    value = (String) datum.get(heardKey[j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valueObject <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">                    <span class="comment">//取出的数据是Integer</span></span><br><span class="line">                    value = String.valueOf(((Integer) (valueObject)).floatValue());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (valueObject <span class="keyword">instanceof</span> BigDecimal) &#123;</span><br><span class="line">                    <span class="comment">//取出的数据是BigDecimal</span></span><br><span class="line">                    value = String.valueOf(((BigDecimal) (valueObject)).floatValue());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    value = valueObject.toString();</span><br><span class="line">                &#125;</span><br><span class="line">                cell.setCellValue(Objects.isNull(value) ? <span class="string">&quot;&quot;</span> : value);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        data.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//导出数据</span></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> URLEncoder.encode(<span class="built_in">this</span>.title, StandardCharsets.UTF_8);</span><br><span class="line">            <span class="comment">//设置Http响应头告诉浏览器下载这个附件</span></span><br><span class="line">            response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;Filename=&quot;</span> + fileName + <span class="string">&quot;.xlsx&quot;</span>);</span><br><span class="line">            wb.write(os);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;导出Excel出现严重异常，异常信息：&quot;</span> + ex.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            wb.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置导出excel 的信息</span></span><br><span class="line"><span class="comment">     * 主要用到了反射，获取类中标注的ExcelProperty注解的字段，</span></span><br><span class="line"><span class="comment">     * 然后根据注解的index进行排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maps</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ExcelExportUtil <span class="title function_">getExcelExportUtil</span><span class="params">(List&lt;Map&gt; maps, Field[] fields)</span> &#123;</span><br><span class="line">        List&lt;Field&gt; fieldList = Arrays.stream(fields)</span><br><span class="line">                .filter(field -&gt; &#123;</span><br><span class="line">                    <span class="type">ExcelProperty</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(ExcelProperty.class);</span><br><span class="line">                    <span class="keyword">if</span> (annotation != <span class="literal">null</span> &amp;&amp; annotation.index() &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">                        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;).sorted(Comparator.comparing(field -&gt; &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="type">ExcelProperty</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(ExcelProperty.class);</span><br><span class="line">                    <span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                        index = annotation.index();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                &#125;)).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; title = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; properties = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        fieldList.forEach(field -&gt; &#123;</span><br><span class="line">            <span class="type">ExcelProperty</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(ExcelProperty.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> String[] value = annotation.value();</span><br><span class="line">                <span class="type">String</span> <span class="variable">tit</span> <span class="operator">=</span> value[<span class="number">0</span>];</span><br><span class="line">                title.add(tit);</span><br><span class="line">                <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> field.getName();</span><br><span class="line">                properties.add(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">ExcelExportUtil</span> <span class="variable">excelExport</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExcelExportUtil</span>();</span><br><span class="line">        excelExport.setData(maps);</span><br><span class="line">        excelExport.setHeardKey(properties.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">        excelExport.setFontSize(<span class="number">14</span>);</span><br><span class="line">        excelExport.setHeardList(title.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> excelExport;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再来看一下controller的导出代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> ExcelService excelService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**导出*/</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/dataExport&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dataExport</span><span class="params">(<span class="meta">@RequestBody</span> UserExcelParamDto dto, HttpServletRequest request, HttpServletResponse response)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// .....调用具体的业务方法</span></span><br><span class="line">        excelService.export(dto, request, response);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.error(<span class="string">&quot;导出 接口报错：&quot;</span>, e);</span><br><span class="line">        result = <span class="string">&quot;excel导出报错，请检查数据是否合规&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据前台传过来的筛选条件，调用service层的业务方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.excel_demo.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.lxiaol.excel_demo.common.utils.ExcelExportUtil;</span><br><span class="line"><span class="keyword">import</span> cn.lxiaol.excel_demo.dto.UserExcelDto;</span><br><span class="line"><span class="keyword">import</span> cn.lxiaol.excel_demo.dto.UserExcelParamDto;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.DateUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年08月15日 14:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExcelService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 导出根据筛选条件查询到的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dto      筛选条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">export</span><span class="params">(UserExcelParamDto dto, HttpServletRequest request,</span></span><br><span class="line"><span class="params">                       HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟从数据库查询到10条数据，真是业务可将这段改为查询数据库获取到list</span></span><br><span class="line">        List&lt;UserExcelDto&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">UserExcelDto</span> <span class="variable">userExcelDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserExcelDto</span>();</span><br><span class="line">            userExcelDto.setUsername(<span class="string">&quot;用户：&quot;</span> + i);</span><br><span class="line">            userExcelDto.setUsername(<span class="string">&quot;手机号：188****8888&quot;</span>);</span><br><span class="line">            list.add(userExcelDto);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 list 数据存放到maps中，主要是为了导出时根据表头填写对应的值</span></span><br><span class="line">        List&lt;Map&gt; maps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.forEach(po -&gt; maps.add(JSONObject.parseObject(JSONObject.toJSONString(po), Map.class)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取到excel导出工具类，并根据传入class设置了表头信息</span></span><br><span class="line">        <span class="type">ExcelExportUtil</span> <span class="variable">excelExportUtil</span> <span class="operator">=</span></span><br><span class="line">                ExcelExportUtil.getExcelExportUtil(maps, UserExcelDto.class.getDeclaredFields());</span><br><span class="line"></span><br><span class="line">        excelExportUtil.setTitle(<span class="string">&quot;Excel导出_&quot;</span> + DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>).format(LocalDateTime.now()));</span><br><span class="line">        excelExportUtil.exportExport(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重点是理解<code>excelExportUtil.exportExport(response)</code>方法。</p>
<p>总的来说 有了easyexcel的加持，excel 的导入到处还是很简单的。</p>
<blockquote>
<p>示例代码在码云上，传送门—&gt;<a href="https://gitee.com/lixiaogou/lxiaol_code_demo/tree/master/excel_demo">ゝ李大龙</a></p>
</blockquote>
]]></content>
      <categories>
        <category>easyexcel</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL Explain详解</title>
    <url>/posts/84c5233f017b/</url>
    <content><![CDATA[<h1 id="MySQL-Explain详解"><a href="#MySQL-Explain详解" class="headerlink" title="MySQL Explain详解"></a>MySQL Explain详解</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 实际SQL，查找用户名为Jefabc的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Jefabc&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查看SQL是否使用索引，前面加上explain即可</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Jefabc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223340.png" alt="img"></p>
<p>expain出来的信息有12列，分别是：</p>
<ol>
<li>id:选择标识符</li>
<li>select_type:表示查询的类型。</li>
<li>table:输出结果集的表</li>
<li>partitions:匹配的分区</li>
<li>type:表示表的连接类型</li>
<li>possible_keys:表示查询时，可能使用的索引</li>
<li>key:表示实际使用的索引</li>
<li>key_len:索引字段的长度</li>
<li>ref:列与索引的比较</li>
<li>rows:扫描出的行数(估算的行数)</li>
<li>filtered:按表条件过滤的行百分比</li>
<li>Extra:执行情况的描述和说明</li>
</ol>
<p><strong>下面对这些字段出现的可能进行解释：</strong></p>
<h1 id="一、-id"><a href="#一、-id" class="headerlink" title="一、 id"></a>一、 id</h1><p>id列的编号是 select 的序列号，</p>
<ol>
<li>id的顺序是按 select 出现的顺序增长的。</li>
<li><strong>id列越大执行优先级越高，</strong></li>
<li><strong>id相同则从上往下执行，</strong></li>
<li>id为NULL最后执行</li>
</ol>
<h2 id="1、连接查询"><a href="#1、连接查询" class="headerlink" title="1、连接查询"></a>1、连接查询</h2><p>对于连接查询来说，一个SELECT关键字后边的FROM子句中可以跟随多个表，所以在连接查询的执行计划中，每个表都会对应一条记录，但是这些记录的id值都是相同的，出现在前边的表表示驱动表，出现在后边的表表示被驱动表。所以从上边的EXPLAIN输出中我们可以看出，查询优化器准备让t1表作为驱动表，让t2表作为被驱动表来执行查询</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223350.png" alt="image-20220114145746944"></p>
<h2 id="2、子查询"><a href="#2、子查询" class="headerlink" title="2、子查询"></a>2、子查询</h2><p>对于包含子查询的查询语句来说，就可能涉及多个SELECT关键字，所以在包含子查询的查询语句的执行计划中，每个SELECT关键字都会对应一个唯一的id值，比如这样：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223404.png" alt="image-20220114150020225"></p>
<p>从输出结果中我们可以看到，t1表在外层查询中，外层查询有一个独立的SELECT关键字，所以第一条记录的id值就是1，t2表在子查询中，子查询有一个独立的SELECT关键字，所以第二条记录的id值就是2。</p>
<h2 id="3、子查询重写"><a href="#3、子查询重写" class="headerlink" title="3、子查询重写"></a>3、子查询重写</h2><p>但是这里大家需要特别注意，查询优化器可能对涉及子查询的查询语句进行<strong>重写</strong>，从而转换为连接查询。所以如果我们想知道查询优化器对某个包含子查询的语句是否进行了重写，直接查看执行计划就好了，比如说：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223409.png" alt="image-20220114150429935"></p>
<p>可以看到，虽然我们的查询语句是一个子查询，但是执行计划中t1和t2表对应的记录的id值全部是1，这就表明了查询优化器将子查询转换为了连接查询。</p>
<h2 id="4、UNION"><a href="#4、UNION" class="headerlink" title="4、UNION"></a>4、UNION</h2><p>对于包含UNION子句的查询语句来说，每个SELECT关键字对应一个id值也是没错的，不过还是有点儿特别的东西，比方说下边这个查询：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223416.png" alt="image-20220114150551296"></p>
<p>UNION子句是为了把id为1的查询和id为2的查询的结果集合并起来并去重，所以在内部创建了一个名为<code>&lt;union1, 2&gt;</code>的临时表（就是执行计划第三条记录的table列的名称），id为NULL表明这个临时表是为了合并两个查询的结果集而创建的。</p>
<h2 id="5、UNION-ALL"><a href="#5、UNION-ALL" class="headerlink" title="5、UNION ALL"></a>5、UNION ALL</h2><p>跟UNION对比起来，UNION ALL就不需要为最终的结果集进行去重，它只是单纯的把多个查询的结果集中的记录合并成一个并返回给用户，所以也就不需要使用临时表。所以在包含UNION ALL子句的查询的执行计划中，就没有那个id为NULL的记录，如下所示：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223423.png" alt="image-20220114150801591"></p>
<h1 id="二、select-type"><a href="#二、select-type" class="headerlink" title="二、select_type"></a>二、select_type</h1><p>不重要</p>
<p>MySQL每一个SELECT关键字代表的小查询都定义了一个称之为<code>select_type</code>的属性，意思是我们只要知道了某个小查询的<code>select_type</code>属性，就知道了这个小查询在整个大查询中扮演了一个什么角色</p>
<p>下面是官方文档介绍：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223441.png" alt="img"></p>
<p>   <strong>表示查询中每个select子句的类型</strong></p>
<h2 id="1、SIMPLE"><a href="#1、SIMPLE" class="headerlink" title="1、SIMPLE"></a>1、SIMPLE</h2><p>查询语句中不包含UNION或者子查询的查询，比方说下边这个单表查询的<code>select_type</code>的值就是SIMPLE：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223444.png" alt="image-20220114151324788"></p>
<h2 id="2、PRIMARY"><a href="#2、PRIMARY" class="headerlink" title="2、PRIMARY"></a>2、PRIMARY</h2><p>对于包含UNION、UNION ALL或者子查询的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>值就是PRIMARY，比方说：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223448.png" alt="image-20220114151527797"></p>
<p>从结果中可以看到，最左边的小查询<code>SELECT * FROM t1</code>对应的是执行计划中的第一条记录，它的<code>select_type</code>值就是PRIMARY。</p>
<h2 id="3、UNION"><a href="#3、UNION" class="headerlink" title="3、UNION"></a>3、UNION</h2><p>对于包含UNION或者UNION ALL的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的<code>select_type</code>值就是UNION，可以对比上一个例子的效果</p>
<h2 id="4、UNION-RESULT"><a href="#4、UNION-RESULT" class="headerlink" title="4、UNION RESULT"></a>4、UNION RESULT</h2><p>MySQL选择使用临时表来完成UNION查询的去重工作，针对该临时表的查询的<code>select_type</code>就是UNION RESULT，同样对比上面的例子</p>
<h2 id="5、SUBQUERY"><a href="#5、SUBQUERY" class="headerlink" title="5、SUBQUERY"></a>5、SUBQUERY</h2><p>子查询中的第一个SELECT，结果不依赖于外部查询</p>
<p>如果包含子查询的查询语句不能够转为对应的semi-join的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该子查询物化的方案来执行该子查询时，该子查询的第一个SELECT关键字代表的那个查询的<code>select_type</code>就是SUBQUERY，比如下边这个查询：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223504.png" alt="image-20220114151824126"></p>
<p>可以看到，外层查询的<code>select_type</code>就是PRIMARY，子查询的<code>select_type</code>就是SUBQUERY。</p>
<p>概念解释：</p>
<blockquote>
<p>semi-join子查询，是指当一张表在另一张表找到匹配的记录之后，半连接（semi-jion）返回第一张表中的记录。与条件连接相反，即使在右节点中找到几条匹配的记录，左节点 的表也只会返回一条记录。另外，右节点的表一条记录也不会返回。半连接通常使用<strong>IN</strong> 或 <strong>EXISTS</strong> 作为连接条件</p>
<p>物化：<strong>这个将子查询结果集中的记录保存到临时表的过程称之为物化（Materialize）</strong>。那个存储子查询结果集的临时表称之为物化表。正因为物化表中的记录都建立了索引（基于内存的物化表有哈希索引，基于磁盘的有B+树索引），通过索引执行IN语句判断某个操作数在不在子查询结果集中变得非常快，从而提升了子查询语句的性能。</p>
</blockquote>
<h2 id="6、DEPENDENT-SUBQUERY"><a href="#6、DEPENDENT-SUBQUERY" class="headerlink" title="6、DEPENDENT SUBQUERY"></a>6、DEPENDENT SUBQUERY</h2><p>子查询中的第一个SELECT，依赖于外部查询</p>
<p>如果包含子查询的查询语句不能够转为对应的semi-join的形式，并且该子查询是相关子查询，则该子查询的第一个SELECT关键字代表的那个查询的<code>select_type</code>就是DEPENDENT SUBQUERY，比如下边这个查询：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223508.png" alt="image-20220114152210531"></p>
<h2 id="7、DEPENDENT-UNION"><a href="#7、DEPENDENT-UNION" class="headerlink" title="7、DEPENDENT UNION"></a>7、DEPENDENT UNION</h2><p>在包含UNION或者UNION ALL的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的<code>select_type</code>的值就是DEPENDENT UNION。比方说下边这个查询：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223512.png" alt="image-20220114152256399"></p>
<p>这个查询比较复杂啊，大查询里包含了一个子查询，子查询里又是由UNION连起来的两个小查询。从执行计划中可以看出来，<code>SELECT key1 FROM t2 WHERE key1 = &#39;a1b6cee57a&#39;</code>这个小查询由于是子查询中第一个查询，所以它的<code>select_type</code>是DEPENDENT SUBQUERY，而<code>SELECT key1 FROM t1 WHERE key1 = &#39;a1b6cee57a&#39;</code>这个查询的<code>select_type</code>就是DEPENDENT UNION。</p>
<h2 id="8、DERIVED"><a href="#8、DERIVED" class="headerlink" title="8、DERIVED"></a>8、DERIVED</h2><p>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的<code>select_type</code>就是DERIVED，比方说下边这个查询：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223516.png" alt="image-20220114152400037"></p>
<p>从执行计划中可以看出，id为2的记录就代表子查询的执行方式，它的<code>select_type</code>是DERIVED，说明该子查询是以物化的方式执行的。id为1的记录代表外层查询，大家注意看它的table列显示的是<code>&lt;derived2&gt;</code>，表示该查询是针对将派生表物化之后的表进行查询的。</p>
<h2 id="9、MATERIALIZED"><a href="#9、MATERIALIZED" class="headerlink" title="9、MATERIALIZED"></a>9、MATERIALIZED</h2><p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是MATERIALIZED，比如下边这个查询：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223520.png" alt="image-20220114152458459"></p>
<p>执行计划的第三条记录的id值为2，说明该条记录对应的是一个单表查询，从它的<code>select_type</code>值为MATERIALIZED可以看出，查询优化器是要把子查询先转换成物化表。然后看执行计划的前两条记录的id值都为1，说明这两条记录对应的表进行连接查询，需要注意的是第二条记录的table列的值是<code>&lt;subquery2&gt;</code>，说明该表其实就是id为2对应的子查询执行之后产生的物化表，然后将s1和该物化表进行连接查询。</p>
<h1 id="三、table"><a href="#三、table" class="headerlink" title="三、table"></a>三、table</h1><p>显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是简称，例如上面的e，d，也可能是第几步执行的结果的简称</p>
<h1 id="四、type"><a href="#四、type" class="headerlink" title="四、type"></a>四、type</h1><p>对表访问方式，表示MySQL在表中找到所需行的方式，又称“访问类型”。<br>尽量保持在 大于等于range</p>
<p>常用的类型有： <strong>NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL（从左到右，性能从好到坏）</strong></p>
<h2 id="1、ALL"><a href="#1、ALL" class="headerlink" title="1、ALL"></a>1、ALL</h2><p>全表扫描</p>
<h2 id="2、index"><a href="#2、index" class="headerlink" title="2、index"></a>2、index</h2><p>只遍历索引树</p>
<h2 id="3、range"><a href="#3、range" class="headerlink" title="3、range"></a>3、range</h2><p>只检索给定范围的行，使用一个索引来选择行。范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。</p>
<h2 id="4、ref"><a href="#4、ref" class="headerlink" title="4、ref"></a>4、ref</h2><p> 当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是ref</p>
<p>相比 <code>eq_ref</code>，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。比如：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223529.png" alt="image-20220114161319498"></p>
<p>可以看到type列的值是ref，表明MySQL即将使用ref访问方法来执行对t1表的查询</p>
<h2 id="5、eq-ref"><a href="#5、eq-ref" class="headerlink" title="5、eq_ref"></a>5、eq_ref</h2><p>类似ref，区别就在使用的索引是primary key 或 unique key 索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件。</p>
<p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是<code>eq_ref</code>，比方说：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223534.png" alt="image-20220114161141498"></p>
<p>从执行计划的结果中可以看出，MySQL打算将t1作为驱动表，t2作为被驱动表，重点关注t2的访问方法是<code>eq_ref</code>，表明在访问t2表的时候可以通过主键的等值匹配来进行访问。</p>
<h2 id="6、const、system"><a href="#6、const、system" class="headerlink" title="6、const、system:"></a>6、const、system:</h2><p>当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system。比如：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223538.png" alt="image-20220114161641994"></p>
<h2 id="7、NULL"><a href="#7、NULL" class="headerlink" title="7、NULL:"></a>7、NULL:</h2><p>MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。</p>
<ol>
<li><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223541.png" alt="image-20220114153230540"></li>
</ol>
<h1 id="五、possible-keys"><a href="#五、possible-keys" class="headerlink" title="五、possible_keys"></a>五、possible_keys</h1><p><code>possible_keys</code>列显示查询可能使用哪些索引来查找。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用（该查询可以利用的索引，如果没有任何索引显示 null）</p>
<p>explain 时可能出现 <code>possible_keys</code> 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。</p>
<p>如果<code>possible_keys</code>列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p>
<p>比如：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223549.png" alt="image-20220114162340903"></p>
<p>上述执行计划的<code>possible_keys</code>列的值是<code>idx_key1,idx_key2_key3</code>，表示该查询可能使用到<code>idx_key1,idx_key2_key3</code>两个索引，然后key列的值是<code>idx_key3</code>，表示经过查询优化器计算使用不同索引的成本后，最后决定使用<code>idx_key3</code>来执行查询比较划算。</p>
<p>需要注意的一点是，<code>possible_keys</code>列中的值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本时就得花费更长时间，所以如果可以的话，尽量删除那些用不到的索引。</p>
<h1 id="六、Key"><a href="#六、Key" class="headerlink" title="六、Key"></a>六、Key</h1><p><strong>key列显示MySQL实际决定使用的索引，必然包含在possible_keys中</strong></p>
<p>key列显示mysql实际采用哪个索引来优化对该表的访问。如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视<code>possible_keys</code>列中的索引，在查询中使用 force index、ignore index。</p>
<p>比如：上一个例子</p>
<h1 id="七、key-len"><a href="#七、key-len" class="headerlink" title="七、key_len"></a>七、key_len</h1><p>不重要</p>
<p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</p>
<p>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值，对于指定字符集的变长类型的索引列来说，比如某个索引列的类型是VARCHAR(100)，使用的字符集是utf8，那么该列实际占用的最大存储空间就是100 × 3 = 300个字节。</p>
<p>如果该索引列可以存储NULL值，则<code>key_len</code>比不可以存储NULL值时多1个字节。</p>
<p>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</p>
<p>当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<blockquote>
<p>key_len计算规则如下：字符串 char(n)：n字节长度 varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2 数值类型 tinyint：1字节 smallint：2字节 int：4字节 bigint：8字节　　 时间类型　 date：3字节 timestamp：4字节 datetime：8字节</p>
</blockquote>
<p>比如:</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223556.png" alt="image-20220114162649887"></p>
<p>由于id列的类型是INT，并且不可以存储NULL值，所以在使用该列的索引时<code>key_len</code>大小就是4。</p>
<p>对于可变长度的索引列来说，比如下边这个查询：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223601.png" alt="image-20220114162721537"></p>
<p>由于key1列的类型是<code>VARCHAR(100)</code>，所以该列实际最多占用的存储空间就是300字节，又因为该列允许存储NULL值，所以<code>key_len</code>需要加1，又因为该列是可变长度列，所以<code>key_len</code>需要加2，所以最后<code>ken_len</code>的值就是303。</p>
<h1 id="八、ref"><a href="#八、ref" class="headerlink" title="八、ref"></a>八、ref</h1><p>不重要</p>
<p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：<code>t1.id</code>）</p>
<p>ref列展示的就是与索引列作等值匹配的值什么，比如只是一个常数或者是某个列。大家看下边这个查询：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223611.png" alt="image-20220114172026767"></p>
<p>可以看到ref列的值是const，表明在使用<code>idx_key1</code>索引执行查询时，与key1列作等值匹配的对象是一个常数。</p>
<p>当然有时候更复杂一点：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223620.png" alt="image-20220114172123221"></p>
<p>可以看到对被驱动表t1的访问方法是<code>eq_ref</code>，而对应的ref列的值是<code>数据库名.t2.id</code>，这说明在对被驱动表进行访问时会用到PRIMARY索引，也就是聚簇索引与一个列进行等值匹配的条件，于t2表的id作等值匹配的对象就是db2019.t2.id`列（注意这里把数据库名也写出来了）。</p>
<p>有的时候与索引列进行等值匹配的对象是一个函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t2.key1 <span class="operator">=</span> <span class="built_in">UPPER</span>(t1.key1);</span><br></pre></td></tr></table></figure>

<p>ref = func</p>
<h1 id="九、rows"><a href="#九、rows" class="headerlink" title="九、rows"></a>九、rows</h1><p> 这一列是mysql预估要读取并检测的行数，注意这个不是结果集里的行数。</p>
<p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的rows列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的rows列就代表预计扫描的索引记录行数。比如下边这个查询：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223630.png" alt="image-20220114162840351"></p>
<p>我们看到执行计划的rows列的值是4，这意味着查询优化器在经过分析使用<code>idx_key1</code>进行查询的成本之后，觉得满足<code>key1 &gt; &#39;a&#39;</code>这个条件的记录只有4条。</p>
<h1 id="十、Extra"><a href="#十、Extra" class="headerlink" title="十、Extra"></a>十、Extra</h1><p>该列包含MySQL解决查询的额外信息,有以下几种情况：</p>
<h2 id="1、Using-index"><a href="#1、Using-index" class="headerlink" title="1、Using index"></a>1、Using index</h2><p>查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高。比如：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223635.png" alt="image-20220114184549956"></p>
<h2 id="2、Using-where"><a href="#2、Using-where" class="headerlink" title="2、Using where:"></a>2、Using where:</h2><p>当我们使用全表扫描来执行对某个表的查询，并且该语句的WHERE子句中有针对该表的搜索条件时，在Extra列中会提示上述额外信息。比如下边这个查询</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223645.png" alt="image-20220114172953753"></p>
<h2 id="3、Using-where-Using-index"><a href="#3、Using-where-Using-index" class="headerlink" title="3、Using where Using index"></a>3、Using where Using index</h2><p>查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列，意味着无法直接通过索引查找来查询到符合条件的数据。比如：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223707.png" alt="image-20220114184706083"></p>
<h2 id="4、NULL"><a href="#4、NULL" class="headerlink" title="4、NULL"></a>4、NULL</h2><p>查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引。比如：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223718.png" alt="image-20220114184758013"></p>
<h2 id="5、Using-index-condition"><a href="#5、Using-index-condition" class="headerlink" title="5、Using index condition"></a>5、Using index condition</h2><p>与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223725.png" alt="image-20220114185050276"></p>
<h2 id="6、Using-temporary"><a href="#6、Using-temporary" class="headerlink" title="6、Using temporary"></a>6、Using temporary</h2><p>表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 group by ; order by</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223729.png" alt="image-20220114173105011"></p>
<p>key1建立了idx_key1索引，此时查询时extra是using index,没有用临时表</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223733.png" alt="image-20220114173155427"></p>
<h2 id="7、Using-filesort"><a href="#7、Using-filesort" class="headerlink" title="7、Using filesort"></a>7、Using filesort</h2><p>当sql中包含 order by 操作，而且无法利用索引完成排序时就会出现“文件排序”</p>
<h2 id="8、Using-join-buffer"><a href="#8、Using-join-buffer" class="headerlink" title="8、Using join buffer"></a>8、Using join buffer</h2><p>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度时，MySQL为了加快查询速度一般会为其分配一块名叫join buffer的内存块来存储中间结果。也就是我们所讲的基于块的嵌套循环算法。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223740.png" alt="image-20220114184213862"></p>
<h2 id="9、Impossible-where"><a href="#9、Impossible-where" class="headerlink" title="9、Impossible where"></a>9、Impossible where</h2><p>这个值强调了where语句会导致没有符合条件的行，也就是说查询语句的WHERE子句永远为FALSE时将会提示该额外信息，比方说：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223750.png" alt="image-20220114184418188"></p>
<h2 id="10、Select-tables-optimized-away"><a href="#10、Select-tables-optimized-away" class="headerlink" title="10、Select tables optimized away"></a>10、Select tables optimized away</h2><p>这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</p>
<h2 id="11、No-tables-used"><a href="#11、No-tables-used" class="headerlink" title="11、No tables used"></a>11、No tables used</h2><p>Query语句中使用from dual 或不含任何from子句</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/Explain%E8%AF%A6%E8%A7%A3/20220325223756.png" alt="image-20220114185310217"></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构和常用指令</title>
    <url>/posts/4cb61cd5a8db/</url>
    <content><![CDATA[<h1 id="Redis数据结构和常用指令"><a href="#Redis数据结构和常用指令" class="headerlink" title="Redis数据结构和常用指令"></a>Redis数据结构和常用指令</h1><h2 id="单线程redis操作为什么那么快？"><a href="#单线程redis操作为什么那么快？" class="headerlink" title="单线程redis操作为什么那么快？"></a>单线程redis操作为什么那么快？</h2><p>一方面，Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。另一方面，就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</p>
<p>Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p>
<h2 id="redis基本数据结构"><a href="#redis基本数据结构" class="headerlink" title="redis基本数据结构"></a>redis基本数据结构</h2><p>Redis 有 5 种基础数据结构，分别为：string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/redis202208271617490.png" alt="基本数据结构"></p>
<p>可以看到，String 类型的底层实现只有一种数据结构，也就是简单动态字符串。</p>
<p>而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong></p>
<h3 id="键和值用什么结构组织？"><a href="#键和值用什么结构组织？" class="headerlink" title="键和值用什么结构组织？"></a>键和值用什么结构组织？</h3><p>为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。</p>
<p>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。</p>
<p>看到这里，你可能会问了：“如果值是集合类型的话，作为数组元素的哈希桶怎么来保存呢？”其实，哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。</p>
<p>在下图中，可以看到，哈希桶中的 entry 元素中保存了key和value指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过*value指针被查找到。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/redis202208271617802.png" alt="在这里插入图片描述"></p>
<p>因为这个哈希表保存了所有的键值对，所以，我也把它称为全局哈希表。</p>
<p>哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。</p>
<p>你看，这个查找过程主要依赖于哈希计算，和数据量的多少并没有直接关系。也就是说，不管哈希表里有 10 万个键还是 100 万个键，我们只需要一次计算就能找到相应的键。</p>
<p>但是，如果你只是了解了哈希表的 O(1) 复杂度和快速查找特性，那么，当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是<strong>哈希冲突问题和 rehash 可能带来的操作阻塞</strong>。</p>
<h3 id="链式哈希"><a href="#链式哈希" class="headerlink" title="链式哈希"></a>链式哈希</h3><p><strong>Redis 解决哈希冲突的方式，就是链式哈希</strong></p>
<p>链式哈希也很容易理解，就是指：<strong>同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。</strong></p>
<p>如下图所示：entry1、entry2 和 entry3 都需要保存在哈希桶 3 中，导致了哈希冲突。此时，entry1 元素会通过一个next指针指向 entry2，同样，entry2 也会通过next指针指向 entry3。这样一来，即使哈希桶 3 中的元素有 100 个，我们也可以通过 entry 元素中的指针，把它们连起来。这就形成了一个链表，也叫作哈希冲突链。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/redis202208271617827.png" alt="在这里插入图片描述"></p>
<p>但是，这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 Redis 来说，这是不太能接受的。</p>
<p>所以，Redis 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。那具体怎么做呢？</p>
<p>其实，为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p>
<p>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；<br>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；<br>释放哈希表 1 的空间。<br>到此，我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。</p>
<p>这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。</p>
<p>为了避免这个问题，Redis 采用了渐进式 rehash。</p>
<h3 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h3><p>Java 的 HashMap 在扩容时会一次性将旧数组下挂接的元素全部转移到新数组下面。如果 HashMap 中元素特别多，线程就会出现卡顿现象。Redis 为了解决这个问题，它采用<strong>渐进式 rehash</strong>。</p>
<p>它会同时保留旧数组和新数组，然后在<strong>定时任务中以及后续对 hash 的指令</strong>操作中渐渐地将旧数组中挂接的元素迁移到新数组上。Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。这意味着要操作处于 rehash 中的字典，需要同时访问新旧两个数组结构。如果在旧数组下面找不到元素，还需要去新数组下面去寻找。</p>
<p>简单来说就是在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。如下图所示：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/redis202208271617073.png" alt="在这里插入图片描述"></p>
<p>这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问</p>
<h3 id="集合数据操作效率"><a href="#集合数据操作效率" class="headerlink" title="集合数据操作效率"></a>集合数据操作效率</h3><p>压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/redis202208271617935.png" alt="在这里插入图片描述"></p>
<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。</p>
<p>我们再来看下跳表。</p>
<p>有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，跳表在链表的基础上，<strong>增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位，</strong>如下图所示：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/redis202208271617340.png" alt="在这里插入图片描述"></p>
<h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><p>字符串 string 是 Redis 最简单的数据结构。</p>
<p>Redis 的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512M。</p>
<p>字符串是由多个字节组成，每个字节又是由 8 个 bit 组成，如此便可以将一个字符串看成很多 bit 的组合，这便是 <strong>bitmap「位图」</strong>数据结构，</p>
<p>String常用指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set key value [EX seconds|PX milliseconds|EXAT timestamp|PXAT milliseconds-timestamp|KEEPTTL] [NX|XX] [GET]</span><br><span class="line">127.0.0.1:6379&gt; set str helloworld</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get str</span><br><span class="line">&quot;helloworld&quot;</span><br><span class="line">127.0.0.1:6379&gt; exists str  # 判断key是否存在</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; keys st*   # 查找某些key，返回符合正则表达式的所有key，如果key很多导致redis卡主</span><br><span class="line">1) &quot;str&quot;</span><br><span class="line">127.0.0.1:6379&gt; scan 0 match st* count 1000 # 也是查找key 从游标0开始，匹配正则， 这里的count 1000不是返回1000条，限定服务器单次遍历的字典槽位数 (约等于1000）</span><br><span class="line">1) &quot;0&quot;  # 返回结果游标为0代表查找遍历结束</span><br><span class="line">2) 1) &quot;str&quot;</span><br><span class="line">127.0.0.1:6379&gt; strlen str</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt; mset str1 v1 str2 v2 # 批量操作</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget str1 str2</span><br><span class="line">1) &quot;v1&quot;</span><br><span class="line">2) &quot;v2&quot;</span><br><span class="line">127.0.0.1:6379&gt; set number 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; incr number</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get number</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; incrby number 5 # 操作value为数字类型</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; setex str4 10 ab # 设置过期时间</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl str4  # 查看剩余时间</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; exists str4</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setnx lock uuid # setnx (set if not exist) # 不存在才能设置，常在分布式锁中使用  </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; setnx lock 123</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; set lock 123 </span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="list-列表"><a href="#list-列表" class="headerlink" title="list(列表)"></a>list(列表)</h3><p>Redis 的列表相当于 Java 语言里面的 LinkedList，注意它是链表而不是数组。这意味着 list 的插入和删除操作非常快，时间复杂度为 O(1)，但是索引定位很慢，时间复杂度为 O(n)，这点让人非常意外。</p>
<p><strong>当列表弹出了最后一个元素之后，该数据结构自动被删除，内存被回收。</strong></p>
<p>Redis 的列表结构常用来做<strong>异步队列</strong>使用。将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</p>
<p>Redis 底层存储的还不是一个简单的 linkedlist，而是称之为<strong>快速链表 quicklist</strong> 的一个结构。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next 。所<strong>以 Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用</strong>。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<p>list常用指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush books java  # 左侧插入元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush books python c++ # 左侧批量插入</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange books 0 -1 # 查看list中元素，-1代表查看所有</span><br><span class="line">1) &quot;c++&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpush books golang # 右侧插入元素</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange books 0 -1</span><br><span class="line">1) &quot;c++&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpop books # 左侧删除元素</span><br><span class="line">&quot;c++&quot;</span><br><span class="line">127.0.0.1:6379&gt; lpush books java</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange books 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrem books 1 java # 移除books集合中指定个数的value，精确匹配</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange books 0 -1</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; rpush books c#</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange books 0 -1</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;golang&quot;</span><br><span class="line">4) &quot;c#&quot;</span><br><span class="line">127.0.0.1:6379&gt; lrange books 1 2 # 显示部分元素</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; llen books # 集合长度</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; ltrim books 1 2  # 截取子集合</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange books 0 -1</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lindex books 1 # 根据位置index获取元素</span><br><span class="line">&quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; exists books # 判断key是否存在</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<h3 id="hash-字典"><a href="#hash-字典" class="headerlink" title="hash(字典)"></a>hash(字典)</h3><p>Redis 的hash相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结结构。</p>
<p>当 hash 移除了最后一个元素之后，该数据结构自动被删除，内存被回收。</p>
<p>hash 结构也可以用来存储用户信息，不同于字符串一次性需要全部序列化整个对象，hash 可以对用户结构中的每个字段单独存储。这样当我们需要获取用户信息时可以进行部分获取。而以整个字符串的形式去保存用户信息的话就只能一次性全部读取，这样就会比较浪费网络流量。</p>
<p>hash 也有缺点，hash 结构的存储消耗要高于单个字符。</p>
<p>hash常用指令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user:1 id 1  # 设置key为user:1的map</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user:1 name xiaoming</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user:1 age 20</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user:1 address 杭州市余杭区</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hmset user:1 email shepherd_zfj@163.com phone 12345678 # 批量设置</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hget user:1 email # 获取key下面某个字段值</span><br><span class="line">&quot;shepherd_zfj@163.com&quot;</span><br><span class="line">127.0.0.1:6379&gt; hgetall user:1 # 获取所以值，o(n)，性能差</span><br><span class="line"> 1) &quot;id&quot;</span><br><span class="line"> 2) &quot;1&quot;</span><br><span class="line"> 3) &quot;name&quot;</span><br><span class="line"> 4) &quot;xiaoming&quot;</span><br><span class="line"> 5) &quot;age&quot;</span><br><span class="line"> 6) &quot;20&quot;</span><br><span class="line"> 7) &quot;address&quot;</span><br><span class="line"> 8) &quot;\xe6\x9d\xad\xe5\xb7\x9e\xe5\xb8\x82\xe4\xbd\x99\xe6\x9d\xad\xe5\x8c\xba&quot;</span><br><span class="line"> 9) &quot;email&quot;</span><br><span class="line">10) &quot;shepherd_zfj@163.com&quot;</span><br><span class="line">11) &quot;phone&quot;</span><br><span class="line">12) &quot;12345678&quot;</span><br><span class="line">127.0.0.1:6379&gt; hincrby user:1 age 5 # 操作某个字段</span><br><span class="line">(integer) 25</span><br><span class="line">127.0.0.1:6379&gt; hexists user:1 name # 判断某个字段是否存</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hlen user:1 # 获取长度</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; hsetnx user:1 age 0 </span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) &quot;id&quot;</span><br><span class="line">2) &quot;name&quot;</span><br><span class="line">3) &quot;age&quot;</span><br><span class="line">4) &quot;address&quot;</span><br><span class="line">5) &quot;email&quot;</span><br><span class="line">6) &quot;phone&quot;</span><br><span class="line">127.0.0.1:6379&gt; hvals user:1</span><br><span class="line">1) &quot;1&quot;</span><br><span class="line">2) &quot;xiaoming&quot;</span><br><span class="line">3) &quot;25&quot;</span><br><span class="line">4) &quot;\xe6\x9d\xad\xe5\xb7\x9e\xe5\xb8\x82\xe4\xbd\x99\xe6\x9d\xad\xe5\x8c\xba&quot;</span><br><span class="line">5) &quot;shepherd_zfj@163.com&quot;</span><br><span class="line">6) &quot;12345678&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<h3 id="set-集合"><a href="#set-集合" class="headerlink" title="set(集合)"></a>set(集合)</h3><p>Redis 的集合相当于 Java 语言里面的 HashSet，它内部的键值对是无序的唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值NULL。</p>
<p>当集合中最后一个元素移除之后，数据结构自动删除，内存被回收。set 结构可以用来存储活动中奖的用户 ID，因为有去重功能，可以保证同一个用户不会中奖两次。还有很有用场景就是集合交并集、差集等，可以给出共同好友，推荐好友啥的。。。</p>
<p>set的常用指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd set1 a b c d  # 批量添加元素</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers set1 # 遍历集合元素 o(n)</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;c&quot;</span><br><span class="line">3) &quot;a&quot;</span><br><span class="line">4) &quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; sismember set1 b # 判断当前元素是否存在</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; scard set1 # 集合长度</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; srandmember set1 2 # 随机取2个元素</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;d&quot;</span><br><span class="line">127.0.0.1:6379&gt; srandmember set1 2</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; sadd set2 b c e f</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; sdiff set1 set2  # 取差集</span><br><span class="line">1) &quot;d&quot;</span><br><span class="line">2) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; sinter set1 set2 # 取交集</span><br><span class="line">1) &quot;c&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">127.0.0.1:6379&gt; sunion set1 set2 # 取并集</span><br><span class="line">1) &quot;f&quot;</span><br><span class="line">2) &quot;b&quot;</span><br><span class="line">3) &quot;d&quot;</span><br><span class="line">4) &quot;c&quot;</span><br><span class="line">5) &quot;e&quot;</span><br><span class="line">6) &quot;a&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<h3 id="Zset-有序集合"><a href="#Zset-有序集合" class="headerlink" title="Zset(有序集合)"></a>Zset(有序集合)</h3><p>zset 可能是 Redis 提供的最为特色的数据结构，它也是在面试中面试官最爱问的数据结构。它类似于 Java 的 SortedSet 和 HashMap 的结合体，一方面它是一个 set，保证了内部 value 的唯一性，另一方面它可以给每个 value 赋予一个 score，代表这个 value 的排序权重。它的内部实现用的是一种叫「<strong>跳跃列表</strong>」的数据结构。</p>
<p>zset 中最后一个 value 被移除后，数据结构自动删除，内存被回收。zset 可以用来存粉丝列表，value 值是粉丝的用户 ID，score 是关注时间。我们可以对粉丝列表按关注时间进行排序。</p>
<p>zset 还可以用来存储学生的成绩，value 值是学生的 ID，score 是他的考试成绩。我们可以对成绩按分数进行排序就可以得到他的名次</p>
<p>zset的常用指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd myzset 99 java # 添加权重和元素值</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 90 python</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 95 c++</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 100 golang</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myzset 85 c#</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange myzset 0 -1 # 遍历集合 权重正序</span><br><span class="line">1) &quot;c#&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">3) &quot;c++&quot;</span><br><span class="line">4) &quot;java&quot;</span><br><span class="line">5) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrange myzset 0 2</span><br><span class="line">1) &quot;c#&quot;</span><br><span class="line">2) &quot;python&quot;</span><br><span class="line">3) &quot;c++&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrevrange myzset 0 -1 # 遍历集合 权重降序</span><br><span class="line">1) &quot;golang&quot;</span><br><span class="line">2) &quot;java&quot;</span><br><span class="line">3) &quot;c++&quot;</span><br><span class="line">4) &quot;python&quot;</span><br><span class="line">5) &quot;c#&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore myzset 90 100 #根据分数查询元素区间</span><br><span class="line">1) &quot;python&quot;</span><br><span class="line">2) &quot;c++&quot;</span><br><span class="line">3) &quot;java&quot;</span><br><span class="line">4) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore myzset 99 inf</span><br><span class="line">1) &quot;java&quot;</span><br><span class="line">2) &quot;golang&quot;</span><br><span class="line">127.0.0.1:6379&gt; zrank myzset java # 元素排名</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrank myzset golang</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; zcard myzset # 集合长度</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>

<h2 id="redis高级数据结构"><a href="#redis高级数据结构" class="headerlink" title="redis高级数据结构"></a>redis高级数据结构</h2><h3 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h3><p>Redis 在 3.2 版本以后增加了地理位置 GEO 模块，意味着我们可以使用 Redis 来实现摩拜单车「附近的 Mobike」、美团和饿了么「附近的餐馆」这样的功能。</p>
<p>在一个地图应用中，车的数据、餐馆的数据、人的数据可能会有百万千万条，如果使用 Redis 的 Geo 数据结构，它们将全部放在一个 zset 集合中。在 Redis 的集群环境中，集合可能会从一个节点迁移到另一个节点，如果单个 key 的数据过大，会对集群的迁移工作造成较大的影响，在集群环境中单个 key 对应的数据量不宜超过 1M，否则会导致集群迁移出现卡顿现象，影响线上服务的正常运行。</p>
<p>所以，这里建议 Geo 的数据使用单独的 Redis 实例部署，不使用集群环境。</p>
<p>如果数据量过亿甚至更大，就需要对 Geo 数据进行拆分，按国家拆分、按省拆分，按市拆分，在人口特大城市甚至可以按区拆分。这样就可以显著降低单个 zset 集合的大小</p>
<p>geo的常用指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing # geoadd添加位置数据</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqi 114.05 22.52 shengzhen</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; GEOPOS china:city beijing # 获取北京的经纬度</span><br><span class="line">1) 1) &quot;116.39999896287918091&quot;</span><br><span class="line">   2) &quot;39.90000009167092543&quot;</span><br><span class="line">127.0.0.1:6379&gt; GEODIST china:city beijing shanghai km  # 获取北京到上海的距离，单位km</span><br><span class="line">&quot;1067.3788&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 500 km withcoord withdist withhash # 以(110,30)为中心500km一类的城市</span><br><span class="line">1) 1) &quot;chongqi&quot;</span><br><span class="line">   2) &quot;341.9374&quot;</span><br><span class="line">   3) (integer) 4026042091628984</span><br><span class="line">   4) 1) &quot;106.49999767541885376&quot;</span><br><span class="line">      2) &quot;29.52999957900659211&quot;</span><br><span class="line">2) 1) &quot;xian&quot;</span><br><span class="line">   2) &quot;483.8340&quot;</span><br><span class="line">   3) (integer) 4040115445396757</span><br><span class="line">   4) 1) &quot;108.96000176668167114&quot;</span><br><span class="line">      2) &quot;34.25999964418929977&quot;</span><br><span class="line">      </span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city shanghai 3000 km  # 获取指定元素的周围元素</span><br><span class="line">1) &quot;chongqi&quot;</span><br><span class="line">2) &quot;xian&quot;</span><br><span class="line">3) &quot;shengzhen&quot;</span><br><span class="line">4) &quot;hangzhou&quot;</span><br><span class="line">5) &quot;shanghai&quot;</span><br><span class="line">6) &quot;beijing&quot;</span><br><span class="line">127.0.0.1:6379&gt; georadiusbymember china:city shanghai 300 km</span><br><span class="line">1) &quot;hangzhou&quot;</span><br><span class="line">2) &quot;shanghai&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE china:city 0 -1 # geohash底层是使用zset实现的，所以可以使用zset的指令操作</span><br><span class="line">1) &quot;chongqi&quot;</span><br><span class="line">2) &quot;xian&quot;</span><br><span class="line">3) &quot;shengzhen&quot;</span><br><span class="line">4) &quot;hangzhou&quot;</span><br><span class="line">5) &quot;shanghai&quot;</span><br><span class="line">6) &quot;beijing&quot;</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<h3 id="Bitmap-位图"><a href="#Bitmap-位图" class="headerlink" title="Bitmap(位图)"></a>Bitmap(位图)</h3><p>在我们平时开发过程中，会有一些 bool 型数据需要存取，比如用户一年的签到记录，签了是 1，没签是 0，要记录 365 天。如果使用普通的 key/value，每个用户要记录 365 个，当用户上亿的时候，需要的存储空间是惊人的。</p>
<p>为了解决这个问题，Redis 提供了位图数据结构，这样每天的签到记录只占据一个位，365 天就是 365 个位，46 个字节 (一个稍长一点的字符串) 就可以完全容纳下，这就大大节约了存储空间。</p>
<p>位图不是特殊的数据结构，它的内容其实就是普通的字符串，也就是 byte 数组。我们可以使用普通的 get/set 直接获取和设置整个位图的内容，也可以使用位图操作 getbit/setbit 等将 byte 数组看成「位数组」来处理。</p>
<p>bitmap常用指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit s 1 1    # h的二进制：0b1101000 e的二进制：0b1100101</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 4 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 9 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 10 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 13 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit s 15 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; get s</span><br><span class="line">&quot;he&quot;</span><br><span class="line">127.0.0.1:6379&gt; getbit s 4</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit s 5</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bitcount 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bitcount s</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; bitcount s 0 3</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; bitpos s 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitpos s 1 4 10</span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379&gt; bitpos s 1 4 8</span><br><span class="line">(integer) -1</span><br><span class="line">127.0.0.1:6379&gt; set w hello</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bitcount w</span><br><span class="line">(integer) 21</span><br><span class="line">127.0.0.1:6379&gt; bitcount w 0 0</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; bitcount w 0 1</span><br><span class="line">(integer) 7</span><br><span class="line">127.0.0.1:6379&gt; bitpos w 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; bitpos w 1 1 1</span><br><span class="line">(integer) 9</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<h3 id="Hyperloglog"><a href="#Hyperloglog" class="headerlink" title="Hyperloglog"></a>Hyperloglog</h3><p>统计网站每个网页每天的 UV 数据，你会如何实现？</p>
<p>如果统计 PV 那非常好办，给每个网页一个独立的 Redis 计数器就可以了，这个计数器的 key 后缀加上当天的日期。这样来一个请求，incrby 一次，最终就可以统计出所有的 PV 数据。</p>
<p>但是 UV 不一样，它要去重，同一个用户一天之内的多次访问请求只能计数一次。这就要求每一个网页请求都需要带上用户的 ID，无论是登陆用户还是未登陆用户都需要一个唯一 ID 来标识。</p>
<p>你也许已经想到了一个简单的方案，那就是为每一个页面一个独立的 set 集合来存储所有当天访问过此页面的用户 ID。当一个请求过来时，我们使用 sadd 将用户 ID 塞进去就可以了。通过 scard 可以取出这个集合的大小，这个数字就是这个页面的 UV 数据。没错，这是一个非常简单的方案。</p>
<p>但是，如果你的页面访问量非常大，比如一个爆款页面几千万的 UV，你需要一个很大的 set 集合来统计，这就非常浪费空间。如果这样的页面很多，那所需要的存储空间是惊人的。为这样一个去重功能就耗费这样多的存储空间，值得么？其实老板需要的数据又不需要太精确，105w 和 106w 这两个数字对于老板们来说并没有多大区别，So，有没有更好的解决方案呢？</p>
<p>这就是本节要引入的一个解决方案，Redis 提供了 HyperLogLog 数据结构就是用来解决这种统计问题的。HyperLogLog 提供不精确的去重计数方案，虽然不精确但是也不是非常不精确，标准误差是 0.81%，这样的精确度已经可以满足上面的 UV 统计需求了。</p>
<p>Hyperloglog常用指令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd hylog 1 2 3 4 5 6 # 添加元素</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount hylog # 统计</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; pfadd hylog1 5 6 7 8 9 10 </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd hylog1 9 10 # 添加重复元素，不成功</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; pfcount hylog1</span><br><span class="line">(integer) 6</span><br><span class="line">127.0.0.1:6379&gt; pfmerge hylog2 hylog hylog1 # 合并</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount hylog2</span><br><span class="line">(integer) 10</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p>Redis 对 HyperLogLog 的存储进行了优化，在计数比较小时，它的存储空间采用稀疏矩阵存储，空间占用很小，仅仅在计数慢慢变大，稀疏矩阵占用空间渐渐超过了阈值时才会一次性转变成稠密矩阵，<strong>才会占用 12k 的空间</strong>，最大固定内存长度。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot全局异常处理</title>
    <url>/posts/b6d0d7be726c/</url>
    <content><![CDATA[<h1 id="springboot全局异常处理"><a href="#springboot全局异常处理" class="headerlink" title="springboot全局异常处理"></a>springboot全局异常处理</h1><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>近期在做代码审查的时候，发现有一些小伙伴在项目中写了很多try…catch…代码，这样不仅代码不简洁看起来不舒服，而且客户经常反馈错误提示语能不能具体化一些，不要总提示服务器异常或者一大堆英文字母……，所以决定对这一块进行小小的改造。</p>
<p>我们知道springboot是有全局异常处理机制的，今天来一起学习一下SpringBoot中的异常处理，这样在日常web开发中发生了异常，只需要通过一个统一的异常处理就可以保证客户端能够收到友好的提示。</p>
<h2 id="ControllerAdvice-介绍"><a href="#ControllerAdvice-介绍" class="headerlink" title="@ControllerAdvice 介绍"></a>@ControllerAdvice 介绍</h2><p>@ControllerAdvice，是Spring3.2提供的新注解，它是一个Controller增强器，可对controller中被 @RequestMapping 注解的方法加一些逻辑处理。</p>
<p>很多初学者可能都没有听说过这个注解，实际上，这是一个非常有用的注解，使用场景如下：</p>
<ol>
<li>全局异常处理（最常用）</li>
<li>全局数据绑定</li>
<li>全局数据预处理</li>
</ol>
<p>灵活使用@ControllerAdvice，可以帮助我们简化很多工作，需要注意的是，这是 SpringMVC 提供的功能，在 Spring Boot 中可以直接使用。</p>
<h2 id="环境需求"><a href="#环境需求" class="headerlink" title="环境需求"></a>环境需求</h2><ul>
<li>spring-boot 2.4.5</li>
<li>java 8</li>
<li>idea </li>
<li>maven 3.6.0</li>
</ul>
<h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p><strong>Maven的相关依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bjsxt<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springbootexception<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springbootexception<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring Boot Web 依赖 核心 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Spring Boot Test 依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.41<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--字符串操作--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>自定义基础异常接口</strong></p>
<p>首先定义一个自定义基础异常接口，自定义的错误描述枚举类需实现该接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基础的异常接口类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月20日 17:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseErrorInfo</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getResultCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">getResultMsg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义普通枚举类</strong></p>
<p>然后我们这里在自定义一个普通的枚举类，并实现BaseErrorInfo接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通的枚举类，</span></span><br><span class="line"><span class="comment"> * 为什么要分普通枚举呢，因为可能还会有别的业务功能的异常枚举类</span></span><br><span class="line"><span class="comment"> * 所以抽取出来了一个BaseErrorInfo接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/20 18:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CommonEnum</span> <span class="keyword">implements</span> <span class="title class_">BaseErrorInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据操作错误定义</span></span><br><span class="line">    SUCCESS(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;成功!&quot;</span>),</span><br><span class="line">    BODY_NOT_MATCH(<span class="string">&quot;400&quot;</span>, <span class="string">&quot;请求的数据格式不符!&quot;</span>),</span><br><span class="line">    PRAM_NOT_MATCH(<span class="string">&quot;400&quot;</span>, <span class="string">&quot;参数不正确&quot;</span>),</span><br><span class="line">    UNAUTHORIZED(<span class="string">&quot;401&quot;</span>, <span class="string">&quot;未登录或token过期，请登录！&quot;</span>),</span><br><span class="line">    VALIDATE_FAILED(<span class="string">&quot;400&quot;</span>, <span class="string">&quot;参数检验失败&quot;</span>),</span><br><span class="line">    SIGNATURE_NOT_MATCH(<span class="string">&quot;SIGNATURE_NOT_MATCH&quot;</span>, <span class="string">&quot;请求的数字签名不匹配!&quot;</span>),</span><br><span class="line">    NOT_FOUND(<span class="string">&quot;404&quot;</span>, <span class="string">&quot;未找到该资源!&quot;</span>),</span><br><span class="line">    INTERNAL_SERVER_ERROR(<span class="string">&quot;500&quot;</span>, <span class="string">&quot;服务器内部错误!&quot;</span>),</span><br><span class="line">    SERVER_BUSY(<span class="string">&quot;503&quot;</span>, <span class="string">&quot;服务器正忙，请稍后再试!&quot;</span>),</span><br><span class="line">    USER_NAME_BLANK(<span class="string">&quot;USER_NAME_BLANK&quot;</span>, <span class="string">&quot;新增用户时,用户姓名不能为空！&quot;</span>),</span><br><span class="line">    NUMBER_FORMAT_EXCEPTION(<span class="string">&quot;400&quot;</span>, <span class="string">&quot;字符串不包含可解析的整数!&quot;</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String resultCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String resultMsg;</span><br><span class="line"></span><br><span class="line">    CommonEnum(String resultCode, String resultMsg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.resultCode = resultCode;</span><br><span class="line">        <span class="built_in">this</span>.resultMsg = resultMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getResultCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getResultMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resultMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>自定义业务功能枚举类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserInfoEnum</span> <span class="keyword">implements</span> <span class="title class_">BaseErrorInfo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据操作错误定义</span></span><br><span class="line">    USER_NAME_BLANK(<span class="string">&quot;USER_NAME_BLANK&quot;</span>, <span class="string">&quot;新增用户时,用户姓名不能为空！&quot;</span>)</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String resultCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String resultMsg;</span><br><span class="line"></span><br><span class="line">    UserInfoEnum(String resultCode, String resultMsg) &#123;</span><br><span class="line">        <span class="built_in">this</span>.resultCode = resultCode;</span><br><span class="line">        <span class="built_in">this</span>.resultMsg = resultMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getResultCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resultCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getResultMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> resultMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>自定义异常类</strong></p>
<p>然后我们在来自定义一个异常类，用于处理我们发生的业务异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义一个异常类，用于处理我们发生的业务异常，继承运行时异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月20日 17:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BizException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String errorCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 错误信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> String errorMsg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">(BaseErrorInfo errorInfoInterface)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(errorInfoInterface.getResultCode());</span><br><span class="line">        <span class="built_in">this</span>.errorCode = errorInfoInterface.getResultCode();</span><br><span class="line">        <span class="built_in">this</span>.errorMsg = errorInfoInterface.getResultMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">(BaseErrorInfo errorInfoInterface, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(errorInfoInterface.getResultCode(), cause);</span><br><span class="line">        <span class="built_in">this</span>.errorCode = errorInfoInterface.getResultCode();</span><br><span class="line">        <span class="built_in">this</span>.errorMsg = errorInfoInterface.getResultMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">(String errorMsg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(errorMsg);</span><br><span class="line">        <span class="built_in">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">(String errorCode, String errorMsg)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(errorCode);</span><br><span class="line">        <span class="built_in">this</span>.errorCode = errorCode;</span><br><span class="line">        <span class="built_in">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">(String errorCode, String errorMsg, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(errorCode, cause);</span><br><span class="line">        <span class="built_in">this</span>.errorCode = errorCode;</span><br><span class="line">        <span class="built_in">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getErrorCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setErrorCode</span><span class="params">(String errorCode)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.errorCode = errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getErrorMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setErrorMsg</span><span class="params">(String errorMsg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.errorMsg = errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errorMsg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Throwable <span class="title function_">fillInStackTrace</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义数据格式</strong></p>
<p>我们定义一下数据的传输格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 响应返回值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月20日 17:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultBody</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResultBody</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ResultBody</span><span class="params">(BaseErrorInfo errorInfo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = errorInfo.getResultCode();</span><br><span class="line">        <span class="built_in">this</span>.message = errorInfo.getResultMsg();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(String code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResult</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成功</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultBody <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> success(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultBody <span class="title function_">success</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="type">ResultBody</span> <span class="variable">rb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultBody</span>();</span><br><span class="line">        rb.setCode(CommonEnum.SUCCESS.getResultCode());</span><br><span class="line">        rb.setMessage(CommonEnum.SUCCESS.getResultMsg());</span><br><span class="line">        rb.setResult(data);</span><br><span class="line">        <span class="keyword">return</span> rb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultBody <span class="title function_">error</span><span class="params">(BaseErrorInfo errorInfo)</span> &#123;</span><br><span class="line">        <span class="type">ResultBody</span> <span class="variable">rb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultBody</span>();</span><br><span class="line">        rb.setCode(errorInfo.getResultCode());</span><br><span class="line">        rb.setMessage(errorInfo.getResultMsg());</span><br><span class="line">        rb.setResult(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> rb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultBody <span class="title function_">error</span><span class="params">(String code, String message)</span> &#123;</span><br><span class="line">        <span class="type">ResultBody</span> <span class="variable">rb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultBody</span>();</span><br><span class="line">        rb.setCode(code);</span><br><span class="line">        rb.setMessage(message);</span><br><span class="line">        rb.setResult(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> rb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ResultBody <span class="title function_">error</span><span class="params">( String message)</span> &#123;</span><br><span class="line">        <span class="type">ResultBody</span> <span class="variable">rb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultBody</span>();</span><br><span class="line">        rb.setCode(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        rb.setMessage(message);</span><br><span class="line">        rb.setResult(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">return</span> rb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONObject.toJSONString(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义全局异常处理类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理全局业务异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月20日 17:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理自定义的业务异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = BizException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> ResultBody <span class="title function_">bizExceptionHandler</span><span class="params">(HttpServletRequest req, BizException e)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;发生业务异常！原因是：&#123;&#125;&quot;</span>, e.getErrorMsg());</span><br><span class="line">        <span class="keyword">return</span> ResultBody.error(e.getErrorCode(), e.getErrorMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理空指针的异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = NullPointerException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> ResultBody <span class="title function_">exceptionHandler</span><span class="params">(HttpServletRequest req, NullPointerException e)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;发生空指针异常！原因是:&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResultBody.error(CommonEnum.BODY_NOT_MATCH);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理其他异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> ResultBody <span class="title function_">exceptionHandler</span><span class="params">(HttpServletRequest req, Exception e)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;未知异常！原因是:&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResultBody.error(CommonEnum.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发生数字类型转换异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = NumberFormatException.class)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> ResultBody <span class="title function_">exceptionHandler</span><span class="params">(HttpServletRequest req, NumberFormatException e)</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;发生数字类型转换异常！原因是:&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ResultBody.error(CommonEnum.NUMBER_FORMAT_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果不需要返回json数据，而要渲染某个页面模板返回给浏览器，那么可以这么实现：</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MyException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">myErrorHandler</span><span class="params">(Exception ex)</span> &#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="comment">//指定错误页面的模板页</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;code&quot;</span>, <span class="number">400</span>);</span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;这是自定义异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实体类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月20日 17:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">/** 编号 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">/** 姓名 */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/** 年龄 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserInfo</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSONObject.toJSONString(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口层</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年05月20日 17:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始新增...&quot;</span>);</span><br><span class="line">        <span class="comment">//如果姓名为空就手动抛出一个自定义的异常！</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(user.getName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(UserInfoEnum.USER_NAME_BLANK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始更新...&quot;</span>);</span><br><span class="line">        <span class="comment">//这里故意造成一个空指针的异常，并且不进行处理</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        str.equals(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始删除...&quot;</span>);</span><br><span class="line">        <span class="comment">//这里故意造成一个异常，并且不进行处理</span></span><br><span class="line">        Integer.parseInt(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserInfo&gt; <span class="title function_">findByUser</span><span class="params">(UserInfo user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始查询...&quot;</span>);</span><br><span class="line">        List&lt;UserInfo&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">UserInfo</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfo</span>();</span><br><span class="line">        user2.setId(<span class="number">1</span>);</span><br><span class="line">        user2.setName(<span class="string">&quot;xuwujing&quot;</span>);</span><br><span class="line">        user2.setAge(<span class="number">18</span>);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<p>调用insert接口时</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;USER_NAME_BLANK&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;新增用户时,用户姓名不能为空！&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用update接口时</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;400&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;请求的数据格式不符!&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用delete接口时</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;400&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;字符串不包含可解析的整数!&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>调用findByUser接口时</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xuwujing&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<p>通过自定义异常处理和异常提示语句可以更友好的返回给客户端错误信息，也使得项目中的异常处理代码更简洁。</p>
<p>关于SpringBoot优雅的全局异常处理的文章就讲解到这里了，如有不妥，欢迎指正！</p>
<p>SpringBoot全局异常的处理源码地址：<a href="https://gitee.com/lixiaogou/springbootdemo/tree/master/springbootexception">springbootexception</a></p>
<p>参考：江南一点雨、虚无境的博客</p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot实现全局入参解密与出参加密功能</title>
    <url>/posts/f2a72f0b2d3b/</url>
    <content><![CDATA[<h1 id="springboot实现全局入参解密与出参加密功能"><a href="#springboot实现全局入参解密与出参加密功能" class="headerlink" title="springboot实现全局入参解密与出参加密功能"></a>springboot实现全局入参解密与出参加密功能</h1><p>在实际项目中，我们常常需要在请求前后进行一些操作，比如：参数解密/返回结果加密，打印请求参数和返回结果的日志等。这些与业务无关的东西，我们不希望写在controller方法中，造成代码重复可读性变差。这里，我们讲讲使用@RestControllerAdvice和RequestBodyAdvice、ResponseBodyAdvice来对请求前后进行处理（本质上就是AOP），来实现解密和加密请求的参数和返回结果。</p>
<p>在实现之前，先来看一下这三个注解的作用</p>
<h2 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h2><p>@RestControllerAdvice = @ControllerAdvice +@ResponseBody</p>
<p>首先，<code>ControllerAdvice</code>是spring 3.2提供的新注解,他是一个controller增强器,可以对controller中使用到@RequestMapping注解的方法做逻辑处理。</p>
<p>然后，我们来看一下此类的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.web.bind.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AliasFor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ControllerAdvice &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    basePackages属性的别名。</span></span><br><span class="line"><span class="comment">    允许更简洁的注释声明——例如，</span></span><br><span class="line"><span class="comment">    <span class="doctag">@ControllerAdvice</span>(&quot;org.my.pkg&quot;)等价于<span class="doctag">@ControllerAdvice</span>(basePackages = &quot;org.my.pkg&quot;) 。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(&quot;basePackages&quot;)</span></span><br><span class="line">	String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">    基础包数组。</span></span><br><span class="line"><span class="comment">    属于这些基础包或其子包的控制器将被包括在内——例如， <span class="doctag">@ControllerAdvice</span>(basePackages = &quot;org.my.pkg&quot;)或<span class="doctag">@ControllerAdvice</span>(basePackages = &#123;&quot;org.my.pkg&quot;, &quot;org.my.other.pkg&quot;&#125;) 。</span></span><br><span class="line"><span class="comment">    value是此属性的别名，只是允许更简洁地使用注释。</span></span><br><span class="line"><span class="comment">    还可以考虑使用basePackageClasses作为基于字符串的包名称的类型安全替代方案</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor(&quot;value&quot;)</span></span><br><span class="line">	String[] basePackages() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">        basePackages类型安全替代方案，用于指定要选择由<span class="doctag">@ControllerAdvice</span>注释类建议的控制器的包。</span></span><br><span class="line"><span class="comment">        考虑在每个包中创建一个特殊的无操作标记类或接口，除了被此属性引用外，没有其他用途。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] basePackageClasses() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">        类数组。</span></span><br><span class="line"><span class="comment">        <span class="doctag">@ControllerAdvice</span>注释类将通知可分配给至少一种给定类型的控制器</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] assignableTypes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">        注释类型数组。</span></span><br><span class="line"><span class="comment">        <span class="doctag">@ControllerAdvice</span>注释类将通知使用至少一种提供的注释类型注释的控制器。</span></span><br><span class="line"><span class="comment">        考虑创建自定义组合注释或使用预定义的注释，例如<span class="doctag">@RestController</span> </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt;[] annotations() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简单翻译一下就是：</p>
<p>这个类是为那些声明了（@ExceptionHandler、@InitBinder 或 @ModelAttribute注解修饰的）方法的类而提供的专业化的@Component , 以供多个 Controller类所共享。</p>
<p>说白了，就是aop思想的一种实现，你告诉我需要拦截规则，我帮你把他们拦下来，具体你想做更细致的拦截筛选和拦截之后的处理，你自己通过@ExceptionHandler、@InitBinder 或 @ModelAttribute这三个注解以及被其注解的方法来自定义。</p>
<p>ControllerAdvice 提供了多种指定Advice规则的定义方式，默认什么都不写，则是Advice所有Controller，当然你也可以通过下列的方式指定规则：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 则匹配org.my.pkg包及其子包下的所有Controller，</span><br><span class="line">1、@ControllerAdvice(&quot;org.my.pkg&quot;) 或者 @ControllerAdvice(basePackages=&quot;org.my.pkg&quot;)，</span><br><span class="line"></span><br><span class="line">// 指定多个包</span><br><span class="line">2、@ControllerAdvice(basePackages=&#123;&quot;org.my.pkg&quot;, &quot;org.my.other.pkg&quot;&#125;), </span><br><span class="line"></span><br><span class="line">3、也可以通过指定注解来匹配，比如我自定了一个 @MyAnnotation 注解，我想匹配所有被这个注解修饰的 Controller, 可以这么写：@ControllerAdvice（annotations=&#123;MyAnnotation.class&#125;)</span><br><span class="line"></span><br><span class="line">还有很多用法，这里就不全部罗列了</span><br></pre></td></tr></table></figure>

<p>ControllerAdvice 该注解有很多种用法，比如配合<code>@ExceptionHandler</code> 实现全局异常处理；配合 <code>@ModelAttribute</code> 预设全局数据； 配合 <code>@InitBinder</code> 实现对请求参数的预处理；</p>
<h2 id="RequestBodyAdvice"><a href="#RequestBodyAdvice" class="headerlink" title="RequestBodyAdvice"></a>RequestBodyAdvice</h2><p>这个是spring4.2之后增加的接口，该注解的作用是：</p>
<blockquote>
<p>在<code>HttpMessageConverter</code>处理request body的前做一些处理，然后处理处理完的数据才会进入到<code>controller</code>。可以通过覆写 <code>beforeBodyRead</code> 来统一的对请求数据体进行修改。这里我们就利用这个特点来做请求数据的解密操作。</p>
</blockquote>
<p>看一下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet.mvc.method.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpInputMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RequestBodyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法用于判断当前请求，是否要执行beforeBodyRead方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter handler方法的参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetType      handler方法的参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType   将会使用到的Http消息转换器类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回true则会执行beforeBodyRead</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter methodParameter, Type targetType,</span></span><br><span class="line"><span class="params">         Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Http消息转换器执转换，之前执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputMessage    客户端的请求数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter handler方法的参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetType      handler方法的参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType   将会使用到的Http消息转换器类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 一个自定义的HttpInputMessage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   HttpInputMessage <span class="title function_">beforeBodyRead</span><span class="params">(HttpInputMessage inputMessage, MethodParameter parameter,</span></span><br><span class="line"><span class="params">         Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Http消息转换器执转换，之前执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body    转换后的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputMessage    客户端的请求数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter handler方法的参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetType      handler方法的参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType   将会使用到的Http消息转换器类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 一个自定义的HttpInputMessage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   Object <span class="title function_">afterBodyRead</span><span class="params">(Object body, HttpInputMessage inputMessage, MethodParameter parameter,</span></span><br><span class="line"><span class="params">         Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span>;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 同上，不过这个方法处理的是，body为空的情况</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   Object <span class="title function_">handleEmptyBody</span><span class="params">(<span class="meta">@Nullable</span> Object body, HttpInputMessage inputMessage, MethodParameter parameter,</span></span><br><span class="line"><span class="params">         Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下RequestBodyAdvice接口的实现类</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/springboot/20220325230152.png" alt="image-20211224145442992"></p>
<p>这里我们用的是RequestBodyAdviceAdapter这个抽象类，因为该类中已经帮我们默认实现了一些此次用不到的方法，所以优先选择该实现类，而不是选择RequestBodyAdvice接口</p>
<h2 id="ResponseBodyAdvice"><a href="#ResponseBodyAdvice" class="headerlink" title="ResponseBodyAdvice"></a>ResponseBodyAdvice</h2><p>这个是spring4.2之后增加的接口，该注解的作用是：</p>
<blockquote>
<p>在 <code>Controller</code> 方法返回数据，并且匹配到了 <code>HttpMessageConverter</code> 之后。<code>HttpMessageConverter</code> 进行序列化之前执行。可以通过覆写 <code>beforeBodyWrite</code> 来统一的对响应体进行修改。</p>
</blockquote>
<p>看一下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet.mvc.method.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResponseBodyAdvice</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法用于判断当前请求的返回值，是否要执行beforeBodyWrite方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter handler方法的参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType   将会使用到的Http消息转换器类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回true则会执行beforeBodyWrite</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Http消息转换器执转换，之前执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body               服务端的响应数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter    handler方法的参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mediaType          响应的ContentType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType      将会使用到的Http消息转换器类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverHttpRequest  serverHttpRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverHttpResponse serverHttpResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 一个自定义的HttpInputMessage，可以为null，表示没有任何响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   T <span class="title function_">beforeBodyWrite</span><span class="params">(<span class="meta">@Nullable</span> T body, MethodParameter returnType, MediaType selectedContentType,</span></span><br><span class="line"><span class="params">         Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType,</span></span><br><span class="line"><span class="params">         ServerHttpRequest request, ServerHttpResponse response)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们选择直接实现该接口，来重写方法达到全局解密的效果。</p>
<h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>项目中用到的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- swagger 两个依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--以下俩ui可并存--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--http://localhost:8081/swagger-ui.html 访问路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--http://localhost:8081/doc.html 访问路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>swagger-bootstrap-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- lombok --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.79<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="EncryptFilter类完整代码"><a href="#EncryptFilter类完整代码" class="headerlink" title="EncryptFilter类完整代码"></a>EncryptFilter类完整代码</h2><p>自定义一个注解，用来修饰方法，判断加密行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EncryptFilter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对入参是否解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">decryptRequest</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对出参是否加密</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">encryptResponse</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="AESUtil类完整代码"><a href="#AESUtil类完整代码" class="headerlink" title="AESUtil类完整代码"></a>AESUtil类完整代码</h2><p>编写加密解密的工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.tomcat.util.codec.binary.Base64;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.security.InvalidKeyException;</span><br><span class="line"><span class="keyword">import</span> java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AES工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年12月23日 13:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AESUtil</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 128位的AESkey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span>[] AES_KEY = <span class="string">&quot;1111111111111111&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待解密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] data) <span class="keyword">throws</span> InvalidKeyException, NoSuchAlgorithmException,</span><br><span class="line">            NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> getCipher(AES_KEY, Cipher.DECRYPT_MODE);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES 加密操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data 待加密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 字节数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encrypt(<span class="type">byte</span>[] data) <span class="keyword">throws</span> InvalidKeyException, NoSuchAlgorithmException,</span><br><span class="line">            NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException &#123;</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> getCipher(AES_KEY, Cipher.ENCRYPT_MODE);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES 加密操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text 待加密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Base64转码后的加密数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encrypt</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] byteContent = text.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] result = encrypt(byteContent);<span class="comment">// 加密</span></span><br><span class="line">            <span class="keyword">return</span> Base64.encodeBase64String(result);<span class="comment">//通过Base64转码返回</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Error message: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * AES 解密操作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">decrypt</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = Base64.decodeBase64(text);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] result = decrypt(bytes);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(result, StandardCharsets.UTF_8);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;Error message: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取加密器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchAlgorithmException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NoSuchPaddingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InvalidKeyException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cipher <span class="title function_">getCipher</span><span class="params">(<span class="type">byte</span>[] key, <span class="type">int</span> model)</span></span><br><span class="line">            <span class="keyword">throws</span> NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException &#123;</span><br><span class="line">        <span class="type">SecretKeySpec</span> <span class="variable">secretKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, <span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES/ECB/PKCS5Padding&quot;</span>);</span><br><span class="line">        cipher.init(model, secretKeySpec);</span><br><span class="line">        <span class="keyword">return</span> cipher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="StreamUtil类"><a href="#StreamUtil类" class="headerlink" title="StreamUtil类"></a>StreamUtil类</h2><p>创建流的工具类，将请求body二进制流转为字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springbootEncrypt.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 流工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年12月23日 18:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将requestBody的数据转成字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputStream</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getBodyString</span><span class="params">(InputStream inputStream)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(inputStream)) &#123;</span><br><span class="line">                bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream));</span><br><span class="line">                <span class="type">int</span> bytesRead;</span><br><span class="line">                <span class="type">char</span>[] charBuffer = <span class="keyword">new</span> <span class="title class_">char</span>[BUFFER_SIZE];</span><br><span class="line">                <span class="keyword">while</span> ((bytesRead = bufferedReader.read(charBuffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    stringBuilder.append(charBuffer, <span class="number">0</span>, bytesRead);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;get body fail，&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bufferedReader.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DecryptRequestBodyAdapter类"><a href="#DecryptRequestBodyAdapter类" class="headerlink" title="DecryptRequestBodyAdapter类"></a>DecryptRequestBodyAdapter类</h2><p>创建 <code>DecryptRequestBodyAdapter</code>类 继承 <code>RequestBodyAdviceAdapter</code>类，然后重写方法，进行入参的解密</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.springbootEncrypt.anno.EncryptFilter;</span><br><span class="line"><span class="keyword">import</span> com.example.springbootEncrypt.utils.AESUtil;</span><br><span class="line"><span class="keyword">import</span> com.example.springbootEncrypt.utils.StreamUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.util.Strings;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpHeaders;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpInputMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.RequestBodyAdviceAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;接口入参解密&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * RequestBodyAdvice可以理解为在<span class="doctag">@RequestBody</span>之前需要进行的 操作，&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * ResponseBodyAdvice可以理解为在<span class="doctag">@ResponseBody</span>之后进行的操作;&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 所以当接口需要加解密时，在使用<span class="doctag">@RequestBody</span>接收前台参数之前可以先在RequestBodyAdvice的实现类中进行参数的解密，&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 当操作结束需要返回数据时，可以在<span class="doctag">@ResponseBody</span>之后进入ResponseBodyAdvice的实现类中进行参数的加密。&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年12月23日 14:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecryptRequestBodyAdapter</span> <span class="keyword">extends</span> <span class="title class_">RequestBodyAdviceAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法用于判断当前请求，是否要执行beforeBodyRead方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter handler方法的参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetType      handler方法的参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType   将会使用到的Http消息转换器类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回true则会执行beforeBodyRead</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter methodParameter, Type targetType,</span></span><br><span class="line"><span class="params">                            Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodParameter.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(method)) &#123;</span><br><span class="line">            <span class="type">EncryptFilter</span> <span class="variable">encryptFilter</span> <span class="operator">=</span> method.getAnnotation(EncryptFilter.class);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(encryptFilter)) &#123;</span><br><span class="line">                <span class="keyword">return</span> encryptFilter.decryptRequest();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Http消息转换器执转换，之前执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputMessage    客户端的请求数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter handler方法的参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetType      handler方法的参数类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType   将会使用到的Http消息转换器类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 一个自定义的HttpInputMessage</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HttpInputMessage <span class="title function_">beforeBodyRead</span><span class="params">(HttpInputMessage inputMessage, MethodParameter methodParameter, Type targetType,</span></span><br><span class="line"><span class="params">                                           Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取加密的请求体</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">body</span> <span class="operator">=</span> inputMessage.getBody();</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> inputMessage.getHeaders();</span><br><span class="line">        headers.remove(<span class="string">&quot;Content-Length&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> StreamUtil.getBodyString(body);</span><br><span class="line">        log.info(<span class="string">&quot;解密前请求body:&quot;</span> + s);</span><br><span class="line">        <span class="keyword">if</span> (Strings.isNotEmpty(s)) &#123;</span><br><span class="line">            <span class="comment">// 使用AES解密</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">bodyDec</span> <span class="operator">=</span> AESUtil.decrypt(s);</span><br><span class="line">            log.info(<span class="string">&quot;解密后请求body:&quot;</span> + bodyDec);</span><br><span class="line">            <span class="keyword">if</span> (Strings.isNotEmpty(bodyDec)) &#123;</span><br><span class="line">                <span class="comment">// 使用解密后的数据，构造新的读取流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bodyDec.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpInputMessage</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> HttpHeaders <span class="title function_">getHeaders</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> inputMessage.getHeaders();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> InputStream <span class="title function_">getBody</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> inputStream;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> inputMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="EncryptResponseBodyAdapter类"><a href="#EncryptResponseBodyAdapter类" class="headerlink" title="EncryptResponseBodyAdapter类"></a>EncryptResponseBodyAdapter类</h2><p>创建 <code>EncryptResponseBodyAdapter</code>类 实现 <code>ResponseBodyAdvice</code>类，然后重写方法，进行返回值的加密。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.springbootEncrypt.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> com.example.springbootEncrypt.anno.EncryptFilter;</span><br><span class="line"><span class="keyword">import</span> com.example.springbootEncrypt.utils.AESUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.MethodParameter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;接口出参加密&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * RequestBodyAdvice可以理解为在<span class="doctag">@RequestBody</span>之前需要进行的 操作，&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * ResponseBodyAdvice可以理解为在<span class="doctag">@ResponseBody</span>之后进行的操作;&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 所以当接口需要加解密时，在使用<span class="doctag">@RequestBody</span>接收前台参数之前可以先在RequestBodyAdvice的实现类中进行参数的解密，&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> * 当操作结束需要返回数据时，可以在<span class="doctag">@ResponseBody</span>之后进入ResponseBodyAdvice的实现类中进行参数的加密。&lt;br/&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年12月24日 10:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//@RestControllerAdvice(&quot;com.example.springbootEncrypt.controller&quot;)</span></span><br><span class="line"><span class="comment">// 表示com.example.springbootEncrypt.controller此包下的所有响应对象都会经过此拦截器，并对响应体加密</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncryptResponseBodyAdapter</span> <span class="keyword">implements</span> <span class="title class_">ResponseBodyAdvice</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该方法用于判断当前请求的返回值，是否要执行beforeBodyWrite方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter handler方法的参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType   将会使用到的Http消息转换器类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回true则会执行beforeBodyWrite</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(MethodParameter methodParameter, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType)</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> methodParameter.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(method)) &#123;</span><br><span class="line">            <span class="type">EncryptFilter</span> <span class="variable">encryptFilter</span> <span class="operator">=</span> method.getAnnotation(EncryptFilter.class);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(encryptFilter)) &#123;</span><br><span class="line">                <span class="keyword">return</span> encryptFilter.encryptResponse();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Http消息转换器执转换，之前执行</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body               服务端的响应数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodParameter    handler方法的参数对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mediaType          响应的ContentType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> converterType      将会使用到的Http消息转换器类类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverHttpRequest  serverHttpRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverHttpResponse serverHttpResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回 一个自定义的HttpInputMessage，可以为null，表示没有任何响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">beforeBodyWrite</span><span class="params">(<span class="meta">@Nullable</span> Object body, MethodParameter methodParameter, MediaType mediaType,Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType,ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;处理请求地址：&#123;&#125; 的返回值&quot;</span>, serverHttpRequest.getURI());</span><br><span class="line">        <span class="comment">//获取请求数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">srcData</span> <span class="operator">=</span> JSON.toJSONString(body);</span><br><span class="line">        log.info(<span class="string">&quot;加密前响应body=&#123;&#125;&quot;</span>, srcData);</span><br><span class="line">        <span class="keyword">if</span> (Objects.nonNull(body)) &#123;</span><br><span class="line">            <span class="comment">//加密</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">returnStr</span> <span class="operator">=</span> AESUtil.encrypt(srcData);</span><br><span class="line">            log.info(<span class="string">&quot;加密后响应body:&quot;</span> + returnStr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//添加 encrypt 告诉前端数据已加密</span></span><br><span class="line">            <span class="comment">//serverHttpResponse.getHeaders().add(&quot;encrypt&quot;, &quot;e=a&quot;);</span></span><br><span class="line">            <span class="keyword">return</span> returnStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> body;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="HelloController"><a href="#HelloController" class="headerlink" title="HelloController"></a>HelloController</h2><p>编写controller 进行测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.springbootEncrypt.anno.EncryptFilter;</span><br><span class="line"><span class="keyword">import</span> com.example.springbootEncrypt.dto.PlainResult;</span><br><span class="line"><span class="keyword">import</span> com.example.springbootEncrypt.dto.UserInfoVO;</span><br><span class="line"><span class="keyword">import</span> com.example.springbootEncrypt.entity.UserInfo;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">//@Controller 视图解析器可以解析return 的jsp,html页面，并且跳转到相应页面，若返回json等内容到页面，则对应的方法需要加@ResponseBody注解</span></span><br><span class="line"><span class="comment">//@RestController 相当于@Controller+@ResponseBody的结合，返回json数据不需要在方法前面加@ResponseBody注解了，</span></span><br><span class="line"><span class="comment">//但使用@RestController这个注解，方法就不能返回jsp,html页面，视图解析器无法解析jsp,html页面。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/api&quot;)</span></span><br><span class="line"><span class="meta">@Api(tags = &quot;Hello接口&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;入参和出参都是密文&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/both&quot;)</span></span><br><span class="line">    <span class="meta">@EncryptFilter</span></span><br><span class="line">    <span class="keyword">public</span> PlainResult&lt;UserInfoVO&gt; <span class="title function_">both</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userinfo)</span> &#123;</span><br><span class="line">        <span class="type">UserInfoVO</span> <span class="variable">userInfoVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfoVO</span>();</span><br><span class="line">        userInfoVO.setUsername(userinfo.getUsername() + System.currentTimeMillis());</span><br><span class="line">        userInfoVO.setAge(userinfo.getAge());</span><br><span class="line"></span><br><span class="line">        PlainResult&lt;UserInfoVO&gt; result = <span class="keyword">new</span> <span class="title class_">PlainResult</span>&lt;&gt;(userInfoVO);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;入参密文，出参明文&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/decryptRequest&quot;)</span></span><br><span class="line">    <span class="meta">@EncryptFilter(encryptResponse = false)</span></span><br><span class="line">    <span class="keyword">public</span> PlainResult&lt;UserInfoVO&gt; <span class="title function_">decryptRequest</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userinfo)</span> &#123;</span><br><span class="line">        <span class="type">UserInfoVO</span> <span class="variable">userInfoVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfoVO</span>();</span><br><span class="line">        userInfoVO.setUsername(userinfo.getUsername() + System.currentTimeMillis());</span><br><span class="line">        userInfoVO.setAge(userinfo.getAge());</span><br><span class="line"></span><br><span class="line">        PlainResult&lt;UserInfoVO&gt; result = <span class="keyword">new</span> <span class="title class_">PlainResult</span>&lt;&gt;(userInfoVO);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;入参明文，出参密文&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/encryptResponse&quot;)</span></span><br><span class="line">    <span class="meta">@EncryptFilter(decryptRequest = false)</span></span><br><span class="line">    <span class="keyword">public</span> PlainResult&lt;UserInfoVO&gt; <span class="title function_">encryptResponse</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userinfo)</span> &#123;</span><br><span class="line">        <span class="type">UserInfoVO</span> <span class="variable">userInfoVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfoVO</span>();</span><br><span class="line">        userInfoVO.setUsername(userinfo.getUsername() + System.currentTimeMillis());</span><br><span class="line">        userInfoVO.setAge(userinfo.getAge());</span><br><span class="line"></span><br><span class="line">        PlainResult&lt;UserInfoVO&gt; result = <span class="keyword">new</span> <span class="title class_">PlainResult</span>&lt;&gt;(userInfoVO);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(value = &quot;入参和出参都是明文&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/non&quot;)</span></span><br><span class="line">    <span class="meta">@EncryptFilter(decryptRequest = false, encryptResponse = false)</span></span><br><span class="line">    <span class="keyword">public</span> PlainResult&lt;UserInfoVO&gt; <span class="title function_">non</span><span class="params">(<span class="meta">@RequestBody</span> UserInfo userinfo)</span> &#123;</span><br><span class="line">        <span class="type">UserInfoVO</span> <span class="variable">userInfoVO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInfoVO</span>();</span><br><span class="line">        userInfoVO.setUsername(userinfo.getUsername() + System.currentTimeMillis());</span><br><span class="line">        userInfoVO.setAge(userinfo.getAge());</span><br><span class="line"></span><br><span class="line">        PlainResult&lt;UserInfoVO&gt; result = <span class="keyword">new</span> <span class="title class_">PlainResult</span>&lt;&gt;(userInfoVO);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动之后打开 <a href="http://127.0.0.1:8081/doc.html">http://127.0.0.1:8081/doc.html</a> 地址，从swagger文档中进行测试</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/springboot/20220325230208.png" alt="image-20211224153047347"></p>
<p>入参明文：{“age”: 10,”username”: “张三”}</p>
<p>入参密文：D1nFLml8orAlGWNTkMdw6DPn0v8N0t7CvNNHlHeny7nzDGnE+UXmVOvUs4ixyPeQ</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/springboot/20220325230218.png" alt="image-20211224153259436"></p>
<h2 id="测试入参出参都是密文"><a href="#测试入参出参都是密文" class="headerlink" title="测试入参出参都是密文"></a>测试入参出参都是密文</h2><p>入参：D1nFLml8orAlGWNTkMdw6DPn0v8N0t7CvNNHlHeny7nzDGnE+UXmVOvUs4ixyPeQ</p>
<p>出参：NHUSTO2pCK/H/t7bUcCokZKxLpScqwaIXJcmF57sMnuX8fliBIJ0cpkclV7usKn5oYAdh6zqPKDSsSdYsdSBQfrE9dX5R6Gskb1ByMl+Dw8kJpJPEUoJa4Op2qRIOqdN6z/5UTYmFKPMPeySCM0w/gk6GC9fMCHCkFEi9kjXhnc=</p>
<p>swagger接口测试情况：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/springboot/20220325230223.png" alt="image-20211224153517213"></p>
<p>后台日志打印：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/springboot/20220325230228.png" alt="image-20211224153505720"></p>
<p>经过<a href="http://tool.chacuo.net/cryptaes">在线AES加密解密</a>之后结果如下：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/springboot/20220325230235.png" alt="image-20211224153621871"></p>
<p>至此，我们在尽可能少的修改controller的基础上，实现了全局接口的加密解密功能</p>
<p>完整版代码在此：<a href="https://gitee.com/lixiaogou/springbootdemo/tree/master/springbootEncrypt">springbootEncrypt</a></p>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTML</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>第 11 章 树结构实际应用【1、 堆排序】</title>
    <url>/posts/c230cf270419/</url>
    <content><![CDATA[<h1 id="第-11-章-树结构实际应用【1、-堆排序】"><a href="#第-11-章-树结构实际应用【1、-堆排序】" class="headerlink" title="第 11 章 树结构实际应用【1、 堆排序】"></a>第 11 章 树结构实际应用【1、 堆排序】</h1><h2 id="1、堆排序"><a href="#1、堆排序" class="headerlink" title="1、堆排序"></a>1、堆排序</h2><h3 id="1-1、堆排序基本介绍"><a href="#1-1、堆排序基本介绍" class="headerlink" title="1.1、堆排序基本介绍"></a>1.1、堆排序基本介绍</h3><ul>
<li><p>堆排序是利用堆这种数据结构而设计的一种排序算法， 堆排序是一种选择排序， 它的最坏， 最好， 平均时间复杂度均为 O(nlogn)， 它也是不稳定排序。</p>
</li>
<li><p>堆是具有以下性质的</p>
<p>完全二叉树</p>
<p>：</p>
<ul>
<li>每个结点的值都大于或等于其左右孩子结点的值， 称为大顶堆，注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。</li>
<li>每个结点的值都小于或等于其左右孩子结点的值， 称为小顶堆</li>
</ul>
</li>
<li><p>完全二叉树：一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/df4fa70e0ea94b3cebd6aa1fe92649ad.png" alt="image-20200718153248525"></p>
<ul>
<li>一般升序采用大顶堆， 降序采用小顶堆</li>
<li>大顶堆特点：<strong>arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2]</strong> ，i 对应第几个节点，i 从0 开始编号</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/848a605f8b6e87a7d9df88d51606c0b0.png" alt="image-20200717224823305"></p>
<ul>
<li>小顶堆特点：<strong>arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2]</strong> ，i 对应第几个节点，i 从 0 开始编号</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/300a8eb38b4a405992277d8017d6234c.png" alt="image-20200717224810239"></p>
<h3 id="1-2、堆排序基本思想"><a href="#1-2、堆排序基本思想" class="headerlink" title="1.2、堆排序基本思想"></a>1.2、堆排序基本思想</h3><ul>
<li>将待排序序列构造成一个大顶堆</li>
<li>此时， 整个序列的最大值就是堆顶的根节点</li>
<li>将其与末尾元素进行交换， 此时末尾就为最大值</li>
<li>然后将剩余 n-1 个元素重新构造成一个堆， 这样会得到 n 个元素的次小值。 如此反复执行， 便能得到一个有序序列了</li>
<li>可以看到在构建大顶堆的过程中， 元素的个数逐渐减少， 最后就得到一个有序序列了</li>
</ul>
<h3 id="1-3、堆排序步骤图解说明"><a href="#1-3、堆排序步骤图解说明" class="headerlink" title="1.3、堆排序步骤图解说明"></a>1.3、堆排序步骤图解说明</h3><h4 id="1-3-1、构造大顶堆"><a href="#1-3-1、构造大顶堆" class="headerlink" title="1.3.1、构造大顶堆"></a>1.3.1、构造大顶堆</h4><ul>
<li>首先构造初始堆，将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆），假设原始数组为 [4, 6, 8, 5, 9]</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ff8c9ddb5c65981c2c7c50ad9ae9a0b1.png" alt="image-20200718150401705"></p>
<ul>
<li>此时我们从最后一个非叶子结点开始（叶子结点自然不用调整，第一个非叶子结点 arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/251f3c65932ac583967612cd96f74aca.png" alt="image-20200718150512803"></p>
<ul>
<li>找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4d8998916da2354e8153282a8a3f6fd0.png" alt="image-20200718150839195"></p>
<ul>
<li>这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/500c1695cb012a67a19703dcdef9acc0.png" alt="image-20200718150629014"></p>
<h4 id="1-3-2、丢弃堆顶元素"><a href="#1-3-2、丢弃堆顶元素" class="headerlink" title="1.3.2、丢弃堆顶元素"></a>1.3.2、丢弃堆顶元素</h4><ul>
<li>将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换，步骤如下：</li>
<li>将堆顶元素 9 和末尾元素 4 进行交换</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6b0bb7636b845e96c387431be3f0efa9.png" alt="image-20200718151131450"></p>
<h4 id="1-3-3、重操旧业"><a href="#1-3-3、重操旧业" class="headerlink" title="1.3.3、重操旧业"></a>1.3.3、重操旧业</h4><ul>
<li>照着之前的方法重新调整结构：将栈顶元素 4 与节点 8 互换，使其继续满足堆定义</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0e84fa5b844c975ca3b2121afc3a25a2.png" alt="image-20200718151220970"></p>
<ul>
<li>再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/060845883f182824c249e4969ef7cbe6.png" alt="image-20200718151436063"></p>
<ul>
<li>后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fd9e0337468979d0a971a46ac96a35f4.png" alt="image-20200718151446928"></p>
<h3 id="1-4、堆排序代码思路"><a href="#1-4、堆排序代码思路" class="headerlink" title="1.4、堆排序代码思路"></a>1.4、堆排序代码思路</h3><h4 id="1-4-1、堆排序基本思路"><a href="#1-4-1、堆排序基本思路" class="headerlink" title="1.4.1、堆排序基本思路"></a>1.4.1、堆排序基本思路</h4><ul>
<li>将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</li>
<li>将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端;</li>
<li>重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</li>
</ul>
<h4 id="1-4-2、编码思路"><a href="#1-4-2、编码思路" class="headerlink" title="1.4.2、编码思路"></a>1.4.2、编码思路</h4><ul>
<li><p>先将数组转为大顶堆，怎么转？</p>
<ul>
<li>先来个完全二叉树，节点编号从 0 开始</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/59ce2e3949b35cf093c40678e6c24642.png" alt="image-20200718155014870"></p>
<ul>
<li>从最深层的非叶子节点开始转换，将最深层的非叶子节点 4 转为大顶堆，即将节点 4 的值与其左右子节点（如果有右节点的话）的值相比较，节点 9 的值大于 节点 4 的值，进行交换，交换后，以节点 4 为根节点的子树就是大顶堆咯</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1f12e4bdc3d23897fefc40fe9b2cd9c8.png" alt="image-20200718155036493"></p>
<ul>
<li>再去到倒数第二个非叶子节点，执行上述操作，倒数第二个非叶子节点为节点 3 ，将节点 3 的值与节点 8 的值互换，交换后，以节点 3 为根节点的子树就是大顶堆咯</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/aa12ae17d95cde0b02313961e126176c.png" alt="image-20200718155058805"></p>
<ul>
<li><p>再去到倒数第三个非叶子节点，执行上述操作，倒数第三个非叶子节点为节点 2 ，节点 2 满足大顶堆，无需执行交换</p>
</li>
<li><p>再去到倒数第四个非叶子节点，执行上述操作，倒数第四个非叶子节点为节点 2 ，节点 2 满足大顶堆，无需执行交换</p>
</li>
<li><p>可以看到，这里出现了<strong>特例</strong>，由于节点 1 的数值比较小，导致以节点 3 为根节点的子树无法构成大顶堆，也导致了以节点 1 为根节点的子树无法构成大顶堆</p>
</li>
<li><p>如何解决这个问题？假设当前非叶子节点为 nonLeafNode ，与其交换值的节点为 exNode ，当每次 nonLeafNode 与 exNode 交换值之后，还要去到以 exNode 为根节点的更深层子树，将 exNode<br>的子树调整为大顶堆</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2f078cfe7a3c04aa94e6d5754516b25f.png" alt="image-20200718155127738"></p>
</li>
<li><p>以此类推… ，直至退到整棵树的根节点</p>
</li>
</ul>
</li>
<li><p>将整个数组转换为大顶堆之后，将堆顶元素与数组最后一个元素交换位置，这样数组最后一个元素就是整个数组中最大的元素，我们就不用管它了</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9811e952561d993190a164dac950567d.png" alt="image-20200718170326132"></p>
<ul>
<li>现在我们拿着新的完全二叉树：节点 0 到节点 8 ，将其调整为大顶堆<ul>
<li>这样来想：节点 1 至 节点 8 已经满足大顶堆的特点了，现在只需要把节点 0 沉下去，把最大的节点浮上来，就又是一棵新的大顶堆啦~~~</li>
<li>怎么沉？那不还是之前的步骤嘛，判断当前节点值与其左右子节点值的大小<ul>
<li>如果无需交换：恭喜，已经是大顶堆了</li>
<li>如果需要交换：假设当前非叶子节点为 nonLeafNode ，与其交换值的节点为 exNode ，交换节点的值后，还要去到以 exNode 为根节点的更深层子树，将 exNode 的子树调整为大顶堆</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-5、堆排序代码实现"><a href="#1-5、堆排序代码实现" class="headerlink" title="1.5、堆排序代码实现"></a>1.5、堆排序代码实现</h3><h4 id="1-5-1、理解堆排序"><a href="#1-5-1、理解堆排序" class="headerlink" title="1.5.1、理解堆排序"></a>1.5.1、理解堆排序</h4><ul>
<li>逐步分解堆排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要求将数组进行升序排序</span></span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写一个堆排序的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分步完成</span></span><br><span class="line">        adjustHeap(arr, <span class="number">1</span>, length);</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次&quot;</span> + Arrays.toString(arr)); <span class="comment">// 4, 9, 8, 5, 6</span></span><br><span class="line"></span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(<span class="string">&quot;第2次&quot;</span> + Arrays.toString(arr)); <span class="comment">// 9,6,8,5,4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        temp = arr[length - <span class="number">1</span>];</span><br><span class="line">        arr[length - <span class="number">1</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = temp;</span><br><span class="line">        length -= <span class="number">1</span>;</span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(<span class="string">&quot;第3次&quot;</span> + Arrays.toString(arr)); <span class="comment">// 8,6,4,5,9</span></span><br><span class="line"></span><br><span class="line">        temp = arr[length - <span class="number">1</span>];</span><br><span class="line">        arr[length - <span class="number">1</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = temp;</span><br><span class="line">        length -= <span class="number">1</span>;</span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(<span class="string">&quot;第4次&quot;</span> + Arrays.toString(arr)); <span class="comment">// 6,5,4,8,9</span></span><br><span class="line"></span><br><span class="line">        temp = arr[length - <span class="number">1</span>];</span><br><span class="line">        arr[length - <span class="number">1</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = temp;</span><br><span class="line">        length -= <span class="number">1</span>;</span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(<span class="string">&quot;第5次&quot;</span> + Arrays.toString(arr)); <span class="comment">// 5,4,6,8,9</span></span><br><span class="line"></span><br><span class="line">        temp = arr[length - <span class="number">1</span>];</span><br><span class="line">        arr[length - <span class="number">1</span>] = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = temp;</span><br><span class="line">        length -= <span class="number">1</span>;</span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, length);</span><br><span class="line">        System.out.println(<span class="string">&quot;第6次&quot;</span> + Arrays.toString(arr)); <span class="comment">// 4,5,6,8,9</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个数组(二叉树), 调整成一个大顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆 举例 int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt;</span></span><br><span class="line"><span class="comment">     * adjustHeap =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; 如果我们再次调用 adjustHeap 传入的是 i = 0 =&gt; 得到 &#123;4, 9,</span></span><br><span class="line"><span class="comment">     * 8, 5, 6&#125; =&gt; &#123;9,6,8,5, 4&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    待调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i      表示非叶子结点在数组中索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 表示对多少个元素继续调整， length 是在逐渐的减少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> length)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];<span class="comment">// 先取出当前元素的值，保存在临时变量</span></span><br><span class="line">        <span class="comment">// 开始调整</span></span><br><span class="line">        <span class="comment">// 说明</span></span><br><span class="line">        <span class="comment">// 1. k = i * 2 + 1 ：k 是 i结点的左子结点</span></span><br><span class="line">        <span class="comment">// 2. X = k * 2 + 1 X 是 k结点的左子结点，循环里始终使用k，所以k变成了 k * 2 + 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123; <span class="comment">// 说明左子结点的值小于右子结点的值</span></span><br><span class="line">                k++; <span class="comment">// k 指向右子结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; temp) &#123; <span class="comment">// 如果子结点大于父结点</span></span><br><span class="line">                arr[i] = arr[k]; <span class="comment">// 把较大的值赋给当前结点</span></span><br><span class="line">                i = k; <span class="comment">// !!! i 指向 k，将小的值沉下去</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// !!! 由于是从最深处往前调整，我能保证下面的子树已经是大顶堆了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)</span></span><br><span class="line">        arr[i] = temp;<span class="comment">// 将temp值放到调整后的位置</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法同上，只不过个人更新换这种方式，这样更方便理解父子节点交换位置的逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lenght</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> lenght)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];<span class="comment">//先取出当前元素的值，保存在临时变量</span></span><br><span class="line">        <span class="comment">//开始调整</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. k = i * 2 + 1 k 是 i结点的左子结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>; k &lt; lenght; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; lenght &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123; <span class="comment">//右子结点的值大于左子结点的值</span></span><br><span class="line">                k++; <span class="comment">// k 指向右子结点，后面再使用arr[k] 意思就是拿到了 左右子结点中的较大值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果较大子结点arr[k]大于父节点temp,将父子节点位置交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; temp) &#123;</span><br><span class="line">                <span class="comment">//把子节点放到父节点的位置</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                <span class="comment">//把父节点放到子结点的值位置</span></span><br><span class="line">                arr[k] = temp;</span><br><span class="line">                <span class="comment">//!!! i 指向 k,继续循环比较，然后将i指向k</span></span><br><span class="line">                i = k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//! 父节点比子节点都大。不在处理</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组=&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">第一次[<span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">第<span class="number">2</span>次[<span class="number">9</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br><span class="line">第<span class="number">3</span>次[<span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">第<span class="number">4</span>次[<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">第<span class="number">5</span>次[<span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">第<span class="number">6</span>次[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">排序后=[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-5-2、编写堆排序"><a href="#1-5-2、编写堆排序" class="headerlink" title="1.5.2、编写堆排序"></a>1.5.2、编写堆排序</h4><ul>
<li>编写堆排序算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编写一个堆排序的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成我们最终代码</span></span><br><span class="line">    <span class="comment">// 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        adjustHeap(arr,i,arr.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2).将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;</span></span><br><span class="line"><span class="comment">         * 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=arr.length-<span class="number">1</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="comment">// 交换</span></span><br><span class="line">        temp=arr[j];</span><br><span class="line">        arr[j]=arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>]=temp;</span><br><span class="line">        adjustHeap(arr,<span class="number">0</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将一个数组(二叉树), 调整成一个大顶堆</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆 举例 int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt;</span></span><br><span class="line"><span class="comment"> * adjustHeap =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; 如果我们再次调用 adjustHeap 传入的是 i = 0 =&gt; 得到 &#123;4, 9,</span></span><br><span class="line"><span class="comment"> * 8, 5, 6&#125; =&gt; &#123;9,6,8,5, 4&#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr    待调整的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i      表示非叶子结点在数组中索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 表示对多少个元素继续调整， length 是在逐渐的减少</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> i,<span class="type">int</span> length)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temp=arr[i];<span class="comment">// 先取出当前元素的值，保存在临时变量</span></span><br><span class="line">    <span class="comment">// 开始调整</span></span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1. k = i * 2 + 1 ：k 是 i结点的左子结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length; k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp;arr[k]&lt;arr[k+<span class="number">1</span>])&#123; <span class="comment">// 说明左子结点的值小于右子结点的值</span></span><br><span class="line">            k++; <span class="comment">// k 指向右子结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(arr[k]&gt;temp)&#123; <span class="comment">// 如果子结点大于父结点</span></span><br><span class="line">            arr[i]=arr[k]; <span class="comment">// 把较大的值赋给当前结点</span></span><br><span class="line">            i=k; <span class="comment">// !!! i 指向 k，将小的值沉下去</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// !!! 由于是从最深处往前调整，我能保证下面的子树已经是大顶堆了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)</span></span><br><span class="line">    arr[i]=temp;<span class="comment">// 将temp值放到调整后的位置</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法同上，只不过个人更新换这种方式，这样更方便理解父子节点交换位置的逻辑</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lenght</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> lenght)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];<span class="comment">//先取出当前元素的值，保存在临时变量</span></span><br><span class="line">    <span class="comment">//开始调整</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. k = i * 2 + 1 k 是 i结点的左子结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>; k &lt; lenght; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k + <span class="number">1</span> &lt; lenght &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123; <span class="comment">//右子结点的值大于左子结点的值</span></span><br><span class="line">            k++; <span class="comment">// k 指向右子结点，后面再使用arr[k] 意思就是拿到了 左右子结点中的较大值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果较大子结点arr[k]大于父节点temp,将父子节点位置交换</span></span><br><span class="line">        <span class="keyword">if</span> (arr[k] &gt; temp) &#123;</span><br><span class="line">            <span class="comment">//把子节点放到父节点的位置</span></span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            <span class="comment">//把父节点放到子结点的值位置</span></span><br><span class="line">            arr[k] = temp;</span><br><span class="line">            <span class="comment">//!!! i 指向 k,继续循环比较，然后将i指向k</span></span><br><span class="line">            i = k;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//! 父节点比子节点都大。不在处理</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组=&quot;</span> + Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-5-3、代码测试"><a href="#1-5-3、代码测试" class="headerlink" title="1.5.3、代码测试"></a>1.5.3、代码测试</h4><ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要求将数组进行升序排序</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    heapSort(arr);</span><br><span class="line">    System.out.println(<span class="string">&quot;排序后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序后=[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-5-4、测试堆排序性能"><a href="#1-5-4、测试堆排序性能" class="headerlink" title="1.5.4、测试堆排序性能"></a>1.5.4、测试堆排序性能</h4><ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(data1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">        heapSort(arr);</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写一个堆排序的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成我们最终代码</span></span><br><span class="line">        <span class="comment">// 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 2).将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端;</span></span><br><span class="line"><span class="comment">         * 3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="comment">// 交换</span></span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将一个数组(二叉树), 调整成一个大顶堆</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆 举例 int arr[] = &#123;4, 6, 8, 5, 9&#125;; =&gt; i = 1 =&gt;</span></span><br><span class="line"><span class="comment">     * adjustHeap =&gt; 得到 &#123;4, 9, 8, 5, 6&#125; 如果我们再次调用 adjustHeap 传入的是 i = 0 =&gt; 得到 &#123;4, 9,</span></span><br><span class="line"><span class="comment">     * 8, 5, 6&#125; =&gt; &#123;9,6,8,5, 4&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    待调整的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i      表示非叶子结点在数组中索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 表示对多少个元素继续调整， length 是在逐渐的减少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> length)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];<span class="comment">// 先取出当前元素的值，保存在临时变量</span></span><br><span class="line">        <span class="comment">// 开始调整</span></span><br><span class="line">        <span class="comment">// 说明</span></span><br><span class="line">        <span class="comment">// 1. k = i * 2 + 1 ：k 是 i结点的左子结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123; <span class="comment">// 说明左子结点的值小于右子结点的值</span></span><br><span class="line">                k++; <span class="comment">// k 指向右子结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; temp) &#123; <span class="comment">// 如果子结点大于父结点</span></span><br><span class="line">                arr[i] = arr[k]; <span class="comment">// 把较大的值赋给当前结点</span></span><br><span class="line">                i = k; <span class="comment">// !!! i 指向 k，将小的值沉下去</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// !!! 由于是从最深处往前调整，我能保证下面的子树已经是大顶堆了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了 最顶(局部)</span></span><br><span class="line">        arr[i] = temp;<span class="comment">// 将temp值放到调整后的位置</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=<span class="number">2020</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">27</span></span><br><span class="line">排序前的时间是=<span class="number">2020</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">17</span>:<span class="number">13</span>:<span class="number">28</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第 11 章 树结构实际应用【4、二叉排序树】</title>
    <url>/posts/ebd5ffcbc363/</url>
    <content><![CDATA[<h1 id="第-11-章-树结构实际应用【4、二叉排序树】"><a href="#第-11-章-树结构实际应用【4、二叉排序树】" class="headerlink" title="第 11 章 树结构实际应用【4、二叉排序树】"></a>第 11 章 树结构实际应用【4、二叉排序树】</h1><h2 id="4、二叉排序树"><a href="#4、二叉排序树" class="headerlink" title="4、二叉排序树"></a>4、二叉排序树</h2><h3 id="4-1、二叉排序树需求"><a href="#4-1、二叉排序树需求" class="headerlink" title="4.1、二叉排序树需求"></a>4.1、二叉排序树需求</h3><h4 id="4-1-1、需求分析"><a href="#4-1-1、需求分析" class="headerlink" title="4.1.1、需求分析"></a>4.1.1、需求分析</h4><ul>
<li>给你一个数列 { 7, 3, 10, 12, 5, 1, 9 } ，要求能够高效的完成对数据的查询和添加。</li>
</ul>
<h4 id="4-1-2、解决方案"><a href="#4-1-2、解决方案" class="headerlink" title="4.1.2、解决方案"></a>4.1.2、解决方案</h4><ol>
<li>使用数组<ul>
<li>数组未排序， 优点：直接在数组尾添加，速度快。 缺点：查找速度慢</li>
<li>数组排序，优点：可以使用二分查找，查找速度快，缺点：为了保证数组有序，在添加新数据时，找到插入位置后，后面的数据需整体移动，速度慢。</li>
</ul>
</li>
<li>使用链式存储-链表：不管链表是否有序，查找速度都慢，但添加数据速度比数组快，不需要数据整体移动。</li>
<li>使用二叉排序树</li>
</ol>
<h3 id="4-2、二叉排序树介绍"><a href="#4-2、二叉排序树介绍" class="headerlink" title="4.2、二叉排序树介绍"></a>4.2、二叉排序树介绍</h3><ul>
<li>二叉排序树：BST(Binary Sort(Search) Tree) ，对于二叉排序树的任何一个非叶子节点，<strong>要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大</strong>。</li>
<li>特别说明：如果有相同的值，可以将该节点放在左子节点或右子节点</li>
<li>二叉树的中序遍历为有序数列</li>
<li>比如针对前面的数据 (7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c801d6f55ca885602df874235d5d7246.png" alt="image-20200719203456275"></p>
<h3 id="4-3、二叉排序树思路分析"><a href="#4-3、二叉排序树思路分析" class="headerlink" title="4.3、二叉排序树思路分析"></a>4.3、二叉排序树思路分析</h3><h4 id="4-3-1、添加子节点"><a href="#4-3-1、添加子节点" class="headerlink" title="4.3.1、添加子节点"></a>4.3.1、添加子节点</h4><ul>
<li><p>假设待添加的节点为 node ，当前遍历的节点为 curNode，编码思路如下：</p>
<ul>
<li><p>待添加节点 node 的值与当前节点 curNode 的值比较</p>
<ul>
<li><code>node.value &lt; curNode.value</code>：需要将 node 节点安排在 curNode 节点的左边，左移当前节点指针：curNode = curNode.left ，为下次判断做准备</li>
<li><code>node.value &gt;= curNode.value</code>：需要将 node 节点安排在 curNode 节点的右边，右移当前节点指针：curNode = curNode.right ，为下次判断做准备</li>
<li>重复执行上述操作即可</li>
</ul>
</li>
<li><p>何时停止递归？以下两个条件均可以让递归停止</p>
<ul>
<li><p>待添加节点 node 的值比当前节点 curNode 的值小，并且 curNode 没有左节点</p>
<p><code>node.value &lt; curNode.value &amp;&amp; curNode.left ==null</code></p>
</li>
<li><p>待添加节点 node 的值比当前节点 curNode 的值大（或相等），并且 curNode 没有右节点</p>
<p><code>node.value &gt;= curNode.value &amp;&amp; curNode.right==null</code></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：<strong>新添加的节点都会沉到最下面去，成为一个叶子节点</strong></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5b01ad23f5da6b6e58600a437570734d.png" alt="image-20200719204006362"></p>
<h4 id="4-3-2、查找子节点"><a href="#4-3-2、查找子节点" class="headerlink" title="4.3.2、查找子节点"></a>4.3.2、查找子节点</h4><ul>
<li>查找目标子节点：假设目标节点的值为 value ，当前遍历的节点为 curNode ，编码思路如下<ul>
<li>目标值 value 与当前节点值 curNode.value 进行比较<ul>
<li><code>value == curNode.value</code>：证明当前节点就是要找的节点，直接返回 curNode</li>
<li><code>value &lt; curNode.value</code>：证明要找的节点在 curNode 左边，左移当前节点指针：<code>curNode = curNode.left</code> ，并继续执行上述比较操作</li>
<li><code>value &gt;= curNode.value</code>：证明要找的节点在 curNode 右边，右移当前节点指针：<code>curNode = curNode.right</code>，并继续执行上述比较操作</li>
</ul>
</li>
<li>何时停止递归？<ul>
<li>当前节点值与目标值相等：<code>curNode.value == value</code>，证明当前节点就是要找的节点，直接返回 curNode</li>
<li>或者当前节点为空：<code>curNode == null</code>，即证明没找到，返回 null</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>查找目标子节点的父节点（删除节点时需要查找目标节点的父节点）：假设目标节点的值为 value ，当前遍历的节点为 parentNode ，parentNode 表示目标节点的父节点，编码思路如下<ul>
<li>已找到目标节点的父节点：<ul>
<li>如果：<code>parentNode.left != null &amp;&amp; value = parentNode.left.value</code>，则说明<code>parent.left</code>为目标节点，<code>parent</code>为目标节点的父节点</li>
<li>如果：<code>parentNode.right != null &amp;&amp; value = parentNode.right.value</code>，则说明<code>parent.right</code>为目标节点，<code>parent</code>为目标节点的父节点</li>
</ul>
</li>
<li>还未找到目标节点的父节点，判断目标值 value 与当前节点值 parentNode.value 的大小<ul>
<li><code>value &lt; this.value &amp;&amp; this.left != null</code>：目标值在当前节点的左边，并且当前节点还有左节点，则将当前节点指针左移 <code>parentNode = parentNode.left</code><br>，继续寻找目标节点</li>
<li><code>value &gt;= this.value &amp;&amp; this.left != null</code>：目标值在当前节点的右边，并且当前节点还有右节点，则将当前节点指针右移 <code>parentNode = parentNode.right</code><br>，继续寻找目标节点</li>
</ul>
</li>
<li>何时停止递归？两个递归停止条件，满足其中一个即可<ul>
<li>value = parentNode.left.value || value = parentNode.right.value ：找到目标节点的父节点，则直接返回 parentNode</li>
<li>找不到目标节点的父节点：往左找找不到，往右找也找不到，</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-3-3、删除子节点"><a href="#4-3-3、删除子节点" class="headerlink" title="4.3.3、删除子节点"></a>4.3.3、删除子节点</h4><ul>
<li>再来一遍：<ul>
<li>单链表能不能实现自删除？不能！</li>
<li>单链表想要删除需要怎么操作？找到其父节点！！！</li>
</ul>
</li>
<li>假设目标节点的值为 value ，根节点为 root ，首先根据 value 值找到目标节点 targetNode ，再找到目标节点的父节点 parentNode<ul>
<li>如果 <code>targetNode == null</code>，说明没有找到目标节点，直接滚蛋</li>
<li>如果 <code>targetNode != null &amp;&amp; root.left == null &amp;&amp; root.right == null</code>，说明只有根节点既是目标节点，删除根节点即可</li>
<li>否则就是下面三种复杂的情况咯：</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>第一种情况：待删除的节点为叶子节点，直接删除该叶子节点即可<ul>
<li>怎么样才算是叶子节点？<code>targetNode.left == null &amp;&amp; targetNode.right == null</code>：左右节点都为空</li>
<li>怎么删除？<ul>
<li>如果 <code>parentNode.left != null &amp;&amp; parentNode.left.value == value</code>：即待删除的节点是 parentNode 的左子节点，则删除 parentNode<br>的左节点：<code>parentNode.left = null;</code></li>
<li>如果 <code>parentNode.right!= null &amp;&amp; parentNode.right.value == value</code>：即待删除的节点是 parentNode 的右子节点，则删除 parentNode<br>的右节点：<code>parentNode.right= null;</code></li>
</ul>
</li>
</ul>
</li>
<li>第二种情况：待删除的节点只有一颗子树，直接将其子树接在 parentNode 左边或右边即可<ul>
<li>怎么判断节点只有一颗子树？targetNode.left 和 targetNode.right 中有且仅有一个为 null</li>
<li>怎么删除？四种情况<ul>
<li>如果 targetNode 只有左子结点，则证明子树挂在 targetNode 的左边，现在来看看 target 挂在 parentNode 的哪边？<ul>
<li>如果 target 挂在 parentNode 的左边，直接将 target 的子树挂在 parentNode 的左边：<code>parentNode.left = target.left</code></li>
<li>如果 target 挂在 parentNode 的右边，直接将 target 的子树挂在 parentNode 的右边：<code>parentNode.right = target.left</code></li>
</ul>
</li>
<li>如果 targetNode 只有右子结点，则证明子树挂在 targetNode 的右边，现在来看看 target 挂在 parentNode 的哪边？<ul>
<li>如果 target 挂在 parentNode 的左边，直接将 target 的子树挂在 parentNode 的左边：<code>parentNode.left = target.right</code></li>
<li>如果 target 挂在 parentNode 的右边，直接将 target 的子树挂在 parentNode 的右边：<code>parentNode.right = target.right</code></li>
</ul>
</li>
</ul>
</li>
<li>以上逻辑有个 Bug ~~~ 当待删除的节点为根节点时 ， <code>parentNode == null</code>，这时候我们直接用根节点 root 来操作即可</li>
</ul>
</li>
<li>第三种情况：待删除的节点具有两棵颗子树<ul>
<li>从 targetNode 的左子树种找到值最大的节点（一直往右遍历），或者从从 targetNode 的右树种找到值最小的节点（一直往左遍历），假设最小值为 temp ，最小值所在的节点为 minNode</li>
<li>此时 minNode 肯定为叶子节点，删除 minNode 节点</li>
<li>将 <code>targetNode.value</code> 设置为 temp ，这样以 targetNode 根节点的子树又是一棵二叉排序树</li>
</ul>
</li>
</ul>
<h3 id="4-4、二叉排序树代码"><a href="#4-4、二叉排序树代码" class="headerlink" title="4.4、二叉排序树代码"></a>4.4、二叉排序树代码</h3><h4 id="4-4-1、树节点的定义"><a href="#4-4-1、树节点的定义" class="headerlink" title="4.4.1、树节点的定义"></a>4.4.1、树节点的定义</h4><ul>
<li>树节点的定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Node结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点的方法</span></span><br><span class="line">    <span class="comment">//递归的形式添加结点，注意需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断传入的结点的值，和当前子树的根结点的值关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//如果当前结点左子结点为null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向左子树添加</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//添加的结点的值大于 当前结点的值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向右子树添加</span></span><br><span class="line">                <span class="built_in">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到返回该结点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="built_in">this</span>.value) &#123; <span class="comment">//找到就是该结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value) &#123;<span class="comment">//如果查找的值小于当前结点，向左子树递归查找</span></span><br><span class="line">            <span class="comment">//如果左子结点为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果查找的值不小于当前结点，向右子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找要删除结点的父结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要找到的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是要删除的结点的父结点，如果没有就返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要删除的结点的父结点，就返回</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.value == value) ||</span><br><span class="line">                (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value); <span class="comment">//向左子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value); <span class="comment">//向右子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 没有找到父结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node [value=&quot;</span> + value + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-2、二叉排序树的定义"><a href="#4-4-2、二叉排序树的定义" class="headerlink" title="4.4.2、二叉排序树的定义"></a>4.4.2、二叉排序树的定义</h4><ul>
<li>二叉排序树的定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySortTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;<span class="comment">//如果root为空则直接让root指向node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找结点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父结点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写方法:</span></span><br><span class="line"><span class="comment">     * 1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     * 2. 删除node 为根结点的二叉排序树的最小结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delRightTreeMin</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">target</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span> (target.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除最小结点，这时 target就指向了最小结点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写方法:</span></span><br><span class="line"><span class="comment">     * 1. 返回的 以node 为根结点的二叉排序树的最大结点的值</span></span><br><span class="line"><span class="comment">     * 2. 删除node 为根结点的二叉排序树的最大结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最大结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delLeftTreeMMax</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">target</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span> (target.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            target = target.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除最大结点，这时 target就指向了最大的节点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除结点</span></span><br><span class="line"><span class="comment">     * 第一种情况:</span></span><br><span class="line"><span class="comment">     * 删除叶子节点(比如：2, 5, 9, 12)</span></span><br><span class="line"><span class="comment">     * 思路</span></span><br><span class="line"><span class="comment">     * (1) 需求先去找到要删除的结点targetNode</span></span><br><span class="line"><span class="comment">     * (2) 找到targetNode 的父结点parent</span></span><br><span class="line"><span class="comment">     * (3) 确定targetNode 是parent 的左子结点还是右子结点</span></span><br><span class="line"><span class="comment">     * (4) 根据前面的情况来对应删除</span></span><br><span class="line"><span class="comment">     * 左子结点parent.left = null</span></span><br><span class="line"><span class="comment">     * 右子结点parent.right = null;</span></span><br><span class="line"><span class="comment">     * 第二种情况: 删除只有一颗子树的节点比如1</span></span><br><span class="line"><span class="comment">     * 思路</span></span><br><span class="line"><span class="comment">     * (1) 需求先去找到要删除的结点targetNode</span></span><br><span class="line"><span class="comment">     * (2) 找到targetNode 的父结点parent</span></span><br><span class="line"><span class="comment">     * (3) 确定targetNode 的子结点是左子结点还是右子结点</span></span><br><span class="line"><span class="comment">     * (4) targetNode 是parent 的左子结点还是右子结点</span></span><br><span class="line"><span class="comment">     * (5) 如果targetNode 有左子结点</span></span><br><span class="line"><span class="comment">     * 5. 1 如果targetNode 是parent 的左子结点</span></span><br><span class="line"><span class="comment">     * parent.left = targetNode.left;</span></span><br><span class="line"><span class="comment">     * 5.2 如果targetNode 是parent 的右子结点</span></span><br><span class="line"><span class="comment">     * parent.right = targetNode.left;</span></span><br><span class="line"><span class="comment">     * (6) 如果targetNode 有右子结点</span></span><br><span class="line"><span class="comment">     * 6.1 如果targetNode 是parent 的左子结点</span></span><br><span class="line"><span class="comment">     * parent.left = targetNode.right;</span></span><br><span class="line"><span class="comment">     * 6.2 如果targetNode 是parent 的右子结点</span></span><br><span class="line"><span class="comment">     * parent.right = targetNode.right</span></span><br><span class="line"><span class="comment">     * 情况三： 删除有两颗子树的节点. (比如：7, 3，10 )</span></span><br><span class="line"><span class="comment">     * 思路</span></span><br><span class="line"><span class="comment">     * (1) 需求先去找到要删除的结点targetNode</span></span><br><span class="line"><span class="comment">     * (2) 找到targetNode 的父结点parent</span></span><br><span class="line"><span class="comment">     * (3) 从targetNode 的右子树找到最小的结点</span></span><br><span class="line"><span class="comment">     * (4) 用一个临时变量，将最小结点的值保存temp = 11</span></span><br><span class="line"><span class="comment">     * (5) 删除该最小结点</span></span><br><span class="line"><span class="comment">     * (6) targetNode.value = temp</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">targetNode</span> <span class="operator">=</span> search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点，也就是只有根节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的结点是叶子结点，也就是没有子节点了</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left == <span class="literal">null</span> &amp;&amp; targetNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="literal">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">                    parent.left = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="literal">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是由子结点</span></span><br><span class="line">                    parent.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="literal">null</span> &amp;&amp; targetNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 方法一 找右树中最小的</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">minVal</span> <span class="operator">=</span> delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value = minVal;</span><br><span class="line">                <span class="comment">// 方法二 找左树中最大的</span></span><br><span class="line"><span class="comment">//                int maxVal = delLeftTreeMin(targetNode.left);</span></span><br><span class="line"><span class="comment">//                targetNode.value = maxVal;</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除只有一颗子树的结点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            parent.left = targetNode.left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点</span></span><br><span class="line">                            parent.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果要删除的结点有右子结点</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            parent.left = targetNode.right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点</span></span><br><span class="line">                            parent.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉排序树为空，不能遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-3、代码测试"><a href="#4-4-3、代码测试" class="headerlink" title="4.4.3、代码测试"></a>4.4.3、代码测试</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="type">BinarySortTree</span> <span class="variable">binarySortTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySortTree</span>();</span><br><span class="line">    <span class="comment">//循环的添加结点到二叉排序树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        binarySortTree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(arr[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">    System.out.println(<span class="string">&quot;中序遍历二叉排序树~&quot;</span>);</span><br><span class="line">    binarySortTree.infixOrder(); <span class="comment">// 1, 3, 5, 7, 9, 10, 12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试一下删除叶子结点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    binarySortTree.delNode(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    binarySortTree.delNode(<span class="number">5</span>);</span><br><span class="line">    binarySortTree.delNode(<span class="number">10</span>);</span><br><span class="line">    binarySortTree.delNode(<span class="number">2</span>);</span><br><span class="line">    binarySortTree.delNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    binarySortTree.delNode(<span class="number">9</span>);</span><br><span class="line">    binarySortTree.delNode(<span class="number">1</span>);</span><br><span class="line">    binarySortTree.delNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;root=&quot;</span> + binarySortTree.getRoot());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;删除结点后&quot;</span>);</span><br><span class="line">    binarySortTree.infixOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">中序遍历二叉排序树~</span><br><span class="line">Node [value=<span class="number">1</span>]</span><br><span class="line">Node [value=<span class="number">2</span>]</span><br><span class="line">Node [value=<span class="number">3</span>]</span><br><span class="line">Node [value=<span class="number">5</span>]</span><br><span class="line">Node [value=<span class="number">7</span>]</span><br><span class="line">Node [value=<span class="number">9</span>]</span><br><span class="line">Node [value=<span class="number">10</span>]</span><br><span class="line">Node [value=<span class="number">12</span>]</span><br><span class="line">删除结点后</span><br><span class="line">Node [value=<span class="number">1</span>]</span><br><span class="line">Node [value=<span class="number">2</span>]</span><br><span class="line">Node [value=<span class="number">3</span>]</span><br><span class="line">Node [value=<span class="number">7</span>]</span><br><span class="line">Node [value=<span class="number">9</span>]</span><br><span class="line">Node [value=<span class="number">12</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-5、课后练习"><a href="#4-5、课后练习" class="headerlink" title="4.5、课后练习"></a>4.5、课后练习</h3><ul>
<li>如果我们从左子树找到最大的结点， 然后前面的思路完成.</li>
</ul>
<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.binarysorttree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉排序树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySortTreeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="type">BinarySortTree</span> <span class="variable">binarySortTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinarySortTree</span>();</span><br><span class="line">        <span class="comment">//循环的添加结点到二叉排序树</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j : arr) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> <span class="title class_">Node</span>(j));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历二叉排序树</span></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历二叉排序树~&quot;</span>);</span><br><span class="line">        binarySortTree.infixOrder(); <span class="comment">// 1, 3, 5, 7, 9, 10, 12</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一下删除叶子结点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        binarySortTree.delNode(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        binarySortTree.delNode(<span class="number">5</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">10</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">2</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        binarySortTree.delNode(<span class="number">9</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">1</span>);</span><br><span class="line">        binarySortTree.delNode(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;root=&quot;</span> + binarySortTree.getRoot());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;删除结点后&quot;</span>);</span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinarySortTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getRoot</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = node;<span class="comment">//如果root为空则直接让root指向node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找结点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找父结点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.searchParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写方法:</span></span><br><span class="line"><span class="comment">     * 1. 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     * 2. 删除node 为根结点的二叉排序树的最小结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delRightTreeMin</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">target</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span> (target.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除最小结点，这时 target就指向了最小结点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写方法:</span></span><br><span class="line"><span class="comment">     * 1. 返回的 以node 为根结点的二叉排序树的最大结点的值</span></span><br><span class="line"><span class="comment">     * 2. 删除node 为根结点的二叉排序树的最大结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点(当做二叉排序树的根结点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的 以node 为根结点的二叉排序树的最大结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">delLeftTreeMMax</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">target</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="comment">//循环的查找左子节点，就会找到最小值</span></span><br><span class="line">        <span class="keyword">while</span> (target.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            target = target.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除最大结点，这时 target就指向了最大的节点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除结点</span></span><br><span class="line"><span class="comment">     * 第一种情况:</span></span><br><span class="line"><span class="comment">     * 删除叶子节点(比如：2, 5, 9, 12)</span></span><br><span class="line"><span class="comment">     * 思路</span></span><br><span class="line"><span class="comment">     * (1) 需求先去找到要删除的结点targetNode</span></span><br><span class="line"><span class="comment">     * (2) 找到targetNode 的父结点parent</span></span><br><span class="line"><span class="comment">     * (3) 确定targetNode 是parent 的左子结点还是右子结点</span></span><br><span class="line"><span class="comment">     * (4) 根据前面的情况来对应删除</span></span><br><span class="line"><span class="comment">     * 左子结点parent.left = null</span></span><br><span class="line"><span class="comment">     * 右子结点parent.right = null;</span></span><br><span class="line"><span class="comment">     * 第二种情况: 删除只有一颗子树的节点比如1</span></span><br><span class="line"><span class="comment">     * 思路</span></span><br><span class="line"><span class="comment">     * (1) 需求先去找到要删除的结点targetNode</span></span><br><span class="line"><span class="comment">     * (2) 找到targetNode 的父结点parent</span></span><br><span class="line"><span class="comment">     * (3) 确定targetNode 的子结点是左子结点还是右子结点</span></span><br><span class="line"><span class="comment">     * (4) targetNode 是parent 的左子结点还是右子结点</span></span><br><span class="line"><span class="comment">     * (5) 如果targetNode 有左子结点</span></span><br><span class="line"><span class="comment">     * 5. 1 如果targetNode 是parent 的左子结点</span></span><br><span class="line"><span class="comment">     * parent.left = targetNode.left;</span></span><br><span class="line"><span class="comment">     * 5.2 如果targetNode 是parent 的右子结点</span></span><br><span class="line"><span class="comment">     * parent.right = targetNode.left;</span></span><br><span class="line"><span class="comment">     * (6) 如果targetNode 有右子结点</span></span><br><span class="line"><span class="comment">     * 6.1 如果targetNode 是parent 的左子结点</span></span><br><span class="line"><span class="comment">     * parent.left = targetNode.right;</span></span><br><span class="line"><span class="comment">     * 6.2 如果targetNode 是parent 的右子结点</span></span><br><span class="line"><span class="comment">     * parent.right = targetNode.right</span></span><br><span class="line"><span class="comment">     * 情况三： 删除有两颗子树的节点. (比如：7, 3，10 )</span></span><br><span class="line"><span class="comment">     * 思路</span></span><br><span class="line"><span class="comment">     * (1) 需求先去找到要删除的结点targetNode</span></span><br><span class="line"><span class="comment">     * (2) 找到targetNode 的父结点parent</span></span><br><span class="line"><span class="comment">     * (3) 从targetNode 的右子树找到最小的结点</span></span><br><span class="line"><span class="comment">     * (4) 用一个临时变量，将最小结点的值保存temp = 11</span></span><br><span class="line"><span class="comment">     * (5) 删除该最小结点</span></span><br><span class="line"><span class="comment">     * (6) targetNode.value = temp</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//1.需求先去找到要删除的结点  targetNode</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">targetNode</span> <span class="operator">=</span> search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点，也就是只有根节点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> searchParent(value);</span><br><span class="line">            <span class="comment">//如果要删除的结点是叶子结点，也就是没有子节点了</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode.left == <span class="literal">null</span> &amp;&amp; targetNode.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode 是父结点的左子结点，还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="literal">null</span> &amp;&amp; parent.left.value == value) &#123; <span class="comment">//是左子结点</span></span><br><span class="line">                    parent.left = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="literal">null</span> &amp;&amp; parent.right.value == value) &#123;<span class="comment">//是由子结点</span></span><br><span class="line">                    parent.right = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="literal">null</span> &amp;&amp; targetNode.right != <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 方法一 找右树中最小的</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">minVal</span> <span class="operator">=</span> delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value = minVal;</span><br><span class="line">                <span class="comment">// 方法二 找左树中最大的</span></span><br><span class="line"><span class="comment">//                int maxVal = delLeftTreeMin(targetNode.left);</span></span><br><span class="line"><span class="comment">//                targetNode.value = maxVal;</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 删除只有一颗子树的结点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            parent.left = targetNode.left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//  targetNode 是 parent 的右子结点</span></span><br><span class="line">                            parent.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果要删除的结点有右子结点</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果 targetNode 是 parent 的左子结点</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            parent.left = targetNode.right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果 targetNode 是 parent 的右子结点</span></span><br><span class="line">                            parent.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉排序树为空，不能遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加结点的方法</span></span><br><span class="line">    <span class="comment">//递归的形式添加结点，注意需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断传入的结点的值，和当前子树的根结点的值关系</span></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="built_in">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//如果当前结点左子结点为null</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向左子树添加</span></span><br><span class="line">                <span class="built_in">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//添加的结点的值大于 当前结点的值</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归的向右子树添加</span></span><br><span class="line">                <span class="built_in">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到返回该结点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="built_in">this</span>.value) &#123; <span class="comment">//找到就是该结点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value) &#123;<span class="comment">//如果查找的值小于当前结点，向左子树递归查找</span></span><br><span class="line">            <span class="comment">//如果左子结点为空</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果查找的值不小于当前结点，向右子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找要删除结点的父结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要找到的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是要删除的结点的父结点，如果没有就返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">searchParent</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要删除的结点的父结点，就返回</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.value == value) ||</span><br><span class="line">                (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点的值, 并且当前结点的左子结点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.left.searchParent(value); <span class="comment">//向左子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="built_in">this</span>.value &amp;&amp; <span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.right.searchParent(value); <span class="comment">//向右子树递归查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 没有找到父结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node [value=&quot;</span> + value + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>第 3 章：稀疏数组和队列</title>
    <url>/posts/7eb995c6defb/</url>
    <content><![CDATA[<h1 id="第-3-章：稀疏数组和队列"><a href="#第-3-章：稀疏数组和队列" class="headerlink" title="第 3 章：稀疏数组和队列"></a>第 3 章：稀疏数组和队列</h1><h2 id="1、稀疏数组"><a href="#1、稀疏数组" class="headerlink" title="1、稀疏数组"></a>1、稀疏数组</h2><h3 id="1-1、实际需求"><a href="#1-1、实际需求" class="headerlink" title="1.1、实际需求"></a>1.1、实际需求</h3><ul>
<li><p>编写的五子棋程序中，有存盘退出和续上盘的功能</p>
</li>
<li><p>因为该二维数组的很多值是默认值 0 ，因此<strong>记录了很多没有意义的数据</strong>，我们将其转为<strong>稀疏数组</strong>进行存储</p>
<p>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325150031.png" alt="image-20210218211723750"></p>
</li>
</ul>
<h3 id="1-2、稀疏数组应用"><a href="#1-2、稀疏数组应用" class="headerlink" title="1.2、稀疏数组应用"></a>1.2、稀疏数组应用</h3><h4 id="1-2-1、稀疏数组处理方法"><a href="#1-2-1、稀疏数组处理方法" class="headerlink" title="1.2.1、稀疏数组处理方法"></a>1.2.1、稀疏数组处理方法</h4><ul>
<li><p>稀疏数组把具有不同值的元素的<strong>行列</strong>及值记录在一个小规模的数组中，从而缩小程序的规模</p>
</li>
<li><p>稀疏数组也是二维数组，行数由原数组的数据决定，列数一般为 3 列</p>
</li>
<li><p>稀疏数组的</p>
<p>第一行</p>
<p>记录原数组一共有几行几列，有多少个不为零的值</p>
<ul>
<li>第一列：原数组的行数</li>
<li>第二列：原数组的列数</li>
<li>第三列：原数组有多少个不为零的值</li>
</ul>
</li>
<li><p>之后的行记录原数组中</p>
<p>不为零（x）的值</p>
<p>所在的行数、列数以及 x 的值</p>
<ul>
<li>第一列：x 在原数组中的行数</li>
<li>第二列：x 在原数组中的列数</li>
<li>第三列：x 的值</li>
</ul>
</li>
</ul>
<h4 id="1-2-2、举例说明"><a href="#1-2-2、举例说明" class="headerlink" title="1.2.2、举例说明"></a>1.2.2、举例说明</h4><ul>
<li>原始二维数组较大，压缩后占用空间减少</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325150037.png" alt="image-20210218211803938"></p>
<h3 id="1-3、应用实例"><a href="#1-3、应用实例" class="headerlink" title="1.3、应用实例"></a>1.3、应用实例</h3><h4 id="1-3-1、思路分析"><a href="#1-3-1、思路分析" class="headerlink" title="1.3.1、思路分析"></a>1.3.1、思路分析</h4><ul>
<li>使用稀疏数组， 来保留类似前面的二维数组(棋盘、 地图等等)</li>
<li>把稀疏数组存盘， 并且可以从新恢复原来的二维数组数</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325150041.png" alt="image-20210218211821238"></p>
<h4 id="1-3-2、代码实现"><a href="#1-3-2、代码实现" class="headerlink" title="1.3.2、代码实现"></a>1.3.2、代码实现</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SparseArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个原始的二维数组 11 * 11</span></span><br><span class="line">        <span class="comment">// 0: 表示没有棋子， 1 表示 黑子 2 表蓝子</span></span><br><span class="line">        <span class="type">int</span> chessArr1[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chessArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chessArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        chessArr1[<span class="number">4</span>][<span class="number">5</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 输出原始的二维数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原始的二维数组~~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将二维数组 转 稀疏数组的思</span></span><br><span class="line">        <span class="comment">// 1. 先遍历二维数组 得到非0数据的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessArr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessArr1[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建对应的稀疏数组</span></span><br><span class="line">        <span class="type">int</span> sparseArr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 给稀疏数组赋值</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = chessArr1.length;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = chessArr1[<span class="number">0</span>].length;</span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历二维数组，将非0的值存放到 sparseArr中</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// count 用于记录是第几个非0数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chessArr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; chessArr1[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chessArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chessArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出稀疏数组的形式</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;得到稀疏数组为~~~~&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\t%d\t%d\n&quot;</span>, sparseArr[i][<span class="number">0</span>], sparseArr[i][<span class="number">1</span>], sparseArr[i][<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将稀疏数组 --》 恢复成 原始的二维数组</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 chessArr2 = int [11][11] 2.</span></span><br><span class="line"><span class="comment">         * 在读取稀疏数组后几行的数据，并赋给 原始的二维数组 即可.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> chessArr2[][] = <span class="keyword">new</span> <span class="title class_">int</span>[sparseArr[<span class="number">0</span>][<span class="number">0</span>]][sparseArr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 在读取稀疏数组后几行的数据(从第二行开始)，并赋给 原始的二维数组 即可</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            chessArr2[sparseArr[i][<span class="number">0</span>]][sparseArr[i][<span class="number">1</span>]] = sparseArr[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出恢复后的二维数组</span></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的二维数组&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : chessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> data : row) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, data);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始的二维数组~~</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	1	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	2	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	2	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line"></span><br><span class="line">得到稀疏数组为~~~~</span><br><span class="line">11	11	3</span><br><span class="line">1	2	1</span><br><span class="line">2	3	2</span><br><span class="line">4	5	2</span><br><span class="line"></span><br><span class="line">恢复后的二维数组</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	1	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	2	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	2	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br><span class="line">0	0	0	0	0	0	0	0	0	0	0	</span><br></pre></td></tr></table></figure>

<h3 id="1-4、课后练习"><a href="#1-4、课后练习" class="headerlink" title="1.4、课后练习"></a>1.4、课后练习</h3><ul>
<li>在前面的基础上， 将稀疏数组保存到磁盘上， 比如 map.data</li>
<li>恢复原来的数组时， 读取 map.data 进行恢复</li>
</ul>
<h2 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h2><h3 id="2-1、队列使用场景"><a href="#2-1、队列使用场景" class="headerlink" title="2.1、队列使用场景"></a>2.1、队列使用场景</h3><ul>
<li>银行排队的案例：</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325150049.png" alt="image-20210218211843387"></p>
<h3 id="2-2、队列介绍"><a href="#2-2、队列介绍" class="headerlink" title="2.2、队列介绍"></a>2.2、队列介绍</h3><ul>
<li>队列是一个有序列表， 可以用数组或是链表来实现。</li>
<li>遵循<strong>先入先出</strong>的原则， 即： 先存入队列的数据， 要先取出，后存入的要后取出</li>
<li>示意图： (使用数组模拟队列示意图)</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325150051.png" alt="image-20210218211855151"></p>
<h3 id="2-3、数组模拟队列"><a href="#2-3、数组模拟队列" class="headerlink" title="2.3、数组模拟队列"></a>2.3、数组模拟队列</h3><h4 id="2-3-1、思路分析"><a href="#2-3-1、思路分析" class="headerlink" title="2.3.1、思路分析"></a>2.3.1、思路分析</h4><ul>
<li>maxSize ：队列容量（数组的长度）</li>
<li>arr ：模拟队列的数组</li>
<li>front ：指向队列头部元素的前一个元素，初始值为 -1</li>
<li>rear ：指向队列尾部元素，初始值为 -1</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325150054.png" alt="image-20210218211908644"></p>
<ul>
<li>基本操作<ul>
<li>队列判空：<strong>front == rear</strong></li>
<li>队列判满：<strong>rear == (maxSize - 1)</strong> ，即 rear 是否已经指向了数组的最后一个位置</li>
<li>队列元素个数：rear - front</li>
<li>队列入队：队列不满才能入队，arr[++rear] = value</li>
<li>队列出队：队列不空才能出队，return arr[front++]</li>
</ul>
</li>
</ul>
<h4 id="2-3-2、代码实现"><a href="#2-3-2、代码实现" class="headerlink" title="2.3.2、代码实现"></a>2.3.2、代码实现</h4><ul>
<li>队列的定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用数组模拟队列-编写一个ArrayQueue类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front; <span class="comment">// 队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建队列的构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> arrMaxSize)</span> &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        front = -<span class="number">1</span>; <span class="comment">// 指向队列头部，分析出front是指向队列头的前一个位置.</span></span><br><span class="line">        rear = -<span class="number">1</span>; <span class="comment">// 指向队列尾，指向队列尾的数据(即就是队列最后一个数据)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加数据到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满，不能加入数据~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rear++; <span class="comment">// 让 rear 后移</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的数据, 出队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 通过抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        front++; <span class="comment">// front后移</span></span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列的所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列空的，没有数据~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front + <span class="number">1</span>; i &lt;= rear; i++) &#123;</span><br><span class="line">            <span class="comment">// Java 中也能用占位符诶</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空的，没有数据~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试一把</span></span><br><span class="line">        <span class="comment">// 创建一个队列</span></span><br><span class="line">        <span class="type">ArrayQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayQueue</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>; <span class="comment">// 接收用户输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show): 显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit): 退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add): 添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get): 从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head): 查看队列头的数据&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">// 接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输出一个数&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>: <span class="comment">// 取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> queue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="comment">// 查看队列头的数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> queue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: <span class="comment">// 退出</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">s</span><br><span class="line">队列空的，没有数据~~</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">输出一个数</span><br><span class="line">1</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">输出一个数</span><br><span class="line">2</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">输出一个数</span><br><span class="line">3</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">s</span><br><span class="line">arr[0]=1</span><br><span class="line">arr[1]=2</span><br><span class="line">arr[2]=3</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">输出一个数</span><br><span class="line">4</span><br><span class="line">队列满，不能加入数据~</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">g</span><br><span class="line">取出的数据是1</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">g</span><br><span class="line">取出的数据是2</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">g</span><br><span class="line">取出的数据是3</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">g</span><br><span class="line">队列空，不能取数据</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-4、数组模型环形队列"><a href="#2-4、数组模型环形队列" class="headerlink" title="2.4、数组模型环形队列"></a>2.4、数组模型环形队列</h3><h4 id="2-4-1、提出问题"><a href="#2-4-1、提出问题" class="headerlink" title="2.4.1、提出问题"></a>2.4.1、提出问题</h4><ul>
<li>目前数组<strong>使用一次就不能用</strong>， 没有达到复用的效果，造成<strong>内存空间的浪费</strong></li>
<li>将这个数组使用算法， 改进成一个<strong>环形</strong>的队列（**取模： %**）</li>
</ul>
<h4 id="2-4-2、思路分析"><a href="#2-4-2、思路分析" class="headerlink" title="2.4.2、思路分析"></a>2.4.2、思路分析</h4><ul>
<li>对前面的队列进行优化，改造为环形队列（通过<strong>取模</strong>实现）</li>
<li>maxSize ：队列容量（数组的长度）</li>
<li>arr ：模拟队列的数组</li>
<li>front ：指向队列头部元素，初始值为 0</li>
<li>rear ：指向队列尾部元素的后一个元素，初始值为 0</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325150103.png" alt="image-20210218211922788"></p>
<ul>
<li>基本操作<ul>
<li>队列判空：<strong>front == rear</strong></li>
<li>队列判满：<ul>
<li>为何要在 rear 之后，front 之前空出一个元素的空间？因为如果不空出一个元素，队列判空条件为：front == rear ，队列判满的条件也是：front == rear ，<strong>有歧义</strong>！</li>
<li>队列容量：因为空出了一个元素，所以队列容量就变成了 (maxSize - 1)</li>
<li>当空出一个元素的空间，如何判满？当还剩一个元素时，队列就已经满了，所以判断条件为 <strong>(rear + 1) % maxSize == front</strong></li>
</ul>
</li>
<li>队列元数个数：<ul>
<li>计算公式：**(rear + maxSize - front) % maxSize** ，这样来思考：</li>
<li>当 rear 比 front 大时，即 (rear -front) &gt; 0 ，这时还没有形成环形结构，**(rear -front)** 即是队列元素个数</li>
<li>当 rear 比 front 小时，即 (rear -front) &lt; 0 ，这时已经形成了环形结构，**(rear -front)** 表示数组还差多少个元素存满（负数），**(rear + maxSize -<br>front)** 即是队列元素个数</li>
<li>综上：**(rear + maxSize - front) % maxSize**</li>
</ul>
</li>
<li>队列入队：<ul>
<li>首先，队列不满才能入队</li>
<li>由于 rear 指向<strong>队列尾部元素的后一个元素</strong>，所以直接设置即可： arr[rear] = value</li>
<li>接下来，rear 应该向后移动一个位置：<strong>rear = (rear + 1) % maxSize</strong></li>
<li>取模是为了<strong>防止数组越界，让指针从新回到数组第一个元素</strong></li>
</ul>
</li>
<li>队列出队：<ul>
<li>首先，队列不空才能出队</li>
<li>由于 front 直接指向队列头部元素，所以直接返回该元素即可：int value = arr[front ]</li>
<li>接下来，front 应该向后移动一个位置：<strong>front = (front + 1) % maxSize</strong></li>
<li>取模是为了<strong>防止数组越界，让指针从新回到数组第一个元素</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-4-3、代码实现"><a href="#2-4-3、代码实现" class="headerlink" title="2.4.3、代码实现"></a>2.4.3、代码实现</h4><ul>
<li>环形队列的实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CircleArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxSize; <span class="comment">// 表示数组的最大容量</span></span><br><span class="line">    <span class="comment">// front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素</span></span><br><span class="line">    <span class="comment">// front 的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="comment">// rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.</span></span><br><span class="line">    <span class="comment">// rear 的初始值 = 0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rear; <span class="comment">// 队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr; <span class="comment">// 该数据用于存放数据, 模拟队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircleArray</span><span class="params">(<span class="type">int</span> arrMaxSize)</span> &#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加数据到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addQueue</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否满</span></span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满，不能加入数据~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接将数据加入</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        <span class="comment">// 将 rear 后移, 这里必须考虑取模</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的数据, 出队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 通过抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空，不能取数据&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里需要分析出 front是指向队列的第一个元素</span></span><br><span class="line">        <span class="comment">// 1. 先把 front 对应的值保留到一个临时变量</span></span><br><span class="line">        <span class="comment">// 2. 将 front 后移, 考虑取模</span></span><br><span class="line">        <span class="comment">// 3. 将临时保存的变量返回</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列的所有数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列空的，没有数据~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 思路：从front开始遍历，遍历多少个元素</span></span><br><span class="line">        <span class="comment">// 动脑筋</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> front; i &lt; front + size(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>, i % maxSize, arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出当前队列有效数据的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// rear = 2</span></span><br><span class="line">        <span class="comment">// front = 1</span></span><br><span class="line">        <span class="comment">// maxSize = 3</span></span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示队列的头数据， 注意不是取出数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">headQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列空的，没有数据~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircleArrayQueueDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试一把</span></span><br><span class="line">        System.out.println(<span class="string">&quot;测试数组模拟环形队列的案例~~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个环形队列</span></span><br><span class="line">        <span class="type">CircleArray</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleArray</span>(<span class="number">4</span>); <span class="comment">// 说明设置4, 其队列的有效数据最大是3</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>; <span class="comment">// 接收用户输入</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);<span class="comment">//</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 输出一个菜单</span></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s(show): 显示队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;e(exit): 退出程序&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;a(add): 添加数据到队列&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;g(get): 从队列取出数据&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;h(head): 查看队列头的数据&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);<span class="comment">// 接收一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输出一个数&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>: <span class="comment">// 取出数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> queue.getQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;取出的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="comment">// 查看队列头的数据</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> queue.headQueue();</span><br><span class="line">                        System.out.printf(<span class="string">&quot;队列头的数据是%d\n&quot;</span>, res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>: <span class="comment">// 退出</span></span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;程序退出~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">测试数组模拟环形队列的案例~~~</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">输出一个数</span><br><span class="line">1</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">输出一个数</span><br><span class="line">2</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">输出一个数</span><br><span class="line">3</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">s</span><br><span class="line">arr[0]=1</span><br><span class="line">arr[1]=2</span><br><span class="line">arr[2]=3</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">a</span><br><span class="line">输出一个数</span><br><span class="line">4</span><br><span class="line">队列满，不能加入数据~</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">g</span><br><span class="line">取出的数据是1</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">g</span><br><span class="line">取出的数据是2</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">s</span><br><span class="line">arr[2]=3</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">g</span><br><span class="line">取出的数据是3</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br><span class="line"></span><br><span class="line">g</span><br><span class="line">队列空，不能取数据</span><br><span class="line">s(show): 显示队列</span><br><span class="line">e(exit): 退出程序</span><br><span class="line">a(add): 添加数据到队列</span><br><span class="line">g(get): 从队列取出数据</span><br><span class="line">h(head): 查看队列头的数据</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第 6 章 递归</title>
    <url>/posts/ff721586239b/</url>
    <content><![CDATA[<h1 id="第-6-章-递归"><a href="#第-6-章-递归" class="headerlink" title="第 6 章 递归"></a>第 6 章 递归</h1><h2 id="1、递归介绍"><a href="#1、递归介绍" class="headerlink" title="1、递归介绍"></a>1、递归介绍</h2><h3 id="1-1、递归应用场景"><a href="#1-1、递归应用场景" class="headerlink" title="1.1、递归应用场景"></a>1.1、递归应用场景</h3><ul>
<li>看个实际应用场景， 迷宫问题(回溯)， 递归(Recursion)</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MTkzNTI3OTEwLnBuZw?x-oss-process=image/format,png" alt="image-20200714193527910"></p>
<h3 id="1-2、递归的概念"><a href="#1-2、递归的概念" class="headerlink" title="1.2、递归的概念"></a>1.2、递归的概念</h3><ul>
<li>简单的说: 递归就是方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。</li>
</ul>
<h3 id="1-3、递归调用机制"><a href="#1-3、递归调用机制" class="headerlink" title="1.3、递归调用机制"></a>1.3、递归调用机制</h3><ul>
<li>打印问题</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTY0NTQ2NTI3LnBuZw?x-oss-process=image/format,png" alt="image-20200806164546527"></p>
<ul>
<li>阶乘问题</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阶乘问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> factorial(n-<span class="number">1</span>)*n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4、递归能解决什么问题"><a href="#1-4、递归能解决什么问题" class="headerlink" title="1.4、递归能解决什么问题"></a>1.4、递归能解决什么问题</h3><ul>
<li>各种数学问题如: <strong>8 皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题</strong>(google 编程大赛)</li>
<li>各种算法中也会使用到递归， 比如<strong>快排， 归并排序， 二分查找， 分治算法</strong>等.</li>
<li>将用栈解决的问题 –&gt; 递归代码比较简洁</li>
</ul>
<h3 id="1-5、递归需遵循的规则"><a href="#1-5、递归需遵循的规则" class="headerlink" title="1.5、递归需遵循的规则"></a>1.5、递归需遵循的规则</h3><ul>
<li>执行一个方法时， 就创建一个新的受保护的独立空间(一个线程有自己独立的一个栈空间，每个方法调用对应着一个栈帧)</li>
<li><strong>方法的局部变量是独立的， 不会相互影响, 比如 n 变量</strong></li>
<li><strong>如果方法中使用的是引用类型变量(比如数组)， 就会共享该引用类型的数据</strong></li>
<li><strong>递归必须向退出递归的条件逼近， 否则就是无限递归</strong>，出现 StackOverflowError， 死龟了 😃</li>
<li>当一个方法执行完毕，或者遇到return，就会返回，<strong>遵守谁调用，就将结果返回给谁</strong>，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ul>
<h2 id="2、递归-迷宫问题"><a href="#2、递归-迷宫问题" class="headerlink" title="2、递归-迷宫问题"></a>2、递归-迷宫问题</h2><h3 id="2-1、代码思路"><a href="#2-1、代码思路" class="headerlink" title="2.1、代码思路"></a>2.1、代码思路</h3><ul>
<li>使用二维数组 <code>map[][]</code> 模拟迷宫</li>
<li>约定： 当 <code>map[i][j]</code> 为 <strong>0 表示该点没有走过；当为 1 表示墙；2 表示通路可以走 ；3 表示该点已经走过，但是走不通</strong></li>
<li><strong>setWay() 方法用于找路，true 表示该路可以走通，false 表示该路走不通</strong></li>
<li><strong>在走迷宫时，需要确定一个策略(方法)</strong> 下-&gt;右-&gt;上-&gt;左 , 一步一步向前试探，如果该点走不通，再回溯</li>
<li>每当走到一个点时，将该点置为 2 ，暂时假设该路能走通，至于到底走不走得通，得看后面有没有找到通路<ul>
<li><strong>如果后面的路能走通，从最后一个点开始返回，整个 setWay() 递归调用链都返回 true</strong></li>
<li><strong>如果后面的路不能走通，那么将当前的点设置为 3 ，表示是死路，走不通，回溯至上一个点，看看其他方向能不能走通</strong></li>
</ul>
</li>
</ul>
<h3 id="2-2、代码实现"><a href="#2-2、代码实现" class="headerlink" title="2.2、代码实现"></a>2.2、代码实现</h3><ul>
<li>迷宫问题递归解法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> //使用递归回溯来给小球找路</span></span><br><span class="line"><span class="comment"> //说明</span></span><br><span class="line"><span class="comment"> //1. map 表示地图</span></span><br><span class="line"><span class="comment"> //2. i,j 表示从地图的哪个位置开始出发 (1,1)</span></span><br><span class="line"><span class="comment"> //3. 如果小球能到 map[6][5] 位置，则说明通路找到.</span></span><br><span class="line"><span class="comment"> //4. 约定： 当map[i][j] 为 0 表示该点没有走过 当为 1 表示墙  ； 2 表示通路可以走 ； 3 表示该点已经走过，但是走不通</span></span><br><span class="line"><span class="comment"> //5. 在走迷宫时，需要确定一个策略(方法) 下-&gt;右-&gt;上-&gt;左 , 如果该点走不通，再回溯</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map 表示地图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i   从哪个位置开始找</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到通路，就返回true, 否则返回false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">setWay</span><span class="params">(<span class="type">int</span>[][]map,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map[<span class="number">6</span>][<span class="number">5</span>]==<span class="number">2</span>)&#123; <span class="comment">// 通路已经找到ok</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[i][j]==<span class="number">0</span>)&#123; <span class="comment">//如果当前这个点还没有走过</span></span><br><span class="line">            <span class="comment">//按照策略 下-&gt;右-&gt;上-&gt;左  走</span></span><br><span class="line">            map[i][j]=<span class="number">2</span>; <span class="comment">// 假定该点是可以走通.</span></span><br><span class="line">            <span class="keyword">if</span>(setWay(map,i+<span class="number">1</span>,j))&#123;<span class="comment">//向下走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j+<span class="number">1</span>))&#123; <span class="comment">//向右走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i-<span class="number">1</span>,j))&#123; <span class="comment">//向上</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(setWay(map,i,j-<span class="number">1</span>))&#123; <span class="comment">// 向左走</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//说明该点是走不通，是死路</span></span><br><span class="line">                map[i][j]=<span class="number">3</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 如果map[i][j] != 0 , 可能是 1， 2， 3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="comment">// 先创建一个二维数组，模拟迷宫</span></span><br><span class="line">    <span class="comment">// 地图</span></span><br><span class="line">    <span class="type">int</span>[][]arr=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">    <span class="comment">// 使用1 表示墙</span></span><br><span class="line">    <span class="comment">// 上下全部置为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; <span class="number">7</span>;i++)&#123;</span><br><span class="line">        arr[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        arr[<span class="number">7</span>][i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右全部置为1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">        arr[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        arr[i][<span class="number">6</span>]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置挡板, 1 表示</span></span><br><span class="line">    arr[<span class="number">3</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//arr[1][2] = 1;</span></span><br><span class="line">    <span class="comment">//arr[2][2] = 1;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出地图</span></span><br><span class="line">    System.out.println(<span class="string">&quot;地图的情况&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt; <span class="number">7</span>;j++)&#123;</span><br><span class="line">            System.out.print(arr[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用递归回溯给小球找路</span></span><br><span class="line">    setWay(map,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//setWay2(arr, 1, 1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出新的地图, 小球走过，并标识过的递归</span></span><br><span class="line">    System.out.println(<span class="string">&quot;小球走过，并标识过的 地图的情况&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt; <span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt; <span class="number">7</span>;j++)&#123;</span><br><span class="line">            System.out.print(arr[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">地图的情况</span><br><span class="line">1 1 1 1 1 1 1 </span><br><span class="line">1 0 0 0 0 0 1 </span><br><span class="line">1 0 0 0 0 0 1 </span><br><span class="line">1 1 1 0 0 0 1 </span><br><span class="line">1 0 0 0 1 0 1 </span><br><span class="line">1 0 0 0 1 0 1 </span><br><span class="line">1 0 0 0 1 0 1 </span><br><span class="line">1 1 1 1 1 1 1 </span><br><span class="line">小球走过，并标识过的 地图的情况</span><br><span class="line">1 1 1 1 1 1 1 </span><br><span class="line">1 2 0 0 0 0 1 </span><br><span class="line">1 2 2 2 0 0 1 </span><br><span class="line">1 1 1 2 2 2 1 </span><br><span class="line">1 3 3 3 1 2 1 </span><br><span class="line">1 3 3 3 1 2 1 </span><br><span class="line">1 3 3 3 1 2 1 </span><br><span class="line">1 1 1 1 1 1 1 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>搞不清逻辑的话，可以自己玩一玩</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">地图的情况</span><br><span class="line">1 1 1 1 1 1 1 </span><br><span class="line">1 0 0 0 0 0 1 </span><br><span class="line">1 0 0 0 0 0 1 </span><br><span class="line">1 1 1 0 0 0 1 </span><br><span class="line">1 0 0 0 1 0 1 </span><br><span class="line">1 0 0 0 1 0 1 </span><br><span class="line">1 0 0 0 1 0 1 </span><br><span class="line">1 1 1 1 1 1 1 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>程序执行逻辑分析</p>
<ul>
<li>第一阶段：按照 下-&gt;右-&gt;上-&gt;左 的策略，走入了死胡同</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjAzNTA2NjExLnBuZw?x-oss-process=image/format,png" alt="image-20200714203506611"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjA0ODUxNzAyLnBuZw?x-oss-process=image/format,png" alt="image-20200714204851702"></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1 1 1 1 1 1 1 </span><br><span class="line">1 2 0 0 0 0 1 </span><br><span class="line">1 2 2 2 0 0 1 </span><br><span class="line">1 1 1 2 0 0 1 </span><br><span class="line">1 2 2 2 1 0 1 </span><br><span class="line">1 2 2 2 1 0 1 </span><br><span class="line">1 2 2 2 1 0 1 </span><br><span class="line">1 1 1 1 1 1 1 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>第二阶段：开始回溯，标记此路不通</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjAzNDM2Mjk2LnBuZw?x-oss-process=image/format,png" alt="image-20200714203436296"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjA0OTQwNjU5LnBuZw?x-oss-process=image/format,png" alt="image-20200714204940659"></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1 1 1 1 1 1 1 </span><br><span class="line">1 2 0 0 0 0 1 </span><br><span class="line">1 2 2 2 0 0 1 </span><br><span class="line">1 1 1 2 0 0 1 </span><br><span class="line">1 3 3 3 1 0 1 </span><br><span class="line">1 3 3 3 1 0 1 </span><br><span class="line">1 3 3 3 1 0 1 </span><br><span class="line">1 1 1 1 1 1 1 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>寻找到了通往天堂的路径</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjAzNjIwMDM1LnBuZw?x-oss-process=image/format,png" alt="image-20200714203620035"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjA1MDA3MjM1LnBuZw?x-oss-process=image/format,png" alt="image-20200714205007235"></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1 1 1 1 1 1 1 </span><br><span class="line">1 2 0 0 0 0 1 </span><br><span class="line">1 2 2 2 0 0 1 </span><br><span class="line">1 1 1 2 2 2 1 </span><br><span class="line">1 3 3 3 1 2 1 </span><br><span class="line">1 3 3 3 1 2 1 </span><br><span class="line">1 3 3 3 1 2 1 </span><br><span class="line">1 1 1 1 1 1 1 </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3、思考题"><a href="#2-3、思考题" class="headerlink" title="2.3、思考题"></a>2.3、思考题</h3><ul>
<li>求出最短路径（枚举可能的找路策略）</li>
</ul>
<h3 id="2-4、总结"><a href="#2-4、总结" class="headerlink" title="2.4、总结"></a>2.4、总结</h3><ul>
<li>刚开始我还觉得很难理解，想了想，这和递归遍历文件夹不也是有相同之处的吗？</li>
<li>如果不进入文件夹看看，我就永远不知道这个文件夹里面是否还有子文件和子文件夹，我们需要遍历到一个文件夹的最深处，然后触底反弹</li>
<li>如果我没有到达终点，这条路到底通不通，我并不知道，所以我先试探性地走到终点，然后从终点往前回溯？</li>
<li>死路咋办？我也是先试探性地往前走，走不通，我回溯到之前的点，再尝试新的走法</li>
</ul>
<h2 id="3、递归-八皇后问题-回溯算法"><a href="#3、递归-八皇后问题-回溯算法" class="headerlink" title="3、递归-八皇后问题(回溯算法 )"></a>3、递归-八皇后问题(回溯算法 )</h2><h3 id="3-1、八皇后问题介绍"><a href="#3-1、八皇后问题介绍" class="headerlink" title="3.1、八皇后问题介绍"></a>3.1、八皇后问题介绍</h3><ul>
<li>八皇后问题， 是一个古老而著名的问题， 是回溯算法的典型案例。 该问题是国际西洋棋棋手马克斯· 贝瑟尔于1848 年提出： 在 8× 8 格的国际象棋上摆放八个皇后， 使其不能互相攻击， 即：<br>任意两个皇后都不能处于同一行、同一列或同一斜线上， 问有多少种摆法(92)。</li>
</ul>
<p><img src="https://gitee.com/lixiaogou/pictures/raw/master/typora/20211106113940.png" alt="image-20211106113936329"></p>
<h3 id="3-2、代码思路"><a href="#3-2、代码思路" class="headerlink" title="3.2、代码思路"></a>3.2、代码思路</h3><ul>
<li>第一个皇后先放第一行第一列</li>
<li>第二个皇后放在第二行第一列、 然后判断是否 OK， 如果不 OK， 继续放在第二列、 第三列、 依次把所有列都放完， 找到一个合适</li>
<li>继续第三个皇后， 还是第一列、 第二列…… ，直到第 8 个皇后也能放在一个不冲突的位置， 算是找到了一个正确解</li>
<li>当得到一个正确解时， 在栈回退到上一个栈时， 就会开始回溯， 即将第一个皇后， 放到第一列的所有正确解，全部得到</li>
<li>然后回头继续第一个皇后放第二列， 后面继续循环执行 1, 2, 3, 4 的步骤</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTY1NzU3NjE4LnBuZw?x-oss-process=image/format,png" alt="image-20200806165757618"></p>
<h3 id="3-3、代码实现"><a href="#3-3、代码实现" class="headerlink" title="3.3、代码实现"></a>3.3、代码实现</h3><ul>
<li>关于 array 数组的说明：<ul>
<li>理论上应该创建一个二维数组来表示棋盘， 但是实际上可以通过算法， 用一个一维数组即可解决问题： array[8] = {0 , 4, 7, 5, 2, 6, 1, 3}</li>
<li><strong>array 数组的下标代表皇后所在的行数，array 数组中的值代表皇后所在的列数</strong></li>
<li>比如 a[0] = 0 ，则表示第一个皇后在第一行第一列</li>
</ul>
</li>
<li>judge(int n) 方法：<ul>
<li>参数 n ：表示当前在放置第 n 个皇后</li>
<li>判断是否在同一列：<strong>array[i] == array[n]</strong></li>
<li>判断是否在同一斜线上：<strong>Math.abs(n - i) == Math.abs(array[n] - array[i])</strong> ，即判断行差绝对值与列差绝对值是否相等</li>
</ul>
</li>
<li>check(int n) 方法：<ul>
<li>参数 n ：当前要放置第几个皇后（索引从 0 开始，n=8 时表示八皇后放置完毕）</li>
<li>当前放置的皇后，需要与之前的皇后位置进行比较，看看冲不冲突，所以需要一个 for 循环：<strong>for (int i = 0; i &lt; n; i++){</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue8</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个max表示共有多少个皇后</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 定义数组array, 保存皇后放置位置的结果,比如 arr = &#123;0 , 4, 7, 5, 2, 6, 1, 3&#125;</span></span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[max];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">judgeCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试一把 ， 8皇后是否正确</span></span><br><span class="line">        <span class="type">Queue8</span> <span class="variable">queue8</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Queue8</span>();</span><br><span class="line">        queue8.check(<span class="number">0</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;一共有%d种解法\n&quot;</span>, count);</span><br><span class="line">        System.out.printf(<span class="string">&quot;一共判断冲突的次数%d次&quot;</span>, judgeCount); <span class="comment">// 1.5w</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写一个方法，放置第n个皇后</span></span><br><span class="line">    <span class="comment">// 特别注意： check 是 每一次递归时，进入到check中都有 for(int i = 0; i &lt; max; i++)，因此会有回溯</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == max) &#123; <span class="comment">// n = 8 , 其实8个皇后就已经放好，因为索引从 0 开始</span></span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 依次放入皇后，并判断是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// 先把当前这个皇后 n , 放到该行的第1列</span></span><br><span class="line">            array[n] = i;</span><br><span class="line">            <span class="comment">// 判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> (judge(n)) &#123; <span class="comment">// 不冲突</span></span><br><span class="line">                <span class="comment">// 接着放n+1个皇后,即开始递归</span></span><br><span class="line">                check(n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行的后移的一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看当我们放置第n个皇后, 就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 表示第n个皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        judgeCount++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 说明</span></span><br><span class="line">            <span class="comment">// 1. array[i] == array[n] 表示判断 第n个皇后是否和前面的n-1个皇后在同一列</span></span><br><span class="line">            <span class="comment">// 2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线</span></span><br><span class="line">            <span class="comment">// n = 1 放置第 2列 1 n = 1 array[1] = 1</span></span><br><span class="line">            <span class="comment">// Math.abs(1-0) == 1 Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1</span></span><br><span class="line">            <span class="comment">// 3. 判断是否在同一行, 没有必要，n 每次都在递增</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 4 7 5 2 6 1 3 </span><br><span class="line">0 5 7 2 6 3 1 4 </span><br><span class="line">0 6 3 5 7 1 4 2 </span><br><span class="line">0 6 4 7 1 3 5 2 </span><br><span class="line">1 3 5 7 2 0 6 4 </span><br><span class="line">1 4 6 0 2 7 5 3 </span><br><span class="line">1 4 6 3 0 7 5 2 </span><br><span class="line">1 5 0 6 3 7 2 4 </span><br><span class="line">1 5 7 2 0 3 6 4 </span><br><span class="line">1 6 2 5 7 4 0 3 </span><br><span class="line">1 6 4 7 0 3 5 2 </span><br><span class="line">1 7 5 0 2 4 6 3 </span><br><span class="line">2 0 6 4 7 1 3 5 </span><br><span class="line">2 4 1 7 0 6 3 5 </span><br><span class="line">2 4 1 7 5 3 6 0 </span><br><span class="line">2 4 6 0 3 1 7 5 </span><br><span class="line">2 4 7 3 0 6 1 5 </span><br><span class="line">2 5 1 4 7 0 6 3 </span><br><span class="line">2 5 1 6 0 3 7 4 </span><br><span class="line">2 5 1 6 4 0 7 3 </span><br><span class="line">2 5 3 0 7 4 6 1 </span><br><span class="line">2 5 3 1 7 4 6 0 </span><br><span class="line">2 5 7 0 3 6 4 1 </span><br><span class="line">2 5 7 0 4 6 1 3 </span><br><span class="line">2 5 7 1 3 0 6 4 </span><br><span class="line">2 6 1 7 4 0 3 5 </span><br><span class="line">2 6 1 7 5 3 0 4 </span><br><span class="line">2 7 3 6 0 5 1 4 </span><br><span class="line">3 0 4 7 1 6 2 5 </span><br><span class="line">3 0 4 7 5 2 6 1 </span><br><span class="line">3 1 4 7 5 0 2 6 </span><br><span class="line">3 1 6 2 5 7 0 4 </span><br><span class="line">3 1 6 2 5 7 4 0 </span><br><span class="line">3 1 6 4 0 7 5 2 </span><br><span class="line">3 1 7 4 6 0 2 5 </span><br><span class="line">3 1 7 5 0 2 4 6 </span><br><span class="line">3 5 0 4 1 7 2 6 </span><br><span class="line">3 5 7 1 6 0 2 4 </span><br><span class="line">3 5 7 2 0 6 4 1 </span><br><span class="line">3 6 0 7 4 1 5 2 </span><br><span class="line">3 6 2 7 1 4 0 5 </span><br><span class="line">3 6 4 1 5 0 2 7 </span><br><span class="line">3 6 4 2 0 5 7 1 </span><br><span class="line">3 7 0 2 5 1 6 4 </span><br><span class="line">3 7 0 4 6 1 5 2 </span><br><span class="line">3 7 4 2 0 6 1 5 </span><br><span class="line">4 0 3 5 7 1 6 2 </span><br><span class="line">4 0 7 3 1 6 2 5 </span><br><span class="line">4 0 7 5 2 6 1 3 </span><br><span class="line">4 1 3 5 7 2 0 6 </span><br><span class="line">4 1 3 6 2 7 5 0 </span><br><span class="line">4 1 5 0 6 3 7 2 </span><br><span class="line">4 1 7 0 3 6 2 5 </span><br><span class="line">4 2 0 5 7 1 3 6 </span><br><span class="line">4 2 0 6 1 7 5 3 </span><br><span class="line">4 2 7 3 6 0 5 1 </span><br><span class="line">4 6 0 2 7 5 3 1 </span><br><span class="line">4 6 0 3 1 7 5 2 </span><br><span class="line">4 6 1 3 7 0 2 5 </span><br><span class="line">4 6 1 5 2 0 3 7 </span><br><span class="line">4 6 1 5 2 0 7 3 </span><br><span class="line">4 6 3 0 2 7 5 1 </span><br><span class="line">4 7 3 0 2 5 1 6 </span><br><span class="line">4 7 3 0 6 1 5 2 </span><br><span class="line">5 0 4 1 7 2 6 3 </span><br><span class="line">5 1 6 0 2 4 7 3 </span><br><span class="line">5 1 6 0 3 7 4 2 </span><br><span class="line">5 2 0 6 4 7 1 3 </span><br><span class="line">5 2 0 7 3 1 6 4 </span><br><span class="line">5 2 0 7 4 1 3 6 </span><br><span class="line">5 2 4 6 0 3 1 7 </span><br><span class="line">5 2 4 7 0 3 1 6 </span><br><span class="line">5 2 6 1 3 7 0 4 </span><br><span class="line">5 2 6 1 7 4 0 3 </span><br><span class="line">5 2 6 3 0 7 1 4 </span><br><span class="line">5 3 0 4 7 1 6 2 </span><br><span class="line">5 3 1 7 4 6 0 2 </span><br><span class="line">5 3 6 0 2 4 1 7 </span><br><span class="line">5 3 6 0 7 1 4 2 </span><br><span class="line">5 7 1 3 0 6 4 2 </span><br><span class="line">6 0 2 7 5 3 1 4 </span><br><span class="line">6 1 3 0 7 4 2 5 </span><br><span class="line">6 1 5 2 0 3 7 4 </span><br><span class="line">6 2 0 5 7 4 1 3 </span><br><span class="line">6 2 7 1 4 0 5 3 </span><br><span class="line">6 3 1 4 7 0 2 5 </span><br><span class="line">6 3 1 7 5 0 2 4 </span><br><span class="line">6 4 2 0 5 7 1 3 </span><br><span class="line">7 1 3 0 6 4 2 5 </span><br><span class="line">7 1 4 2 0 6 3 5 </span><br><span class="line">7 2 0 5 1 4 6 3 </span><br><span class="line">7 3 0 2 5 1 6 4 </span><br><span class="line">一共有92种解法</span><br><span class="line">一共判断冲突的次数15720次</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4、总结"><a href="#3-4、总结" class="headerlink" title="3.4、总结"></a>3.4、总结</h3><ul>
<li><strong>还是和走迷宫一样，当前摆法行不行，需要摆完第八个皇后我才能知道</strong></li>
<li>上面的解法其实是枚举<ul>
<li>第一个皇后摆在第一行第一列，然后开始试探，第二个皇后摆在哪里，才不会和第一个皇后冲突，第三个皇后摆在哪里，才不会和第二个皇后冲突。。。</li>
<li>如果遇到冲突，则把当前正在放置的皇后往后挪一格，如果 8 列都不行，那么就回溯至上一级皇后，让它试着挪一挪</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第 8 章 查找算法</title>
    <url>/posts/86fd8817980f/</url>
    <content><![CDATA[<h1 id="第-8-章-查找算法"><a href="#第-8-章-查找算法" class="headerlink" title="第 8 章 查找算法"></a>第 8 章 查找算法</h1><h2 id="1、查找算法介绍"><a href="#1、查找算法介绍" class="headerlink" title="1、查找算法介绍"></a>1、查找算法介绍</h2><ul>
<li>顺序(线性)查找</li>
<li>二分查找/折半查找</li>
<li>插值查找</li>
<li>斐波那契查找</li>
</ul>
<h2 id="2、线性查找"><a href="#2、线性查找" class="headerlink" title="2、线性查找"></a>2、线性查找</h2><ul>
<li>编写线性查找算法代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeqSearch</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;<span class="comment">// 没有顺序的数组</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> seqSearch(arr, -<span class="number">11</span>);</span><br><span class="line">		<span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;没有找到到&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;找到，下标为=&quot;</span> + index);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 这里我们实现的线性查找是找到一个满足条件的值，就返回</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">seqSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">		<span class="comment">// 线性查找是逐一比对，发现有相同值，就返回下标</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] == value) &#123;</span><br><span class="line">				<span class="keyword">return</span> i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">找到，下标为=4</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线性查找，其实就是咱们平常最常用的顺序遍历，找到就返回第一次出现的下标</p>
<p>对象查找就需要判断是不是null，仿照arrayList的get方法就明白了，</p>
</blockquote>
<h2 id="3、二分查找"><a href="#3、二分查找" class="headerlink" title="3、二分查找"></a>3、二分查找</h2><h3 id="3-1、二分查找思路"><a href="#3-1、二分查找思路" class="headerlink" title="3.1、二分查找思路"></a>3.1、二分查找思路</h3><ul>
<li><strong>二分查找算法的前提：数组必须是有序数组</strong></li>
<li>二分查找算法思路分析（递归版）：<ul>
<li>定义两个辅助指针：left、right ，待查找的元素在 arr[left]~arr[right] 之间</li>
<li>left 初始值为 0 ，right 初始值为 arr.length - 1</li>
<li>将数组分成两半：int mid = (left + right) / 2; ，取数组中间值与目标值 findVal 比较<ul>
<li>如果 mid &gt; findVal ，说明待查找的值在数组左半部分</li>
<li>如果 mid &lt; findVal ，说明待查找的值在数组右半部分</li>
<li>如果 mid == findVal ，查找到目标值，返回即可</li>
</ul>
</li>
<li>何时终止递归？分为两种情况：<ul>
<li>找到目标值，直接返回目标值 findVal ，结束递归即可</li>
<li><strong>未找到目标值：left &gt; right</strong>，这样想：如果递归至数组中只有一个数时（left == right），还没有找到目标值，继续执行下一次递归时， left 指针和 right 指针总有一个会再走一步，这时<br>left 和 right 便会错开，此时 left &gt; right ，返回 -1 并结束递归表示没有找到目标值</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTkxNTU3NTcyLnBuZw?x-oss-process=image/format,png" alt="image-20200806191557572"></p>
<h3 id="3-2、代码实现"><a href="#3-2、代码实现" class="headerlink" title="3.2、代码实现"></a>3.2、代码实现</h3><h4 id="3-2-1、二分查找（单个值）"><a href="#3-2-1、二分查找（单个值）" class="headerlink" title="3.2.1、二分查找（单个值）"></a>3.2.1、二分查找（单个值）</h4><ul>
<li>编写二分查找算法：查找到目标值就返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意：使用二分查找的前提是 该数组是有序的.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">resIndex</span> <span class="operator">=</span> binarySearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;resIndex=&quot;</span> + resIndex);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找算法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr     数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left    左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right   右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal 要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回下标，如果没有找到，就返回 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> findVal)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resIndex=4</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2、二分查找（所有值）"><a href="#3-2-2、二分查找（所有值）" class="headerlink" title="3.2.2、二分查找（所有值）"></a>3.2.2、二分查找（所有值）</h4><ul>
<li>编写二分查找算法：查找到所有目标值，在找到目标值之后，分别往左、往右进行扩散搜索</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意：使用二分查找的前提是 该数组是有序的.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; resIndexList = binarySearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;resIndexList=&quot;</span> + resIndexList);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成一个课后思考题:</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 课后思考题： &#123;1,8, 10, 89, 1000, 1000，1234&#125; 当一个有序数组中， 有多个相同的数值时，如何将所有的数值都查找到，比如这里的</span></span><br><span class="line"><span class="comment">     * 1000</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 思路分析 1. 在找到mid 索引值，不要马上返回 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">     * 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList 4. 将Arraylist返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> findVal)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 left &gt; right 时，说明递归整个数组，但是没有找到</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 向 右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 向左递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 思路分析</span></span><br><span class="line">            <span class="comment">// 1. 在找到mid 索引值，不要马上返回</span></span><br><span class="line">            <span class="comment">// 2. 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line">            <span class="comment">// 3. 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line">            <span class="comment">// 4. 将Arraylist返回</span></span><br><span class="line"></span><br><span class="line">            List&lt;Integer&gt; resIndexlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="comment">// 向mid 索引值的左边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[temp] == findVal) &#123;</span><br><span class="line">                    resIndexlist.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line">            resIndexlist.add(mid); <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 向mid 索引值的右边扫描，将所有满足 1000， 的元素的下标，加入到集合ArrayList</span></span><br><span class="line">            temp = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp &lt; arr.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[temp] == findVal) &#123;</span><br><span class="line">                    resIndexlist.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> resIndexlist;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">resIndexList=[4, 5, 6]</span><br></pre></td></tr></table></figure>

<h2 id="4、插值查找"><a href="#4、插值查找" class="headerlink" title="4、插值查找"></a>4、插值查找</h2><h3 id="4-1、插值查找基本介绍"><a href="#4-1、插值查找基本介绍" class="headerlink" title="4.1、插值查找基本介绍"></a>4.1、插值查找基本介绍</h3><ul>
<li>插值查找算法类似于二分查找， 不同的是插值查找每次从自适应 mid 处开始查找。</li>
</ul>
<h3 id="4-2、插值查找图解"><a href="#4-2、插值查找图解" class="headerlink" title="4.2、插值查找图解"></a>4.2、插值查找图解</h3><ul>
<li><p>将折半查找中的求 mid 索引的公式 , low 表示左边索引 left ，high 表示右边索引 right ，key 就是前面我们讲的 findVal</p>
</li>
<li><p>图中公式：<strong>int mid = low + (high - low) * (key - arr[low]) / (arr[high] - arr[low]) ;</strong></p>
<p>对应前面的代码公式：</p>
<p>int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])</p>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE2MjE0MDQ0NjU4LnBuZw?x-oss-process=image/format,png" alt="image-20200716214044658"></p>
<ul>
<li><p>大致思路和二分查找一样，有如下不同：</p>
<ul>
<li><p>寻找 mid 公式不同：</p>
<p>int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left]);</p>
</li>
<li><p>由于公式中出现 findVal ，所以 findVal 的值不能过大或者过小，否则会引起 mid 过大或过小，引起数组越界问题，</p>
<ul>
<li>添加判断：<strong>findVal &lt; arr[left] 和 findVal &gt; arr[right]</strong></li>
<li>why？findVal = arr[left] 时，mid = left；findVal = arr[right] 时，mid = right；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTkyMzAwNDc5LnBuZw?x-oss-process=image/format,png" alt="image-20200806192300479"></p>
<h3 id="4-3、代码实现"><a href="#4-3、代码实现" class="headerlink" title="4.3、代码实现"></a>4.3、代码实现</h3><ul>
<li>编写插值查找算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertValueSearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> insertValueSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;index = &quot;</span> + index);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写插值查找算法</span></span><br><span class="line">    <span class="comment">//说明：插值查找算法，也要求数组是有序的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal 查找值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到，就返回对应的下标，如果没有找到，返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">insertValueSearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> findVal)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;插值查找次数~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意：findVal &lt; arr[left]  和  findVal &gt; arr[right] 必须需要，否则我们得到的 mid 可能越界</span></span><br><span class="line">        <span class="comment">// findVal &lt; arr[left] ：说明待查找的值比数组中最小的元素都小</span></span><br><span class="line">        <span class="comment">// findVal &gt; arr[right] ：说明待查找的值比数组中最大的元素都大</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right || findVal &lt; arr[left] || findVal &gt; arr[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求出mid, 自适应，额，这不就是一次函数吗</span></span><br><span class="line">        <span class="comment">// findVal = arr[left] 时，mid = left</span></span><br><span class="line">        <span class="comment">// findVal = arr[right] 时，mid = right</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">midVal</span> <span class="operator">=</span> arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123; <span class="comment">// 说明应该向右边递归</span></span><br><span class="line">            <span class="keyword">return</span> insertValueSearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123; <span class="comment">// 说明向左递归查找</span></span><br><span class="line">            <span class="keyword">return</span> insertValueSearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">插值查找次数~~</span><br><span class="line">index = 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p>像直角坐标系里面的函数一样，知道 两个点的坐标，给出第三个点的纵坐标k，让你找第三个点的横坐标mid；</p>
<p>并且 k要在处于中间位置。</p>
<p>(k-y1)/(y2-y1) = (mid-x1)/(x2-x1)==&gt;求mid。</p>
<p>mid = (k-y1)/(y2-y1) * (x2-x1) + x1</p>
</blockquote>
<h3 id="4-4、总结"><a href="#4-4、总结" class="headerlink" title="4.4、总结"></a>4.4、总结</h3><ul>
<li>对于<strong>数据量较大，关键字分布比较均匀</strong>（最好是线性分布）的查找表来说，采用插值查找，速度较快</li>
<li>关键字分布不均匀的情况下， 该方法不一定比折半查找要好</li>
</ul>
<h2 id="5、斐波那契查找"><a href="#5、斐波那契查找" class="headerlink" title="5、斐波那契查找"></a>5、斐波那契查找</h2><h3 id="5-1、斐波那契数列"><a href="#5-1、斐波那契数列" class="headerlink" title="5.1、斐波那契数列"></a>5.1、斐波那契数列</h3><ul>
<li>黄金分割点是指把一条线段分割为两部分， 使其中一部分与全长之比等于另一部分与这部分之比。 取其前三位数字的近似值是 0.618。 由于按此比例设计的造型十分美丽， 因此称为黄金分割， 也称为中外比。 这是一个神奇的数字，<br>会带来意想不到的效果。</li>
<li>斐波那契数列 { 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数的比例， 无限接近 黄金分割值 0.618</li>
</ul>
<h3 id="5-2、斐波那契查找介绍"><a href="#5-2、斐波那契查找介绍" class="headerlink" title="5.2、斐波那契查找介绍"></a>5.2、斐波那契查找介绍</h3><ul>
<li><p>那为什么一定要等分呐？能不能进行“黄金分割”？也就是 mid = left+0.618(right-left) ，当然mid 要取整数。如果这样查找，时间复杂性是多少？也许你还可以编程做个试验，比较一下二分法和“黄金分割”法的执行效率。</p>
</li>
<li><p>斐波那契查找算法又称为黄金分割法查找算法，斐波那契查找原理与前两种相似， 仅仅改变了中间结点（mid） 的位置，mid 不再是中间或由插值计算得到，而是位于黄金分割点附近， 即 mid = low + F(k-1) - 1</p>
</li>
<li><p>对 F(k)-1 的理解</p>
<ul>
<li>由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质， 可以得到</li>
</ul>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">F[k]-1） =（F[k-1]-1） +（F[k-2]-1） + 1 </span><br></pre></td></tr></table></figure></li>
<li><p>该式说明：<strong>只要顺序表的长度为 F[k]-1， 则可以将该表分成长度为 F[k-1]-1 和 F[k-2]-1 的两段</strong> ，即如图所示。 从而中间位置为 mid=low+F(k-1)-1 ，类似的， 每一子段也可以用相同的方式分割</p>
<ul>
<li>但顺序表长度 n 不一定刚好等于 F[k]-1， 所以需要将原来的顺序表长度 n 增加至 F[k]-1。 这里的 k 值只要能使得 F[k]-1 恰好大于或等于 n 即可</li>
<li>为什么数组总长度是 F(k) - 1 ，而不是 F(k) ？<strong>因为凑成 F(k-1) 才能找出中间值</strong>，如果数组长度为 F(k) ，而 F(k) = F(k-1) + F(k-2) ，咋个找中间值嘞？</li>
<li>为什么数组左边的长度是 F(k-1) - 1 ，数组右边的长度是 F(k-2) - 1 ？就拿个斐波那契数列来说：{ 1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } ，54 = 33 + 20 + 1<br>，左边是不是 F(k-1) - 1 ，右边是不是 F(k-2) - 1 ，也恰好空出了一个中间值~~~</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE2MjIyODM1NjM5LnBuZw?x-oss-process=image/format,png" alt="image-20200716222835639"></p>
<h3 id="5-3、斐波那契查找思路"><a href="#5-3、斐波那契查找思路" class="headerlink" title="5.3、斐波那契查找思路"></a>5.3、斐波那契查找思路</h3><ul>
<li>先根据原数组大小，计算斐波那契数列的得 k 值</li>
<li>数组扩容条件是：增大 k 值（索引从 0 开始），使得数组长度刚好大于或者等于斐波那契数列中的 F[k]-1 ，我们定义临时数组 temp ，temp 后面为 0 的元素都按照数组最大元素值填充</li>
<li>何时终止斐波那契查找？<ul>
<li>找到目标值：直接返回目标值索引</li>
<li>没有找到目标值：low 指针和 high 指针相等或者擦肩而过，即 <strong>low &gt;= high</strong></li>
</ul>
</li>
<li>为什么 low == high 时需要单独拎出来？<ul>
<li><strong>low == high 时说明此时数组中只剩下一个元素（a[low] 或者 a[high]）没有与目标值比较，并且此时 k 有可能等于 0 ，无法执行 mid = low + f[k - 1] - 1; 操作（k - 1<br>将导致数组越界）</strong></li>
<li>解决办法：我们在程序的最后，将 a[low] 或者 a[high] 单独与目标值 value 进行比较即可，我是通过 Debug 解决数组越界异常的，我并没有想明白，但是不把 low == high<br>单独拎出来，就会抛异常，哎，烧脑壳~~~改天再想</li>
</ul>
</li>
<li>mid 值怎么定？<strong>mid = low + f[k - 1] - 1</strong> ：用黄金分割点确定 mid 的值</li>
<li>左右两条路，你怎么选？<ul>
<li>key &lt; temp[mid] ：目标值在黄金分割点的左边，看上面的图，应该是 <strong>k -= 1;</strong></li>
<li>key &gt; temp[mid] ：目标值在黄金分割点的右边，看上面的图，应该是 <strong>k -= 2;</strong></li>
<li>key = temp[mid] ：找到目标值，因为数组经历过扩容，后面的值其实有些是多余的，mid 可能会越界（相对于原数组来说）<ul>
<li>mid &lt;= high ：证明 mid 索引在原数组中，返回 mid</li>
<li>mid &gt; high 时，证明 mid 索引已经越界（相对于原数组来说），返回 high</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-4、代码实现"><a href="#5-4、代码实现" class="headerlink" title="5.4、代码实现"></a>5.4、代码实现</h3><ul>
<li>编写斐波那契查找算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FibonacciSearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;index=&quot;</span> + fibSearch(arr, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为后面我们mid=low+F(k-1)-1，需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span></span><br><span class="line">    <span class="comment">// 非递归方法得到一个斐波那契数列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] fib() &#123;</span><br><span class="line">        <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[maxSize];</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写斐波那契查找算法</span></span><br><span class="line">    <span class="comment">// 使用非递归的方式编写算法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a   数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 我们需要查找的关键码(值)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的下标，如果没有-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fibSearch</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 表示斐波那契分割数值的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 存放mid值</span></span><br><span class="line">        <span class="type">int</span> f[] = fib(); <span class="comment">// 获取到斐波那契数列</span></span><br><span class="line">        <span class="comment">// 获取到斐波那契分割数值的下标</span></span><br><span class="line">        <span class="keyword">while</span> (high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为 f[k] 值 可能大于 a 的 长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span></span><br><span class="line">        <span class="comment">// 不足的部分会使用0填充</span></span><br><span class="line">        <span class="type">int</span>[] temp = Arrays.copyOf(a, f[k]);</span><br><span class="line">        <span class="comment">// 实际上需求使用a数组最后的数填充 temp</span></span><br><span class="line">        <span class="comment">// 举例:</span></span><br><span class="line">        <span class="comment">// temp = &#123;1,8, 10, 89, 1000, 1234, 0, 0&#125; =&gt; &#123;1,8, 10, 89, 1000, 1234, 1234,</span></span><br><span class="line">        <span class="comment">// 1234,&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            temp[i] = a[high];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用while来循环处理，找到我们的数 key</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123; <span class="comment">// 只要这个条件满足，就可以找</span></span><br><span class="line">            mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; temp[mid]) &#123; <span class="comment">// 我们应该继续向数组的前面查找(左边)</span></span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 为甚是 k--</span></span><br><span class="line">                <span class="comment">// 当前：f[k-1] = f[k-2] + f[k-3]</span></span><br><span class="line">                <span class="comment">// 往左查找：f[k-2] = f[k-3] + f[k-4];</span></span><br><span class="line">                <span class="comment">// 假设下次k变为X，那下次进入循环就是：f[X-1] = f[k-3] + f[k-4]</span></span><br><span class="line">                <span class="comment">// 得到f[X-1] = f[k-2] =&gt;X=k-1,而此处的X又是原来的k，所以k--</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; temp[mid]) &#123; <span class="comment">// 我们应该继续向数组的后面查找(右边)</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//为什么是k -=2</span></span><br><span class="line">                <span class="comment">// 当前：f[k-1] = f[k-2] + f[k-3]</span></span><br><span class="line">                <span class="comment">// 往右查找：f[k-3] = f[k-4] + f[k-5];</span></span><br><span class="line">                <span class="comment">// 假设下次k变为X，那下次进入循环就是：f[X-1] = f[k-4] + f[k-5];</span></span><br><span class="line">                <span class="comment">// 得到f[X-1] = f[k-3] =&gt;X=k-2,而此处的X又是原来的k，所以k-=2</span></span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 找到</span></span><br><span class="line">                <span class="comment">// 需要确定，返回的是哪个下标</span></span><br><span class="line">                <span class="keyword">if</span> (mid &lt;= high) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[low] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> low;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">index=4</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第 9 章 哈希表</title>
    <url>/posts/da24c4185170/</url>
    <content><![CDATA[<h1 id="第-9-章-哈希表"><a href="#第-9-章-哈希表" class="headerlink" title="第 9 章 哈希表"></a>第 9 章 哈希表</h1><h2 id="1、Google-上机题"><a href="#1、Google-上机题" class="headerlink" title="1、Google 上机题"></a>1、Google 上机题</h2><ul>
<li>看一个实际需求， google 公司的一个上机题:</li>
<li>有一个公司，当有新的员工来报道时,要求将该员工的信息加入(id, 性别, 年龄, 住址…)，当输入该员工的 id 时，要求查找到该员工的所有信息</li>
<li>要求：不使用数据库，尽量节省内存，速度越快越好 =&gt; 哈希表(散列)</li>
</ul>
<h2 id="2、哈希表基本介绍"><a href="#2、哈希表基本介绍" class="headerlink" title="2、哈希表基本介绍"></a>2、哈希表基本介绍</h2><ul>
<li><strong>散列表（Hash table， 也叫哈希表） ，是根据关键码值(Key value)而直接进行访问的数据结构。</strong></li>
<li>它通过把关键码值映射到表中一个位置来访问记录， 以加快查找的速度。 这个映射函数叫做散列函数， 存放记录的数组叫做散列表。</li>
<li>哈希表的核心：<strong>private EmpLinkedList[] empLinkedListArray;</strong></li>
<li>哈希表编程思路：<ul>
<li>先根据对象的信息将其散列，得到 hashCode</li>
<li><strong>根据对象的 hashCode 值，找到对应的数组下标，其实就是找到存储对象的链表</strong></li>
<li>在链表中进行相应的增删改查操作</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MjAzMDE0OTE2LnBuZw?x-oss-process=image/format,png" alt="image-20200806203014916"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTExMDM0OTMwLnBuZw?x-oss-process=image/format,png" alt="image-20200717111034930"></p>
<h2 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h2><h3 id="3-1、Emp-节点"><a href="#3-1、Emp-节点" class="headerlink" title="3.1、Emp 节点"></a>3.1、Emp 节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示一个雇员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmpNode</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> EmpNode next; <span class="comment">// next 默认为 null</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">EmpNode</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		<span class="built_in">this</span>.id = id;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-2、Emp-链表"><a href="#3-2、Emp-链表" class="headerlink" title="3.2、Emp 链表"></a>3.2、Emp 链表</h3><ul>
<li>head 是首指针（指向真正存放数据的节点），不是头指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建EmpLinkedList ,表示链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmpLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// 首指针，指向第一个EmpNode,因此我们这个链表的head 是直接指向第一个EmpNode</span></span><br><span class="line">    <span class="keyword">private</span> EmpNode head; <span class="comment">// 默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加雇员到链表</span></span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大</span></span><br><span class="line">    <span class="comment">// 因此我们将该雇员直接加入到本链表的最后即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(EmpNode empNode)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是添加第一个雇员</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = empNode;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后</span></span><br><span class="line">        <span class="type">EmpNode</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="literal">null</span>) &#123;<span class="comment">// 说明到链表最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next; <span class="comment">// 后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出时直接将emp 加入链表</span></span><br><span class="line">        curEmp.next = empNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表的雇员信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123; <span class="comment">// 说明链表为空</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第 &quot;</span> + (no + <span class="number">1</span>) + <span class="string">&quot; 链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;第 &quot;</span> + (no + <span class="number">1</span>) + <span class="string">&quot; 链表的信息为&quot;</span>);</span><br><span class="line">        <span class="type">EmpNode</span> <span class="variable">curEmp</span> <span class="operator">=</span> head; <span class="comment">// 辅助指针</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot; =&gt; id=%d name=%s &quot;</span>, curEmp.id, curEmp.name);</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="literal">null</span>) &#123;<span class="comment">// 说明curEmp已经是最后结点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next; <span class="comment">// 后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据id查找雇员</span></span><br><span class="line">    <span class="comment">// 如果查找到，就返回Emp, 如果没有找到，就返回null</span></span><br><span class="line">    <span class="keyword">public</span> EmpNode <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 辅助指针</span></span><br><span class="line">        <span class="type">EmpNode</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.id == id) &#123;<span class="comment">// 找到</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">// 这时curEmp就指向要查找的雇员</span></span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;<span class="comment">// 后移</span></span><br><span class="line">            <span class="comment">// 退出</span></span><br><span class="line">            <span class="keyword">if</span> (curEmp == <span class="literal">null</span>) &#123;<span class="comment">// 说明遍历当前链表没有找到该雇员</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curEmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-3、Emp-哈希表"><a href="#3-3、Emp-哈希表" class="headerlink" title="3.3、Emp 哈希表"></a>3.3、Emp 哈希表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建HashTab 管理多条链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTab</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size; <span class="comment">// 表示有多少条链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashTab</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="comment">// 初始化empLinkedListArray</span></span><br><span class="line">        empLinkedListArray = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i] = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加雇员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(EmpNode empNode)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据员工的id ,得到该员工应当添加到哪条链表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNO</span> <span class="operator">=</span> hashFun(empNode.id);</span><br><span class="line">        <span class="comment">// 将emp 添加到对应的链表中</span></span><br><span class="line">        empLinkedListArray[empLinkedListNO].add(empNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有的链表,遍历hashtab</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据输入的id,查找雇员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用散列函数确定到哪条链表查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNO</span> <span class="operator">=</span> hashFun(id);</span><br><span class="line">        <span class="type">EmpNode</span> <span class="variable">empNode</span> <span class="operator">=</span> empLinkedListArray[empLinkedListNO].findEmpById(id);</span><br><span class="line">        <span class="keyword">if</span> (empNode != <span class="literal">null</span>) &#123;<span class="comment">// 找到</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;在第%d条链表中找到 雇员 id = %d\n&quot;</span>, (empLinkedListNO + <span class="number">1</span>), id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在哈希表中，没有找到该雇员~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写散列函数, 使用一个简单取模法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashFun</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4、代码测试"><a href="#3-4、代码测试" class="headerlink" title="3.4、代码测试"></a>3.4、代码测试</h3><ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTabDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建哈希表</span></span><br><span class="line">        <span class="type">HashTab</span> <span class="variable">hashTab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTab</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写一个简单的菜单</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;add:  添加雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;list: 显示雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;find: 查找雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit: 退出系统&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入id&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入名字&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                    <span class="comment">// 创建 雇员</span></span><br><span class="line">                    <span class="type">EmpNode</span> <span class="variable">empNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpNode</span>(id, name);</span><br><span class="line">                    hashTab.add(empNode);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;find&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入要查找的id&quot;</span>);</span><br><span class="line">                    id = scanner.nextInt();</span><br><span class="line">                    hashTab.findEmpById(id);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">add:  添加雇员</span><br><span class="line">list: 显示雇员</span><br><span class="line">find: 查找雇员</span><br><span class="line">exit: 退出系统</span><br><span class="line"></span><br><span class="line">add</span><br><span class="line">输入id</span><br><span class="line">1</span><br><span class="line">输入名字</span><br><span class="line">Heygo</span><br><span class="line">add:  添加雇员</span><br><span class="line">list: 显示雇员</span><br><span class="line">find: 查找雇员</span><br><span class="line">exit: 退出系统</span><br><span class="line"></span><br><span class="line">add</span><br><span class="line">输入id</span><br><span class="line">2</span><br><span class="line">输入名字</span><br><span class="line">Oneby</span><br><span class="line">add:  添加雇员</span><br><span class="line">list: 显示雇员</span><br><span class="line">find: 查找雇员</span><br><span class="line">exit: 退出系统</span><br><span class="line"></span><br><span class="line">add</span><br><span class="line">输入id</span><br><span class="line">8</span><br><span class="line">输入名字</span><br><span class="line">NiuNiu</span><br><span class="line">add:  添加雇员</span><br><span class="line">list: 显示雇员</span><br><span class="line">find: 查找雇员</span><br><span class="line">exit: 退出系统</span><br><span class="line"></span><br><span class="line">list</span><br><span class="line">第 1 链表为空</span><br><span class="line">第 2 链表的信息为 =&gt; id=1 name=Heygo  =&gt; id=8 name=NiuNiu </span><br><span class="line">第 3 链表的信息为 =&gt; id=2 name=Oneby </span><br><span class="line">第 4 链表为空</span><br><span class="line">第 5 链表为空</span><br><span class="line">第 6 链表为空</span><br><span class="line">第 7 链表为空</span><br><span class="line">add:  添加雇员</span><br><span class="line">list: 显示雇员</span><br><span class="line">find: 查找雇员</span><br><span class="line">exit: 退出系统</span><br><span class="line"></span><br><span class="line">find</span><br><span class="line">请输入要查找的id</span><br><span class="line">1</span><br><span class="line">在第2条链表中找到 雇员 id = 1</span><br><span class="line">add:  添加雇员</span><br><span class="line">list: 显示雇员</span><br><span class="line">find: 查找雇员</span><br><span class="line">exit: 退出系统</span><br><span class="line"></span><br><span class="line">find</span><br><span class="line">请输入要查找的id</span><br><span class="line">8</span><br><span class="line">在第2条链表中找到 雇员 id = 8</span><br><span class="line">add:  添加雇员</span><br><span class="line">list: 显示雇员</span><br><span class="line">find: 查找雇员</span><br><span class="line">exit: 退出系统</span><br><span class="line"></span><br><span class="line">find</span><br><span class="line">请输入要查找的id</span><br><span class="line">9</span><br><span class="line">在哈希表中，没有找到该雇员~</span><br><span class="line">add:  添加雇员</span><br><span class="line">list: 显示雇员</span><br><span class="line">find: 查找雇员</span><br><span class="line">exit: 退出系统</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-5、课后练习"><a href="#3-5、课后练习" class="headerlink" title="3.5、课后练习"></a>3.5、课后练习</h3><ul>
<li>实现员工的删除</li>
</ul>
<h2 id="4、Emp-哈希表全部代码"><a href="#4、Emp-哈希表全部代码" class="headerlink" title="4、Emp 哈希表全部代码"></a>4、Emp 哈希表全部代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.hashtab;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTabDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建哈希表</span></span><br><span class="line">        <span class="type">HashTab</span> <span class="variable">hashTab</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashTab</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写一个简单的菜单</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;add:  添加雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;show: 显示雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;find: 查找雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit: 退出系统&quot;</span>);</span><br><span class="line"></span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入id&quot;</span>);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入名字&quot;</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                    <span class="comment">//创建 雇员</span></span><br><span class="line">                    <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(id, name);</span><br><span class="line">                    hashTab.add(emp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;find&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;请输入要查找的id&quot;</span>);</span><br><span class="line">                    id = scanner.nextInt();</span><br><span class="line">                    hashTab.findEmpById(id);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建HashTab 管理多条链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTab</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> size; <span class="comment">//表示有多少条链表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashTab</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">        <span class="comment">//初始化empLinkedListArray</span></span><br><span class="line">        empLinkedListArray = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>[size];</span><br><span class="line">        <span class="comment">//？留一个坑, 这时不要分别初始化每个链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i] = <span class="keyword">new</span> <span class="title class_">EmpLinkedList</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加雇员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span> &#123;</span><br><span class="line">        <span class="comment">//根据员工的id ,得到该员工应当添加到哪条链表</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNO</span> <span class="operator">=</span> hashFun(emp.id);</span><br><span class="line">        <span class="comment">//将emp 添加到对应的链表中</span></span><br><span class="line">        empLinkedListArray[empLinkedListNO].add(emp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNO</span> <span class="operator">=</span> hashFun(id);</span><br><span class="line">        empLinkedListArray[empLinkedListNO].delEmpById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有的链表,遍历hashtab</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据输入的id,查找雇员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">//使用散列函数确定到哪条链表查找</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">empLinkedListNO</span> <span class="operator">=</span> hashFun(id);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> empLinkedListArray[empLinkedListNO].findEmpById(id);</span><br><span class="line">        <span class="keyword">if</span> (emp != <span class="literal">null</span>) &#123;<span class="comment">//找到</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;在第%d条链表中找到 雇员 id = %d\n&quot;</span>, (empLinkedListNO + <span class="number">1</span>), id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在哈希表中，没有找到该雇员~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写散列函数, 使用一个简单取模法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashFun</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表示一个雇员</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Emp next; <span class="comment">//next 默认为 null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建EmpLinkedList ,表示链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmpLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">//头指针，执行第一个Emp,因此我们这个链表的head 是直接指向第一个Emp</span></span><br><span class="line">    <span class="keyword">private</span> Emp head; <span class="comment">//默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加雇员到链表</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. 假定，当添加雇员时，id 是自增长，即id的分配总是从小到大</span></span><br><span class="line">    <span class="comment">//   因此我们将该雇员直接加入到本链表的最后即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Emp emp)</span> &#123;</span><br><span class="line">        <span class="comment">//如果是添加第一个雇员</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//判断是否到链表最后</span></span><br><span class="line">        <span class="keyword">while</span> (curEmp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            curEmp = curEmp.next; <span class="comment">//后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//已到链表最后，将emp 加入链表</span></span><br><span class="line">        curEmp.next = emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按照id顺序添加，有序链表</span></span><br><span class="line"><span class="comment">     * 注意需要单独处理头节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> emp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderAdd</span><span class="params">(Emp emp)</span> &#123;</span><br><span class="line">        <span class="comment">//按顺序添加员工信息</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//空链表</span></span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.id == emp.id) &#123;</span><br><span class="line">            <span class="comment">//如果头结点的id等于要加入的id，则提示不能加入</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;第%d号员工已经存在，不能加人\n&quot;</span>, emp.id);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head.id &gt; emp.id) &#123;</span><br><span class="line">            <span class="comment">//如果头结点的id大于要插入的id，则将emp指向当前头结点，然后再把头结点置为emp</span></span><br><span class="line">            emp.next = head;</span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (curEmp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next.id &gt; emp.id) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (curEmp.next.id == emp.id) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;<span class="comment">//后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;第%d号员工已经存在，不能加人\n&quot;</span>, emp.id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果要插入的位置在节点中间</span></span><br><span class="line">                <span class="comment">// 则将emp.next指向当前curEmp.next结点，</span></span><br><span class="line">                <span class="comment">// 然后再把curEmp.next结点置为emp</span></span><br><span class="line">                emp.next = curEmp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp.next = emp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据id删除，</span></span><br><span class="line"><span class="comment">     * 注意也是需要单独处理头节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">//按照id删除员工信息</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (head.id == id) &#123;</span><br><span class="line">            <span class="comment">// 如果头结点的id等于要删除的id，则将头结点指向下一个</span></span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="comment">//head = null;</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (curEmp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next.id == id) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;<span class="comment">//后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            curEmp.next = curEmp.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到第&quot;</span> + id + <span class="string">&quot;号员工&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历链表的雇员信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123; <span class="comment">//说明链表为空</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第 &quot;</span> + (no + <span class="number">1</span>) + <span class="string">&quot; 链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;第 &quot;</span> + (no + <span class="number">1</span>) + <span class="string">&quot; 链表的信息为&quot;</span>);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head; <span class="comment">//辅助指针</span></span><br><span class="line">        <span class="comment">// 判断是否到链表最后</span></span><br><span class="line">        <span class="keyword">while</span> (curEmp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot; =&gt; id=%d name=%s\t&quot;</span>, curEmp.id, curEmp.name);</span><br><span class="line">            curEmp = curEmp.next; <span class="comment">//后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出循环的时候curEmp已经是最后结点，然后再将最后一个节点打印出来</span></span><br><span class="line">        System.out.printf(<span class="string">&quot; =&gt; id=%d name=%s\t&quot;</span>, curEmp.id, curEmp.name);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id查找雇员</span></span><br><span class="line">    <span class="comment">//如果查找到，就返回Emp, 如果没有找到，就返回null</span></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">findEmpById</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助指针</span></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">curEmp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.id == id) &#123;<span class="comment">//找到</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//这时curEmp就指向要查找的雇员</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//退出</span></span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="literal">null</span>) &#123;<span class="comment">//说明遍历当前链表没有找到该雇员</span></span><br><span class="line">                curEmp = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;<span class="comment">//以后</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> curEmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程基础（1）</title>
    <url>/posts/fc4dc6b8f766/</url>
    <content><![CDATA[<h1 id="Java多线程基础（1）"><a href="#Java多线程基础（1）" class="headerlink" title="Java多线程基础（1）"></a>Java多线程基础（1）</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>进程是代码在数据集合上的一次运行活动， 是系统进行<code>资源分配和调度的基本单位</code>， 线程则是进程的一个执行路径， 一个进程中至少有一个线程，进程中的多个线程共享进程的资源。</p>
<p>线程是<code>CPU分配</code>的基本单位。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213432.png" alt="image-20210730110749370"></p>
<p>由图1-1 可以看到， 一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈区域。</p>
<p><code>程序计数器</code>是一块<code>内存区域</code>，用来记录线程当前要执行的指令地址。那么为何要将程序计数器设计为线程私有的呢？前面说了线程是占用CPU 执行的基本单位，而CPU 一般是使用时间片轮转方式让线程轮询占用的，所以当前线程CPU 时间片用完后，要让出CPU ，等下次轮到自己的时候再执行。那么如何知道之前程序执行到哪里了呢？其实程序计数器就是为了记录该线程让出CPU 时的执行地址的，待再次分配到时间片时线程就可以从自己私有的计数器指定地址继续执行。</p>
<blockquote>
<p>注意，如果执行的是native 方法，那么pc 计数器记录的是undefined 地址，只有执行的是Java 代码时pc 计数器记录的才是下一条指令的地址。</p>
</blockquote>
<p>每个线程都有自己的<code>栈</code>资源，用于存储该线程的<code>局部变量</code>，这些局部变量是该线程私有的，其他线程是访问不了的，除此之外栈还用来存放线程的调用栈帧。</p>
<p>堆是一个进程中最大的一块内存，堆是被进程中的所有线程共享的，是进程创建时分配的，堆里面主要存放使用new 操作创建的对象实例。</p>
<p>方法区则用来存放JVM加载的类、常量及静态变量等信息，也是线程共享的。</p>
<p>后续会扩展讲解<code>JMM</code></p>
<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><p>三种</p>
<p>1.继承Thread，重写run方法 </p>
<p>2.实现Runnable接口，重写run方法</p>
<p>3.实现Callable接口 定义返回值 重写call方法创建执行服务 提交执行 获取结果  抛出异常 关闭服务</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213439.jpg" alt="img"></p>
<h3 id="1、继承Thread，重写run方法"><a href="#1、继承Thread，重写run方法" class="headerlink" title="1、继承Thread，重写run方法"></a>1、继承Thread，重写run方法</h3><p>继承Thread类，重写run（）方法，调用start开启线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.xiancheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年07月29日 17:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数传入所需的url和filename</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadTest01</span><span class="params">(String url, String filename)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.url = url;</span><br><span class="line">        <span class="built_in">this</span>.filename = filename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//调用downLoader来获取文件</span></span><br><span class="line">        <span class="type">WebDownLoader</span> <span class="variable">webDownLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebDownLoader</span>();</span><br><span class="line">        webDownLoader.downLoader(url, filename);</span><br><span class="line">        System.out.println(filename + <span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//传入三张图图片的url</span></span><br><span class="line">        <span class="type">ThreadTest01</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest01</span>(</span><br><span class="line">                <span class="string">&quot;https://i0.hdslb.com/bfs/album/481ba607ba31e9932b90e383f3698fec4c1d9577.jpg@518w_1e_1c.jpg&quot;</span>, <span class="string">&quot;pic01.jpg&quot;</span>);</span><br><span class="line">        <span class="type">ThreadTest01</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest01</span>(</span><br><span class="line">                <span class="string">&quot;https://i0.hdslb.com/bfs/album/98d71302c030aa86258eb17a5db084bfadf8ff39.jpg@518w_1e_1c.jpg&quot;</span>, <span class="string">&quot;pic02.jpg&quot;</span>);</span><br><span class="line">        <span class="type">ThreadTest01</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest01</span>(</span><br><span class="line">                <span class="string">&quot;https://i0.hdslb.com/bfs/album/70849f611883c3e7feffc730c4f1e7b7173c9695.jpg@518w_1e_1c.jpg&quot;</span>, <span class="string">&quot;pic03.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始多线程下载</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WebDownLoader</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过url获取文件内容，并保存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downLoader</span><span class="params">(String url, String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用Commons_io包里面的方法copyURLToFile</span></span><br><span class="line">            FileUtils.copyURLToFile(<span class="keyword">new</span> <span class="title class_">URL</span>(url), <span class="keyword">new</span> <span class="title class_">File</span>(name));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;IO异常，downLoader出现问题&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213449.png" alt="image-20201031134111826"></p>
<p>多次运行发现（最好修改循环输出次数多一点），输出结果一般会不同，原因就是CPU在进行线程的调度。</p>
<h3 id="2、实现Runnable接口，重写run方法（建议使用）"><a href="#2、实现Runnable接口，重写run方法（建议使用）" class="headerlink" title="2、实现Runnable接口，重写run方法（建议使用）"></a>2、实现Runnable接口，重写run方法（建议使用）</h3><p>在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个Thread对象。</p>
<p>新线程创建之后，你调用它的 start() 方法它才会运行。</p>
<p>下面是一个创建线程并开始让它执行的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.xiancheng;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年07月29日 17:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_03</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//run方法线程体</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;我在写代码&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//main线程，主线程</span></span><br><span class="line">        <span class="comment">//创建ruunnable实现类对象</span></span><br><span class="line">        <span class="type">Thread_03</span> <span class="variable">thread_03</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread_03</span>();</span><br><span class="line">        <span class="comment">//创建线程对象通过线程对象实现我们的接口类</span></span><br><span class="line">		<span class="comment">//Thread thread = new Thread(thread_03);</span></span><br><span class="line">		<span class="comment">//thread.start();</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(thread_03).start();<span class="comment">//与上两行实现的结果是一样的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;我在学JAVA&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="typora/20210729223744.png" alt="image-20201031134702704"></p>
<p><strong>推荐使用：实现Runable()接口，因为可以有效的避免单继承的局限性，灵活方便，方便同一个对象被多个线程使用</strong></p>
<h3 id="3、实现Callable接口（不经常使用）"><a href="#3、实现Callable接口（不经常使用）" class="headerlink" title="3、实现Callable接口（不经常使用）"></a>3、实现Callable接口（不经常使用）</h3><p> 与使用runnable方式相比，callable功能更强大些：call方法可以有返回值，方法可以抛出异常，支持泛型的返回值，需要借助FutureTask类，获取返回结果等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.xiancheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年07月30日 11:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest03</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写具体业务操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello Callable&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadTest03</span> <span class="variable">callable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest03</span>();</span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待任务执行完毕，并返回结果</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get ();</span><br><span class="line">            System.out.println(<span class="string">&quot;result = &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>如上代码中的CallerTask 类实现了Callable 接口，并设置了返回值类型的</p>
</li>
<li><p>CallerTask 类重写了call（）方法。</p>
</li>
<li><p>在main 函数内首先创建了一个Futrue Task 对象（ 构造函数为CallerTask 的实例） ，</p>
</li>
<li><p>然后使用创建的FutrueTask对象作为任务创建了一个线程并且启动它，</p>
</li>
<li><p>最后通过futureTask.get（） 等待任务执行完毕并返回结果。</p>
</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213518.jpg" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213528.png" alt="img"></p>
<p>注意FutureTask这行代码 运行Callable</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213534.jpg" alt="img"></p>
<h2 id="一个线程的生命周期"><a href="#一个线程的生命周期" class="headerlink" title="一个线程的生命周期"></a>一个线程的生命周期</h2><p>创建、就绪、运行、阻塞、死亡</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213538.jpg" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213543.jpg" alt="img"></p>
<ul>
<li><p>新建状态:</p>
<blockquote>
<p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>
</blockquote>
</li>
<li><p>就绪状态:</p>
<blockquote>
<p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
</blockquote>
</li>
<li><p>运行状态:</p>
<blockquote>
<p>如果就绪状态的线程获取 CPU 资源，就可以执行 **run()**，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
</blockquote>
</li>
<li><p>阻塞状态:</p>
<blockquote>
<p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p>
<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。</li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。</li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。</li>
</ul>
</blockquote>
</li>
<li><p>死亡状态:</p>
<blockquote>
<p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>
</blockquote>
</li>
</ul>
<h2 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213557.jpg" alt="img"></p>
<h3 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h3><p>自定义停止方法 stop(）</p>
<ul>
<li>不推荐使用JDK提供的stop()、destroy()。</li>
<li>推荐让线程自己停下来，但也不建议使用死循环</li>
<li>建议使用一个标志位作为终止变量，当flag==false时，线程终止运行</li>
</ul>
<blockquote>
<p>思考为什么废弃了stop()方法？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.livorth.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestStop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子进程执行中---&quot;</span> + i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置个公开方法，利用标志位停止线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestStop</span> <span class="variable">testStop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestStop</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(testStop).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主进程执行中---&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">90</span>)&#123;</span><br><span class="line">                testStop.stop();</span><br><span class="line">                System.out.println(<span class="string">&quot;子进程结束运行&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><p>sleep 抛出异常, <strong>sleep不会释放锁</strong></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213612.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><p>yield，让当前线程转为就绪状态，进入就绪状态后 有可能调度器会再次调度该线程，让该线程进入运行状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程开始执行&quot;</span>);</span><br><span class="line">   Thread.yield();<span class="comment">//礼让</span></span><br><span class="line">   System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程停止执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213624.jpg" alt="img"></p>
<h3 id="线程插队"><a href="#线程插队" class="headerlink" title="线程插队"></a>线程插队</h3><p>join 对其他线程造成阻塞</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213630.jpg" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.livorth.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJoin</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行---&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestJoin</span> <span class="variable">testJoin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestJoin</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(testJoin);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">200</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//阻塞主线程，使子线程优先执行完</span></span><br><span class="line">                    thread.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行---&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当i==200时 vip线程插队了 main线程必须等vip线程执行完了，main线程才继续执行。</p>
<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行， 而是被中断的线程根据中断状态自行处理。</p>
<p>interrupt():中断线程。例如，当线程A 运行时，线程B 可以调用A的interrupt（） 方法来设置线程A 的中断标志为true 并立即返回。</p>
<blockquote>
<p>interrup()仅仅是设置标志， 线程A 实际并没有被中断， 它会继续往下执行。</p>
<p>但是如果线程A 因为调用了wait 系列函数、join 方法或者sle ep 方法而被阻塞挂起，这时候线程B 再调用A 的interrupt（） 方法，线程A 会抛出InterruptedException 异常而返回。</p>
</blockquote>
<p>isInterrupted() 方法：检测当前线程是否被中断，如果是返回true ， 否则返回false 。</p>
<p>interrupted()方法：检测当前线程是否被中断，如果是返回true ， 否则返回false 。与islnterrupted 不同的是，该方法如果发现当前线程被中断， 则会清除中断标志。</p>
<h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>1、NEW 尚未启动的线程处于此状态。</p>
<p>2、RUNAABLE 在Java虚拟机中执行的线程处于此状态。</p>
<p>3、BLOCKED 被阻塞等待监视器锁定的线程处于此状态。</p>
<p>4、WAITING 正在等待另一个线程执行特定动作的线程处于此状态。</p>
<p>5、TIMED_WAITING 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。</p>
<p>6、TEPM4INATED 已退出的线程处于此状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.xiancheng;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年07月29日 17:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread_State</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//运用lambda表达式对方法进行简化</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//观察状态</span></span><br><span class="line">        Thread.<span class="type">State</span> <span class="variable">state</span> <span class="operator">=</span> thread.getState();</span><br><span class="line">        System.out.println(state);<span class="comment">//期待输出NEW</span></span><br><span class="line">        <span class="comment">//观察启动后</span></span><br><span class="line">        thread.start();</span><br><span class="line">        state = thread.getState();</span><br><span class="line">        System.out.println(state);<span class="comment">//RUN</span></span><br><span class="line">        <span class="keyword">while</span>(state != thread.getState().TERMINATED)&#123;</span><br><span class="line">            thread.sleep(<span class="number">200</span>);</span><br><span class="line">            state = thread.getState();</span><br><span class="line">            System.out.println(state);<span class="comment">//RUN</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><ul>
<li><p>Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。</p>
</li>
<li><p>线程的优先级用数字表示，范围从1~10.</p>
<ul>
<li>Thread.MIN_ PRIORITY= 1;</li>
<li>Thread.MAX PRIORITY = 10;</li>
<li>Thread.NORM_ PRIORITY= 5;</li>
</ul>
</li>
<li><p>使用以下方式获取或改变优先级</p>
<ul>
<li>getPriority() ，setPriority(int xxx)</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li><strong>先设置优先级再启动</strong></li>
<li>main方法的默认优先级为5</li>
<li>理论上来说优先级越高的越先执行，哪怕他start更晚</li>
</ol>
<h3 id="守护线程（daemon）"><a href="#守护线程（daemon）" class="headerlink" title="守护线程（daemon）"></a>守护线程（daemon）</h3><ul>
<li>线程分为<strong>用户线程</strong>和<strong>守护线程</strong></li>
<li>虚拟机必须确保用户线程执行完毕.</li>
<li>虚拟机不用等待守护线程执行完毕</li>
<li>如，后台记录操作日志，监控内存，垃圾回收等待…</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.livorth.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDaemon</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Die</span> <span class="variable">die</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Die</span>();</span><br><span class="line">       <span class="type">You</span> <span class="variable">you</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">You</span>();</span><br><span class="line"></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(die);</span><br><span class="line">       <span class="comment">//将上帝设置为守护线程，在false的时候为用户线程</span></span><br><span class="line">       thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">       thread.start();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//开启一般的用户线程</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Thread</span>(you).start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Die</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//无限循环</span></span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;我是你爹&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">You</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;happy everyday&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">&quot;goodbye 爹&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程通知与等待"><a href="#线程通知与等待" class="headerlink" title="线程通知与等待"></a>线程通知与等待</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213650.jpg" alt="img"></p>
<h3 id="wait-函数何时不在等待？"><a href="#wait-函数何时不在等待？" class="headerlink" title="wait ()函数何时不在等待？"></a>wait ()函数何时不在等待？</h3><ul>
<li>其他线程调用了该共享对象的notify()或者notify All()方法；</li>
<li>其他线程调用了该线程的interrupt()方法，该线程抛出InterruptedExce ption 异常返回。</li>
</ul>
<h3 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h3><p>一个线程可以从挂起状态变为可以运行状态(也就是被唤醒)，即使该线程没有被其他线程调用<code>通知</code>或者被<code>中断</code>，或者等待超时，这就是所谓的虚假唤醒。</p>
<p>如何防范：加入一个判断，判断是否满足继续等待的条件，不满足则唤醒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">	<span class="keyword">while</span>(条件)&#123;</span><br><span class="line">    	obj.wait()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码是经典的调用共享变量wait（）方法的实例，首先通过同步块获取obj 上面的监视器锁，然后在while 循环内调用。obj的wait（） 方法。</p>
<h3 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h3><p><strong>解决方式：</strong></p>
<p>管程法:设置一个缓冲区，用于暂存数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.xiancheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者消费者问题，管程法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年07月30日 16:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        <span class="type">SynContainer</span> <span class="variable">container</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynContainer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producer</span>(container).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumer</span>(container).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producer</span><span class="params">(SynContainer container)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;生产了第&quot;</span> + i + <span class="string">&quot;件产品&quot;</span>);</span><br><span class="line">            container.push(<span class="keyword">new</span> <span class="title class_">Products</span>(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    SynContainer container;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(SynContainer container)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.container = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消费了第&quot;</span> + container.pop().id + <span class="string">&quot;件产品&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Products</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Products</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynContainer</span> &#123;</span><br><span class="line">    Queue&lt;Products&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生产者放入产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Products product)</span> &#123;</span><br><span class="line">        <span class="comment">//容器满，等待消费者消费</span></span><br><span class="line">        <span class="keyword">if</span> (count == size) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">                System.out.println(<span class="string">&quot;容器满，等待消费者消费&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没满，我们则需要存入成品,并唤醒消费者</span></span><br><span class="line">        count++;</span><br><span class="line">        queue.offer(product);</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者消费产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Products <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//容器为空，等待生产者生产</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">                System.out.println(<span class="string">&quot;容器为空，等待生产者生产&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//容器有剩，取出物品，并告诉生产者可以生产了</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="type">Products</span> <span class="variable">productPoll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">        <span class="keyword">return</span> productPoll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号灯法:设置一个标记位（类似于容量为1的管程法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.livorth.gaoji;</span><br><span class="line"></span><br><span class="line"><span class="comment">//信号灯法解决</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestPC2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建缓冲区</span></span><br><span class="line">        <span class="type">TheProduct</span> <span class="variable">theProduct</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">TheProduct</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Producers</span>(theProduct).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Consumers</span>(theProduct).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Producers</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    TheProduct theProduct;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Producers</span><span class="params">(TheProduct theProduct)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.theProduct = theProduct;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            theProduct.push(<span class="string">&quot;产品&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumers</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    TheProduct theProduct;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Consumers</span><span class="params">(TheProduct container)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.theProduct = container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            theProduct.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TheProduct</span>&#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    String product;</span><br><span class="line">    <span class="comment">//生产者生产，消费者等待</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(String product)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;生产者生产了&quot;</span> + product);</span><br><span class="line">        <span class="built_in">this</span>.product = product;</span><br><span class="line">        <span class="built_in">this</span>.flag = !<span class="built_in">this</span>.flag;</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费者消费，生产者等待</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;消费者消费了&quot;</span> + product);</span><br><span class="line">        <span class="built_in">this</span>.flag = !<span class="built_in">this</span>.flag;</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized锁升级过程</title>
    <url>/posts/6928685461da/</url>
    <content><![CDATA[<h1 id="Synchronized锁升级过程"><a href="#Synchronized锁升级过程" class="headerlink" title="Synchronized锁升级过程"></a>Synchronized锁升级过程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="synchronized-是什么"><a href="#synchronized-是什么" class="headerlink" title="synchronized 是什么"></a>synchronized 是什么</h3><p>synchronized  是java的 关键字，同时也代表着Java 内置锁，是用于线程间的同步，以及保护临界区内的资源。</p>
<p>在 Java 中，每个对象头中都隐藏着一把锁，而 synchronized 关键字就是激活这把锁的开关。</p>
<h3 id="Monitor-是什么"><a href="#Monitor-是什么" class="headerlink" title="Monitor 是什么"></a>Monitor 是什么</h3><p>Monitor 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个 Java 对象就有一把看不见的锁，称为内置锁或者 Monitor 锁。</p>
<p>Monitor 是<strong>线程私有</strong>的数据结构，每一个线程都有一个可用 monitor record 列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个 monitor 关联，同时 monitor 中有一个 Owner 字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。</p>
<h2 id="synchronized-3种使用方式"><a href="#synchronized-3种使用方式" class="headerlink" title="synchronized 3种使用方式"></a>synchronized 3种使用方式</h2><ol>
<li>修饰代码块：其作用域是被修饰的整个代码块里面的内容，锁住的是小括号中的对象，这个对象可以是类对象也可以是实例对象，或者也可以是指定的对象。</li>
<li>修饰静态方法：锁住当前类的 class对象</li>
<li>修饰非静态方法：只会锁住当前 class 的实例</li>
</ol>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101443001.png" alt="在这里插入图片描述"></p>
<h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><h3 id="1、作用对象是类"><a href="#1、作用对象是类" class="headerlink" title="1、作用对象是类"></a>1、作用对象是类</h3><p>作用范围是类及该类的所有对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedUsage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步代码块——锁的对象是类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedCodelockClass</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 这里锁住的是类</span></span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedUsage.class)&#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于锁住的是类的时候，虽然多个线程所关联的对象不一样，但这些对象都是SynchronizedUsage类的实例对象。所以甲乙线程不能并发执行，只能在当前已获得锁的线程执行完毕之后，才能由下一个线程去获得锁然后执行代码块。</p>
<p>synchronizedCodelockClass方法源码与编译后的样子，注意看行号，与编译后的LINENUMBER 相对应</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101451570.png" alt="image-20221209094157534"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101451499.png" alt="synchronizedCodelockClass方法编译后的样子"></p>
<h3 id="2、作用对象是实例对象"><a href="#2、作用对象是实例对象" class="headerlink" title="2、作用对象是实例对象"></a>2、作用对象是实例对象</h3><p>​    在SynchronizedUsage中添加2个方法，一个锁住当前对象，另一个锁住其他对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSynchronizedCodelockObjct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedUsage</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedUsage</span>();</span><br><span class="line">        <span class="type">SynchronizedUsage</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedUsage</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;启动&quot;</span>);</span><br><span class="line">            s3.synchronizedCodelockObjct();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread3.setName(<span class="string">&quot;丙线程&quot;</span>);</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;启动&quot;</span>);</span><br><span class="line">            s3.synchronizedCodelockObjct();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread4.setName(<span class="string">&quot;丁线程&quot;</span>);</span><br><span class="line">        thread4.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;启动&quot;</span>);</span><br><span class="line">            s4.synchronizedCodelockObjct();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread5.setName(<span class="string">&quot;戊线程&quot;</span>);</span><br><span class="line">        thread5.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;启动&quot;</span>);</span><br><span class="line">            s3.synchronizedCodelockObjct2();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread6.setName(<span class="string">&quot;己线程&quot;</span>);</span><br><span class="line">        thread6.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest</span>();</span><br><span class="line">        test.testSynchronizedCodelockObjct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SynchronizedUsage</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步代码块——锁的对象是对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedCodelockObjct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 这里锁住的是当前对象</span></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同步代码块——锁的对象是对象实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">synchronizedCodelockObjct2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">// 这里锁住的是当前对象</span></span><br><span class="line">        <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;锁的是object对象&quot;</span>);</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>丙线程和丁线程锁的是同一个对象s3，所以它们不能并发运行print方法；</li>
<li>戊线程作用的是另一个对象s4，因此它可以跟丙线程并发运行；</li>
<li>己线程虽然也是调用对象s3，但它锁住的对象是obj，跟丙、丁锁的对象不一致，所以它也可以跟戊、丙线程并发运行。</li>
</ul>
<p>synchronizedCodelockObjct方法编译后的样子</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101501518.png" alt="synchronizedCodelockObjct"></p>
<p>synchronizedCodelockObjct2方法编译后的样子</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101501001.png" alt="synchronizedCodelockObjct2"></p>
<h3 id="3、同步代码块原理"><a href="#3、同步代码块原理" class="headerlink" title="3、同步代码块原理"></a>3、同步代码块原理</h3><p> 查看编译后的字节码，会发现，被Synchronized修饰过的程序块，在编译后生成了 <strong>monitorenter</strong> 和 <strong>monitorexit</strong> 两个指令，monitorenter 指向同步代码块的开始位置，monitorexit 指明同步代码块的结束位置。</p>
<blockquote>
<p> monitorexit 指令出现了两次，第1次为同步正常退出释放锁，第2次为发生异步退出释放锁</p>
</blockquote>
<p>​    先看monitorenter指令。每个对象都是一个监视器锁（monitor）（不加 synchronized 的对象不会关联监视器），在虛拟机执行到monitorenter指令时，首先要尝试获取对象的锁，获取monitor的所有权。</p>
<ul>
<li>（1）如果monitor的进入数为0，表示这个对象没有被锁定，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者；</li>
<li>（2）如果当前线程已经占有该monitor，表示当前线程已经拥有了这个对象的锁，此时只是重新进入monitor，将monitor的进入数加1；</li>
<li>（3）如果其他线程已经占有了monitor，则当前线程获取monitor的所有权失败，当前线程进入阻塞状态等待，直到monitor的进入数为0，再重新尝试获取monitor的所有权；</li>
</ul>
<p>​    执行 monitorexit 指令的线程必须是对象锁所对应的 monitor 的所有者，也就是退出和进入必须是同一个monitor的持有者。monitorexit 指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</p>
<blockquote>
<p>由此可见，不管同步代码块作用对象是类还是类的实例，还是其他某个对象，原理都是一样的。</p>
</blockquote>
<h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><h3 id="1、同步普通方法"><a href="#1、同步普通方法" class="headerlink" title="1、同步普通方法"></a>1、同步普通方法</h3><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用反编译命令，查看反编译的字节码</p>
<blockquote>
<p>javap -verbose  SyncMethod &gt;&gt; SyncMethod.txt</p>
<p>或者</p>
<p>javap -c  SyncMethod &gt;&gt; SyncMethod.txt</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field count:I</span></span><br><span class="line">       <span class="number">5</span>: iconst_1</span><br><span class="line">       <span class="number">6</span>: iadd</span><br><span class="line">       <span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field count:I</span></span><br><span class="line">      <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">10</span></span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcn/lxiaol/synchronizedDemo/SyncMethod;</span><br></pre></td></tr></table></figure>

<p>方法标识 flags</p>
<ol>
<li>ACC_PUBLIC代表public修饰，</li>
<li><strong>ACC_SYNCHRONIZED</strong>指明该方法为同步方法</li>
</ol>
<h3 id="2、同步静态方法"><a href="#2、同步静态方法" class="headerlink" title="2、同步静态方法"></a>2、同步静态方法</h3><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译的字节码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span>;</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">       <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field count:I</span></span><br><span class="line">       <span class="number">3</span>: iconst_1</span><br><span class="line">       <span class="number">4</span>: iadd</span><br><span class="line">       <span class="number">5</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// Field count:I</span></span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">      line <span class="number">14</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>方法标识 flags</p>
<ol>
<li>ACC_PUBLIC代表public修饰，</li>
<li>ACC_STATIC代表static修饰</li>
<li><strong>ACC_SYNCHRONIZED</strong>指明该方法为同步方法</li>
</ol>
<h3 id="3、同步方法的原理"><a href="#3、同步方法的原理" class="headerlink" title="3、同步方法的原理"></a>3、同步方法的原理</h3><p>对比普通方法反编译后的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反编译后的内容</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: dup</span><br><span class="line">         <span class="number">2</span>: getfield      #<span class="number">2</span>                  <span class="comment">// Field count:I</span></span><br><span class="line">         <span class="number">5</span>: iconst_1</span><br><span class="line">         <span class="number">6</span>: iadd</span><br><span class="line">         <span class="number">7</span>: putfield      #<span class="number">2</span>                  <span class="comment">// Field count:I</span></span><br><span class="line">        <span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">14</span>: <span class="number">10</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">11</span>     <span class="number">0</span>  <span class="built_in">this</span>   Lcn/lxiaol/synchronizedDemo/SyncMethod;</span><br></pre></td></tr></table></figure>



<p>​    当Synchronize同步一个方法（既可以是普通方法，也可以是静态方法）时，通过反编译查看，被Synchronized修饰过的方法，在编译后并没 monitorenter 和 monitorexit 指令 ，相对于普通方法，其常量池中多了 <strong>ACC_SYNCHRONIZED</strong> 标示符。</p>
<p>​    这其实是一种隐式的方式，JVM根据 <strong>ACC_SYNCHRONIZED</strong> 标示符来实现方法的同步的。</p>
<ol>
<li>当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 是否被设置，</li>
<li>如果被设置，当前线程就去获取monitor，获取成功后才执行方法体，最后不管方法是否正常结束都会释放monitor。</li>
<li>在方法执行期间，其他线程都无法再获得同一个monitor对象。</li>
</ol>
<blockquote>
<p>  两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。</p>
</blockquote>
<p>​    monitorenter 和 monitorexit 指令的执行是JVM通过调用<strong>操作系统</strong>的互斥原语mutex来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p>
<h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>既然说它是<strong>对象锁</strong>，那我们就得去看看Java 对象长啥样</p>
<h3 id="Java对象组成"><a href="#Java对象组成" class="headerlink" title="Java对象组成"></a>Java对象组成</h3><p>java中对象是放在堆内存中的，对象大致可以分为三个部分，分别是<strong>对象头，实例变量和填充字节</strong></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101539768.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>对象头</strong>，主要包括三部分<ul>
<li><ol>
<li>Mark Word：标记字段，用于存储对象自身的运行时数据</li>
<li>Klass Pointer：类型指针，指向方法区中该 class 的对象，JVM 通过此字段来判断当前对象是哪个类的实例</li>
<li>数组长度：当且仅当对象是数组时才会有该字段</li>
</ol>
</li>
</ul>
</li>
<li><strong>实例变量</strong>，存放类的属性数据信息，包括父类的属性信息，这部分内存按4字节对齐</li>
<li><strong>填充字节</strong>，由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据<strong>不是必须存在的</strong>，仅仅是为了字节对齐，所以也叫对齐字节</li>
</ul>
<h3 id="Mark-Word（重点）"><a href="#Mark-Word（重点）" class="headerlink" title="Mark Word（重点）"></a>Mark Word（重点）</h3><p>Mark Word 所代表的<strong>运行时数据</strong>主要用来表示当前 Java 对象的<strong>线程锁状态</strong>以及 <strong>GC 的标志</strong>。而线程锁状态有四种，从级别由低到高依次是：<strong>无锁、偏向锁，轻量级锁，重量级锁</strong>，锁状态只能升级，不能降级。</p>
<p>如图所示：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101542442.png" alt="在这里插入图片描述"></p>
<p>Mark Word 可以表示 4 种不同的锁状态，其内部到底是怎么区分的呢？接下来我们通过图片直观的感受一下。</p>
<p>在32位的虚拟机中：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101542428.png" alt="在这里插入图片描述"></p>
<p>在64位的虚拟机中</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101542187.png" alt="在这里插入图片描述"></p>
<p>先解释一下几个名词</p>
<ul>
<li>unused：未使用</li>
<li>threadId：操作系统的线程id，也是偏向锁的线程id</li>
<li>epoch：偏向时间戳</li>
<li>age：分带年龄，由于最大四位，所以最大值是15，所以新生代对象到老年代最多经历15次</li>
<li>biased_lock：是否偏向锁标记，上图中的倒数第二列</li>
<li>lock：锁状态标记，上图中最后一列</li>
<li>lock record 指针：指向栈中锁记录的指针</li>
<li>ObjectMonitor 互斥量指针：指向重量级锁的指针</li>
</ul>
<p>下面我们以64位虚拟机为例，具体列举一下 Mark Word 每种状态下的含义</p>
<ul>
<li>001：无锁，有hash值，不可偏向状态 </li>
<li>101：无锁，无hash，可偏向状态（匿名偏向），因为线程id为空</li>
<li>101：已偏向，偏向锁</li>
<li>00：轻量锁</li>
<li>10 ：重量锁</li>
<li>11：GC标记清除markSweep</li>
</ul>
<h3 id="Mark-Word-代码验证"><a href="#Mark-Word-代码验证" class="headerlink" title="Mark Word 代码验证"></a>Mark Word 代码验证</h3><p>我们需要依赖一个工具JOL (JAVA OBJECT LAYOUT)可以通过pom.xml进行引入，这个版本号的不同，查看的内容格式也不同。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个版本号的不同，查看的内容格式也不同--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;version&gt;0.16&lt;/version&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="无锁，不可偏向状态-001"><a href="#无锁，不可偏向状态-001" class="headerlink" title="无锁，不可偏向状态 001"></a>无锁，不可偏向状态 001</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//  -XX:BiasedLockingStartupDelay=0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一次结果: &quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(<span class="keyword">new</span> <span class="title class_">Object</span>()).toPrintable());</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次结果: 无hash &quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> o.hashCode();</span><br><span class="line">        System.out.println(<span class="string">&quot;第三次结果:有hash &quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0.14版本：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101542446.png" alt="image-20221209163252371"></p>
<p>第一次果：无hash，无锁，不可偏向状态</p>
<blockquote>
<p>其实JVM默认是偏向状态的，但是JVM虚拟机有延迟，所以第一次结果就是无锁不可偏向状态。如果需要调整这个延迟的时间，可以通过参数 <code>-XX:BiasedLockingStartupDelay=0</code> 来控制。</p>
</blockquote>
<p>第二次结果：有hash，无锁，不可偏向状态，</p>
<blockquote>
<p>因为偏向锁中的threadId与hashcode复用存储空间，调用hashCode()之后会存入hash，就没有空间存偏向线程的id了。所以结果是 无锁，有hash，不可偏向</p>
</blockquote>
<p>0.16版本：看得更一目了然</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101542097.png" alt="image-20221209163417232"></p>
<p>同样第一次结果：无hash，无锁，不可偏向状态， non-biasable,</p>
<p>第二次结果：有hash，无锁，不可偏向状态，hash</p>
<h4 id="无锁，可偏向状态-101"><a href="#无锁，可偏向状态-101" class="headerlink" title="无锁，可偏向状态 101"></a>无锁，可偏向状态 101</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>); <span class="comment">//或者虚拟机设置  -XX:BiasedLockingStartupDelay=0</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次结果: &quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(o).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0.14版本：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101542047.png" alt="image-20221209164106119"></p>
<p>第一次结果：因为取消了虚拟机延迟，所以第一次结果就是 无锁，无hash，可偏向，匿名偏向</p>
<p>0.16版本：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101542340.png" alt="image-20221209164009641"></p>
<p>结果也是 可偏向，biasable</p>
<h4 id="可偏向状态，偏向锁-101"><a href="#可偏向状态，偏向锁-101" class="headerlink" title="可偏向状态，偏向锁 101"></a>可偏向状态，偏向锁 101</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="comment">//  关闭延迟开启偏向锁</span></span><br><span class="line">    	<span class="comment">//  -XX:BiasedLockingStartupDelay=0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一次结果: &quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;加锁后结果: &quot;</span>);</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;解锁后结果: &quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0.16版本：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101542253.png" alt="image-20221209164936407"></p>
<p>上图可以看到，关闭了偏向延迟之后。</p>
<p>第一次结果：无锁，无hash，可偏向状态。</p>
<p>加锁后结果：偏向锁，并且线程Id是后面那一大串。</p>
<p>解锁后结果：偏向锁，并且线程Id是后面那一大串。如果该线程再次加锁时，可以直接加锁，提高所得性能，类似于可重入锁。</p>
<h4 id="轻量锁（自旋锁）-00"><a href="#轻量锁（自旋锁）-00" class="headerlink" title="轻量锁（自旋锁） 00"></a>轻量锁（自旋锁） 00</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//  关闭延迟开启偏向锁</span></span><br><span class="line">        <span class="comment">//  -XX:BiasedLockingStartupDelay=0</span></span><br><span class="line">        System.out.println(<span class="string">&quot;第一次结果: &quot;</span>);</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程加锁: &quot;</span>);</span><br><span class="line">            System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程加锁: &quot;</span>);</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>0.16版本：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101543798.png" alt="image-20221209170446620"></p>
<p>由上图可以看到，</p>
<p>第一次结果：无锁，可偏向状态，</p>
<p>主线程加锁后：该对象进行第一次加锁，由可偏向状态转换为<strong>偏向锁</strong>，并且记录偏向线程ID</p>
<p>子线程加锁后：对改对象进行第二次加锁，由原来的偏向锁变更为<strong>轻量锁</strong>，并且也记录了轻量锁线程ID</p>
<h4 id="重量锁-10"><a href="#重量锁-10" class="headerlink" title="重量锁 10"></a>重量锁 10</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BiasLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//  关闭延迟开启偏向锁</span></span><br><span class="line">        <span class="comment">//  -XX:BiasedLockingStartupDelay=0</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1加锁: &quot;</span>);</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t2加锁: &quot;</span>);</span><br><span class="line">                System.out.println(ClassLayout.parseInstance(lock).toPrintable());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待t1, t2执行完, 否则无法打印</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>0.16版本：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101543293.png" alt="image-20221209172950002"></p>
<p>由于是两个线程在并发执行，会竞争锁，锁会膨胀为重量级锁，存储了重量级锁的互斥量指针</p>
<h4 id="GC标记清除-11"><a href="#GC标记清除-11" class="headerlink" title="GC标记清除 11"></a>GC标记清除 11</h4><p>这里暂不演示</p>
<h2 id="锁升级的过程"><a href="#锁升级的过程" class="headerlink" title="锁升级的过程"></a>锁升级的过程</h2><p>了解完 4 种锁状态之后，我们就可以整体的来看一下锁升级的过程了。</p>
<p>线程 A 进入 synchronized 开始抢锁，JVM 会判断当前是否是偏向锁的状态，如果是就会根据 Mark Word 中存储的线程 ID 来判断，当前线程 A 是否就是持有偏向锁的线程。如果是，则忽略 check，线程 A 直接执行临界区内的代码。</p>
<p>如果 Mark Word 里的线程不是线程 A，线程A 就会通过自旋尝试获取锁，如果A获取到了，就将 Mark Word 中的线程 ID 改为自己的；如果A竞争失败，锁就会膨胀为轻量级锁。</p>
<p>后续的竞争线程都会通过自旋来尝试获取锁，如果自旋成功那么锁的状态仍然是轻量级锁。如果轻量级锁竞争失败，锁会膨胀为重量级锁，后续竞争的线程都会被阻塞。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/202212101543269.png" alt="详细了解 Synchronized 锁升级过程_重量级锁_10"></p>
]]></content>
      <categories>
        <category>并发多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程基础（2）</title>
    <url>/posts/c46ecde49ecd/</url>
    <content><![CDATA[<h1 id="Java多线程基础（2）"><a href="#Java多线程基础（2）" class="headerlink" title="Java多线程基础（2）"></a>Java多线程基础（2）</h1><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><p>CPU通过分配时间片来执行任务，当一个任务的时间片用完，就会切换到另一个任务（也可能再次切换到自己身上）。在切换之前会保存上一个任务的状态，当下次再切换到该任务，就会加载这个状态。</p>
<p><strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p><strong>切出：</strong> 一个线程被剥夺处理器的使用权而被暂停运行</p>
<p><strong>切入：</strong> 一个线程被系统选中占用处理器开始或继续运行</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213739.png" alt="在这里插入图片描述"></p>
<p>上图的进度信息就是上下文，一般包括<code>通用寄存器</code>和<code>程序计数器</code>的内容。在切出时，操作系统会将线程的进度信息保存到内存。在切入时，操作系统需要从内存中加载线程的上下文。</p>
<h3 id="什么时候会发生上下文切换？"><a href="#什么时候会发生上下文切换？" class="headerlink" title="什么时候会发生上下文切换？"></a>什么时候会发生上下文切换？</h3><p><strong>自发性上下文切换指线程由于自身因素导致的切出。</strong>通过调用下列方法会导致自发性上下文切换：</p>
<ul>
<li>Thread.sleep()</li>
<li>Object.wait()</li>
<li>Thread.yeild()</li>
<li>Thread.join()</li>
<li>LockSupport.park()</li>
<li>sync hro ni zed</li>
</ul>
<p><strong>非自发性上下文切换指线程由于线程调度器的原因被迫切出。</strong>发生下列情况可能导致非自发性上下文切换：</p>
<ul>
<li>切出线程的时间片用完</li>
<li>有一个比切出线程优先级更高的线程需要被运行</li>
<li>虚拟机的垃圾回收动作</li>
</ul>
<h3 id="上下文切换的开销"><a href="#上下文切换的开销" class="headerlink" title="上下文切换的开销"></a>上下文切换的开销</h3><p><strong>直接开销</strong>有如下几点：</p>
<ul>
<li>操作系统保存回复上下文所需的开销</li>
<li>线程调度器调度线程的开销</li>
</ul>
<p><strong>间接开销</strong>有如下几点：</p>
<ul>
<li>处理器高速缓存重新加载的开销</li>
<li>上下文切换可能导致整个一级高速缓存中的内容被冲刷，即被写入到下一级高速缓存或主存</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal在set存数据到线程上下文context的时候，把自己[this]也放进去了。也就是这样的：</p>
<p>多钱程访问同一个共享变量时特别容易出现并发问题，特别是在多个线程需要对一个共享变量进行写入时。为了保证线程安全，一般使用者在访问共享变量时需要进行适当的同步，如图所示。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213750.png" alt="image-20210802161210847"></p>
<p><strong>ThreadLocal</strong>是线程上下文context的代理对象，context的目的是存放数据，自然ThreadLocal也是用来<strong>存放数据</strong>，所以主要用法就是set和get操作。 源码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal提供了线程本地变量，也就是如果你创建了一个ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。如图所示。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213800.png" alt="image-20210802162551398"></p>
<p>使用场景：可以将类变量放到ThreadLocal类型的对象中，使变量在每个线程中都有独立拷贝，不会出现一个线程读取变量时而被另一个线程修改的现象。最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理等。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.xiancheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.LocalVariable;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xpath.internal.operations.Variable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年08月02日 16:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建ThreadLocal 变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//打印当前线程本地内存中localVariable变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot;:&quot;</span> + localVariable.get());</span><br><span class="line">        <span class="comment">//清除当前线程本地内存中的localVariable 交量</span></span><br><span class="line">        <span class="comment">//localVariable.remove();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建多个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 设置线程t1中的本地变量localVariable的值</span></span><br><span class="line">            localVariable.set(<span class="string">&quot;t1 local variable&quot;</span>);</span><br><span class="line">            print(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 remove after&quot;</span> + <span class="string">&quot;:&quot;</span> + localVariable.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建多个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 设置线程t1中的本地变量localVariable的值</span></span><br><span class="line">            localVariable.set(<span class="string">&quot;t2 local variable&quot;</span>);</span><br><span class="line">            print(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 remove after&quot;</span> + <span class="string">&quot;:&quot;</span> + localVariable.get());</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocal的内存泄漏</p>
<p>什么是内存泄漏呢？简单的说，就是东西放在内存里面，但你忘记它放哪里了，它占着一块内存，但是不能回收。当这样的东西越来越多，内存就吃紧，最终导致服务器宕机。</p>
<h2 id="Java-中共享变量的内存可见性问题"><a href="#Java-中共享变量的内存可见性问题" class="headerlink" title="Java 中共享变量的内存可见性问题"></a>Java 中共享变量的内存可见性问题</h2><p>先来看看在多线程下处理共享变量时Java 的内存模型</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213815.png" alt="image-20210802172422294"></p>
<p>Java 内存模型规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内存里面的变量复制到自己的工作内存中，线程读写变量时操作的是自己工作内存中的变量，处理完后将变量值更新到主内存。</p>
<p>Java 内存模型是一个抽象的概念，那么在实际实现中线程的工作内存是什么呢？请看图</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213820.png" alt="image-20210802172650898"></p>
<p>图中所示是一个双核CPU 系统架构，每个核有自己的控制器和运算器，其中控制器包含一组寄存器和操作控制器，运算器执行算术逻辅运算。那么Java 内存模型里面的工作内存，就对应这里的Ll 或者L2 缓存或者CPU 的寄存器。</p>
<blockquote>
<p>每个核都有自己的一级缓存，在有些架构里面还有一个所有CPU 都共享的二级缓存。</p>
</blockquote>
<p>使用Java 中的volatile 关键字就可以解决共享变量内存不可见问题</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>是Java 提供的一种原子性内置锁，也叫监视器锁，是排他锁。也会导致上下文切换问题。</p>
<p>原理：synchronization的内存语义是 把synchronization块内使用到的共享变量从线程的工作内存中清除，从主内存中去获取，退出synchronization时候在将共享变量的值写入主内存中。</p>
<blockquote>
<p>但是synchronization会产生上下文切换问题，增加线程调度开销。</p>
</blockquote>
<h2 id="synchronized-根据队列-锁来实现同步"><a href="#synchronized-根据队列-锁来实现同步" class="headerlink" title="synchronized 根据队列+锁来实现同步"></a>synchronized 根据队列+锁来实现同步</h2><p>synchronized用在方法上，实际锁的是this对象，谁调用该方法谁就被锁上</p>
<p>synchronized (Obj ){…} 同步块，锁的是Obj这个对象 {}中的代码都被锁上了 </p>
<p>难点是确定需要上锁的对象和锁的范围  </p>
<p>一般来说需要上锁的对象是 可能出错的对象</p>
<p>锁的范围是 操作增删改数据的代码</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个或两个以上的线程，因为抢夺资源造成互相等待对方解锁，就导致谁都解不了锁</p>
<p>如下 资源A和资源B互相等待对方释放锁，造成了谁也解不开锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.xiancheng;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年08月02日 15:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockTest2</span> &#123;</span><br><span class="line">    <span class="comment">//创建资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resourceA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resourceB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">ta</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (resourceA)&#123;</span><br><span class="line">               System.out.println(Thread.currentThread()+<span class="string">&quot;get A and Lock A&quot;</span>);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                   System.out.println(<span class="string">&quot;e = &quot;</span> + e);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               System.out.println(Thread.currentThread()+<span class="string">&quot;wait get B&quot;</span>);</span><br><span class="line">               <span class="keyword">synchronized</span> (resourceB)&#123;</span><br><span class="line">                   System.out.println(Thread.currentThread()+ <span class="string">&quot;get B&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceB)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;get B and Lock B&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;e = &quot;</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(Thread.currentThread()+<span class="string">&quot;wait get A&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread()+ <span class="string">&quot;get A&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        ta.start();</span><br><span class="line">        tb.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213847.png" alt="image-20210802160732800"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213852.jpg" alt="img"></p>
<h2 id="Lock-锁（-java5）"><a href="#Lock-锁（-java5）" class="headerlink" title="Lock 锁（ java5）"></a>Lock 锁（ java5）</h2><p>显式定义锁对象，相比synchronized 更能直观的确定 谁被上锁了</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213859.jpg" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213908.jpg" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213912.jpg" alt="img"></p>
<p>对比</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213917.jpg" alt="img"></p>
<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p>该关键字可以确保对一个共享变量更新对其他线程马上可见，从而解决<code>内存可见性</code>问题。</p>
<p>写：当一个变量被声明为volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。</p>
<p>读：其他线程读取该共享变量时，不是从线程工作内存中获取，而是从主内存中读取最新值。</p>
<blockquote>
<p>保证了共享变量的可见性，但并不保证操作的原子性。</p>
</blockquote>
<p>何时使用</p>
<ul>
<li>写入变量值不依赖变量的当前值时。尤其是i++ 这类操作</li>
</ul>
<blockquote>
<p>因为如果依赖当前值，将是获取一计算一写入三步操作，这三步操作不是原子性的，而volatile <code>不保证原子性。</code></p>
</blockquote>
<ul>
<li>读写变量值时没有加锁。</li>
</ul>
<blockquote>
<p>因为加锁本身已经保证了内存可见性，这时候不需要把变量声明为vo latile 的。但是没加锁就需要加volatile 来保证可见性</p>
</blockquote>
<p>禁止指令重排</p>
<h2 id="原子性操作"><a href="#原子性操作" class="headerlink" title="原子性操作"></a>原子性操作</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213931.png" alt="image-20210816153149147"></p>
<p>查看字节码文件发现 ++value 对应的是 2、5、6、7 四步，其中第2步是获取当前value 的值放入栈顶，第5步是把常量1放入栈顶，第6步是当前栈顶的两个值相加并把结果放入栈顶，第7步是把栈顶的结果赋值给value。由此可见，++value，不具备原子性，</p>
<p>如何实现原子性呢？</p>
<p>1.synchronization关键字，但是会有阻塞降低了并发</p>
<p>2.使用AtomicXXX类</p>
<p>3.非阻塞CAS算法</p>
<h2 id="Java中的CAS操作"><a href="#Java中的CAS操作" class="headerlink" title="Java中的CAS操作"></a>Java中的CAS操作</h2><p>Compare and Swap 是Java提供的<code>非阻塞</code>原子性操作，它通过硬件保证了<code>比较--更新</code>操作的原子性</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object obj, <span class="type">long</span> offset, <span class="type">long</span> expect, <span class="type">long</span> newValue)</span></span><br></pre></td></tr></table></figure>

<p>CAS 有四个操作数， 分别为： 对象内存位置、对象中的变量的偏移量、变量预期值、新的值</p>
<p>其操作含义是， 如果对象obj 中内存偏移量为offset 的变量值为expect，则使用新的值newValue 替换旧的值expect。</p>
<blockquote>
<p>CAS是一个原子操作，用于多线程环境下的同步。它比较内存中的内容和给定的值，只有当两者相同时（说明其未被修改），才会修改内存中的内容。 </p>
</blockquote>
<h2 id="CAS的ABA-问题"><a href="#CAS的ABA-问题" class="headerlink" title="CAS的ABA 问题"></a>CAS的ABA 问题</h2><p>假如线程I 使用CAS 修改初始值为A 的变量X ， 那么线程I 会首先去获取当前变量X 的值（为A）， 然后使用CAS 操作尝试修改X 的值为B ， 如果使用CAS 操作成功了， 那么程序运行一定是正确的吗？</p>
<p>其实未必，这是因为有可能在线程I 获取变量X 的值A 后，在执行CAS 前，线程II 使用CAS 修改了变量X 的值为B ，然后又使用CAS 修改了变量X 的值为A 。所以虽然线程I 执行CAS时X 的值是A ， 但是这个A 己经不是线程I 获取时的A 了。这就是AB A 问题。</p>
<p>主要</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213940.png" alt="image-20210816161103733"></p>
<p>ABA 问题的产生是因为变量的状态值产生了环形转换，就是变量的值可以从A 到B,然后再从B 到A。如果变量的值只能朝着一个方向转换，比如A 到B , B 到C ， 不构成环形，就不会存在问题。</p>
<p>JDK 中的AtomicStampedReference 类给每个变量的状态值都配备了一个时间戳， 从而避免了ABA 问题的产生。</p>
<h2 id="Java-指令重排序"><a href="#Java-指令重排序" class="headerlink" title="Java 指令重排序"></a>Java 指令重排序</h2><p>Java 内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。</p>
<blockquote>
<p>多线程情况下会存在问题</p>
<p>使用volatile 修饰变量可以避免重排序和解决内存可见性问题</p>
</blockquote>
<p>写volatile 变量时，可以确保vo latile 写之前的操作不会被编译器重排序到vo latile 写之后。</p>
<p>读volatile 变量时，可以确保volatile 读之后的操作不会被编译器重排序到volatile读之前。</p>
<h2 id="伪共享-先忽略"><a href="#伪共享-先忽略" class="headerlink" title="伪共享(先忽略)"></a>伪共享(先忽略)</h2><h2 id="锁的概述"><a href="#锁的概述" class="headerlink" title="锁的概述"></a>锁的概述</h2><h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><p>悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。</p>
<p>乐观锁是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测</p>
<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><p>根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁，</p>
<p>公平锁：线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，先到先得。（带来性能开销）</p>
<p>而非公平锁则在运行时闯入，也就是先来不一定先得。</p>
<h3 id="独占锁与共享锁"><a href="#独占锁与共享锁" class="headerlink" title="独占锁与共享锁"></a>独占锁与共享锁</h3><p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。</p>
<p>独占锁保证任何时候都只有一个线程能得到锁,是<code>悲观锁</code>。 ReentrantLock 就是以独占方式实现的。</p>
<p>共享锁则可以同时由多个线程持有，是<code>乐观锁</code>。例如ReadWriteLock 读写锁，它允许一个资源可以被多线程同时进行读操作。</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取它自己己经获取的锁时是否会被阻塞呢？如果不被阻塞，那么我们说该锁是可重入的，也就是只要该线程获取了该锁，那么可以无限次数（在高级篇中我们将知道，严格来说是有限次数）地进入被该锁锁住的代码。</p>
<p>synchronized 内部锁是可重入锁</p>
<p>可重入锁的原理：</p>
<p>在锁内部维护一个线程<br>标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。一开始计数器值为0,说明该锁没有被任何线程占用。当一个钱程获取了该锁时，计数器的值会变成1 ，这时其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞挂起。</p>
<p>但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加＋ 1,当释放锁后计数器值－ 1 。当计数器值为0 时－，锁里面的线程标示被重置为null ， 这时候被阻塞的线程会被唤醒来竞争获取该锁。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>线程的状态切换（阻塞/运行）开销是比较大的，在一定程度上会影响并发性能。</p>
<p>自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU 使用权的情况下，多次尝试获取（默认次数是10 ，可以使用－XX :PreB lockS pins h 参数设置该值），很有可能在后面几次尝试中其他线程己经释放了锁。但是也有可能得不到，白白浪费cpu时间。</p>
<p>自旋锁是使用CPU 时间换取线程阻塞与调度的开销，但是很有可能这些CPU 时间白白浪费。</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p>
]]></content>
      <categories>
        <category>并发多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL之索引</title>
    <url>/posts/a144b91bc3ff/</url>
    <content><![CDATA[<h1 id="MySQL之索引"><a href="#MySQL之索引" class="headerlink" title="MySQL之索引"></a>MySQL之索引</h1><h1 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h1><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：<code>索引是数据结构</code>。</p>
<p>我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。</p>
<p>最基本的查询算法当然是顺序查找（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如二分查找（binary search）、二叉树查找（binary tree search）等。</p>
<p>如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于二叉查找树上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织）。</p>
<p>所以，<code>在数据之外，数据库系统还维护着满足特定查找算法的数据结构</code>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325223902.png" alt="在这里插入图片描述"></p>
<p>上图展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在O(log2n)的复杂度内获取到相应数据。</p>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种红黑树（red-black tree）实现的，原因会在下文介绍</p>
<p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。</p>
<p>索引如果没有特别指明，都是指B-Tree（多路搜索树，并不一定是二叉树）结构组织的索引。</p>
<p>其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引。</p>
<p>除了B+树索引，还有哈希索引。</p>
<h1 id="索引的优势和劣势"><a href="#索引的优势和劣势" class="headerlink" title="索引的优势和劣势"></a>索引的优势和劣势</h1><p>优势</p>
<ul>
<li><p>提高数据检索的效率，降低磁盘IO成本</p>
</li>
<li><p>数据排序，降低CPU消耗</p>
</li>
</ul>
<p>劣势</p>
<ul>
<li>占用数据库空间</li>
<li>降低表的更新速度</li>
</ul>
<h1 id="MySQL的索引结构"><a href="#MySQL的索引结构" class="headerlink" title="MySQL的索引结构"></a>MySQL的索引结构</h1><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325223906.png" alt="在这里插入图片描述"></p>
<p>【初始化介绍】</p>
<p>磁盘块 1 包含数据项 17 和 35，包含指针 P1、P2、P3， P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。</p>
<p>真实数据存在于叶子节点即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。</p>
<p>非叶子节点不存储真实数据，只存储指引搜索方向的数据项，如 17、35 并不真实存在于数据表中。</p>
<p>【查找过程】</p>
<p>模拟查找关键字29的过程：</p>
<ol>
<li>从根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】<code>根节点常驻内存</code></li>
<li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
<li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
<li>在磁盘块8中的关键字列表中做二分查找找到关键字29。</li>
</ol>
<h2 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p>
<p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点能存储的key的数量很小，导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。</p>
<p>在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
<p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： </p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325223915.png" alt="在这里插入图片描述"></p>
<p> 通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的<code>叶子节点</code>，而且所有叶子节点（即数据节点）之间是一种链式环结构，<code>方便顺序遍历</code>（例如查看一个目录下的所有文件，一个表中的所有记录等）。</p>
<blockquote>
<p>因此B+Tree有两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p>
</blockquote>
<h2 id="B-Tree-与-B-Tree-的区别"><a href="#B-Tree-与-B-Tree-的区别" class="headerlink" title="B+Tree 与 B-Tree 的区别"></a>B+Tree 与 B-Tree 的区别</h2><p>B+Tree相对于B-Tree有几点不同：</p>
<ol>
<li>非叶子节点只存储键值信息和指向下一个节点的索引。</li>
<li>所有叶子节点之间都有一个链指针。</li>
<li>数据记录都存放在叶子节点中。</li>
<li>在 B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在</li>
<li>B+树中每个记录 的查找时间基本相同，都需要从根节点走到叶子节点，在叶子节点中还要再比较关键字。</li>
</ol>
<blockquote>
<p>从这4.5两点来看B-Tree的性能好像要比 B+Tree好，而在实际应用中却是 B+树的性能要好些。</p>
<p>因为 B+树的非叶子节点不存放实际的数据， 这样每个节点可容纳的元素个数比 B-树多，树高比 B-树小，这样带来的好处是减少磁盘访问次数。</p>
<p>虽然B+树找到 一个记录所需的内存比较次数要比 B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中 B+树的性能可能还会好些，而且 B+树的叶子节点使用指针连接在一起，<code>方便顺序遍历</code>，这也是很多数据库和文件系统使用 B+树的缘故。</p>
</blockquote>
<h2 id="B-Tree的优势"><a href="#B-Tree的优势" class="headerlink" title="B+Tree的优势"></a>B+Tree的优势</h2><ul>
<li>B+树的磁盘读写代价更低</li>
<li>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点 的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就 越多。相对来说 IO 读写次数也就降低了</li>
<li>B+树的查询效率更加稳定，由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须 走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ul>
<h1 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h1><p>数据库中的B+Tree索引可以分为聚簇索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚簇索引，聚簇索引的B+Tree中的叶子节点存放的是整张表的行记录数据。</p>
<p>辅助索引与聚簇索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚簇索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。</p>
<p>聚簇索引并不是一种单独的索引类型，而是一种<code>数据存储方式</code>。术语‘聚簇’表示数据行和相邻的键值聚簇的存储 在一起。如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325223933.png" alt="在这里插入图片描述"></p>
<h2 id="聚簇索引的好处"><a href="#聚簇索引的好处" class="headerlink" title="聚簇索引的好处"></a>聚簇索引的好处</h2><p>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不不用从多个数据块中提取数据，所以节省了大量的 io 操作。</p>
<h2 id="聚簇索引的限制"><a href="#聚簇索引的限制" class="headerlink" title="聚簇索引的限制"></a>聚簇索引的限制</h2><p>对于 mysql 数据库目前只有 <code>innodb 数据引擎支持聚簇索引</code>，而 Myisam 不支持聚簇索引。 </p>
<p>由于数据物理存储排序方式只能有一种，所以每个 Mysql 的表只能有一个聚簇索引。一般情况下就是该表的主键。 为了充分利用聚簇索引的聚簇的特性，所以 innodb 表的主键列尽量选用有序的顺序 id，而不建议用无序的 id，比如 uuid。</p>
<h1 id="B-Tree索引实现"><a href="#B-Tree索引实现" class="headerlink" title="B+Tree索引实现"></a>B+Tree索引实现</h1><h2 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h2><p>MyISAM引擎使用B+Tree作为索引结构，<code>叶节点的data域存放的是数据记录的地址</code>。下图是MyISAM索引的原理图：<br><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325223942.png" alt="在这里插入图片描述"></p>
<p>这里假设表一共有三列，假设我们以Col1为主键，上图是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。</p>
<p><code>在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复</code>。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：<br><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325223949.png" alt="在这里插入图片描述"></p>
<p>上图同样也是一颗B+Tree，data域保存数据记录的地址。</p>
<p>因此，MyISAM中索引检索的算法:</p>
<ul>
<li>首先按照B+Tree搜索算法搜索索引，</li>
</ul>
<ul>
<li>如果指定的Key存在，则取出其data域的值，</li>
<li>然后以data域的值为地址，读取相应数据记录。</li>
</ul>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h2 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h2><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的<code>叶节点data域保存了完整的数据记录</code>。这个索引的key是数据表的主键，因此<code>InnoDB表数据文件本身就是主索引</code>。<br><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325223954.png" alt="在这里插入图片描述"></p>
<p>图10</p>
<p>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做<code>聚集索引</code>。</p>
<blockquote>
<p>因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
</blockquote>
<p>第二个与MyISAM索引的不同是<code>InnoDB的辅助索引data域存储相应记录主键的值</code>而不是地址。换句话说，<code>InnoDB的所有辅助索引都引用主键作为data域</code>。例如，图11为定义在Col3上的一个辅助索引：<br><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325224003.png" alt="在这里插入图片描述"></p>
<p>图11</p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<h1 id="为什么使用B-Tree（B-Tree）"><a href="#为什么使用B-Tree（B-Tree）" class="headerlink" title="为什么使用B-Tree（B+Tree）"></a>为什么使用B-Tree（B+Tree）</h1><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p>
<blockquote>
<p>一般来说，索引往往以索引文件的形式存储的磁盘上。索引查找过程中产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p>
</blockquote>
<h2 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h2><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。<br><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325224009.png" alt="在这里插入图片描述"></p>
<p>图5</p>
<p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p>
<p>主存的存取过程如下：</p>
<p>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p>
<p>写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p>
<p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p>
<h2 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h2><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。</p>
<p>图6是磁盘的整体结构示意图。<br><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325224019.png" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325224022.png" alt="img"></p>
<p>图6</p>
<p>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。</p>
<p>图7是磁盘结构的示意图。<br><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325224026.png" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325224029.png" alt="img"></p>
<p>图7</p>
<p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p>
<p>磁盘读取时，系统将数据逻辑地址传给磁盘，磁盘的控制电路会解析出物理地址（哪个磁道，哪个扇区），于是磁头需要前后移动到相应的磁道——寻道，消耗的时间叫——寻道时间，磁盘旋转将对应的扇区转到磁头下（磁头找到对应磁道的对应扇区），消耗的时间叫——旋转时间，这一系列操作是非常耗时。</p>
<h2 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h2><p><strong>局部性原理</strong>：当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<blockquote>
<p>程序运行期间所需要的数据通常比较集中。</p>
</blockquote>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数，页是计算机管理存储器的逻辑块。</p>
<blockquote>
<p>硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
</blockquote>
<p>计算机系统是分页读取和存储的，一般一页为<strong>4KB</strong>（8个扇区，每个扇区125B，8*125B=4KB），每次读取和存取的最小单元为一页，而磁盘预读时通常会读取页的整倍数。</p>
<h2 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h2><p>根据B-Tree的定义，可知检索一次最多需要访问h个节点。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325224036.png" alt="image-20220310155849994"></p>
<p>数据库系统的设计者巧妙利用了磁盘预读原理，<strong>将一个节点的大小设为等于一个页</strong>，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（<strong>根节点常驻内存</strong>），渐进复杂度为O（h）=O（logdN）。一般d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p>
<p>dmax=floor(pagesize/(keysize+datasize+pointsize))dmax=floor(pagesize/(keysize+datasize+pointsize))</p>
<p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>B-Tree：如果一次检索需要访问4个节点，数据库系统设计者利用磁盘预读原理，把节点的大小设计为一个页，那读取一个节点只需要一次I/O操作，完成这次检索操作，最多需要3次I/O(根节点常驻内存)。数据记录越小，每个节点存放的数据就越多，树的高度也就越小，I/O操作就少了，检索效率也就上去了。</p>
<p>B+Tree：非叶子节点只存key，大大滴减少了非叶子节点的大小，那么每个节点就可以存放更多的记录，树更矮了，I/O操作更少了。所以B+Tree拥有更好的性能。</p>
<h1 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h1><p>常见的索引类型有：主键索引、唯一索引、普通索引、全文索引、组合索引等</p>
<p>主键索引：根据主键建立的索引，不允许重复，不允许空值</p>
<p>唯一索引： 用来建立索引的列的值必须是唯一的，允许空值</p>
<p>普通索引：用表中的普通列构建的索引，没有任何限制</p>
<p>全文索引：用大文本对象的列构建的索引</p>
<p>组合索引：用多个列组合构建的索引，这多个列中的值不允许有空值</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的 目的在于选择合适算法和改进算法。 时间复杂度是指执行算法所需要的计算工作量，用大 O 表示记为：O(…)</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325224043.png" alt="在这里插入图片描述"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325224048.png" alt="在这里插入图片描述"></p>
<h1 id="索引创建的条件"><a href="#索引创建的条件" class="headerlink" title="索引创建的条件"></a>索引创建的条件</h1><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><ul>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>与其他表关联的字段，外键关系应该创建索引</li>
<li>查询中排序的字段</li>
<li>查询中统计的字段或者分组字段</li>
</ul>
<h2 id="无需创建索引"><a href="#无需创建索引" class="headerlink" title="无需创建索引"></a>无需创建索引</h2><ul>
<li>数据表记录太少</li>
<li>频繁更新的字段（如果创建索引，每当更新字段都会更新索引）</li>
<li>数据重复且分布平均的字段，不宜创建索引（性别字段，国籍字段等）</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/MySQL%E4%B9%8B%E7%B4%A2%E5%BC%95/20220325224100.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>mysql</category>
        <category>索引</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 技术书籍大全</title>
    <url>/posts/5e7e5e050ddc/</url>
    <content><![CDATA[<h1 id="Java-技术书籍大全"><a href="#Java-技术书籍大全" class="headerlink" title="Java 技术书籍大全"></a>Java 技术书籍大全</h1><p>本文档目前已收录 <b>277</b>本 Java相关领域经典技术书籍，从初级开发者到资深架构师，涵盖 Java 从业者的各个阶段，并持续更新。</p>
<p>涵盖领域：Java入门书籍，Java基础及进阶书籍，框架与中间件，架构设计，设计模式，数学与算法，JVM周边语言，项目管理&amp;领导力&amp;流程，职业素养与个人成长，格局与视野，面试参考书等。</p>
<h2 id="入门书籍"><a href="#入门书籍" class="headerlink" title="入门书籍"></a>入门书籍</h2><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TA6z3m">《明解Java》</a> - 豆瓣评分 8.5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7urNtH">《Java从入门到精通（第4版 附光盘）》</a> - 豆瓣评分 6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/2dDnsY">《入门很简单丛书：Java Web开发入门很简单》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7zm17P">《程序员炼成记 从小白到工程师》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZCbVjQ">《Java从小白到大牛》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mnkAJR">《JavaWeb项目开发实战入门（全彩版）》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/9TGA0S">《Java精彩编程200例（全彩版）》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zMDeI7">《Java轻松学》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/td3bUo">《大话Java：程序设计从入门到精通（含DVD光盘1张）》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HOFu01">《Java语言袖珍指南（第二版）》</a></li>
</ul>
<h2 id="基础书籍"><a href="#基础书籍" class="headerlink" title="基础书籍"></a>基础书籍</h2><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ajylTp">《Java编程思想（第4版） [thinking in java]》</a> - 豆瓣评分 9.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/tp87o1">《Java核心技术 卷I：基础知识（原书第10版）》</a> - 豆瓣评分 8.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fYGMsC">《Java核心技术卷II：高级特性（原书第10版）》</a> - 豆瓣评分 7.7</li>
</ul>
<h3 id="多线程与并发"><a href="#多线程与并发" class="headerlink" title="多线程与并发"></a>多线程与并发</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ERgtGV">《华章专业开发者丛书·Java并发编程实战》</a> - 豆瓣评分 9.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XRUB8H">《Java多线程编程实战指南（设计模式篇）》</a> - 豆瓣评分 8.5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/LDOFjh">《图解Java多线程设计模式》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/WXhQuO">《实战Java高并发程序设计》</a> - 豆瓣评分 8.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/e5tZdf">《Java高并发编程详解：多线程与架构设计》</a> - 豆瓣评分 7.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5p2KoJ">《Java核心技术系列：Java多线程编程核心技术 [Java Multi-thread Programming]》</a> - 豆瓣评分 5.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/RQu2W6">《Java并发编程：核心方法与框架》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fkn9NP">《Java多线程与Socket：实战微服务框架》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZwyPCp">《NIO与Socket编程技术指南》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/vB6BA2">《Java并发编程之美》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fthTzf">《实战Java高并发程序设计（第2版）》</a></li>
</ul>
<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/osowEq">《Java网络编程（第四版） [Java network programming, forth edition]》</a> - 豆瓣评分 7.6</li>
</ul>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wdrJls">《数据结构与算法分析：Java语言描述（原书第3版）》</a> - 豆瓣评分 8.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/9GKS26">《图解数据结构：使用Java》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DCJzy6">《数据结构与算法Java语言描述》</a></li>
</ul>
<h3 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/MNwLHg">《Java 8实战》</a> - 豆瓣评分 9.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/M6XqLp">《Java函数式编程》</a> - 豆瓣评分 8.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/YApFXv">《Java编程的逻辑》</a> - 豆瓣评分 8.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/UZgI0F">《O’Reilly：Head First Java（中文版 第2版 涵盖Java5.0）》</a> - 豆瓣评分 8.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZCMWOr">《写给大忙人看的Java核心技术》</a> - 豆瓣评分 7.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ajoGad">《精通lambda表达式：Java多核编程 [Mastering Lambdas: Java Programming in a Multicore]》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5HXsKg">《Java 9模块化开发：核心原则与实践》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/l7fy1C">《Java JDK 9学习笔记》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/CqmtBM">《Java 9编程参考官方大全（第10版） [Java：Thte Complete Reference，Tenth Edition]》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JMdy64">《写给大忙人的Java SE 9核心技术》</a></li>
</ul>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/MBhyO7">《深入分析Java Web技术内幕（修订版）》</a> - 豆瓣评分 7.5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GEdlD0">《Java RESTful Web Service实战（第2版）》</a></li>
</ul>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qTFNCP">《Java性能优化权威指南 [Java performance]》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6CYRQi">《Java程序性能优化：让你的Java程序更快、更稳定》</a> - 豆瓣评分 8.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/KmJo2x">《Java性能权威指南》</a> - 豆瓣评分 8.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GKe55M">《51CTO学院系列丛书·实战Java虚拟机：JVM故障诊断与性能优化》</a> - 豆瓣评分 8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/sQPN8w">《Java性能调优指南》</a> - 豆瓣评分 7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Uqaj5n">《大话Java性能优化》</a> - 豆瓣评分 4.4</li>
</ul>
<h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/nvsfLb">《响应式架构：消息模式Actor实现与Scala、Akka应用集成》</a> - 豆瓣评分 8.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HeIp16">《RxJava响应式编程》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/iIZc0A">《RxJava 2.x 实战》</a></li>
</ul>
<h3 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DgTnN2">《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》</a> - 豆瓣评分 8.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/73DIJB">《Java核心技术系列：Java虚拟机规范（Java SE 8版） [The Java Virtual Machine Specification Jave SE 8 Edition]》</a> - 豆瓣评分 8.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ct4KRw">《揭秘Java虚拟机：JVM设计原理与实现》</a> - 豆瓣评分 7.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xJZjRH">《HotSpot实战》</a> - 豆瓣评分 7.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0ZMjqZ">《Java从入门到动手写虚拟机1（套装共2册）》</a></li>
</ul>
<h3 id="代码-amp-设计优化"><a href="#代码-amp-设计优化" class="headerlink" title="代码&amp;设计优化"></a>代码&amp;设计优化</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/QSoCEv">《重构 改善既有代码的设计 Java语言版》</a> - 豆瓣评分 9.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wxQc3i">《代码大全（第2版）》</a> - 豆瓣评分 9.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/syzAFD">《Effective Java中文版（原书第3版）》</a> - 豆瓣评分 9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Rt31CM">《代码整洁之道 程序员的职业素养》</a> - 豆瓣评分 8.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XBQxz8">《代码整洁之道 [Clean Code A Handbook of Agile Software Craftsmanship]》</a> - 豆瓣评分 8.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ld8p0r">《Spring实战（第4版）》</a> - 豆瓣评分 8.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0hnAnw">《代码不朽：编写可维护软件的10大要则（Java版）》</a> - 豆瓣评分 7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/tyYWro">《Java代码与架构之完美优化 实战经典》</a></li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/SJWtpV">《反应式设计模式》</a> - 豆瓣评分 9.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/IGKmVq">《O’Reilly：Head First设计模式（中文版）》</a> - 豆瓣评分 9.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/D59mge">《设计模式：可复用面向对象软件的基础》</a> - 豆瓣评分 9.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/lFwQdc">《实现领域驱动设计 [Implementing Domain-Driven Design]》</a> - 豆瓣评分 8.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/yxTBEJ">《原创精品系列：设计模式之禅（第2版）》</a> - 豆瓣评分 8.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/H9tRFl">《图解设计模式》</a> - 豆瓣评分 8.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qfAaGS">《大话设计模式》</a> - 豆瓣评分 8.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/PllZtF">《领域驱动设计 软件核心复杂性应对之道 修订版》</a> - 豆瓣评分 8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xRo8Ur">《Java测试驱动开发》</a> - 豆瓣评分 6.6</li>
</ul>
<h2 id="框架与中间件"><a href="#框架与中间件" class="headerlink" title="框架与中间件"></a>框架与中间件</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/i4KCQO">《高性能MySQL（第3版）》</a> - 豆瓣评分 9.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Th90ra">《MySQL技术内幕：InnoDB存储引擎（第2版）》</a> - 豆瓣评分 8.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/YivOvQ">《大型网站系统与Java中间件实践》</a> - 豆瓣评分 7.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HjaHc2">《深入浅出MySQL 数据库开发 优化与管理维护 第2版》</a> - 豆瓣评分 7.5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oYHlHw">《PostgreSQL修炼之道：从小工到专家》</a> - 豆瓣评分 7.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/hKsMRX">《PostgreSQL技术内幕：查询优化深度探索》</a></li>
</ul>
<h3 id="缓存与NoSQL"><a href="#缓存与NoSQL" class="headerlink" title="缓存与NoSQL"></a>缓存与NoSQL</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/uZirI6">《Redis 深度历险：核心原理与应用实践》</a> - 豆瓣评分 9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VMo7w2">《Redis实战》</a> - 豆瓣评分 8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GmFr7B">《Redis入门指南（第2版）》</a> - 豆瓣评分 7.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TKeCR2">《深入分布式缓存：从原理到实践》</a> - 豆瓣评分 7.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8DuE9W">《人人都是架构师：分布式系统架构落地与瓶颈突破》</a> - 豆瓣评分 6.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qd9tLA">《MongoDB应用设计模式》</a> - 豆瓣评分 6.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Mlefug">《MongoDB实战 架构、开发与管理》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1QhhB6">《NoSQL数据库入门与实践（基于MongoDB、Redis）》</a></li>
</ul>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4SyxGo">《RabbitMQ实战指南》</a> - 豆瓣评分 9.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qIwmGY">《Kafka权威指南》</a> - 豆瓣评分 8.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/hqBGgy">《Kafka入门与实践》</a> - 豆瓣评分 7.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/vyU3eK">《RocketMQ实战与原理解析》</a> - 豆瓣评分 7.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GZh0yK">《Kafka技术内幕 图文详解Kafka源码设计与实现》</a> - 豆瓣评分 6.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/sTtFQn">《深入理解Kafka：核心设计与实践原理》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GzBNOZ">《分布式消息中间件实践》</a></li>
</ul>
<h3 id="ORM框架"><a href="#ORM框架" class="headerlink" title="ORM框架"></a>ORM框架</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0GXsRh">《MyBatis从入门到精通》</a> - 豆瓣评分 7.7</li>
</ul>
<h3 id="Spring家族"><a href="#Spring家族" class="headerlink" title="Spring家族"></a>Spring家族</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ohN8uh">《Spring微服务实战》</a> - 豆瓣评分 8.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/z1QvAP">《Spring Cloud微服务实战》</a> - 豆瓣评分 7.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/FfCbxt">《深入理解Spring Cloud与微服务构建》</a> - 豆瓣评分 7.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wAPeEw">《MyBatis技术内幕》</a> - 豆瓣评分 7.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/BcQznU">《Spring Boot实战》</a> - 豆瓣评分 7.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/k0xgoA">《深入浅出Spring Boot 2.x》</a> - 豆瓣评分 7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4Rtvg3">《JavaEE开发的颠覆者：Spring Boot实战》</a> - 豆瓣评分 6.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/2rz8BY">《Spring技术内幕：深入解析Spring架构与设计原理（第2版）》</a> - 豆瓣评分 5.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xrNcv1">《Spring Boot 2精髓：从构建小系统到架构分布式大系统》</a> - 豆瓣评分 4.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/dtDOqc">《Spring 5开发大全》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oFsaYt">《Spring Cloud微服务架构进阶》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/SdhhtK">《Spring源码深度解析 第2版》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ghc04R">《Spring MVC实战》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fCZpVU">《Spring Boot编程思想（核心篇）（限量版亲笔签名书签 随机发售）》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HO244A">《互联网轻量级SSM框架解密：Spring、Spring MVC、MyBatis源码深度剖析》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/O9L5Nb">《Spring学习指南 第3版》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/k4WSg3">《精通Spring MVC 4》</a></li>
</ul>
<h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/htIJgi">《Netty实战》</a> - 豆瓣评分 7.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/81Pbod">《七周七并发模型》</a> - 豆瓣评分 7.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7tGXx5">《Netty权威指南（第2版）》</a> - 豆瓣评分 6.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VBYLE0">《Netty进阶之路：跟着案例学Netty》</a></li>
</ul>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/3rp1Hv">《从Paxos到Zookeeper分布式一致性原理与实践》</a> - 豆瓣评分 7.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/LAyupw">《ZooKeeper：分布式过程协同技术详解》</a> - 豆瓣评分 7.2</li>
</ul>
<h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/IdftoH">《从Lucene到Elasticsearch：全文检索实战》</a></li>
</ul>
<h3 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/BlEDc7">《Hadoop权威指南：大数据的存储与分析(第4版)》</a> - 豆瓣评分 8.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/dW1kpa">《Hadoop构建数据仓库实践》</a> - 豆瓣评分 8.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wqb9z0">《HBase权威指南 [HBase： The Definitive Guide]》</a> - 豆瓣评分 8.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/azPD8S">《图解Spark：核心技术与案例实战》</a> - 豆瓣评分 7.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/bd1YCS">《Hive编程指南 [Programming Hive]》</a> - 豆瓣评分 7.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/kFRuj2">《HBase应用架构》</a></li>
</ul>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pTZ8xk">《Web性能权威指南》</a> - 豆瓣评分 8.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7tOuAz">《从零开始学架构：照着做，你也能成为架构师》</a> - 豆瓣评分 8.5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Qs9SXn">《Java应用架构设计：模块化模式与OSGi》</a> - 豆瓣评分 6.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GVYZr9">《大型网站技术架构演进与性能优化》</a> - 豆瓣评分 6.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7y5NpR">《高可用架构（第1卷）》</a> - 豆瓣评分 6.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/kPGIoj">《Java架构师指南》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Bc2TLN">《大话代码架构（项目实战版）》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mzqn7f">《小团队构建大网站：中小研发团队架构实践》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zDMNQs">《未来架构 从服务化到云原生(限量签名 随机发放)》</a></li>
</ul>
<h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zpE3MI">《可伸缩架构：面向增长应用的高可用》</a> - 豆瓣评分 7.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/HQHcMY">《分布式服务架构：原理、设计与实战》</a> - 豆瓣评分 7.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/9JXTi8">《亿级流量网站架构核心技术 跟开涛学搭建高可用高并发系统》</a> - 豆瓣评分 6.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/zzctjK">《大型分布式网站架构设计与实践》</a> - 豆瓣评分 6.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/l4UA35">《可伸缩服务架构：框架与中间件》</a> - 豆瓣评分 5.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1YUJxK">《架构探险：从零开始写分布式服务框架》</a> - 豆瓣评分 5.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4trb76">《Cloud Native分布式架构原理与实践》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/QWumiy">《分布式系统常用技术及案例分析（第2版）》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/53hDaR">《云原生Java：Spring Boot、Spring Cloud与Cloud Foundry弹性系统设计》</a></li>
</ul>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5KB81a">《微服务设计》</a> - 豆瓣评分 8.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/LF3vzd">《生产微服务》</a> - 豆瓣评分 8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xoCkW1">《架构解密：从分布式到微服务》</a> - 豆瓣评分 5.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/jk1V1F">《Java微服务》</a> - 豆瓣评分 5.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/QvfyPI">《Spring Cloud 微服务架构开发实战（全新升级版）》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DyZQbc">《微服务实践》</a></li>
</ul>
<h3 id="架构方法论"><a href="#架构方法论" class="headerlink" title="架构方法论"></a>架构方法论</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/k8yxj0">《架构整洁之道》</a> - 豆瓣评分 8.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pQOd7z">《企业应用架构模式 [Patterns of Enterprise Application Architecture]》</a> - 豆瓣评分 8.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ipHhzt">《企业IT架构转型之道 阿里巴巴中台战略思想与架构实战》</a> - 豆瓣评分 8.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/jRMw2b">《聊聊“架构”》</a> - 豆瓣评分 7.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1gr9nd">《架构真经：互联网技术架构的设计原则（原书第2版）》</a> - 豆瓣评分 7.5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4Y77J0">《软件架构设计：程序员向架构师转型必备（第2版）》</a> - 豆瓣评分 7.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XOr8py">《恰如其分的软件架构 [Just Enough Software Architecture]》</a> - 豆瓣评分 7.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/lSUYn8">《软件架构设计：大型网站技术架构与业务架构融合之道》</a></li>
</ul>
<h2 id="JVM周边语言"><a href="#JVM周边语言" class="headerlink" title="JVM周边语言"></a>JVM周边语言</h2><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/R0JT1a">《Scala编程（第3版）》</a> - 豆瓣评分 9.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/AMZkGX">《Groovy程序设计》</a> - 豆瓣评分 8.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/h6Gnct">《快学Scala（第2版）》</a> - 豆瓣评分 8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/loJfwO">《Kotlin极简教程》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/WvMNgs">《Scala集合技术手册》</a></li>
</ul>
<h2 id="项目管理-amp-领导力-amp-流程"><a href="#项目管理-amp-领导力-amp-流程" class="headerlink" title="项目管理&amp;领导力&amp;流程"></a>项目管理&amp;领导力&amp;流程</h2><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5OmcTI">《构建之法 现代软件工程（第三版）》</a> - 豆瓣评分 9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/gcHfSY">《精益思想（白金版）》</a> - 豆瓣评分 8.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/uZ2nZV">《给产品经理讲技术》</a></li>
</ul>
<h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TzKtiz">《持续交付：发布可靠软件的系统方法》</a> - 豆瓣评分 8.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qEOLhm">《名家经典系列：人件（原书第3版） [Peopleware: Productive Projects and Teams]》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/gc719a">《硝烟中的Scrum和XP：我们如何实施Scrum》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZHeyFS">《敏捷软件开发实践 估算与计划》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mUkwcD">《人月神话（40周年中文纪念版） [The Mythical Man-Month：Essays on Software Engineering Anniversary Edition]》</a> - 豆瓣评分 8.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/T9HSMS">《Scrum敏捷软件开发》</a> - 豆瓣评分 8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/D8oZoG">《用户故事与敏捷方法 [User Stories Applied:For Agile Software Development]》</a> - 豆瓣评分 8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/P6RDR3">《用户故事地图 [User Story Mapping]》</a> - 豆瓣评分 7.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/1zgjNd">《知行合一 实现价值驱动的敏捷和精益开发》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Dtrvqn">《互联网项目管理实践精粹》</a></li>
</ul>
<h3 id="团队管理"><a href="#团队管理" class="headerlink" title="团队管理"></a>团队管理</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/f2kMe8">《卓有成效的管理者（珍藏版） [The Effective Executive]》</a> - 豆瓣评分 8.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xLBU9J">《跃迁：从技术到管理的硅谷路径》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/w4p97S">《告别失控 软件开发团队管理必读》</a> - 豆瓣评分 7.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/K5DiJn">《赋能：打造应对不确定性的敏捷团队 [Team of Teams]》</a> - 豆瓣评分 7.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8Gsrin">《OKR工作法：谷歌、领英等顶级公司的高绩效秘籍 [Radical Focus]》</a> - 豆瓣评分 7.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/PchUJJ">《CTO说》</a> - 豆瓣评分 7.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/wGQe5I">《轻流程 IT团队的积分式绩效管理》</a> - 豆瓣评分 7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/spqdp1">《技术领导力：程序员如何才能带团队》</a> - 豆瓣评分 5.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pSHHhA">《敏捷文化：如何打造优秀的高效能团队 [The Agile Culture: Leading through Trust and Owner]》</a></li>
</ul>
<h2 id="数学与算法"><a href="#数学与算法" class="headerlink" title="数学与算法"></a>数学与算法</h2><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/lcuOQq">《数学之美（第二版）》</a> - 豆瓣评分 8.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Yte3WW">《程序员的数学2 概率统计》</a> - 豆瓣评分 8.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/WiKN9k">《程序员的数学3 线性代数》</a> - 豆瓣评分 8.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/iwv4Zd">《程序员的数学》</a> - 豆瓣评分 7.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/qhD5IJ">《程序员的数学思维修炼（趣味解读）》</a> - 豆瓣评分 5.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/vBLDyU">《统计之美：人工智能时代的科学思维》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/iCEv9a">《统计思维：程序员数学之概率统计（第2版）》</a></li>
</ul>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/AmwANr">《算法导论（原书第3版）/计算机科学丛书 [Introduction to Algorithms, third edition]》</a> - 豆瓣评分 9.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/J7HWa6">《算法图解》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Jt8KBI">《漫画算法：小灰的算法之旅（全彩）》</a></li>
</ul>
<h2 id="职业素养与个人成长"><a href="#职业素养与个人成长" class="headerlink" title="职业素养与个人成长"></a>职业素养与个人成长</h2><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DGNxfn">《我编程，我快乐：程序员职业规划之道》</a> - 豆瓣评分 7.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/THQJSq">《程序员的自我修养》</a> - 豆瓣评分 6.5</li>
</ul>
<h3 id="职业素养提升"><a href="#职业素养提升" class="headerlink" title="职业素养提升"></a>职业素养提升</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/J7iABA">《码农翻身：用故事给技术加点料》</a> - 豆瓣评分 9.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/TL272C">《程序员修炼之道：从小工到专家》</a> - 豆瓣评分 8.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mAbLoA">《极客与团队：软件工程师的团队生存秘笈》</a> - 豆瓣评分 8.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8l5o8l">《程序员思维修炼(修订版)》</a> - 豆瓣评分 8.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/s1OiZc">《高效能程序员的修炼》</a> - 豆瓣评分 8.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/XxVx3J">《O’Reilly：卓有成效的程序员 [Productive programmer]》</a> - 豆瓣评分 8.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ODjq2h">《Java工程师修炼之道》</a> - 豆瓣评分 7.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/DKrbwc">《程序员的成长课》</a> - 豆瓣评分 7.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/y36OqE">《高效程序员的45个习惯：敏捷开发修炼之道(修订版)》</a> - 豆瓣评分 7.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JKgll1">《温伯格技术思想三部曲：颠覆完美软件 软件测试必须知道的几件事》</a> - 豆瓣评分 7.5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0K8XDo">《温伯格技术思想三部曲：程序开发心理学（银年纪念版）》</a> - 豆瓣评分 7.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/AlxMcW">《软件开发本质论：追求简约、体现价值、逐步构建》</a> - 豆瓣评分 7.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/W0uA76">《内外兼修：程序员的成长之路》</a> - 豆瓣评分 6.6</li>
</ul>
<h3 id="个人软技能"><a href="#个人软技能" class="headerlink" title="个人软技能"></a>个人软技能</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/I3D7Z0">《把时间当作朋友（第3版 全彩）》</a> - 豆瓣评分 8.5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/GZgwi5">《暗时间》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/jpIkyt">《关键对话：如何高效能沟通（原书第2版） [Crucial Conversations: Tools for Talking When Stak]》</a> - 豆瓣评分 8.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/N6YwQD">《温伯格技术思想三部曲：成为技术领导者 掌握全面解决问题的方法》</a> - 豆瓣评分 8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/KkL3kA">《软技能 代码之外的生存指南》</a> - 豆瓣评分 8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/8YQH5T">《程序员健康指南》</a> - 豆瓣评分 7.5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/NS6cLf">《如何把事情做到最好：改变全球9800万人的人生指导书 [Mastery]》</a> - 豆瓣评分 7.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Gt5VDT">《程序员的英语》</a> - 豆瓣评分 5.9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oG641c">《高效能人士的七个习惯（30周年纪念版）》</a></li>
</ul>
<h2 id="大厂出品"><a href="#大厂出品" class="headerlink" title="大厂出品"></a>大厂出品</h2><h3 id="阿里巴巴技术丛书"><a href="#阿里巴巴技术丛书" class="headerlink" title="阿里巴巴技术丛书"></a>阿里巴巴技术丛书</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/mIi1ic">《码出高效：Java开发手册》</a> - 豆瓣评分 8.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/4888rh">《大数据之路 阿里巴巴大数据实践》</a> - 豆瓣评分 7.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/xHqHfG">《技术之瞳 阿里巴巴技术笔试心得》</a> - 豆瓣评分 7.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/uZYvrV">《淘宝技术这十年》</a> - 豆瓣评分 7.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VA9xEV">《尽在双11 阿里巴巴技术演进与超越》</a> - 豆瓣评分 7.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5NdzxY">《逆流而上：阿里巴巴技术成长之路》</a> - 豆瓣评分 6.9</li>
</ul>
<h3 id="京东技术丛书"><a href="#京东技术丛书" class="headerlink" title="京东技术丛书"></a>京东技术丛书</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ET1NkI">《京东基础架构建设之路（全彩）》</a> - 豆瓣评分 6.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/0OOBCc">《京东系统质量保障技术实战》</a> - 豆瓣评分 6.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/V6tLFs">《京东技术解密》</a> - 豆瓣评分 6.1</li>
</ul>
<h2 id="工具书"><a href="#工具书" class="headerlink" title="工具书"></a>工具书</h2><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/5U9zkK">《Linux命令行与shell脚本编程大全（第3版）》</a> - 豆瓣评分 9.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/28U5lx">《阿里巴巴Java开发手册》</a> - 豆瓣评分 8.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/d5ADPR">《SQL即查即用 （全彩版）》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VgrIgv">《Linux命令速查手册（第三版）》</a></li>
</ul>
<h2 id="面试求职"><a href="#面试求职" class="headerlink" title="面试求职"></a>面试求职</h2><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/IgfC55">《剑指Offer：名企面试官精讲典型编程题（第2版）》</a> - 豆瓣评分 9.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/E4WimD">《编程之美：微软技术面试心得》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/UqcYlU">《Java程序员面试笔试宝典》</a> - 豆瓣评分 7.6</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/tm79JE">《Java程序员面试宝典（第4版）》</a> - 豆瓣评分 5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/7ujWIz">《编程之法：面试和算法心得》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/eE9uWg">《Java程序员面试算法宝典》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Jc9Xlt">《Java程序员面试笔试真题库》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/VqoEj5">《Java程序员面试笔试真题与解析》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pfIsU6">《Java核心技术及面试指南》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/j0XMdh">《解忧程序员：高薪编程、求职面试与成长转型宝典》</a></li>
</ul>
<h2 id="格局与视野"><a href="#格局与视野" class="headerlink" title="格局与视野"></a>格局与视野</h2><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/bgG9yE">《全球科技通史》</a> - 豆瓣评分 9.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/koCTxD">《浪潮之巅 第三版 套装上下册》</a> - 豆瓣评分 9.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/KbwmLQ">《黑客与画家：硅谷创业之父Paul Graham文集 [Hackers and Painters Big Ldeas From the Computer Age]》</a> - 豆瓣评分 8.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/EcKZym">《软件随想录 卷1》</a> - 豆瓣评分 8.8</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/px8Sgu">《软件随想录 卷2》</a> - 豆瓣评分 8.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6jRwgY">《编程人生：15位软件先驱访谈录》</a> - 豆瓣评分 8.5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6Y4Mcd">《大教堂与集市（最新版） [The Cathedral &amp; the Bazaar]》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/3yyV1D">《硅谷之谜：浪潮之巅 续集》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/M7OrgY">《原则 [Principles]》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/PxHueV">《精益创业》</a> - 豆瓣评分 8.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/rdipjJ">《态度：吴军博士新书》</a> - 豆瓣评分 8.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/cP4xDs">《见识》</a> - 豆瓣评分 8.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/oGJFTx">《极限创新 35岁之前改变世界的全球科技精英》</a> - 豆瓣评分 7.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/FBINiB">《大学的终结：泛在大学与高等教育革命》</a> - 豆瓣评分 7.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/ZfHw4B">《未来版图 全球聪明公司的科技创新趋势和商业化路径》</a> - 豆瓣评分 7.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/cNCbEF">《你好哇，程序员——漫话程序员面试求职、升职加薪、创业与生活》</a> - 豆瓣评分 6.5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/S1ZQhz">《图灵和ACM图灵奖（1966-2015 第五版） 纪念计算机诞生70周年》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/M3PkIU">《文明之光（全彩印刷套装1-4册）入选2014中国好书/第六届中华优秀出版物获奖图书》</a></li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JHxmei">《大师访谈录：成就非凡的软件人生》</a></li>
</ul>
<h2 id="Java之外"><a href="#Java之外" class="headerlink" title="Java之外"></a>Java之外</h2><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/RCgC9H">《计算机科学丛书：计算机程序的构造和解释（原书第2版）》</a> - 豆瓣评分 9.5</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/URRIW5">《计算机科学丛书：编译原理（第2版） [Compilers:Principle,Techniques and Tools]》</a> - 豆瓣评分 9.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/fbemS8">《一个APP的诞生——从零开始设计你的手机应用》</a> - 豆瓣评分 6.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/F4SUYQ">《大型网站性能优化实战：从前端、网络、CDN到后端、大促的全链路性能优化详解》</a></li>
</ul>
<h3 id="网络知识"><a href="#网络知识" class="headerlink" title="网络知识"></a>网络知识</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/q3lNRK">《图解HTTP》</a> - 豆瓣评分 8.1</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Ip1U7X">《图解TCP/IP 第5版》</a> - 豆瓣评分 7.8</li>
</ul>
<h3 id="安全知识"><a href="#安全知识" class="headerlink" title="安全知识"></a>安全知识</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/6oCOp8">《白帽子讲Web安全（纪念版）》</a> - 豆瓣评分 7.4</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/gecmeS">《Web安全攻防：渗透测试实战指南》</a></li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Fv9ksZ">《Maven实战》</a> - 豆瓣评分 8.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/JvxLfz">《大象：Thinking in UML（第2版）》</a> - 豆瓣评分 8.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/x06AA6">《Git学习指南》</a> - 豆瓣评分 6.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/W50GoO">《UML基础、案例与应用（第3版 修订版）》</a></li>
</ul>
<h3 id="运维-amp-DevOps"><a href="#运维-amp-DevOps" class="headerlink" title="运维&amp;DevOps"></a>运维&amp;DevOps</h3><ul>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/3ejMcd">《编码：隐匿在计算机软硬件背后的语言 [Code:The Hidden Language of Computer Hardware and Software]》</a> - 豆瓣评分 9.3</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/pVBguN">《DevOps实践指南》</a> - 豆瓣评分 9</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/RXZBkB">《性能之巅：洞悉系统、企业与云计算》</a> - 豆瓣评分 8.7</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/kzDG88">《鸟哥的Linux私房菜 基础学习篇 第四版》</a> - 豆瓣评分 8.2</li>
<li><a href="https://www.coderxing.com/r.php?r=https://u.jd.com/Slnb59">《DevOps开发运维训练营》</a></li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ笔记(基础篇)</title>
    <url>/posts/0b29424708cf/</url>
    <content><![CDATA[<h1 id="RabbitMQ笔记-基础篇"><a href="#RabbitMQ笔记-基础篇" class="headerlink" title="RabbitMQ笔记(基础篇)"></a>RabbitMQ笔记(基础篇)</h1><h1 id="MQ基本概念"><a href="#MQ基本概念" class="headerlink" title="MQ基本概念"></a>MQ基本概念</h1><h2 id="1-MQ概述"><a href="#1-MQ概述" class="headerlink" title="1. MQ概述"></a>1. MQ概述</h2><blockquote>
<p><code>MQ全称 Message Queue（消息队列）</code>，是在消息传输过程中保存消息的容器。<code>多</code>用于<code>分布式系统之间进行通信。</code></p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155459.png" alt="传统服务调用20210202101233"></p>
<blockquote>
<p>使用MQ中间件</p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155510.png" alt="image-20201214200537641"></p>
<blockquote>
<p>小结：</p>
<ol>
<li>MQ—消息队列，存储消息的中间件。</li>
<li>分布式系统通信两种方式：<code>直接远程调用</code>和==借助第三方完成间接通信==。</li>
<li>发送方称为生产者，接收方称为消费者。</li>
</ol>
</blockquote>
<h2 id="2-MQ的优势和劣势"><a href="#2-MQ的优势和劣势" class="headerlink" title="2. MQ的优势和劣势"></a>2. MQ的优势和劣势</h2><h3 id="2-1-优势☆"><a href="#2-1-优势☆" class="headerlink" title="2.1 优势☆"></a>2.1 优势☆</h3><p><strong>应用解耦</strong> <code>提升容错性和可维护性</code></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155513.png" alt="image-20201214202740735"></p>
<p>系统的耦合性越高，容错性就越低，可维护性就越低。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155515.png" alt="image-20201214202817687"></p>
<p>使用 MQ 使得应用间解耦，提升容错性和可维护性。</p>
<hr>
<p><strong>异步提速</strong> <code>提升用户体验和系统吞吐量（单位时间内处理请求的数目）。</code></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155518.png" alt="image-20201214203001503"></p>
<p>一个下单操作耗时：20 + 300 + 300 + 300 = 920ms，用户点击完下单按钮后，需要等待920ms才能得到下单响应，太慢！</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155520.png" alt="image-20201214203119022"></p>
<p>用户点击完下单按钮后，只需等待20 + 5 = 25ms就能得到下单响应 。</p>
<hr>
<p><strong>削峰填谷</strong> <code>可以提高系统稳定性</code></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155522.png" alt="image-20201214203243219"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155525.png" alt="image-20201214203331072"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155527.png" alt="image-20201214203352618"></p>
<p>使用了 MQ 之后，限制消费消息的速度为1000，这样一来，高峰期产生的数据势必会被积压在 MQ 中，高峰就被<code>“削”</code>掉了，但是因为消息积压，在高峰期过后的一段时间内，消费消息的速度还是会维持在1000，直到消费完积压的消息，这就叫做<code>“填谷”</code>。</p>
<h3 id="2-2-劣势"><a href="#2-2-劣势" class="headerlink" title="2.2 劣势"></a>2.2 劣势</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155529.png" alt="rabbit劣势"></p>
<p><strong>系统可用性降低</strong></p>
<p>系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。==如何保证MQ的高可用？==</p>
<p><strong>系统复杂度提高</strong></p>
<p>MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？</p>
<p><strong>一致性问题</strong></p>
<p>A 系统处理完业务，通过 MQ 给B、C、D三个系统发消息数据，如果 B 系统、C 系统处理成功，D 系统处理失败。如何保证消息数据处理的一致性？</p>
<h3 id="2-3-使用-MQ-需要满足什么条件呢？"><a href="#2-3-使用-MQ-需要满足什么条件呢？" class="headerlink" title="2.3 使用 MQ 需要满足什么条件呢？"></a>2.3 使用 MQ 需要满足什么条件呢？</h3><ol>
<li>生产者不需要从消费者处获得反馈。</li>
</ol>
<blockquote>
<p>引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。</p>
</blockquote>
<ol start="2">
<li>容许短暂的不一致性。</li>
<li>解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本。</li>
</ol>
<h2 id="3-常见的MQ产品"><a href="#3-常见的MQ产品" class="headerlink" title="3. 常见的MQ产品"></a>3. 常见的MQ产品</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155533.png" alt="image-20201214204101628"></p>
<h1 id="RabbitMQ基本介绍"><a href="#RabbitMQ基本介绍" class="headerlink" title="RabbitMQ基本介绍"></a>RabbitMQ基本介绍</h1><p>2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</p>
<p><strong>AMQP</strong>，即 Advanced Message Queuing Protocol（高级消息队列协议），是一个网络协议，是<code>应用层协议</code>的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。<code>2006年，AMQP 规范发布。类比HTTP。</code></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155537.png" alt="image-20210202165357596"></p>
<h2 id="1-RabbitMQ-基础架构"><a href="#1-RabbitMQ-基础架构" class="headerlink" title="1. RabbitMQ 基础架构"></a>1. RabbitMQ 基础架构</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155544.png" alt="image-20201214204938331"></p>
<h2 id="2-RabbitMQ-中的相关概念"><a href="#2-RabbitMQ-中的相关概念" class="headerlink" title="2. RabbitMQ 中的相关概念"></a>2. RabbitMQ 中的相关概念</h2><p><code>Broker：</code>接收和分发消息的应用，<code>RabbitMQ Server就是 Message Broker。</code></p>
<p><code>Virtual host：</code>出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</p>
<p><code>Connection：</code>publisher／consumer 和 broker 之间的 TCP 连接。</p>
<p><code>Channel：</code>如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。</p>
<p><code>Exchange：</code>message 到达 broker 的第一站，根据分发规则，<code>匹配查询表中的 routing key，</code>分发消息到queue 中去。常用的类型有：</p>
<ul>
<li>direct (point-to-point)</li>
<li>topic (publish-subscribe)</li>
<li>fanout (multicast)</li>
</ul>
<p><code>Queue：</code>消息最终被送到这里等待 consumer 取走</p>
<p><code>Binding：</code>exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据</p>
<h2 id="3-RabbitMQ的6-种工作模式☆"><a href="#3-RabbitMQ的6-种工作模式☆" class="headerlink" title="3. RabbitMQ的6 种工作模式☆"></a>3. RabbitMQ的6 种工作模式☆</h2><p>==简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing 路由模式、Topics 主题模式、RPC 远程调用模式（远程调用，不太算 MQ；暂不作介绍）。==</p>
<p>官网对应模式介绍：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155604.png" alt="1555988678324"></p>
<h2 id="4-AMQP-和-JMS"><a href="#4-AMQP-和-JMS" class="headerlink" title="4. AMQP 和 JMS"></a>4. AMQP 和 JMS</h2><p>MQ是消息通信的模型；实现MQ的大致有两种主流方式：AMQP、JMS。</p>
<h3 id="4-1-AMQP"><a href="#4-1-AMQP" class="headerlink" title="4.1 AMQP"></a>4.1 AMQP</h3><p>AMQP是一种协议，更准确的说是一种binary wire-level protocol（链接协议）。这是其和JMS的本质差别，AMQP不从API层进行限定，而是直接<code>定义网络交换的数据格式</code>。</p>
<h3 id="4-2-JMS"><a href="#4-2-JMS" class="headerlink" title="4.2 JMS"></a>4.2 JMS</h3><p><code>JMS即Java消息服务（JavaMessage Service）应用程序接口，</code>是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p>
<p> JMS 是 JavaEE 规范中的一种，类比JDBC。</p>
<h3 id="4-3-AMQP-与-JMS-区别☆"><a href="#4-3-AMQP-与-JMS-区别☆" class="headerlink" title="4.3 AMQP 与 JMS 区别☆"></a>4.3 AMQP 与 JMS 区别☆</h3><p>本质：JMS是定义了统一的<strong>接口</strong>，对消息进行统一操作；AMQP<strong>只是协议</strong>，只规定了数据交互的格式</p>
<p>语言：JMS必须<strong>使用Java</strong>语言；AMQP不规定实现方式，是<strong>跨语言</strong>的。</p>
<p>消息模式：JMS规定了<strong>两种</strong>，而AMQP的<strong>多种</strong>消息模式</p>
<h3 id="4-4-再谈市场上常见的消息队列"><a href="#4-4-再谈市场上常见的消息队列" class="headerlink" title="4.4 再谈市场上常见的消息队列"></a>4.4 再谈市场上常见的消息队列</h3><p>ActiveMQ：基于JMS</p>
<p>ZeroMQ：基于C语言开发</p>
<p>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</p>
<p>RocketMQ：基于JMS，阿里巴巴产品</p>
<p>Kafka：类似MQ的产品；分布式消息系统，高吞吐量。</p>
<hr>
<h1 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h1><h2 id="1-相关概念介绍"><a href="#1-相关概念介绍" class="headerlink" title="1. 相关概念介绍"></a>1. 相关概念介绍</h2><p>AMQP  一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</p>
<p>AMQP是一个二进制协议，拥有一些现代化特点：多信道、协商式，异步，安全，扩平台，中立，高效。</p>
<p>RabbitMQ是AMQP协议的Erlang的实现。</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>连接Connection</td>
<td>一个网络连接，比如TCP/IP套接字连接。</td>
</tr>
<tr>
<td>会话Session</td>
<td>端点之间的命名对话。在一个会话上下文中，保证“恰好传递一次”。</td>
</tr>
<tr>
<td>信道Channel</td>
<td>多路复用连接中的一条独立的双向数据流通道。为会话提供物理传输介质。</td>
</tr>
<tr>
<td>客户端Client</td>
<td>AMQP连接或者会话的发起者。AMQP是非对称的，客户端生产和消费消息，服务器存储和路由这些消息。</td>
</tr>
<tr>
<td>服务节点Broker</td>
<td>消息中间件的服务节点；一般情况下可以将一个RabbitMQ Broker看作一台RabbitMQ 服务器。</td>
</tr>
<tr>
<td>端点</td>
<td>AMQP对话的任意一方。一个AMQP连接包括两个端点（一个是客户端，一个是服务器）。</td>
</tr>
<tr>
<td>消费者Consumer</td>
<td>一个从消息队列里请求消息的客户端程序。</td>
</tr>
<tr>
<td>生产者Producer</td>
<td>一个向交换机发布消息的客户端应用程序。</td>
</tr>
</tbody></table>
<h2 id="2-RabbitMQ运转流程"><a href="#2-RabbitMQ运转流程" class="headerlink" title="2. RabbitMQ运转流程"></a>2. RabbitMQ运转流程</h2><p>在入门案例中：</p>
<ul>
<li>生产者发送消息<ol>
<li>生产者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker；</li>
<li>声明队列并设置属性；是否排它，是否持久化，是否自动删除；</li>
<li>将路由键（空字符串）与队列绑定起来；</li>
<li>发送消息至RabbitMQ Broker；</li>
<li>关闭信道；</li>
<li>关闭连接；</li>
</ol>
</li>
<li>消费者接收消息<ol>
<li>消费者创建连接（Connection），开启一个信道（Channel），连接到RabbitMQ Broker</li>
<li>向Broker 请求消费相应队列中的消息，设置相应的回调函数；</li>
<li>等待Broker回应闭关投递响应队列中的消息，消费者接收消息；</li>
<li>确认（ack，自动确认）接收到的消息；</li>
<li>RabbitMQ从队列中删除相应已经被确认的消息；</li>
<li>关闭信道；</li>
<li>关闭连接；</li>
</ol>
</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155610.png" alt="1565105223969"></p>
<h2 id="3-生产者流转过程说明☆"><a href="#3-生产者流转过程说明☆" class="headerlink" title="3. 生产者流转过程说明☆"></a>3. 生产者流转过程说明☆</h2><ol>
<li>客户端与代理服务器Broker建立连接。会调用newConnection() 方法，这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。</li>
<li>客户端调用connection.createChannel方法。此方法开启信道，其包装的channel.open命令发送给Broker,等待channel.basicPublish方法，对应的AMQP命令为Basic.Publish,这个命令包含了content Header 和content Body()。content Header 包含了消息体的属性，例如:投递模式，优先级等，content Body 包含了消息体本身。</li>
<li>客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。</li>
</ol>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155612.png" alt="image-20210203103412258"></p>
<h2 id="4-消费者流转过程说明☆"><a href="#4-消费者流转过程说明☆" class="headerlink" title="4. 消费者流转过程说明☆"></a>4. 消费者流转过程说明☆</h2><ol>
<li>消费者客户端与代理服务器Broker建立连接。会调用newConnection() 方法，这个方法会进一步封装Protocol Header 0-9-1 的报文头发送给Broker ，以此通知Broker 本次交互采用的是AMQPO-9-1 协议，紧接着Broker 返回Connection.Start 来建立连接，在连接的过程中涉及Connection.Start/.Start-OK 、Connection.Tune/.Tune-Ok ，Connection.Open/ .Open-Ok 这6 个命令的交互。</li>
<li>消费者客户端调用connection.createChannel方法。和生产者客户端一样，协议涉及Channel . Open/Open-Ok命令。</li>
<li>在真正消费之前，消费者客户端需要向Broker 发送Basic.Consume 命令(即调用channel.basicConsume 方法〉将Channel 置为接收模式，之后Broker 回执Basic . Consume - Ok 以告诉消费者客户端准备好消费消息。</li>
<li>Broker 向消费者客户端推送(Push) 消息，即Basic.Deliver 命令，这个命令和Basic.Publish 命令一样会携带Content Header 和Content Body。</li>
<li>消费者接收到消息并正确消费之后，向Broker 发送确认，即Basic.Ack 命令。</li>
<li>客户端发送完消息需要关闭资源时，涉及到Channel.Close和Channl.Close-Ok 与Connetion.Close和Connection.Close-Ok的命令交互。</li>
</ol>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155618.png" alt="image-20210203103458054"></p>
<hr>
<h1 id="RabbitMQ的安装和配置（了解）"><a href="#RabbitMQ的安装和配置（了解）" class="headerlink" title="RabbitMQ的安装和配置（了解）"></a>RabbitMQ的安装和配置（了解）</h1><p><a href="https://blog.csdn.net/Kermit_father/article/details/105181740">https://blog.csdn.net/Kermit_father/article/details/105181740</a></p>
<h2 id="1-安装依赖环境"><a href="#1-安装依赖环境" class="headerlink" title="1. 安装依赖环境"></a>1. 安装依赖环境</h2><p>在线安装依赖环境：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</span><br></pre></td></tr></table></figure>

<h2 id="2-安装Erlang"><a href="#2-安装Erlang" class="headerlink" title="2. 安装Erlang"></a>2. 安装Erlang</h2><p>下载下面三个安装包</p>
<blockquote>
<p>erlang-18.3-1.el7.centos.x86_64.rpm</p>
<p>socat-1.7.3.2-5.el7.lux.x86_64.rpm</p>
<p>rabbitmq-server-3.6.5-1.noarch.rpm</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载erlang</span></span><br><span class="line">wget www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载socat</span></span><br><span class="line">wget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment">#下载rabbitmq-server</span></span><br><span class="line">wget www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>如果出现如下错误</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155622.png" alt="1565526174751"></p>
<p>说明gblic 版本太低。我们可以查看当前机器的gblic 版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strings /lib64/libc.so.6 | grep GLIBC</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155624.png" alt="1565526264426"></p>
<h3 id="2-1升级glibc-非必须"><a href="#2-1升级glibc-非必须" class="headerlink" title="2.1升级glibc(非必须)"></a>2.1升级glibc(非必须)</h3><p>当前最高版本2.12，需要2.15.所以需要升级glibc</p>
<ul>
<li><p>使用yum更新安装依赖</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc make -y</span><br></pre></td></tr></table></figure></li>
<li><p>下载rpm包</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-utils-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-static-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpm &amp;</span><br><span class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/nscd-2.17-55.el6.x86_64.rpm &amp;</span><br></pre></td></tr></table></figure></li>
<li><p>安装rpm包</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rpm -Uvh *-2.17-55.el6.x86_64.rpm --force --nodeps</span><br></pre></td></tr></table></figure></li>
<li><p>安装完毕后再查看glibc版本,发现glibc版本已经到2.17了</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">strings /lib64/libc.so.6 | grep GLIBC</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155627.png" alt="1565528746057"></p>
<h2 id="3-安装RabbitMQ"><a href="#3-安装RabbitMQ" class="headerlink" title="3. 安装RabbitMQ"></a>3. 安装RabbitMQ</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">rpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm</span><br></pre></td></tr></table></figure>


<h2 id="4-开启管理界面及配置"><a href="#4-开启管理界面及配置" class="headerlink" title="4. 开启管理界面及配置"></a>4. 开启管理界面及配置</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启管理界面</span></span><br><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br><span class="line"><span class="comment"># 修改默认配置信息 </span></span><br><span class="line">vim rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app </span><br><span class="line"><span class="comment"># 比如修改密码、配置等等，例如：loopback_users 中的 &lt;&lt;&quot;guest&quot;&gt;&gt;,只保留guest</span></span><br></pre></td></tr></table></figure>


<h2 id="5-启动"><a href="#5-启动" class="headerlink" title="5. 启动"></a>5. 启动</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl start rabbitmq-server  <span class="comment"># 启动服务</span></span><br><span class="line">systemctl stop rabbitmq-server  <span class="comment"># 停止服务</span></span><br><span class="line">systemctl restart rabbitmq-server  <span class="comment"># 重启服务</span></span><br><span class="line">systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure>

<p>设置配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/share/doc/rabbitmq-server-3.6.5/</span><br><span class="line">cp rabbitmq.config.example /etc/rabbitmq/rabbitmq.config</span><br></pre></td></tr></table></figure>

<p>启动rabbitmq</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin</span><br><span class="line"> rabbitmq-server start &amp;</span><br></pre></td></tr></table></figure>

<p>常用命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">  rabbitmq-server -deched  --后台启动节点</span><br><span class="line">  rabbitmqctl stop_app --关闭节点上的应用</span><br><span class="line">  rabbitmqctl start_app --启动节点上的应用</span><br><span class="line">  rabbitmqctl stop --关闭节点</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155631.png" alt="image-20201215115721783"></p>
<blockquote>
<p>修改了用户名之后，重启服务器造成创建用户丢失：</p>
<p>因为rabbitmq数据是根据当前hostname作为node节点作为数据名保存，这一点可以从rabbitmq-env文件中可以看出。</p>
<p>解决方案：</p>
<ol>
<li>不要更改hostname</li>
<li><a href="https://blog.csdn.net/qq_27037443/article/details/78050526">https://blog.csdn.net/qq_27037443/article/details/78050526</a></li>
</ol>
</blockquote>
<h2 id="6-配置虚拟主机及用户"><a href="#6-配置虚拟主机及用户" class="headerlink" title="6. 配置虚拟主机及用户"></a>6. 配置虚拟主机及用户</h2><h3 id="6-1-用户角色"><a href="#6-1-用户角色" class="headerlink" title="6.1 用户角色"></a>6.1 用户角色</h3><p>RabbitMQ在安装好后，可以访问<code>http://ip地址:15672</code> ；其自带了guest/guest的用户名和密码；如果需要创建自定义用户；那么也可以登录管理界面后，如下操作：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155634.png" alt="1565098043833"> </p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155636.png" alt="1565098315375"></p>
<p><strong>角色说明</strong>：</p>
<p>1、 超级管理员(administrator)</p>
<p>可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。</p>
<p>2、 监控者(monitoring)</p>
<p>可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等)</p>
<p>3、 策略制定者(policymaker)</p>
<p>可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。</p>
<p>4、 普通管理者(management)</p>
<p>仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。</p>
<p>5、 其他</p>
<p>无法登陆管理控制台，通常就是普通的生产者和消费者。</p>
<h3 id="6-2-Virtual-Hosts配置"><a href="#6-2-Virtual-Hosts配置" class="headerlink" title="6.2 Virtual Hosts配置"></a>6.2 Virtual Hosts配置</h3><p>像mysql拥有数据库的概念并且可以指定用户对库和表等操作的权限。RabbitMQ也有类似的权限管理；在RabbitMQ中可以虚拟消息服务器Virtual Host，每个Virtual Hosts相当于一个相对独立的RabbitMQ服务器，每个VirtualHost之间是相互隔离的。exchange、queue、message不能互通。 相当于mysql的db。Virtual Name一般以/开头。</p>
<p><strong>创建Virtual Hosts</strong></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155639.png" alt="1565098496482"></p>
<p><strong>设置Virtual Hosts权限</strong></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155641.png" alt="1565098585317"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155643.png" alt="1565098719054"></p>
<hr>
<h1 id="RabbitMQ入门"><a href="#RabbitMQ入门" class="headerlink" title="RabbitMQ入门"></a>RabbitMQ入门</h1><h3 id="1-搭建示例工程"><a href="#1-搭建示例工程" class="headerlink" title="1. 搭建示例工程"></a>1. 搭建示例工程</h3><p><a href="https://gitee.com/lixiaogou/rabbitmq">https://gitee.com/lixiaogou/rabbitmq</a></p>
<p>消息生产者com.itheima.producer.Producer_HelloWorld;</p>
<p>在执行上述的消息发送之后；可以登录rabbitMQ的管理控制台，可以发现队列和其消息：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155646.png" alt="image-20201214231440832"></p>
<hr>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155649.png" alt="image-20201214231617494"></p>
<p>消息消费者com.itheima.consumer.Consumer_HelloWorld;</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155656.png" alt="image-20201214231933716"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155657.png" alt="image-20201214232206963"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155700.png" alt="image-20201214232226947"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155705.png" alt="image-20201214232238896"></p>
<h3 id="2-小结"><a href="#2-小结" class="headerlink" title="2. 小结"></a>2. 小结</h3><p>上述的入门案例使用的是如下的<code>简单模式：</code></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155708.png" alt="1555991074575"></p>
<p>在上图的模型中，有以下概念：</p>
<ul>
<li>P：生产者，也就是要发送消息的程序</li>
<li>C：消费者：消息的接受者，会一直等待消息到来。</li>
<li>queue：消息队列，图中红色部分。可以缓存消息，生产者向其投递消息，消费者从其取出消息。 </li>
</ul>
<hr>
<h1 id="RabbitMQ工作模式"><a href="#RabbitMQ工作模式" class="headerlink" title="RabbitMQ工作模式"></a>RabbitMQ工作模式</h1><p>官网对应模式介绍：<a href="https://www.rabbitmq.com/getstarted.html">https://www.rabbitmq.com/getstarted.html</a></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155714.png" alt="1555988678324"></p>
<h2 id="1-Helloworld简单模式"><a href="#1-Helloworld简单模式" class="headerlink" title="1. Helloworld简单模式"></a>1. Helloworld简单模式</h2><p>上面入门案例即是简单模式</p>
<hr>
<h2 id="2-Work-queues工作队列模式"><a href="#2-Work-queues工作队列模式" class="headerlink" title="2. Work queues工作队列模式"></a>2. Work queues工作队列模式</h2><h3 id="2-1-模式说明"><a href="#2-1-模式说明" class="headerlink" title="2.1 模式说明"></a>2.1 模式说明</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155729.png" alt="1556009144848"></p>
<p><code>Work Queues</code>与入门程序的<code>简单模式</code>相比，多了一个或一些消费端，多个消费端==竞争==消费同一个队列中的消息。</p>
<p><code>应用场景</code>：对于 任务过重或任务较多情况使用工作队列可以提高任务处理的速度。例如发送短信服务</p>
<h3 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h3><p><code>Work Queues</code>与入门程序的<code>简单模式</code>的代码是几乎一样的；可以完全复制，并复制多个消费者进行竞争消费测试。</p>
<p><strong>生产者 Producer_WorkQueues</strong></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155734.png" alt="image-20201214233115280"></p>
<p><strong>消费者1Consumer_WorkQueues1</strong></p>
<p><strong>消费者2Consumer_WorkQueues2</strong></p>
<h3 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h3><p>启动两个消费者，然后再启动生产者发送消息；到IDEA的两个消费者对应的控制台查看是否竞争性的接收到消息。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155738.png" alt="image-20201214233458985"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155741.png" alt="image-20201214233412557"></p>
<h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h3><p>在一个Work queues队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是<code>竞争</code>的关系。</p>
<hr>
<h2 id="3-Publish-Subscribe发布订阅模式☆"><a href="#3-Publish-Subscribe发布订阅模式☆" class="headerlink" title="3. Publish/Subscribe发布订阅模式☆"></a>3. Publish/Subscribe发布订阅模式☆</h2><p>前面2个案例中，只有3个角色：</p>
<ul>
<li>P：生产者，也就是要发送消息的程序</li>
<li>C：消费者：消息的接受者，会一直等待消息到来。</li>
<li>queue：消息队列，图中红色部分</li>
</ul>
<h3 id="3-1-模式说明"><a href="#3-1-模式说明" class="headerlink" title="3.1 模式说明"></a>3.1 模式说明</h3><p>在订阅模型中，多了一个<code>exchange</code>角色，而且过程略有变化：</p>
<ul>
<li>P：生产者，不再发送消息到队列中，而是发给X（交换机）</li>
<li>C：消费者，消息的接受者，会一直等待消息到来。</li>
<li>Queue：消息队列，接收消息、缓存消息。</li>
<li>Exchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：<ul>
<li>Fanout：广播，将消息交给==所有绑定==到交换机的队列</li>
<li>Direct：定向，把消息交给==符合指定routing key== 的队列</li>
<li>Topic：通配符，把消息交给==符合routing pattern（路由模式）== 的队列</li>
</ul>
</li>
</ul>
<p><code>Exchange（交换机）只负责转发消息，不具备存储消息的能力</code>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>
<p>订阅模式示例图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155744.png" alt="1556014499573"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155747.png" alt="1556010329032"></p>
<blockquote>
<ol>
<li>每个消费者监听自己的队列。</li>
<li>生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息。</li>
</ol>
</blockquote>
<h3 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2. 代码"></a>3.2. 代码</h3><p>生产者Producer_PubSub</p>
<p>消费者1Consumer_PubSub1</p>
<p>消费者2Consumer_PubSub2</p>
<h3 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155751.png" alt="image-20201214235015805"></p>
<p>启动所有消费者，然后使用生产者发送消息；在每个消费者对应的控制台可以查看到生产者发送的所有消息；到达<code>广播</code>的效果。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155755.png" alt="image-20201214234959997"></p>
<p>在执行完测试代码后，其实到RabbitMQ的管理后台找到<code>Exchanges</code>选项卡，点击 <code>test_fanout</code> 的交换机，可以查看到如下的绑定：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155759.png" alt="image-20210203140856511"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155803.png" alt="image-20201214234927452"></p>
<h3 id="3-4-小结"><a href="#3-4-小结" class="headerlink" title="3.4 小结"></a>3.4 小结</h3><p>交换机需要与队列进行绑定，绑定之后；一个消息可以被多个消费者收到。</p>
<p><code>发布订阅模式与工作队列模式的区别</code>，重点还是在交换机上面</p>
<p>1、工作队列模式不用定义交换机，而发布/订阅模式需要定义交换机。 </p>
<p>2、发布/订阅模式的生产方是面向交换机发送消息，工作队列模式的生产方是面向队列发送消息(底层使用默认交换机)。</p>
<p>3、发布/订阅模式需要设置队列和交换机的绑定，工作队列模式不需要设置，实际上工作队列模式会将队列绑定到默认的交换机 。</p>
<hr>
<h2 id="4-Routing路由模式"><a href="#4-Routing路由模式" class="headerlink" title="4. Routing路由模式"></a>4. Routing路由模式</h2><h3 id="4-1-模式说明"><a href="#4-1-模式说明" class="headerlink" title="4.1 模式说明"></a>4.1 模式说明</h3><p>路由模式特点：</p>
<ul>
<li>队列与交换机的绑定，不能是任意绑定了，而是要指定一个<code>RoutingKey</code>（路由key）</li>
<li>消息的发送方在向Exchange发送消息时，也必须指定消息的 <code>RoutingKey</code>。</li>
<li>Exchange不再把消息交给每一个绑定的队列，而是根据消息的<code>Routing Key</code>进行判断，只有队列的<code>Routingkey</code>与消息的 <code>Routing key</code>完全一致，才会接收到消息</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155808.png" alt="1556029284397"></p>
<p>图解：</p>
<ul>
<li>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</li>
<li>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</li>
<li>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</li>
<li>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</li>
</ul>
<h3 id="4-2-代码"><a href="#4-2-代码" class="headerlink" title="4.2 代码"></a>4.2 代码</h3><p>在编码上与 <code>Publish/Subscribe发布与订阅模式</code> 的区别是交换机的类型为：Direct，还有队列绑定交换机的时候需要指定routing key。</p>
<p>生产者Producer_Routing</p>
<p>消费者1Consumer_Routing1</p>
<p>消费者2Consumer_Routing2</p>
<h3 id="4-3-测试"><a href="#4-3-测试" class="headerlink" title="4.3 测试"></a>4.3 测试</h3><p>启动所有消费者，然后使用生产者发送消息；消费者可以接收到生产者发送routing key对应队列的消息；达到<code>按需接收</code>的效果。</p>
<p>在执行完测试代码后，到RabbitMQ的管理后台找到<code>Exchanges</code>选项卡，点击 <code>test_direct</code> 交换机，可以查看到如下的绑定：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155812.png" alt="image-20210203140818561"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155817.png" alt="image-20201214235922773"></p>
<h3 id="4-4-小结"><a href="#4-4-小结" class="headerlink" title="4.4 小结"></a>4.4 小结</h3><p>Routing模式要求队列在绑定交换机时要指定routing key，消息会转发到符合routing key的队列。</p>
<hr>
<h2 id="5-Topics通配符模式"><a href="#5-Topics通配符模式" class="headerlink" title="5. Topics通配符模式"></a>5. Topics通配符模式</h2><h3 id="5-1-模式说明"><a href="#5-1-模式说明" class="headerlink" title="5.1. 模式说明"></a>5.1. 模式说明</h3><p><code>Topic</code>类型与<code>Direct</code>相比，都可以根据<code>RoutingKey</code>把消息路由到不同的队列。但是<code>Topic</code>类型可以让队列在绑定<code>Routing key</code> 的时候==使用通配符==！</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155821.png" alt="image-20210206102003412"></p>
<p><code>Routingkey</code> 一般是由一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code></p>
<p> 通配符规则：</p>
<p><code>#</code>：匹配一个或多个词，多个占位符</p>
<p><code>*</code>：只匹配一个词，一个占位符</p>
<p>举例：</p>
<p><code>item.#</code>：能够匹配<code>item.insert.abc</code> 或者 <code>item.insert</code></p>
<p><code>item.*</code>：只能匹配<code>item.insert</code></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155825.png" alt="image-20210206102026543"></p>
<p>图解：</p>
<ul>
<li>红色Queue：绑定的是<code>usa.#</code> ，凡是以 <code>usa.</code>开头的routing key 都会被匹配到</li>
<li>黄色Queue：绑定的是<code>#.news</code> ，凡是以 <code>.news</code>结尾的 routing key 都会被匹配</li>
</ul>
<h3 id="5-2-代码"><a href="#5-2-代码" class="headerlink" title="5.2. 代码"></a>5.2. 代码</h3><p>生产者Producer_Topics，所有error级别的日志存入数据库，所有order系统的日志存入数据库</p>
<p>消费者1Consumer_Topic1</p>
<p>消费者2Consumer_Topic2</p>
<h3 id="5-3-测试"><a href="#5-3-测试" class="headerlink" title="5.3 测试"></a>5.3 测试</h3><p>启动所有消费者，然后使用生产者发送消息；在消费者对应的控制台可以查看到生产者发送对应routing key对应队列的消息；到达<code>按照需要接收</code>的效果；并且这些routing key可以使用通配符。</p>
<p>在执行完测试代码后，其实到RabbitMQ的管理后台找到<code>Exchanges</code>选项卡，点击 <code>test_topic</code> 的交换机，可以查看到如下的绑定：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155829.png" alt="image-20210203142455093"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155832.png" alt="image-20201215000614183"></p>
<h3 id="5-4-小结"><a href="#5-4-小结" class="headerlink" title="5.4. 小结"></a>5.4. 小结</h3><p>Topic主题模式可以实现 <code>Publish/Subscribe发布与订阅模式</code> + <code> Routing路由模式</code> 的功能；</p>
<p>Topic在配置routing key 的时候可以使用通配符，更加灵活。</p>
<hr>
<h2 id="6-工作模式总结"><a href="#6-工作模式总结" class="headerlink" title="6. 工作模式总结"></a>6. 工作模式总结</h2><p>1、简单模式 HelloWorld</p>
<blockquote>
<p>一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）</p>
</blockquote>
<p>2、工作队列模式 Work Queue</p>
<blockquote>
<p>一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）</p>
</blockquote>
<p>3、发布订阅模式 Publish/subscribe</p>
<blockquote>
<p>需要设置类型为==fanout==的交换机，并且交换机和队列进行绑定，当生产者发送消息到交换机后，交换机会将消息发送到绑定的队列，</p>
</blockquote>
<p>4、路由模式 Routing</p>
<blockquote>
<p>需要设置类型为==direct==的交换机，交换机和队列进行绑定，并且指定routing key，当生产者发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p>
</blockquote>
<p>5、通配符模式 Topic</p>
<blockquote>
<p>需要设置类型为==topic==的交换机，交换机和队列进行绑定，并且指定通配符方式的routing key，当生产者发送消息到交换机后，交换机会根据routing key将消息发送到对应的队列</p>
</blockquote>
<hr>
<h1 id="Spring-整合RabbitMQ"><a href="#Spring-整合RabbitMQ" class="headerlink" title="Spring 整合RabbitMQ"></a>Spring 整合RabbitMQ</h1><h2 id="1-搭建工程"><a href="#1-搭建工程" class="headerlink" title="1. 搭建工程"></a>1. 搭建工程</h2><p><a href="https://gitee.com/lixiaogou/rabbitmq/tree/master/spring-rabbitmq-producers">https://gitee.com/lixiaogou/rabbitmq/tree/master/spring-rabbitmq-producers</a></p>
<p><a href="https://gitee.com/lixiaogou/rabbitmq/tree/master/spring-rabbitmq-consumers">https://gitee.com/lixiaogou/rabbitmq/tree/master/spring-rabbitmq-consumers</a></p>
<h2 id="2-消息监听器"><a href="#2-消息监听器" class="headerlink" title="2. 消息监听器"></a>2. 消息监听器</h2><h4 id="队列监听器SpringQueueListener"><a href="#队列监听器SpringQueueListener" class="headerlink" title="队列监听器SpringQueueListener"></a>队列监听器SpringQueueListener</h4><h4 id="广播监听器1-FanoutListener1"><a href="#广播监听器1-FanoutListener1" class="headerlink" title="广播监听器1 FanoutListener1"></a>广播监听器1 FanoutListener1</h4><h4 id="广播监听器2FanoutListener2"><a href="#广播监听器2FanoutListener2" class="headerlink" title="广播监听器2FanoutListener2"></a>广播监听器2FanoutListener2</h4><h4 id="星号通配符监听器TopicListenerStar"><a href="#星号通配符监听器TopicListenerStar" class="headerlink" title="星号通配符监听器TopicListenerStar"></a>星号通配符监听器TopicListenerStar</h4><h4 id="井号通配符监听器TopicListenerWell"><a href="#井号通配符监听器TopicListenerWell" class="headerlink" title="井号通配符监听器TopicListenerWell"></a>井号通配符监听器TopicListenerWell</h4><h4 id="井号通配符监听器2TopicListenerWell2"><a href="#井号通配符监听器2TopicListenerWell2" class="headerlink" title="井号通配符监听器2TopicListenerWell2"></a>井号通配符监听器2TopicListenerWell2</h4><h2 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h2><p>ConsumerTest</p>
<hr>
<h1 id="Spring-Boot整合RabbitMQ"><a href="#Spring-Boot整合RabbitMQ" class="headerlink" title="Spring Boot整合RabbitMQ"></a>Spring Boot整合RabbitMQ</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>在Spring项目中，可以使用Spring-Rabbit去操作RabbitMQ<br><a href="https://github.com/spring-projects/spring-amqp">https://github.com/spring-projects/spring-amqp</a></p>
<p>尤其是在spring boot项目中只需要引入对应的amqp启动器依赖即可，方便的使用RabbitTemplate发送消息，使用注解接收消息。</p>
<p>一般在开发过程中：</p>
<p><code>生产者工程：</code></p>
<ol>
<li><p>application.yml文件配置$RabbitMQ$相关信息；</p>
</li>
<li><p>在生产者工程中编写配置类，用于创建交换机和队列，并进行绑定</p>
</li>
<li><p>注入RabbitTemplate对象，通过RabbitTemplate对象发送消息到交换机</p>
</li>
</ol>
<p><code>消费者工程：</code></p>
<ol>
<li><p>application.yml文件配置$RabbitMQ$相关信息</p>
</li>
<li><p>创建消息处理类，用于接收队列中的消息并进行处理</p>
</li>
</ol>
<h2 id="2-搭建生产者工程"><a href="#2-搭建生产者工程" class="headerlink" title="2. 搭建生产者工程"></a>2. 搭建生产者工程</h2><p><a href="https://gitee.com/lixiaogou/rabbitmq/tree/master/springboot-rabbitmq-producer">https://gitee.com/lixiaogou/rabbitmq/tree/master/springboot-rabbitmq-producer</a></p>
<h3 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1 创建工程"></a>2.1 创建工程</h3><h3 id="2-2-添加依赖"><a href="#2-2-添加依赖" class="headerlink" title="2.2 添加依赖"></a>2.2 添加依赖</h3><p>修改pom.xml文件内容为如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>producer-springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1. 父工程依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--2. rabbitmq--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-启动类"><a href="#2-3-启动类" class="headerlink" title="2.3 启动类"></a>2.3 启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lixiaolong</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ProducerApplication.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;介就对了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-配置RabbitMQ"><a href="#2-4-配置RabbitMQ" class="headerlink" title="2.4 配置RabbitMQ"></a>2.4 配置RabbitMQ</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>创建application.yml，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置RabbitMQ的基本信息  ip 端口 username  password..</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># ip</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">lxl</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">lxl</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/lxl</span></span><br></pre></td></tr></table></figure>

<h4 id="绑定交换机和队列"><a href="#绑定交换机和队列" class="headerlink" title="绑定交换机和队列"></a>绑定交换机和队列</h4><p>创建RabbitMQ队列与交换机绑定的配置类com.itheima.rabbitmq.config.RabbitMQConfig</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.rabbitmq.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">EXCHANGE_NAME</span> <span class="operator">=</span> <span class="string">&quot;boot_topic_exchange&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">QUEUE_NAME</span> <span class="operator">=</span> <span class="string">&quot;boot_queue&quot;</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Exchange <span class="title function_">bootExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder.topicExchange(EXCHANGE_NAME).durable(<span class="literal">true</span>).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.Queue 队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">bootQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_NAME).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 队列和交互机绑定关系 Binding</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queue    队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindQueueExchange</span><span class="params">(Queue queue, Exchange exchange)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queue).to(exchange).with(<span class="string">&quot;boot.#&quot;</span>).noargs();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-搭建消费者工程"><a href="#3-搭建消费者工程" class="headerlink" title="3. 搭建消费者工程"></a>3. 搭建消费者工程</h2><p><a href="https://gitee.com/lixiaogou/rabbitmq/tree/master/springboot-rabbitmq-consumer">https://gitee.com/lixiaogou/rabbitmq/tree/master/springboot-rabbitmq-consumer</a></p>
<h3 id="3-1-创建工程"><a href="#3-1-创建工程" class="headerlink" title="3.1 创建工程"></a>3.1 创建工程</h3><h3 id="3-2-添加依赖"><a href="#3-2-添加依赖" class="headerlink" title="3.2 添加依赖"></a>3.2 添加依赖</h3><p>修改pom.xml文件内容为如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-springboot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- RabbitMQ 启动依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-启动类"><a href="#3-3-启动类" class="headerlink" title="3.3 启动类"></a>3.3 启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.rabbit.consumer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;介就对了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-配置RabbitMQ"><a href="#3-4-配置RabbitMQ" class="headerlink" title="3.4 配置RabbitMQ"></a>3.4 配置RabbitMQ</h3><p>创建application.yml，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置RabbitMQ的基本信息  ip 端口 username  password..</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span> <span class="comment"># ip</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">lxl</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">lxl</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/lxl</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-消息监听处理类"><a href="#3-5-消息监听处理类" class="headerlink" title="3.5 消息监听处理类"></a>3.5 消息监听处理类</h3><p>编写消息监听器com.itheima.rabbitmq.listener.RabbimtMQListener</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.rabbit.consumer.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbimtMQListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;boot_queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ListenerQueue</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(message.getBody()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h2><p>在生产者工程producer-springboot 中创建测试类，发送消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"><span class="keyword">import</span> com.itheima.rabbitmq.config.RabbitMQConfig;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerTest</span> &#123;</span><br><span class="line">    <span class="comment">//1.注入RabbitTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSend</span><span class="params">()</span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(RabbitMQConfig.EXCHANGE_NAME,<span class="string">&quot;boot.haha&quot;</span>,<span class="string">&quot;boot mq hello~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155843.png" alt="image-20201215162243570"></p>
<p>先运行上述测试程序（交换机和队列才能先被声明和绑定），然后启动消费者；</p>
<p>在消费者工程consumer-springboot中控制台查看是否接收到对应消息。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155845.png" alt="image-20201215162317180"></p>
<p>另外，也可以在RabbitMQ的管理控制台中查看到交换机与队列的绑定：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/RabbitMQ/20220325155848.png" alt="image-20201215162341130"></p>
<hr>
<h1 id="☆"><a href="#☆" class="headerlink" title="☆"></a>☆</h1>]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HTML</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis SQL映射文件详解</title>
    <url>/posts/bfa052c8a227/</url>
    <content><![CDATA[<h1 id="Mybatis-SQL映射文件详解"><a href="#Mybatis-SQL映射文件详解" class="headerlink" title="Mybatis SQL映射文件详解"></a>Mybatis SQL映射文件详解</h1><p>在mybatis的映射文件中，可以编写以下的顶级元素标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cache – 该命名空间的缓存配置。</span><br><span class="line">cache-ref – 引用其它命名空间的缓存配置。</span><br><span class="line">resultMap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</span><br><span class="line">parameterMap – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。</span><br><span class="line">sql – 可被其它语句引用的可重用语句块。</span><br><span class="line">insert – 映射插入语句。</span><br><span class="line">update – 映射更新语句。</span><br><span class="line">delete – 映射删除语句。</span><br><span class="line">select – 映射查询语句。</span><br></pre></td></tr></table></figure>

<p>在每个顶级元素标签中可以添加很多个属性，下面我们开始详细了解下具体的配置。</p>
<h2 id="1、insert、update、delete元素"><a href="#1、insert、update、delete元素" class="headerlink" title="1、insert、update、delete元素"></a>1、insert、update、delete元素</h2><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td>
</tr>
<tr>
<td><code>parameterType</code></td>
<td>将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td>
</tr>
<tr>
<td><code>parameterMap</code></td>
<td>用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</td>
</tr>
<tr>
<td><code>flushCache</code></td>
<td>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。</td>
</tr>
<tr>
<td><code>timeout</code></td>
<td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td>
</tr>
<tr>
<td><code>statementType</code></td>
<td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td>
</tr>
<tr>
<td><code>useGeneratedKeys</code></td>
<td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td>
</tr>
<tr>
<td><code>keyProperty</code></td>
<td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td>
</tr>
<tr>
<td><code>keyColumn</code></td>
<td>（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td>
</tr>
<tr>
<td><code>databaseId</code></td>
<td>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td>
</tr>
</tbody></table>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--如果数据库支持自增可以使用这样的方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into user(user_name) values(#&#123;userName&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果数据库不支持自增的话，那么可以使用如下的方式进行赋值查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser2&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">order</span>=<span class="string">&quot;BEFORE&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;integer&quot;</span>&gt;</span></span><br><span class="line">        select max(id)+1 from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into user(id,user_name) values(#&#123;id&#125;,#&#123;userName&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="2、select元素"><a href="#2、select元素" class="headerlink" title="2、select元素"></a>2、select元素</h2><h3 id="1、select的参数传递"><a href="#1、select的参数传递" class="headerlink" title="1、select的参数传递"></a>1、select的参数传递</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    当查询语句中包含多个参数的是，如果使用#&#123;属性名称&#125;就无法获取具体的值了，那么应该如何使用呢？</span></span><br><span class="line"><span class="comment">        下面就是mybatis的参数传递方式</span></span><br><span class="line"><span class="comment">        1、如果是单个参数，</span></span><br><span class="line"><span class="comment">            基本类型：使用#&#123;随便写&#125;</span></span><br><span class="line"><span class="comment">            引用类型：使用#&#123;类的属性名称&#125;</span></span><br><span class="line"><span class="comment">        2、多个参数：</span></span><br><span class="line"><span class="comment">            当查询的时候传入多个参数的时候，就无法简单的通过#&#123;参数名&#125;来获取值了，</span></span><br><span class="line"><span class="comment">            只能通过arg0,arg1...或者param1,param2等方式来获取值</span></span><br><span class="line"><span class="comment">            原因就在于，mybatis在传入多个参数的时候，会将这些参数封装到一个map中，此时map中的key就是arg0,arg1,param1,param2这些值，但是很明显，这样的传值方式不是很友好，没有办法根据参数的名称来获取具体的值，因此可以使用如下的方式来指定参数的key是什么</span></span><br><span class="line"><span class="comment">            Emp selectEmpByNoAndName(@Param(&quot;empno&quot;) Integer empno, @Param(&quot;ename&quot;) String ename);</span></span><br><span class="line"><span class="comment">            也就是通过@Param来指定存入map中的key值是什么</span></span><br><span class="line"><span class="comment">        3、使用map来传递参数：</span></span><br><span class="line"><span class="comment">                依然是直接使用#&#123;key&#125;来获取具体的属性值</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmpByNoAndName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp where empno=#&#123;empno&#125; and ename=#&#123;ename&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmpByNoAndName2&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp where empno=#&#123;empno&#125; and ename=#&#123;ename&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、参数的取值方式"><a href="#2、参数的取值方式" class="headerlink" title="2、参数的取值方式"></a>2、参数的取值方式</h3><p>在xml文件中编写sql语句的时候有两种取值的方式，分别是#{}和${}，下面来看一下他们之间的区别：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">       当使用#&#123;&#125;来获取值的时候会发现打印的sql语句如下：</span></span><br><span class="line"><span class="comment">           select * from emp where empno=? and ename=?</span></span><br><span class="line"><span class="comment">       当使用$&#123;&#125;来获取值的时候会发现打印的sql语句如下：</span></span><br><span class="line"><span class="comment">           select * from emp where empno=7369 and ename=&#x27;SMITH&#x27;</span></span><br><span class="line"><span class="comment">       使用#&#123;&#125;方式进行取值：采用的是参数预编译的方式，参数的位置使用？进行替代，不会出现sql注入的问题</span></span><br><span class="line"><span class="comment">       使用$&#123;&#125;方式进行取值：采用的是直接跟sql语句进行拼接的方式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       此处大家需要注意，如果我们的sql语句中的某些值不支持参数预编译，那么就必须要使用$&#123;&#125;的方式来取值了</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmpByNoAndName&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">       select * from #&#123;t&#125; where empno = $&#123;empno&#125; and ename = $&#123;ename&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、处理集合返回结果"><a href="#3、处理集合返回结果" class="headerlink" title="3、处理集合返回结果"></a>3、处理集合返回结果</h3><p>EmpDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--当返回值的结果是集合的时候，返回值的类型依然写的是集合中具体的类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAllEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在查询的时候可以设置返回值的类型为map，当mybatis查询完成之后会把列的名称作为key</span></span><br><span class="line"><span class="comment">    列的值作为value，转换到map中</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmpByEmpReturnMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">        select * from emp where empno = #&#123;empno&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注意，当返回的结果是一个集合对象的是，返回值的类型一定要写集合具体value的类型</span></span><br><span class="line"><span class="comment">    同时在dao的方法上要添加@MapKey的注解，来设置key是什么结果</span></span><br><span class="line"><span class="comment">    @MapKey(&quot;empno&quot;)</span></span><br><span class="line"><span class="comment">    Map&lt;Integer,Emp&gt; getAllEmpReturnMap();--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmpReturnMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>UserDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.bean.Emp;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.MapKey;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Emp <span class="title function_">findEmpByEmpno</span><span class="params">(Integer empno)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">updateEmp</span><span class="params">(Emp emp)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteEmp</span><span class="params">(Integer empno)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertEmp</span><span class="params">(Emp emp)</span>;</span><br><span class="line"></span><br><span class="line">    Emp <span class="title function_">selectEmpByNoAndName</span><span class="params">(<span class="meta">@Param(&quot;empno&quot;)</span> Integer empno, <span class="meta">@Param(&quot;ename&quot;)</span> String ename,<span class="meta">@Param(&quot;t&quot;)</span> String tablename)</span>;</span><br><span class="line">    Emp <span class="title function_">selectEmpByNoAndName2</span><span class="params">(Map&lt;String,Object&gt; map)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Emp&gt; <span class="title function_">selectAllEmp</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;String,Object&gt; <span class="title function_">selectEmpByEmpReturnMap</span><span class="params">(Integer empno)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MapKey(&quot;empno&quot;)</span></span><br><span class="line">    Map&lt;Integer,Emp&gt; <span class="title function_">getAllEmpReturnMap</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、自定义结果集—resultMap"><a href="#4、自定义结果集—resultMap" class="headerlink" title="4、自定义结果集—resultMap"></a>4、自定义结果集—resultMap</h3><p>Dog.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter 和 setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dog.sql</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Navicat MySQL Data Transfer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Source Server         : node01</span></span><br><span class="line"><span class="comment">Source Server Version : 50729</span></span><br><span class="line"><span class="comment">Source Host           : 192.168.85.111:3306</span></span><br><span class="line"><span class="comment">Source Database       : demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Target Server Type    : MYSQL</span></span><br><span class="line"><span class="comment">Target Server Version : 50729</span></span><br><span class="line"><span class="comment">File Encoding         : 65001</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Date: 2020-03-24 23:54:22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for `dog`</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `dog`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dog` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `dname` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `dage` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `dgender` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">4</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Records of dog</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dog <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;大黄&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;雄&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dog <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;二黄&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;雌&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dog <span class="keyword">VALUES</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;三黄&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;雄&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>DogDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.bean.Dog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DogDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">selectDogById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DogDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mashibing.dao.DogDao&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   在使用mybatis进行查询的时候，mybatis默认会帮我们进行结果的封装，但是要求列名跟属性名称一一对应上</span></span><br><span class="line"><span class="comment">   在实际的使用过程中，我们会发现有时候数据库中的列名跟我们类中的属性名并不是一一对应的，此时就需要起别名</span></span><br><span class="line"><span class="comment">   起别名有两种实现方式：</span></span><br><span class="line"><span class="comment">      1、在编写sql语句的时候添加别名</span></span><br><span class="line"><span class="comment">      2、自定义封装结果集</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--根据查询的数据进行结果的封装要使用resultMap属性，表示使用自定义规则--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectDogById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;myDog&quot;</span>&gt;</span></span><br><span class="line">      select * from dog where id = #&#123;id&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--自定义结果集，将每一个列的数据跟javaBean的对象属性对应起来</span></span><br><span class="line"><span class="comment">   type:表示为哪一个javaBean对象进行对应</span></span><br><span class="line"><span class="comment">   id:唯一标识，方便其他属性标签进行引用</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;myDog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.mashibing.bean.Dog&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      指定主键列的对应规则：</span></span><br><span class="line"><span class="comment">      column：表示表中的主键列</span></span><br><span class="line"><span class="comment">      property:指定javaBean的属性</span></span><br><span class="line"><span class="comment">      --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--设置其他列的对应关系--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dage&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dgender&quot;</span> <span class="attr">property</span>=<span class="string">&quot;gender&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--可以在sql语句中写别名--&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--  &lt;select id=&quot;selectDogById&quot; resultType=&quot;com.mashibing.bean.Dog&quot;&gt;</span></span><br><span class="line"><span class="comment">      select id id,dname name,dage age,dgender gender from dog where id = #&#123;id&#125;</span></span><br><span class="line"><span class="comment">   &lt;/select&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--这种方式是查询不到任何结果的，因为属性名跟列名并不是一一对应的--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;select id=&quot;selectDogById&quot; resultType=&quot;com.mashibing.bean.Dog&quot;&gt;</span></span><br><span class="line"><span class="comment">      select * from dog where id = #&#123;id&#125;</span></span><br><span class="line"><span class="comment">   &lt;/select&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5、联合查询"><a href="#5、联合查询" class="headerlink" title="5、联合查询"></a>5、联合查询</h3><p>emp.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer empno;</span><br><span class="line">    <span class="keyword">private</span> String ename;</span><br><span class="line">    <span class="keyword">private</span> String job;</span><br><span class="line">    <span class="keyword">private</span> Integer mgr;</span><br><span class="line">    <span class="keyword">private</span> Date hiredate;</span><br><span class="line">    <span class="keyword">private</span> Double sal;</span><br><span class="line">    <span class="keyword">private</span> Double common;</span><br><span class="line">    <span class="keyword">private</span> Dept dept;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(Integer empno, String ename)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.empno = empno;</span><br><span class="line">        <span class="built_in">this</span>.ename = ename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Emp</span><span class="params">(Integer empno, String ename, String job, Integer mgr, Date hiredate, Double sal, Double common, Dept dept)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.empno = empno;</span><br><span class="line">        <span class="built_in">this</span>.ename = ename;</span><br><span class="line">        <span class="built_in">this</span>.job = job;</span><br><span class="line">        <span class="built_in">this</span>.mgr = mgr;</span><br><span class="line">        <span class="built_in">this</span>.hiredate = hiredate;</span><br><span class="line">        <span class="built_in">this</span>.sal = sal;</span><br><span class="line">        <span class="built_in">this</span>.common = common;</span><br><span class="line">        <span class="built_in">this</span>.dept = dept;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter 和 setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dept.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer deptno;</span><br><span class="line">    <span class="keyword">private</span> String dname;</span><br><span class="line">    <span class="keyword">private</span> String loc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dept</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dept</span><span class="params">(Integer deptno, String dname, String loc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.deptno = deptno;</span><br><span class="line">        <span class="built_in">this</span>.dname = dname;</span><br><span class="line">        <span class="built_in">this</span>.loc = loc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter 和 setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EmpDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--namespace:编写接口的全类名，就是告诉要实现该配置文件是哪个接口的具体实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mashibing.dao.EmpDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--再做查询的时候，有时候需要关联其他对象，因此需要使用关联查询</span></span><br><span class="line"><span class="comment">    可以通过下面自定义结果集的方式实现</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empDept&quot;</span>&gt;</span></span><br><span class="line">        select * from emp left join dept on emp.deptno = dept.deptno where empno = #&#123;empno&#125;;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empDept&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;empno&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;job&quot;</span> <span class="attr">property</span>=<span class="string">&quot;job&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;mgr&quot;</span> <span class="attr">property</span>=<span class="string">&quot;mgr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;hiredate&quot;</span> <span class="attr">property</span>=<span class="string">&quot;hiredate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sal&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sal&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;comm&quot;</span> <span class="attr">property</span>=<span class="string">&quot;common&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;loc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dept.loc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在mybatis中还提供了一种简单的形式，使用association标签可以搞定</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empDept&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;empno&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;job&quot;</span> <span class="attr">property</span>=<span class="string">&quot;job&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;mgr&quot;</span> <span class="attr">property</span>=<span class="string">&quot;mgr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;hiredate&quot;</span> <span class="attr">property</span>=<span class="string">&quot;hiredate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sal&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sal&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;comm&quot;</span> <span class="attr">property</span>=<span class="string">&quot;common&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.mashibing.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">property</span>=<span class="string">&quot;deptno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;loc&quot;</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取数据库的会话</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">EmpDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpDao.class);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.selectEmpAndDept(<span class="number">7369</span>);</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、获取集合元素"><a href="#6、获取集合元素" class="headerlink" title="6、获取集合元素"></a>6、获取集合元素</h3><p>Dept.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer deptno;</span><br><span class="line">    <span class="keyword">private</span> String dname;</span><br><span class="line">    <span class="keyword">private</span> String loc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Emp&gt; emps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dept</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dept</span><span class="params">(Integer deptno, String dname, String loc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.deptno = deptno;</span><br><span class="line">        <span class="built_in">this</span>.dname = dname;</span><br><span class="line">        <span class="built_in">this</span>.loc = loc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter 和 setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DeptDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.bean.Dept;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.bean.Emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">getDeptAndEmps</span><span class="params">(Integer deptno)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DeptDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mashibing.dao.DeptDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--定义查询集合元素--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmps&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptEmp&quot;</span>&gt;</span></span><br><span class="line">        select * from dept left join emp on dept.deptno = emp.deptno where dept.deptno=#&#123;deptno&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptEmp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.mashibing.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span> <span class="attr">column</span>=<span class="string">&quot;loc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--封装集合类的元素</span></span><br><span class="line"><span class="comment">            property：指定集合的属性</span></span><br><span class="line"><span class="comment">            ofType:指定集合中的元素类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;empno&quot;</span> <span class="attr">column</span>=<span class="string">&quot;empno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;job&quot;</span> <span class="attr">property</span>=<span class="string">&quot;job&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;mgr&quot;</span> <span class="attr">property</span>=<span class="string">&quot;mgr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;hiredate&quot;</span> <span class="attr">property</span>=<span class="string">&quot;hiredate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sal&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sal&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;comm&quot;</span> <span class="attr">property</span>=<span class="string">&quot;common&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据库的会话</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">DeptDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DeptDao.class);</span><br><span class="line">        <span class="type">Dept</span> <span class="variable">deptAndEmps</span> <span class="operator">=</span> mapper.getDeptAndEmps(<span class="number">10</span>);</span><br><span class="line">        System.out.println(deptAndEmps);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7、分步查询"><a href="#7、分步查询" class="headerlink" title="7、分步查询"></a>7、分步查询</h3><p>在上述逻辑的查询中，是由我们自己来完成sql语句的关联查询的，那么，我们能让mybatis帮我们实现自动的关联查询吗?</p>
<p><strong>关联查询的分步</strong></p>
<p>DeptDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.bean.Dept;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.bean.Emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">getDeptAndEmps</span><span class="params">(Integer deptno)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">getDeptAndEmpsBySimple</span><span class="params">(Integer deptno)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EmpDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.bean.Emp;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.MapKey;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    Emp <span class="title function_">selectEmpAndDept</span><span class="params">(Integer empno)</span>;java</span><br><span class="line">    Emp <span class="title function_">selectEmpAndDeptBySimple</span><span class="params">(Integer empno)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DeptDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mashibing.dao.DeptDao&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpsBySimple&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mashibing.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">        select * from dept where deptno = #&#123;deptno&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>EmpDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mashibing.dao.EmpDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmpAndDeptBySimple&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;simpleEmpAndDept&quot;</span>&gt;</span></span><br><span class="line">        select * from emp where empno = #&#123;empno&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;simpleEmpAndDept&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;empno&quot;</span> <span class="attr">property</span>=<span class="string">&quot;empno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ename&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ename&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;job&quot;</span> <span class="attr">property</span>=<span class="string">&quot;job&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;mgr&quot;</span> <span class="attr">property</span>=<span class="string">&quot;mgr&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;hiredate&quot;</span> <span class="attr">property</span>=<span class="string">&quot;hiredate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;sal&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sal&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;comm&quot;</span> <span class="attr">property</span>=<span class="string">&quot;common&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.mashibing.dao.DeptDao.getDeptAndEmpsBySimple&quot;</span> <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test08</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据库的会话</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">EmpDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpDao.class);</span><br><span class="line"><span class="comment">//            Emp emp = mapper.selectEmpAndDept(7369);</span></span><br><span class="line">            <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.selectEmpAndDeptBySimple(<span class="number">7369</span>);</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>集合的分步查询</strong></p>
<p>EmpDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.bean.Emp;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.MapKey;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Param;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmpDao</span> &#123;</span><br><span class="line">    Emp <span class="title function_">selectEmpAndDeptBySimple</span><span class="params">(Integer empno)</span>;</span><br><span class="line">    Emp <span class="title function_">selectEmpByStep</span><span class="params">(Integer empno)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DeptDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mashibing.bean.Dept;</span><br><span class="line"><span class="keyword">import</span> com.mashibing.bean.Emp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeptDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">getDeptAndEmps</span><span class="params">(Integer deptno)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">getDeptAndEmpsBySimple</span><span class="params">(Integer deptno)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dept <span class="title function_">getDeptAndEmpsByStep</span><span class="params">(Integer deptno)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EmpDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mashibing.dao.EmpDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectEmpByStep&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp where deptno = #&#123;deptno&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>DeptDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.mashibing.dao.DeptDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpsByStep&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;deptEmpByStep&quot;</span>&gt;</span></span><br><span class="line">        select * from dept where deptno = #&#123;deptno&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;deptEmpByStep&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.mashibing.bean.Dept&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dname&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;loc&quot;</span> <span class="attr">column</span>=<span class="string">&quot;loc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--封装集合类的元素</span></span><br><span class="line"><span class="comment">            property：指定集合的属性</span></span><br><span class="line"><span class="comment">            ofType:指定集合中的元素类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.mashibing.dao.EmpDao.selectEmpByStep&quot;</span> <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Test</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test09</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取数据库的会话</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">DeptDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DeptDao.class);</span><br><span class="line"><span class="comment">//            Dept deptAndEmps = mapper.getDeptAndEmps(10);</span></span><br><span class="line">            <span class="type">Dept</span> <span class="variable">deptAndEmpsByStep</span> <span class="operator">=</span> mapper.getDeptAndEmpsByStep(<span class="number">10</span>);</span><br><span class="line">            System.out.println(deptAndEmpsByStep);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、延迟查询"><a href="#8、延迟查询" class="headerlink" title="8、延迟查询"></a>8、延迟查询</h3><p>当我们在进行表关联的时候，有可能在查询结果的时候不需要关联对象的属性值，那么此时可以通过延迟加载来实现功能。在全局配置文件中添加如下属性</p>
<p>mybatis-config.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启延时加载--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果设置了全局加载，但是希望在某一个sql语句查询的时候不适用延时策略，可以添加如下属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.mashibing.dao.DeptDao.getDeptAndEmpsBySimple&quot;</span> <span class="attr">column</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;eager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3、动态sql"><a href="#3、动态sql" class="headerlink" title="3、动态sql"></a>3、动态sql</h2><p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p>
<p>使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。</p>
<p>如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</p>
<ul>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
<h3 id="1、if"><a href="#1、if" class="headerlink" title="1、if"></a>1、if</h3><p>EmpDao.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp where </span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empno!=null&quot;</span>&gt;</span></span><br><span class="line">            empno &gt; #&#123;empno&#125; and</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename!=null&quot;</span>&gt;</span></span><br><span class="line">            ename like #&#123;ename&#125; and</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal!=null&quot;</span>&gt;</span></span><br><span class="line">            sal &gt; #&#123;sal&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>EmpDao.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Emp&gt; <span class="title function_">getEmpByCondition</span><span class="params">(Emp emp)</span>;</span><br></pre></td></tr></table></figure>

<p>Test.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test10</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">EmpDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpDao.class);</span><br><span class="line">           <span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>();</span><br><span class="line">           emp.setEmpno(<span class="number">6500</span>);</span><br><span class="line">           emp.setEname(<span class="string">&quot;%E%&quot;</span>);</span><br><span class="line">           emp.setSal(<span class="number">500.0</span>);</span><br><span class="line">           List&lt;Emp&gt; empByCondition = mapper.getEmpByCondition(emp);</span><br><span class="line">           <span class="keyword">for</span> (Emp emp1 : empByCondition) &#123;</span><br><span class="line">               System.out.println(emp1);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           sqlSession.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>看起来测试是比较正常的，但是大家需要注意的是如果我们传入的参数值有缺失会怎么呢？这个时候拼接的sql语句就会变得有问题，例如不传参数或者丢失最后一个参数，那么语句中就会多一个where或者and的关键字，因此在mybatis中也给出了具体的解决方案：</p>
<p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empno!=null&quot;</span>&gt;</span></span><br><span class="line">                empno &gt; #&#123;empno&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename!=null&quot;</span>&gt;</span></span><br><span class="line">                and ename like #&#123;ename&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal!=null&quot;</span>&gt;</span></span><br><span class="line">                and sal &gt; #&#123;sal&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在看起来没有什么问题了，但是我们的条件添加到了拼接sql语句的前后，那么我们该如何处理呢？</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">   trim截取字符串：</span></span><br><span class="line"><span class="comment">   prefix：前缀，为sql整体添加一个前缀</span></span><br><span class="line"><span class="comment">   prefixOverrides:去除整体字符串前面多余的字符</span></span><br><span class="line"><span class="comment">   suffixOverrides:去除后面多余的字符串</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">       select * from emp</span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">prefixOverrides</span>=<span class="string">&quot;and&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empno!=null&quot;</span>&gt;</span></span><br><span class="line">               empno &gt; #&#123;empno&#125; and</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename!=null&quot;</span>&gt;</span></span><br><span class="line">               ename like #&#123;ename&#125; and</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal!=null&quot;</span>&gt;</span></span><br><span class="line">               sal &gt; #&#123;sal&#125; and</span><br><span class="line">           <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、foreach"><a href="#2、foreach" class="headerlink" title="2、foreach"></a>2、foreach</h3><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--foreach是对集合进行遍历</span></span><br><span class="line"><span class="comment">    collection=&quot;deptnos&quot;  指定要遍历的集合</span></span><br><span class="line"><span class="comment">    close=&quot;&quot; 表示以什么结束</span></span><br><span class="line"><span class="comment">    index=&quot;&quot; 给定一个索引值</span></span><br><span class="line"><span class="comment">    item=&quot;&quot;  遍历的每一个元素的值</span></span><br><span class="line"><span class="comment">    open=&quot;&quot;  表示以什么开始</span></span><br><span class="line"><span class="comment">    separator=&quot;&quot; 表示多个元素的分隔符</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByDeptnos&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp where deptno in </span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;deptnos&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">index</span>=<span class="string">&quot;idx&quot;</span> <span class="attr">item</span>=<span class="string">&quot;deptno&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;deptno&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、choose"><a href="#3、choose" class="headerlink" title="3、choose"></a>3、choose</h3><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByConditionChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.mashibing.bean.Emp&quot;</span>&gt;</span></span><br><span class="line">        select * from emp</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empno!=null&quot;</span>&gt;</span></span><br><span class="line">                    empno &gt; #&#123;empno&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;ename!=null&quot;</span>&gt;</span></span><br><span class="line">                    ename like #&#123;ename&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sal!=null&quot;</span>&gt;</span></span><br><span class="line">                    sal &gt; #&#123;sal&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                    1=1</span><br><span class="line">                <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4、set"><a href="#4、set" class="headerlink" title="4、set"></a>4、set</h3><p>用于动态更新语句的类似解决方案叫做 <em>set</em>。<em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateEmpByEmpno&quot;</span>&gt;</span></span><br><span class="line">    update emp</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empno!=null&quot;</span>&gt;</span></span><br><span class="line">            empno=#&#123;empno&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ename!=null&quot;</span>&gt;</span></span><br><span class="line">            ename = #&#123;ename&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sal!=null&quot;</span>&gt;</span></span><br><span class="line">            sal = #&#123;sal&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        empno = #&#123;empno&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="4、缓存"><a href="#4、缓存" class="headerlink" title="4、缓存"></a>4、缓存</h2><p>MyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。为了使它更加强大而且易于配置，我们对 MyBatis 3 中的缓存实现进行了许多改进。</p>
<p>默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>当添加上该标签之后，会有如下效果：</p>
<ul>
<li>映射语句文件中的所有 select 语句的结果将会被缓存。</li>
<li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li>
<li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li>
<li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li>
<li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li>
<li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li>
</ul>
<p>在进行配置的时候还会分为一级缓存和二级缓存：</p>
<p>一级缓存：线程级别的缓存，是本地缓存，sqlSession级别的缓存</p>
<p>二级缓存：全局范围的缓存，不止局限于当前会话</p>
<h3 id="1、一级缓存的使用"><a href="#1、一级缓存的使用" class="headerlink" title="1、一级缓存的使用"></a>1、一级缓存的使用</h3><p>一级缓存是sqlsession级别的缓存，默认是存在的。在下面的案例中，大家发现我发送了两个相同的请求，但是sql语句仅仅执行了一次，那么就意味着第一次查询的时候已经将结果进行了缓存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="type">EmpDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpDao.class);</span><br><span class="line">           List&lt;Emp&gt; list = mapper.selectAllEmp();</span><br><span class="line">           <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">               System.out.println(emp);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line">           List&lt;Emp&gt; list2 = mapper.selectAllEmp();</span><br><span class="line">           <span class="keyword">for</span> (Emp emp : list2) &#123;</span><br><span class="line">               System.out.println(emp);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           sqlSession.close();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在大部分的情况下一级缓存是可以的，但是有几种特殊的情况会造成一级缓存失效：</p>
<p>1、一级缓存是sqlSession级别的缓存，如果在应用程序中只有开启了多个sqlsession，那么会造成缓存失效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">EmpDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpDao.class);</span><br><span class="line">        List&lt;Emp&gt; list = mapper.selectAllEmp();</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">EmpDao</span> <span class="variable">mapper2</span> <span class="operator">=</span> sqlSession2.getMapper(EmpDao.class);</span><br><span class="line">        List&lt;Emp&gt; list2 = mapper2.selectAllEmp();</span><br><span class="line">        <span class="keyword">for</span> (Emp emp : list2) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        sqlSession2.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>2、在编写查询的sql语句的时候，一定要注意传递的参数，如果参数不一致，那么也不会缓存结果</p>
<p>3、如果在发送过程中发生了数据的修改，那么结果就不会缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">       <span class="type">EmpDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpDao.class);</span><br><span class="line">       <span class="type">Emp</span> <span class="variable">empByEmpno</span> <span class="operator">=</span> mapper.findEmpByEmpno(<span class="number">1111</span>);</span><br><span class="line">       System.out.println(empByEmpno);</span><br><span class="line">       </span><br><span class="line">       empByEmpno.setEname(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mapper.updateEmp(empByEmpno);</span><br><span class="line">       System.out.println(i);</span><br><span class="line">       </span><br><span class="line">       <span class="type">Emp</span> <span class="variable">empByEmpno1</span> <span class="operator">=</span> mapper.findEmpByEmpno(<span class="number">1111</span>);</span><br><span class="line">       System.out.println(empByEmpno1);</span><br><span class="line">       sqlSession.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>4、在两次查询期间，手动去清空缓存，也会让缓存失效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">EmpDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpDao.class);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">empByEmpno</span> <span class="operator">=</span> mapper.findEmpByEmpno(<span class="number">1111</span>);</span><br><span class="line">        System.out.println(empByEmpno);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;手动清空缓存&quot;</span>);</span><br><span class="line">        sqlSession.clearCache();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Emp</span> <span class="variable">empByEmpno1</span> <span class="operator">=</span> mapper.findEmpByEmpno(<span class="number">1111</span>);</span><br><span class="line">        System.out.println(empByEmpno1);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、二级缓存"><a href="#2、二级缓存" class="headerlink" title="2、二级缓存"></a>2、二级缓存</h3><p>二级缓存是全局作用域缓存，默认是不开启的，需要手动进行配置。</p>
<p>Mybatis提供二级缓存的接口以及实现，缓存实现的时候要求实体类实现Serializable接口，二级缓存在sqlSession关闭或提交之后才会生效。</p>
<h4 id="1、缓存的使用"><a href="#1、缓存的使用" class="headerlink" title="1、缓存的使用"></a>1、缓存的使用</h4><p>步骤：</p>
<p>1、全局配置文件中添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span> = <span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span> = <span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、需要在使用二级缓存的映射文件出使用标签标注</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、实体类必须要实现Serializable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test04</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="type">EmpDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpDao.class);</span><br><span class="line">        <span class="type">EmpDao</span> <span class="variable">mapper2</span> <span class="operator">=</span> sqlSession2.getMapper(EmpDao.class);</span><br><span class="line">        <span class="type">Emp</span> <span class="variable">empByEmpno</span> <span class="operator">=</span> mapper.findEmpByEmpno(<span class="number">1111</span>);</span><br><span class="line">        System.out.println(empByEmpno);</span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line">        <span class="type">Emp</span> <span class="variable">empByEmpno1</span> <span class="operator">=</span> mapper2.findEmpByEmpno(<span class="number">1111</span>);</span><br><span class="line">        System.out.println(empByEmpno1);</span><br><span class="line">        sqlSession2.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、缓存的属性"><a href="#2、缓存的属性" class="headerlink" title="2、缓存的属性"></a>2、缓存的属性</h4><ul>
<li><code>eviction</code>:表示缓存回收策略，默认是LRU<ul>
<li>LRU：最近最少使用的，移除最长时间不被使用的对象</li>
<li>FIFO：先进先出，按照对象进入缓存的顺序来移除</li>
<li>SOFT：软引用，移除基于垃圾回收器状态和软引用规则的对象</li>
<li>WEAK：弱引用，更积极地移除基于垃圾收集器状态和弱引用规则的对象</li>
</ul>
</li>
<li><code>flushInternal</code>:缓存刷新间隔，缓存多长时间刷新一次，默认不清空，设置一个毫秒值</li>
<li><code>size</code>：引用数目，正整数，代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li>
<li><code>readonly</code>：是否只读；<ul>
<li><strong>true 只读</strong>，MyBatis 认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。MyBatis 为了加快获取数据，直接就会将数据在缓存中的引用交给用户。不安全，速度快。</li>
<li>**false 读写(默认)**：MyBatis 觉得数据可能会被修改，会将缓存中获取的数据深拷贝一份返回给调用者。</li>
</ul>
</li>
<li><code>type</code>: 指定自定义缓存的全类名(实现Cache 接口即可)</li>
<li><code>blocking</code>： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以看到会去二级缓存中查找数据，而且二级缓存跟一级缓存中不会同时存在数据，因为二级缓存中的数据是在sqlsession 关闭之后才生效的</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="type">EmpDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpDao.class);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">empByEmpno</span> <span class="operator">=</span> mapper.findEmpByEmpno(<span class="number">1111</span>);</span><br><span class="line">    System.out.println(empByEmpno);</span><br><span class="line">    sqlSession.close();</span><br><span class="line"></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="type">EmpDao</span> <span class="variable">mapper2</span> <span class="operator">=</span> sqlSession2.getMapper(EmpDao.class);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">empByEmpno2</span> <span class="operator">=</span> mapper2.findEmpByEmpno(<span class="number">1111</span>);</span><br><span class="line">    System.out.println(empByEmpno2);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">empByEmpno3</span> <span class="operator">=</span> mapper2.findEmpByEmpno(<span class="number">1111</span>);</span><br><span class="line">    System.out.println(empByEmpno3);</span><br><span class="line">    sqlSession2.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存查询的顺序是先查询二级缓存再查询一级缓存</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test05</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="type">EmpDao</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpDao.class);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">empByEmpno</span> <span class="operator">=</span> mapper.findEmpByEmpno(<span class="number">1111</span>);</span><br><span class="line">    System.out.println(empByEmpno);</span><br><span class="line">    sqlSession.close();</span><br><span class="line"></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="type">EmpDao</span> <span class="variable">mapper2</span> <span class="operator">=</span> sqlSession2.getMapper(EmpDao.class);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">empByEmpno2</span> <span class="operator">=</span> mapper2.findEmpByEmpno(<span class="number">1111</span>);</span><br><span class="line">    System.out.println(empByEmpno2);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">empByEmpno3</span> <span class="operator">=</span> mapper2.findEmpByEmpno(<span class="number">1111</span>);</span><br><span class="line">    System.out.println(empByEmpno3);</span><br><span class="line"></span><br><span class="line">    <span class="type">Emp</span> <span class="variable">empByEmpno4</span> <span class="operator">=</span> mapper2.findEmpByEmpno(<span class="number">7369</span>);</span><br><span class="line">    System.out.println(empByEmpno4);</span><br><span class="line">    <span class="type">Emp</span> <span class="variable">empByEmpno5</span> <span class="operator">=</span> mapper2.findEmpByEmpno(<span class="number">7369</span>);</span><br><span class="line">    System.out.println(empByEmpno5);</span><br><span class="line">    sqlSession2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、二级缓存的作用范围："><a href="#3、二级缓存的作用范围：" class="headerlink" title="3、二级缓存的作用范围："></a>3、二级缓存的作用范围：</h4><p>如果设置了全局的二级缓存配置，那么在使用的时候需要注意，在每一个单独的select语句中，可以设置将查询缓存关闭，以完成特殊的设置</p>
<p>1、在setting中设置，是配置二级缓存开启，一级缓存默认一直开启</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、select标签的useCache属性：</p>
<p>在每一个select的查询中可以设置当前查询是否要使用二级缓存，只对二级缓存有效</p>
<p>3、sql标签的flushCache属性</p>
<p>增删改操作默认值为true，sql执行之后会清空一级缓存和二级缓存，而查询操作默认是false</p>
<p>4、sqlSession.clearCache()</p>
<p>只是用来清楚一级缓存</p>
<h3 id="3、整合第三方缓存"><a href="#3、整合第三方缓存" class="headerlink" title="3、整合第三方缓存"></a>3、整合第三方缓存</h3><p>在某些情况下我们也可以自定义实现缓存，或为其他第三方缓存方案创建适配器，来完全覆盖缓存行为。 </p>
<p>1、导入对应的maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.ehcache/ehcache --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0-alpha1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-log4j12 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0-alpha1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、导入ehcache配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\ehcache&quot;</span> /&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="tag">&lt;<span class="name">defaultCache</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1&quot;</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span> </span></span><br><span class="line"><span class="tag">   <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">属性说明：</span></span><br><span class="line"><span class="comment">l diskStore：指定数据在磁盘中的存储位置。</span></span><br><span class="line"><span class="comment">l defaultCache：当借助CacheManager.add(&quot;demoCache&quot;)创建Cache时，EhCache便会采用&lt;defalutCache/&gt;指定的的管理策略</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">以下属性是必须的：</span></span><br><span class="line"><span class="comment">l maxElementsInMemory - 在内存中缓存的element的最大数目 </span></span><br><span class="line"><span class="comment">l maxElementsOnDisk - 在磁盘上缓存的element的最大数目，若是0表示无穷大</span></span><br><span class="line"><span class="comment">l eternal - 设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断</span></span><br><span class="line"><span class="comment">l overflowToDisk - 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">以下属性是可选的：</span></span><br><span class="line"><span class="comment">l timeToIdleSeconds - 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时，这些数据便会删除，默认值是0,也就是可闲置时间无穷大</span></span><br><span class="line"><span class="comment">l timeToLiveSeconds - 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</span></span><br><span class="line"><span class="comment"> diskSpoolBufferSizeMB 这个参数设置DiskStore(磁盘缓存)的缓存区大小.默认是30MB.每个Cache都应该有自己的一个缓冲区.</span></span><br><span class="line"><span class="comment">l diskPersistent - 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。</span></span><br><span class="line"><span class="comment">l diskExpiryThreadIntervalSeconds - 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s，相应的线程会进行一次EhCache中数据的清理工作</span></span><br><span class="line"><span class="comment">l memoryStoreEvictionPolicy - 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出）</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、在mapper文件中添加自定义缓存</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程的艺术</title>
    <url>/posts/db811320f87a/</url>
    <content><![CDATA[<h1 id="Java并发编程的艺术"><a href="#Java并发编程的艺术" class="headerlink" title="Java并发编程的艺术"></a>Java并发编程的艺术</h1><h2 id="第1章-并发编程的挑战"><a href="#第1章-并发编程的挑战" class="headerlink" title="第1章　并发编程的挑战"></a>第1章　并发编程的挑战</h2><h3 id="多线程存在的一些问题"><a href="#多线程存在的一些问题" class="headerlink" title="多线程存在的一些问题"></a>多线程存在的一些问题</h3><p>比如上下文切换、死锁的问题，以及受限于软件和硬件的资源限制问题。</p>
<p>软件资源限制：有数据库的链接数和socket连接数等</p>
<p>硬件的资源限制有带宽的上传、下载速度、硬盘读写速度和CPU处理速度。</p>
<h3 id="如何减少上下文切换"><a href="#如何减少上下文切换" class="headerlink" title="如何减少上下文切换"></a>如何减少上下文切换</h3><ol>
<li>无锁并发编程，例如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li>
<li>CAS算法，Java的Atomic包</li>
<li>使用最少线程，避免大量线程处于等待状态</li>
<li>使用协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ol>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><ol>
<li>避免一个线程获得多个锁</li>
<li>避免一个线程在锁内同时占有多个资源，尽量保证每个锁只占用一个资源</li>
<li>尝试使用定时锁，使用lock.tryLock（timeout）替代内部锁机制</li>
<li>数据库锁，加锁和解锁在一个数据库连接里，避免解锁失败</li>
</ol>
<blockquote>
<p>建议使用并发容器和工具类来解决并发问题</p>
</blockquote>
<h2 id="第2章-并发机制的底层实现原理"><a href="#第2章-并发机制的底层实现原理" class="headerlink" title="第2章 并发机制的底层实现原理"></a>第2章 并发机制的底层实现原理</h2><p>java代码编译成.class字节码，字节码被<code>类加载器</code>加载到jvm当中，jvm执行字节码，最终需要转化为汇编指令在CPU上执行。Java中所使用的并发机制依赖于JVM的实现和CPU的指令。</p>
<p>在多线程并发编程中synchronized和volatile都扮演着重要的角色，volatile是轻量级的synchronized。</p>
<p>相关CPU术语与说明</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325211907.png" alt="image-20210924145629979"></p>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p><em>保证了共享变量的可见性，但并不保证操作的原子性</em></p>
<p>特性：</p>
<ul>
<li>可见性，该关键字可以确保对一个共享变量更新对其他线程马上可见，从而解决<code>内存可见性</code>问题。</li>
<li>禁止指令重排</li>
</ul>
<p>volatile是如何来保证可见性的呢</p>
<p>如果对声明了volatile的变量进行写操作，jvm就会向处理器发送一条<code>Lock前缀的指令</code>，将这个变量所在缓存行的数据写回系统内存，同时根据处理器的<code>缓存一致性协议</code>，每个处理器通过嗅探在总线上传播的数据来检查自己的数据是否过期，过期就要设置无效重新加载。</p>
<p>Lock前缀的指令在多核处理器下会引发了两件事情</p>
<ul>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个缓存回写到内存的操作会使其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
<blockquote>
<p>知识点：lock前缀，缓存一致性</p>
</blockquote>
<p>内存语义的实现:</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<p>实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VolatileBarrierExample</span> &#123;</span><br><span class="line">	<span class="type">int</span> a;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">readAndWrite</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> v1;　　 <span class="comment">// 第一个volatile读</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> v2; 　 <span class="comment">// 第二个volatile读</span></span><br><span class="line">		a = i + j; <span class="comment">// 普通写</span></span><br><span class="line">		v1 = i + <span class="number">1</span>; 　 <span class="comment">// 第一个volatile写</span></span><br><span class="line">		v2 = j * <span class="number">2</span>; 　 <span class="comment">// 第二个 volatile写</span></span><br><span class="line">	&#125;</span><br><span class="line">	…　　　　　　 <span class="comment">// 其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325211923.png" alt="image-20210926105543345"></p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>实现同步的基础，java中每一个对象都可以作为锁：</p>
<ul>
<li>对于普通同步方法，锁是当前实例对象</li>
<li>对于静态同步方法，锁是当前类的Class对象</li>
<li>对于同步方法块，锁是Synchonized括号里面的配置对象</li>
</ul>
<p>每个对象有一个monitor与之关联，获得monitor获得锁，代码块同步是使用monitorenter和monitorexit实现的，分别插入到同步代码块的前后位置。检查是否持有monitor所有权，即尝试获得对象的锁。</p>
<p><strong>偏向锁</strong></p>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。为了解决同一线程多次获得一个锁，需要频繁切换上下文等问题。</p>
<p>做法：</p>
<ul>
<li>在锁对象的对象头和栈帧的锁记录里存储锁偏向的线程ID，进入和退出同步块时检测对象头的Mark Word里是否存储着指向当前线程的偏向锁。</li>
<li>如果测试成功，表示线程已经获得了锁。</li>
<li>如果检测没有偏向锁，再检测Mark Word中的锁标识是否设置为1（表示当前是偏向锁），<ul>
<li>如果没有设置就是用CAS竞争锁</li>
<li>如果设置了1，就尝试用CAS将对象的偏向锁指向当前线程</li>
</ul>
</li>
</ul>
<p><strong>轻量级锁</strong></p>
<p>加锁：</p>
<ul>
<li>在当前线程的栈帧中创建用于存储锁记录的空间，将对象头中的Mark Word复制到锁记录中，然后尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针，失败则与其他线程竞争，尝试自旋获得锁。</li>
</ul>
<p>解锁：</p>
<ul>
<li>CAS将栈帧中存储的Mark Word替换回对象中，失败就代表存在竞争，膨胀为重量级锁</li>
</ul>
<p><strong>锁升级过程</strong></p>
<blockquote>
<p>这几种都不是Java语言中的锁，而是Jvm为了提高锁的获取与释放效率而做的优化(使用synchronized时)。</p>
</blockquote>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325211935.png" alt="img"></p>
<p><strong>锁的优缺点对比</strong></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325211945.png" alt="image-20210924154043641"></p>
<h3 id="原子操作的实现原理atomic"><a href="#原子操作的实现原理atomic" class="headerlink" title="原子操作的实现原理atomic"></a>原子操作的实现原理atomic</h3><p>先要了解一下相关的术语</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325211956.png" alt="image-20210924154542611"></p>
<p><strong>处理器</strong></p>
<p>处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。</p>
<ul>
<li>基于总线。使用处理器提供的一个LOCK 信号，当一个处理器在总线上输出此信号时，其他处理器的请求被阻塞，该处理器独占总线。</li>
<li>基于缓存。使用缓存一致性原则</li>
</ul>
<p><strong>java</strong></p>
<p>使用锁和循环CAS的方式实现</p>
<ul>
<li>CAS，循环进行CAS直到成功。存在三大问题：</li>
</ul>
<ol>
<li>ABA问题</li>
<li>循环时间长开销大</li>
<li>只能保证一个共享变量的原子操作，可以考虑把多个变量合成，或者使用锁</li>
</ol>
<ul>
<li>使用锁。偏向锁，轻量级锁和互斥锁。除了偏向锁，其他实现锁的方式都使用了循环CAS获得和释放锁</li>
</ul>
<h2 id="第3章-java内存模型"><a href="#第3章-java内存模型" class="headerlink" title="第3章 java内存模型"></a>第3章 java内存模型</h2><p>并发编程需要解决两大问题，线程如何通信和同步。</p>
<p><strong>通信</strong>是指线程之间以何种机制来交换信息。通信机制有两种：<strong>共享内存和消息传递</strong></p>
<ul>
<li>共享内存是通过读写内存中的公共状态进行隐式通信，</li>
<li>消息传递是发送消息进行显示通信</li>
</ul>
<p><strong>同步</strong>是指程序中用于控制不同线程间发生相对顺序的机制。</p>
<ul>
<li>在共享内存并发模型里，同步是显式进行的。</li>
<li>在消息传递的并发模型里，同步是隐式进行的。</li>
</ul>
<p>Java的并发采用的是<code>共享内存模型</code>，线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p>
<p><code>内存可见性问题</code></p>
<h3 id="Java内存模型的抽象结构（JMM）"><a href="#Java内存模型的抽象结构（JMM）" class="headerlink" title="Java内存模型的抽象结构（JMM）"></a>Java内存模型的抽象结构（JMM）</h3><p>共享变量：实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。</p>
<p>局部变量：方法定义参数和异常处理器参数不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影<br>响。</p>
<p>线程之间的共享变量存储在<code>主内存</code>中，每个线程都有一个私有的<code>本地内存</code>，本地内存中存储了该线程以读/写共享变量的<code>副本</code>。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212005.png" alt="image-20210924172723256"></p>
<h3 id="从源代码到指令重排"><a href="#从源代码到指令重排" class="headerlink" title="从源代码到指令重排"></a>从源代码到指令重排</h3><p>在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。</p>
<ul>
<li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212023.png" alt="image-20210924173025880"></p>
<p>1属于编译器重排序，2和3属于处理器重排序。这些重排序可能会导致多线程程序出现<code>内存可见性</code>问题。</p>
<p>对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过<code>内存屏障指令</code>来禁止特定类型的处理器重排序。</p>
<h3 id="happens-before简介"><a href="#happens-before简介" class="headerlink" title="happens-before简介"></a>happens-before简介</h3><p>在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关<br>系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212034.png" alt="image-20210924185115054"></p>
<h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a>as-if-serial语义</h3><p>不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义</p>
<h3 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h3><p>锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</p>
<h4 id="锁的释放-获取建立的happens-before关系"><a href="#锁的释放-获取建立的happens-before关系" class="headerlink" title="锁的释放-获取建立的happens-before关系"></a>锁的释放-获取建立的happens-before关系</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MonitorExample</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;　　　　 <span class="comment">// 1</span></span><br><span class="line">		a++;　　　　　　　　　　 <span class="comment">// 2</span></span><br><span class="line">	&#125;　　　　　　　　　　　　 <span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;　　　 <span class="comment">// 4</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a;　　　　　　　　 <span class="comment">// 5</span></span><br><span class="line">		……</span><br><span class="line">	&#125;　　　　　　　　　　　　 <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述happens-before关系的图形化表现形式如图</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212045.png" alt="image-20210926110420079"></p>
<h4 id="锁的释放和获取的内存语义"><a href="#锁的释放和获取的内存语义" class="headerlink" title="锁的释放和获取的内存语义"></a>锁的释放和获取的内存语义</h4><p>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212052.png" alt="image-20210926110635294"></p>
<p>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212102.png" alt="image-20210926110744460"></p>
<p>锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</p>
<p><strong>下面对锁释放和锁获取的内存语义做个总结</strong>。</p>
<ul>
<li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li>
<li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li>
<li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
<p>现在对公平锁和非公平锁的内存语义做个总结。</p>
<ul>
<li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li>
<li>公平锁获取时，首先会去读volatile变量。</li>
<li>非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。</li>
</ul>
<p>锁释放-获取的内存语义的实现至少有下面两种方式。</p>
<ul>
<li>利用volatile变量的写-读所具有的内存语义。</li>
<li>利用CAS所附带的volatile读和volatile写的内存语义。</li>
</ul>
<h3 id="concurrent包的实现"><a href="#concurrent包的实现" class="headerlink" title="concurrent包的实现"></a>concurrent包的实现</h3><p>由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现在有了下面4种方式。<br>1）A线程写volatile变量，随后B线程读这个volatile变量。<br>2）A线程写volatile变量，随后B线程用CAS更新这个volatile变量。<br>3）A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。<br>4）A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</p>
<p>如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式。<br>首先，声明共享变量为volatile。<br>然后，使用CAS的原子条件更新来实现线程之间的同步。<br>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</p>
<p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212117.png" alt="image-20210926113137763"></p>
<h3 id="双重检查锁定与延迟初始化存在的问题"><a href="#双重检查锁定与延迟初始化存在的问题" class="headerlink" title="双重检查锁定与延迟初始化存在的问题"></a>双重检查锁定与延迟初始化存在的问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleCheckedLocking</span> &#123; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Instance instance; <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// 4:第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckedLocking.class) &#123; <span class="comment">// 5:加锁</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) <span class="comment">// 6:第二次检查</span></span><br><span class="line">                	instance = <span class="keyword">new</span> <span class="title class_">Instance</span>(); <span class="comment">// 7:问题的根源出在这里</span></span><br><span class="line">                &#125; <span class="comment">// 8</span></span><br><span class="line">            &#125; <span class="comment">// 9</span></span><br><span class="line">        <span class="keyword">return</span> instance; <span class="comment">// 10</span></span><br><span class="line">    &#125; <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在线程执行到第4行，代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p>
<h4 id="问题的根源"><a href="#问题的根源" class="headerlink" title="问题的根源"></a>问题的根源</h4><p>前面的双重检查锁定示例代码的第7行（instance=new Singleton();）创建了一个对象。这一行代码可以分解为如下的3行伪代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();　　<span class="comment">// 1：分配对象的内存空间</span></span><br><span class="line">ctorInstance(memory);　 <span class="comment">// 2：初始化对象</span></span><br><span class="line">instance = memory;　　 <span class="comment">// 3：设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure>

<p>上面3行伪代码中的2和3之间，可能会被重排。重排序后的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();　　<span class="comment">// 1：分配对象的内存空间</span></span><br><span class="line">instance = memory;　　 <span class="comment">// 3：设置instance指向刚分配的内存地址// 注意，此时对象还没有被初始化！</span></span><br><span class="line">ctorInstance(memory);　 <span class="comment">// 2：初始化对象</span></span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212123.png" alt="image-20210926144316740"></p>
<p>第7行（instance=new Singleton();）如果发生重排序，另一个并发执行的线程B就有可能在第4行判断instance不为null。线程B接下来将访问instance所引用的对象，但此时这个对象可能还没有被A线程初始</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212127.png" alt="image-20210926145021996"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212146.png" alt="image-20210926145057765"></p>
<p>线程B将会访问到一个还未初始化的对象</p>
<p>在知晓了问题发生的根源之后，我们可以想出两个办法来实现线程安全的延迟初始化。</p>
<p>1）不允许2和3重排序。</p>
<p>2）允许2和3重排序，但不允许其他线程“看到”这个重排序。</p>
<h4 id="基于volatile的解决方案"><a href="#基于volatile的解决方案" class="headerlink" title="基于volatile的解决方案"></a>基于volatile的解决方案</h4><p>把instance声明为volatile型，会禁止重排序，对应上方的解决方案1</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212203.png" alt="image-20210926145321363"></p>
<h4 id="基于类初始化的解决方案"><a href="#基于类初始化的解决方案" class="headerlink" title="基于类初始化的解决方案"></a>基于类初始化的解决方案</h4><p>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> InstanceHolder.instance ;　　<span class="comment">// 这里将导致InstanceHolder类被初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">InstanceHolder</span> &#123;</span><br><span class="line">	    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Instance</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instance</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212219.png" alt="image-20210926145703039"></p>
<p>这个方案的实质是：允许3.8.2节中的3行伪代码中的2和3重排序，但不允许非构造线程（这里指线程B）“看到”这个重排序。</p>
<p>初始化一个类，包括执行这个类的静态初始化和初始化在这个类中声明的静态字段。根据Java语言规范，在首次发生下列任意一种情况时，一个类或接口类型T将被<code>立即初始化</code>。</p>
<p>1）T是一个类，而且一个T类型的实例被创建。</p>
<p>2）T是一个类，且T中声明的一个静态方法被调用。</p>
<p>3）T中声明的一个静态字段被赋值。</p>
<p>4）T中声明的一个静态字段被使用，而且这个字段不是一个常量字段。</p>
<p>5）T是一个顶级类（Top Level Class，见Java语言规范的§7.6），而且一个断言语句嵌套在T内部被执行。</p>
<p>在InstanceFactory示例代码中，首次执行getInstance()方法的线程将导致InstanceHolder类被初始化（符合情况4）。</p>
<p>Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了</p>
<p>简单来说类的初始化过程有5个阶段</p>
<p><strong>第1阶段</strong>：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化。这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。</p>
<p>假设Class对象当前还没有被初始化（初始化状态state，此时被标记为state=noInitialization），且有两个线程A和B试图同时初始化这个Class对象。图3-41是对应的示意图。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212230.png" alt="image-20210926150854453"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212236.png" alt="image-20210926150951655"></p>
<p><strong>第2阶段</strong>：线程A执行类的初始化，同时线程B在初始化锁对应的condition上等待。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212244.png" alt="image-20210926151153949"></p>
<p><strong>第3阶段</strong>：线程A设置state=initialized，然后唤醒在condition中等待的所有线程。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212309.png" alt="image-20210926151657745"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212316.png" alt="image-20210926151710271"></p>
<p><strong>第4阶段</strong>：线程B结束类的初始化处理。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212326.png" alt="image-20210926151840991"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212334.png" alt="image-20210926151947352"></p>
<p>线程A在第2阶段的A1执行类的初始化，并在第3阶段的A4释放初始化锁；线程B在第4阶段的B1获取同一个初始化锁，并在第4阶段的B4之后才开始访问这个类。</p>
<p>根据Java内存模型规范的锁规则，这里将存在如下的happens-before关系。</p>
<p>这个happens-before关系将保证：<em>线程A执行类的初始化时的写入操作（执行类的静态初始化和初始化类中声明的静态字段），线程B一定能看到</em>。</p>
<p><strong>第5阶段</strong>：线程C执行类的初始化的处理。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212504.png" alt="image-20210926152430406"></p>
<p>在第3阶段之后，类已经完成了初始化。因此线程C在第5阶段的类初始化处理过程相对简单一些（前面的线程A和B的类初始化处理过程都经历了两次锁获取-锁释放，而线程C的类初始化处理只需要经历一次锁获取-锁释放）。</p>
<p>线程A在第2阶段的A1执行类的初始化，并在第3阶段的A4释放锁；线程C在第5阶段的C1获取同一个锁，并在在第5阶段的C4之后才开始访问这个类。</p>
<p>根据Java内存模型规范的锁规则，将存在如下的happens-before关系。</p>
<p>这个happens-before关系将保证：线程A执行类的初始化时的写入操作，线程C一定能看到。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212517.png" alt="image-20210926153348690"></p>
<p><em>注意</em>　</p>
<blockquote>
<p>这里的condition和state标记是本文虚构出来的。Java语言规范并没有硬性规定一定要使用condition和state标记。JVM的具体实现只要实现类似功能即可。</p>
<p>Java语言规范允许Java的具体实现，优化类的初始化处理过程（对这里的第5阶段做优化），具体细节参见Java语言规范的12.4.2节。</p>
</blockquote>
<p>我们会发现基于类初始化的方案的实现代码更简洁。</p>
<p>但基于volatile的双重检查锁定的方案有一个额外的优势：除了可以对静态字段实现延迟初始化外，还可以对实例字段实现延迟初始化。</p>
<p>如果需要对<code>实例字段</code>使用线程安全的延迟初始化，请使用上面介绍的基于<code>volatile</code>的延迟初始化的方案；</p>
<p>如果需要对<code>静态字段</code>使用线程安全的延迟初始化，请使用上面介绍的基于<code>类初始化</code>的方案；</p>
<h2 id="第4章-Java并发编程基础"><a href="#第4章-Java并发编程基础" class="headerlink" title="第4章　Java并发编程基础"></a>第4章　Java并发编程基础</h2><p>详情请查看《Java多线程基础（1）.md》</p>
<h2 id="第5章-Java中的锁"><a href="#第5章-Java中的锁" class="headerlink" title="第5章　Java中的锁"></a>第5章　Java中的锁</h2><p>详情请查看《Java多线程基础（2）.md》</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a><strong>读写锁</strong></h3><p>Java并发包提供读写锁的实现是ReentrantReadWriteLock。</p>
<h3 id="AQS实现分析"><a href="#AQS实现分析" class="headerlink" title="AQS实现分析"></a><code>AQS</code>实现分析</h3><h3 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212538.png" alt="image-20210926180941517"></p>
<p>Condition是依赖Lock对象的。</p>
<p>Condition的使用方式比较简单，需要注意在调用方法前获取锁，使用方式如代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    	lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般都会将Condition对象作为成员变量。当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p>
<h4 id="Condition的实现分析"><a href="#Condition的实现分析" class="headerlink" title="Condition的实现分析"></a>Condition的实现分析</h4><p>ConditionObject是同步器AbstractQueuedSynchronizer的内部类。每个Condition对象都包含着一个队列（以下称为等待队列），该队列是Condition对象实现等待/通知功能的关键。</p>
<h2 id="第6章-Java并发容器和框架"><a href="#第6章-Java并发容器和框架" class="headerlink" title="第6章　Java并发容器和框架"></a>第6章　Java并发容器和框架</h2><p>详情请查看《Java并发容器和框架.md》</p>
<h2 id="第7章-Java中的13个原子操作类"><a href="#第7章-Java中的13个原子操作类" class="headerlink" title="第7章　Java中的13个原子操作类"></a>第7章　Java中的13个原子操作类</h2><p>java.util.concurrent.atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。</p>
<p>Atomic包里的类基本都是使用Unsafe实现的包装类。</p>
<h2 id="第8章-Java中的并发工具类"><a href="#第8章-Java中的并发工具类" class="headerlink" title="第8章　Java中的并发工具类"></a>第8章　Java中的并发工具类</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>countDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。</p>
<p>是通过一个计数器来实现的，计数器的初始值是线程的数量。在每个线程(任务) 完成的最后一行加上CountDownLatch.countDown()，让计数器-1；当所有线程完成-1，计数器减到0后，主线程往下执行汇总任务。</p>
<h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>让单个线程等待：多个线程(任务)完成后，进行汇总合并</p>
<p>比如数据详情页需要同时调用多个接口获取数据，并发请求获取到数据后、需要进行结果合并；或者多个数据操作完成后，需要数据check；<br>这其实都是：在多个线程(任务)完成后，进行汇总合并的场景。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年09月27日 16:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parallellimit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span> + ThreadLocalRandom.current().nextInt(<span class="number">1000</span>));</span><br><span class="line">                    System.out.println(<span class="string">&quot;finish-&quot;</span> + index + Thread.currentThread().getName());</span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await();<span class="comment">// 主线程在阻塞，当计数器==0，就唤醒主线程往下执行。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程:在所有任务运行完成后，进行结果汇总&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">finish4Thread-<span class="number">4</span></span><br><span class="line">finish1Thread-<span class="number">1</span></span><br><span class="line">finish2Thread-<span class="number">2</span></span><br><span class="line">finish3Thread-<span class="number">3</span></span><br><span class="line">finish0Thread-<span class="number">0</span></span><br><span class="line">主线程:在所有任务运行完成后，进行结果汇总</span><br></pre></td></tr></table></figure>

<h4 id="CountDownLatch-工作原理"><a href="#CountDownLatch-工作原理" class="headerlink" title="CountDownLatch 工作原理"></a><strong>CountDownLatch 工作原理</strong></h4><p>CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量；<br>调用await()方法的线程会被阻塞，直到计数器 减到 0 的时候，才能继续往下执行；</p>
<p>调用了await()进行阻塞等待的线程，它们阻塞在Latch门闩/栅栏上；只有当条件满足的时候（countDown() N次，将计数减为0），它们才能同时通过这个栅栏；以此能够实现，让所有的线程站在一个起跑线上。</p>
<h4 id="CountDownLatch与Thread-join"><a href="#CountDownLatch与Thread-join" class="headerlink" title="CountDownLatch与Thread.join"></a>CountDownLatch与Thread.join</h4><p>CountDownLatch的作用就是允许一个或多个线程等待其他线程完成操作，看起来有点类似join() 方法，但其提供了比 join() 更加灵活的API。<br>CountDownLatch可以手动控制在n个线程里调用n次countDown()方法使计数器进行减一操作，也可以在一个线程里调用n次执行减一操作。<br>而 join() 的实现原理是不停检查join线程是否存活，如果 join 线程存活则让当前线程永远等待。</p>
<p>所以两者之间相对来说还是CountDownLatch使用起来较为灵活。</p>
<h4 id="CountDownLatch与CyclicBarrier"><a href="#CountDownLatch与CyclicBarrier" class="headerlink" title="CountDownLatch与CyclicBarrier"></a>CountDownLatch与CyclicBarrier</h4><p>CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</p>
<ul>
<li>CountDownLatch一般用于一个或多个线程，等待其他线程执行完任务后，再才执行</li>
<li>CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行<br>  另外，CountDownLatch是减计数，计数减为0后不能重用；而CyclicBarrier是加计数，可置0后复用。</li>
<li></li>
</ul>
<h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>可循环使用的屏障，让一组线程到达一个屏障被阻塞，直到最后一个到达，屏幕开门继续执行。下图演示了这一过程。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212548.gif" alt="img"></p>
<p>CyclicBarrier字面意思是“可重复使用的栅栏”，CyclicBarrier 相比 CountDownLatch 来说，要简单很多，其源码没有什么高深的地方，它是 ReentrantLock 和 Condition 的组合使用。</p>
<p>看如下示意图，CyclicBarrier 和 CountDownLatch 是不是很像，只是 CyclicBarrier 可以有不止一个栅栏，因为它的栅栏（Barrier）可以重复使用（Cyclic）。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212557.png" alt="cyclicbarrier-2"></p>
<p>首先，CyclicBarrier 的源码实现和 CountDownLatch 大同小异，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现的</p>
<p>在CyclicBarrier类的内部有一个计数器，每个线程在到达屏障点的时候都会调用await方法将自己阻塞，此时计数器会减1，当计数器减为0的时候所有因调用await方法而被阻塞的线程将被唤醒。这就是实现一组线程相互等待的原理，下面我们先看看CyclicBarrier有哪些成员变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步操作锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//线程拦截器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">trip</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="comment">//每次拦截的线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> parties;</span><br><span class="line"><span class="comment">//换代前执行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"><span class="comment">//表示栅栏的当前代</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">Generation</span> <span class="variable">generation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line"><span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//静态内部类Generation</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Generation</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">broken</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier内部是通过条件队列trip来对线程进行阻塞的，并且其内部维护了两个int型的变量parties和count，parties表示每次拦截的线程数，该值在构造时进行赋值。count是内部计数器，它的初始值和parties相同，以后随着每次await方法的调用而减1，直到减为0就将所有线程唤醒。</p>
<p>CyclicBarrier有一个静态内部类Generation，该类的对象代表栅栏的当前代，就像玩游戏时代表的本局游戏，利用它可以实现循环等待。</p>
<p>barrierCommand表示换代前执行的任务，当count减为0时表示本局游戏结束，需要转到下一局。在转到下一局游戏之前会将所有阻塞的线程唤醒，在唤醒所有线程之前你可以通过指定barrierCommand来执行自己的任务。</p>
<p>CyclicBarrier 里面的一些概念</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212607.png" alt="img"></p>
<p>接下来我们看看它的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器1</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">  <span class="built_in">this</span>.parties = parties;</span><br><span class="line">  <span class="built_in">this</span>.count = parties;</span><br><span class="line">  <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//构造器2</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>(parties, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CyclicBarrier有两个构造器，其中构造器1是它的核心构造器，在这里你可以指定本局游戏的参与者数量(要拦截的线程数)以及本局结束时要执行的任务，还可以看到计数器count的初始值被设置为parties。</p>
<p>CyclicBarrier类最主要的功能就是使先到达屏障点的线程阻塞并等待后面的线程，其中它提供了两种等待的方法，分别是<code>定时等待</code>和<code>非定时等待</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非定时等待</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(toe);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定时等待</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException &#123;</span><br><span class="line">  <span class="keyword">return</span> dowait(<span class="literal">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不管是定时等待还是非定时等待，它们都调用了dowait方法，只不过是传入的参数不同而已，我们就来看看dowait方法都做了些什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核心等待方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">  lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line">    <span class="comment">//检查当前栅栏是否被打翻</span></span><br><span class="line">    <span class="keyword">if</span> (g.broken) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查当前线程是否被中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">      <span class="comment">//如果当前线程被中断会做以下三件事</span></span><br><span class="line">      <span class="comment">//1.打翻当前栅栏</span></span><br><span class="line">      <span class="comment">//2.唤醒拦截的所有线程</span></span><br><span class="line">      <span class="comment">//3.抛出中断异常</span></span><br><span class="line">      breakBarrier();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每次都将计数器的值减1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">    <span class="comment">//计数器的值减为0则需唤醒所有线程并转换到下一代</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//唤醒所有线程前先执行指定的任务</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">        <span class="keyword">if</span> (command != <span class="literal">null</span>) &#123;</span><br><span class="line">          command.run();</span><br><span class="line">        &#125;</span><br><span class="line">        ranAction = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//唤醒所有线程并转到下一代</span></span><br><span class="line">        nextGeneration();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//确保在任务未成功执行时能将所有线程唤醒</span></span><br><span class="line">        <span class="keyword">if</span> (!ranAction) &#123;</span><br><span class="line">          breakBarrier();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果计数器不为0则执行此循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//根据传入的参数来决定是定时等待还是非定时等待</span></span><br><span class="line">        <span class="keyword">if</span> (!timed) &#123;</span><br><span class="line">          trip.await();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">          nanos = trip.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">        <span class="comment">//若当前线程在等待期间被中断则打翻栅栏唤醒其他线程</span></span><br><span class="line">        <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">          breakBarrier();</span><br><span class="line">          <span class="keyword">throw</span> ie;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//若在捕获中断异常前已经完成在栅栏上的等待, 则直接调用中断操作</span></span><br><span class="line">          Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果线程因为打翻栅栏操作而被唤醒则抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (g.broken) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果线程因为换代操作而被唤醒则返回计数器的值</span></span><br><span class="line">      <span class="keyword">if</span> (g != generation) &#123;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果线程因为时间到了而被唤醒则打翻栅栏并抛出异常</span></span><br><span class="line">      <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">        breakBarrier();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切换栅栏到下一代</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//唤醒条件队列所有线程</span></span><br><span class="line">  trip.signalAll();</span><br><span class="line">  <span class="comment">//设置计数器的值为需要拦截的线程数</span></span><br><span class="line">  count = parties;</span><br><span class="line">  <span class="comment">//重新设置栅栏代次</span></span><br><span class="line">  generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//打翻当前栅栏</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">breakBarrier</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//将当前栅栏状态设置为打翻</span></span><br><span class="line">  generation.broken = <span class="literal">true</span>;</span><br><span class="line">  <span class="comment">//设置计数器的值为需要拦截的线程数</span></span><br><span class="line">  count = parties;</span><br><span class="line">  <span class="comment">//唤醒所有线程</span></span><br><span class="line">  trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在dowait方法中每次都将count减1，减完后立马进行判断看看是否等于0，如果等于0的话就会先去执行之前指定好的任务，执行完之后再调用<strong>nextGeneration</strong>方法将栅栏转到下一代。</p>
<p>在nextGeneration方法中会将所有线程唤醒，将计数器的值重新设为parties，最后会重新设置栅栏代次，在执行完nextGeneration方法之后就意味着游戏进入下一局。</p>
<p>如果计数器此时还不等于0的话就进入for循环，根据参数来决定是调用trip.awaitNanos(nanos)还是trip.await()方法，这两方法对应着定时和非定时等待。</p>
<p>如果在等待过程中当前线程被中断就会执行<strong>breakBarrier</strong>方法，该方法叫做打破栅栏，意味着游戏在中途被掐断，设置generation的broken状态为true并唤醒所有线程。同时这也说明在等待过程中有一个线程被中断整盘游戏就结束，所有之前被阻塞的线程都会被唤醒。</p>
<p>线程醒来后会执行下面三个if判断，如果是因为调用breakBarrier方法而被唤醒，则抛出异常；如果是正常的换代操作而被唤醒，则返回计数器的值；如果是因为超时而被唤醒，就调用breakBarrier打破栅栏并抛出异常。这里还需要注意的是，如果其中有一个线程因为等待超时而退出，那么整盘游戏也会结束，其他线程都会被唤醒。</p>
<p>怎么重置一个栅栏</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reset</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们设想一下，如果初始化时，指定了线程 parties = 4，前面有 3 个线程调用了 await 等待，在第 4 个线程调用 await 之前，我们调用 reset 方法，那么会发生什么？</p>
<p>首先，打破栅栏，那意味着所有等待的线程（3个等待的线程）会唤醒，await 方法会通过抛出 BrokenBarrierException 异常返回。然后开启新的一代，重置了 count 和 generation，相当于一切归零了。</p>
<h4 id="代码案例：赛马的例子"><a href="#代码案例：赛马的例子" class="headerlink" title="代码案例：赛马的例子"></a>代码案例：赛马的例子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年09月27日 18:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HorseRace</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FINISH_LINE</span> <span class="operator">=</span> <span class="number">75</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Horse&gt; horses = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Horse&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//打印赛道边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; FINISH_LINE; i++) &#123;</span><br><span class="line">            s.append(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//打印赛马轨迹</span></span><br><span class="line">        <span class="keyword">for</span>(Horse horse : horses) &#123;</span><br><span class="line">            System.out.println(horse.tracks());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否结束</span></span><br><span class="line">        <span class="keyword">for</span>(Horse horse : horses) &#123;</span><br><span class="line">            <span class="keyword">if</span>(horse.getStrides() &gt;= FINISH_LINE) &#123;</span><br><span class="line">                System.out.println(horse + <span class="string">&quot;won!&quot;</span>);</span><br><span class="line">                exec.shutdownNow();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//休息指定时间再到下一轮</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;barrier-action sleep interrupted&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">7</span>, <span class="keyword">new</span> <span class="title class_">HorseRace</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="type">Horse</span> <span class="variable">horse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Horse</span>(barrier);</span><br><span class="line">            horses.add(horse);</span><br><span class="line">            exec.execute(horse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Horse</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> counter++;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">strides</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">47</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Horse</span><span class="params">(CyclicBarrier b)</span> &#123; barrier = b; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="comment">//赛马每次随机跑几步</span></span><br><span class="line">                    strides += rand.nextInt(<span class="number">3</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tracks</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; getStrides(); i++) &#123;</span><br><span class="line">            s.append(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s.append(id);</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">int</span> <span class="title function_">getStrides</span><span class="params">()</span> &#123; <span class="keyword">return</span> strides; &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="string">&quot;Horse &quot;</span> + id + <span class="string">&quot; &quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该赛马程序主要是通过在控制台不停的打印各赛马的当前轨迹，以此达到动态显示的效果。整场比赛有多个轮次，每一轮次各个赛马都会随机走上几步然后调用await方法进行等待，当所有赛马走完一轮的时候将会执行任务将所有赛马的当前轨迹打印到控制台上。这样每一轮下来各赛马的轨迹都在不停的增长，当其中某个赛马的轨迹最先增长到指定的值的时候将会结束整场比赛，该赛马成为整场比赛的胜利者！程序的运行结果如下：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325212620.gif" alt="20181218144511713"></p>
<h4 id="CyclicBarrier与CountDownLatch的区别"><a href="#CyclicBarrier与CountDownLatch的区别" class="headerlink" title="CyclicBarrier与CountDownLatch的区别"></a>CyclicBarrier与CountDownLatch的区别</h4><p>至此我们难免会将CyclicBarrier与CountDownLatch进行一番比较。这两个类都可以实现一组线程在到达某个条件之前进行等待，它们内部都有一个计数器，当计数器的值不断的减为0的时候所有阻塞的线程将会被唤醒。</p>
<p>有区别的是CyclicBarrier的计数器由自己控制，而CountDownLatch的计数器则由使用者来控制，在CyclicBarrier中线程调用await方法不仅会将自己阻塞还会将计数器减1，而在CountDownLatch中线程调用await方法只是将自己阻塞而不会减少计数器的值。</p>
<p>另外，CountDownLatch只能拦截一轮，而CyclicBarrier可以实现循环拦截。一般来说用CyclicBarrier可以实现CountDownLatch的功能，而反之则不能，例如上面的赛马程序就只能使用CyclicBarrier来实现。总之，这两个类的异同点大致如此，至于何时使用CyclicBarrier，何时使用CountDownLatch，还需要读者自己去拿捏。</p>
<p>除此之外，CyclicBarrier还提供了：resert()、getNumberWaiting()、isBroken()等比较有用的方法。</p>
<h3 id="控制并发线程数的Semaphore"><a href="#控制并发线程数的Semaphore" class="headerlink" title="控制并发线程数的Semaphore"></a>控制并发线程数的Semaphore</h3><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p>
<h4 id="怎么使用-Semaphore？"><a href="#怎么使用-Semaphore？" class="headerlink" title="怎么使用 Semaphore？"></a>怎么使用 Semaphore？</h4><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// permits 表示许可线程的数量</span></span><br><span class="line"><span class="comment">// fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> permits, <span class="type">boolean</span> fair)</span></span><br></pre></td></tr></table></figure>



<p>重要方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// acquire() 表示阻塞并获取许可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"></span><br><span class="line"><span class="comment">// release() 表示释放许可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span></span><br></pre></td></tr></table></figure>



<p>使用案例</p>
<p>多个线程在执行，但是限制同时执行的线程数量为 2 个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年09月28日 14:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SemaphoreDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">TaskThread</span>(semaphore).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TaskThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TaskThread</span><span class="params">(Semaphore semaphore)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.semaphore = semaphore;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot; acquire&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">                System.out.println();</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot; release &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Thread-<span class="number">1</span> acquire</span><br><span class="line">Thread-<span class="number">0</span> acquire</span><br><span class="line"></span><br><span class="line">Thread-<span class="number">3</span> acquire</span><br><span class="line">Thread-<span class="number">1</span> release </span><br><span class="line">Thread-<span class="number">2</span> acquire</span><br><span class="line"></span><br><span class="line">Thread-<span class="number">0</span> release </span><br><span class="line"></span><br><span class="line">Thread-<span class="number">4</span> acquire</span><br><span class="line">Thread-<span class="number">3</span> release </span><br><span class="line"></span><br><span class="line">Thread-<span class="number">2</span> release </span><br><span class="line"></span><br><span class="line">Thread-<span class="number">4</span> release </span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意的是 Semaphore 只是对资源并发访问的线程数进行监控，并不会保证线程安全</p>
</blockquote>
<h3 id="线程间交换数据的Exchanger"><a href="#线程间交换数据的Exchanger" class="headerlink" title="线程间交换数据的Exchanger"></a>线程间交换数据的Exchanger</h3><p>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</p>
<h4 id="Exchanger的应用场景"><a href="#Exchanger的应用场景" class="headerlink" title="Exchanger的应用场景"></a>Exchanger的应用场景</h4><p><strong>Exchanger可以用于遗传算法</strong>，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。Exchanger也可以用于校对工作，比如我们需要将纸制银行流水通过人工的方式录入成电子银行流水，为了避免错误，采用AB岗两人进行录入，录入到Excel之后，系统需要加载这两个Excel，并对两个Excel数据进行校对，看看是否录入一致，代码如下所示。</p>
<p>字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年09月28日 14:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Exchanger&lt;String&gt; exgr = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> <span class="string">&quot;银行流水A&quot;</span>;<span class="comment">//A录入银行流水数据</span></span><br><span class="line">                exgr.exchange(A);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">B</span> <span class="operator">=</span> <span class="string">&quot;银行流水B&quot;</span>;<span class="comment">//B录入银行流水数据</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">A</span> <span class="operator">=</span> exgr.exchange(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;A和B数据是否一致：&quot;</span> + A.equals(B) + <span class="string">&quot;,A录入的是：&quot;</span> + A + <span class="string">&quot;,B录入是：&quot;</span> + B);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年09月28日 14:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;List&lt;Integer&gt;&gt; exchanger = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">            list.add(<span class="number">1</span>);</span><br><span class="line">            list.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                list = exchanger.exchange(list);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread1:&quot;</span> + list);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">            list2.add(<span class="number">3</span>);</span><br><span class="line">            list2.add(<span class="number">4</span>);</span><br><span class="line">            list2.add(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                list2 = exchanger.exchange(list2);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread2:&quot;</span> + list2);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>如果两个线程有一个没有执行exchange()方法，则会一直等待，如果担心有特殊情况发生，避免一直等待，可以使用exchange（V x，longtimeout，TimeUnit unit）设置最大等待时长。</p>
<h2 id="第9章-Java中的线程池"><a href="#第9章-Java中的线程池" class="headerlink" title="第9章　Java中的线程池"></a>第9章　Java中的线程池</h2><p>第一：降低资源消耗。</p>
<p>第二：提高响应速度。</p>
<p>第三：提高线程的可管理性</p>
]]></content>
      <categories>
        <category>并发多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal作用、场景、原理</title>
    <url>/posts/2c6ab7085b4f/</url>
    <content><![CDATA[<h1 id="ThreadLocal作用、场景、原理"><a href="#ThreadLocal作用、场景、原理" class="headerlink" title="ThreadLocal作用、场景、原理"></a>ThreadLocal作用、场景、原理</h1><h2 id="1、是什么？"><a href="#1、是什么？" class="headerlink" title="1、是什么？"></a>1、是什么？</h2><p>在JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。</p>
<p>ThreadLocal并不是一个Thread，而是Thread的局部变量，也许把它命名为ThreadLocalVariable更容易让人理解一些。</p>
<p>在JDK5.0中，ThreadLocal已经支持泛型，该类的类名已经变为ThreadLocal<T>。API方法也相应进行了调整，新版本的API方法分别是void set(T value)、T get()以及T initialValue()。</p>
<h2 id="2、作用？"><a href="#2、作用？" class="headerlink" title="2、作用？"></a>2、作用？</h2><blockquote>
<p>ThreadLocal是解决线程安全问题的一个思路</p>
</blockquote>
<p>多钱程访问同一个共享变量时特别容易出现并发问题，特别是在多个线程需要对一个共享变量进行写入时。为了保证线程安全，一般使用者在访问共享变量时需要进行适当的同步，如图所示。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213750.png" alt="image-20210802161210847"></p>
<p><strong>ThreadLocal</strong>是线程上下文context的代理对象，context的目的是存放数据，自然ThreadLocal也是用来<strong>存放数据</strong>，所以主要用法就是set和get操作。 源码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadLocal</span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">            map.set(<span class="built_in">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>ThreadLocal提供了线程本地变量，也就是如果你创建了一个ThreadLocal 变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。如图所示。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325213800.png" alt="image-20210802162551398"></p>
<h2 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h2><p>ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单：在ThreadLocal类中有一个静态的ThreadLocalMap，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应线程的变量副本。</p>
<p>ThreadLocalMap是Thread里面的一个属性</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214449.png" alt="在这里插入图片描述"></p>
<p>我们从源码中了解ThreadLocal的原理，下面来看一下具体ThreadLocal是如何实现的。</p>
<p>ThreadLocal类中提供了几个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get()方法是用来获取ThreadLocal在当前线程中保存的变量副本</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set()用来设置当前线程中变量的副本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove()用来移除当前线程中变量的副本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法</span></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span>&#123; &#125;</span><br></pre></td></tr></table></figure>



<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前线程中保存ThreadLocal的值</span></span><br><span class="line"><span class="comment"> * 如果当前线程没有此ThreadLocal变量，</span></span><br><span class="line"><span class="comment"> * 则它会通过调用&#123;<span class="doctag">@link</span> #initialValue&#125; 方法进行初始化值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回当前线程对应此ThreadLocal的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 2获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 3如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 3.1以当前的ThreadLocal 为 key，调用getEntry获取对应的存储实体e</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 3.2找到对应的存储实体 e </span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="comment">// 3.2.1获取存储实体 e 对应的 value值</span></span><br><span class="line">            <span class="comment">// 即为我们想要的当前线程对应此ThreadLocal的值</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3如果map不存在，则证明此线程没有维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="comment">// 调用setInitialValue进行初始化</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set的变样实现，用于初始化值initialValue，</span></span><br><span class="line"><span class="comment"> * 用于代替防止用户重写set()方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial value 初始化后的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1调用initialValue获取初始化的值</span></span><br><span class="line">    <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">    <span class="comment">// 2获取当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 3获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="comment">// 4如果此map存在</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)&#123;&#125;</span><br><span class="line">        <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">        <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">        <span class="comment">// 3）并将此实体entry作为第一个值存放至ThreadLocalMap中</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">// 返回设置的值value</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取当前线程Thread对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  t the current thread 当前线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the map 对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>createMap:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建当前线程Thread对应的ThreadLocalMap</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  t – 当前线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  firstValue – 初始条目的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the map 对应维护的ThreadLocalMap </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>threadLocals: 是thread类的变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">     <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>调用<code>get()</code>操作获取<code>ThreadLocal</code>中对应当前线程存储的值时，进行了如下操作：</p>
<p>1 ) 获取当前线程<code>Thread</code>对象，进而获取此线程对象中维护的<code>ThreadLocalMap</code>对象。</p>
<p>2 ) 判断当前的<code>ThreadLocalMap</code>是否存在：</p>
<p>如果存在，则以当前的<code>ThreadLocal</code> 为 <code>key</code>，调用<code>ThreadLocalMap</code>中的<code>getEntry</code>方法获取对应的存储实体 e。找到对应的存储实体 e，获取存储实体 e 对应的 <code>value</code>值，即为我们想要的当前线程对应此<code>ThreadLocal</code>的值，返回结果值。</p>
<p>如果不存在，则证明此线程没有维护的<code>ThreadLocalMap</code>对象，调用<code>setInitialValue</code>方法进行初始化。返回<code>setInitialValue</code>初始化的值。</p>
<p><code>setInitialValue</code>方法的操作如下：</p>
<p>1 ) 调用<code>initialValue</code>获取初始化的值。</p>
<p>2 ) 获取当前线程<code>Thread</code>对象，进而获取此线程对象中维护的<code>ThreadLocalMap</code>对象。</p>
<p>3 ) 判断当前的<code>ThreadLocalMap</code>是否存在：</p>
<p>如果存在，则调用<code>map.set</code>设置此实体<code>entry</code>。</p>
<p>如果不存在，则调用<code>createMap</code>进行<code>ThreadLocalMap</code>对象的初始化，并将此实体<code>entry</code>作为第一个值存放至<code>ThreadLocalMap</code>中。</p>
<h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214504.png" alt="在这里插入图片描述"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214508.png" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">   * 大多数子类都不需要重写此方法，</span></span><br><span class="line"><span class="comment">   * 只需要重写 &#123;<span class="doctag">@link</span> #initialValue&#125;方法代替设置当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 将要保存在当前线程对应的ThreadLocal的值</span></span><br><span class="line"><span class="comment">   *  </span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">      <span class="comment">// 获取当前线程对象</span></span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">      <span class="comment">// 获取此线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">      <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">      <span class="comment">// 如果此map存在</span></span><br><span class="line">      <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">          <span class="comment">// 存在则调用map.set设置此实体entry</span></span><br><span class="line">          map.set(<span class="built_in">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="comment">// 1）当前线程Thread 不存在ThreadLocalMap对象</span></span><br><span class="line">          <span class="comment">// 2）则调用createMap进行ThreadLocalMap对象的初始化</span></span><br><span class="line">          <span class="comment">// 3）并将此实体entry作为第一个值存放至ThreadLocalMap中</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>调用<code>set(T value)</code>操作，设置ThreadLocal中对应当前线程要存储的值时，进行了如下操作：</p>
<p>1 ) 获取当前线程<code>Thread</code>对象，进而获取此线程对象中维护的<code>ThreadLocalMap</code>对象。</p>
<p>2 ) 判断当前的<code>ThreadLocalMap</code>是否存在：</p>
<p>如果存在，则调用<code>map.set</code>设置此实体<code>entry</code>。</p>
<p>如果不存在，则调用<code>createMap</code>进行<code>ThreadLocalMap</code>对象的初始化，并将此实体<code>entry</code>作为第一个值存放至<code>ThreadLocalMap</code>中。</p>
<blockquote>
<p><strong>注意：</strong>如果使用ThreadLocal时，在进行get之前，必须先set，否则会报空指针异常</p>
</blockquote>
<p>演示空指针异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest2</span> &#123;</span><br><span class="line">    ThreadLocal&lt;Long&gt; longLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">()</span> &#123;</span><br><span class="line">        longLocal.set(Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> longLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadLocalTest2</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocalTest2</span>();</span><br><span class="line">        <span class="comment">//注意:没有set之前，直接get，报null异常了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-------threadLocal value-------&quot;</span> + test.getLong());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214514.png" alt="image-20210903144908416"></p>
<h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><ul>
<li><p>调用<code>remove()</code>操作删除ThreadLocal中对应当前线程已存储的值时，进行了如下操作：</p>
<p>  1 ) 获取当前线程<code>Thread</code>对象，进而获取此线程对象中维护的<code>ThreadLocalMap</code>对象。</p>
<p>  2 ) 判断当前的<code>ThreadLocalMap</code>是否存在， 如果存在，则调用<code>map.remove</code>，以当前<code>ThreadLocal</code>为<code>key</code>删除对应的实体<code>entry</code>。</p>
</li>
<li><p>示例代码：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除当前线程中保存的ThreadLocal对应的实体entry</span></span><br><span class="line"><span class="comment"> * 如果此ThreadLocal变量在当前线程中调用 &#123;<span class="doctag">@linkplain</span> #get read&#125;方法</span></span><br><span class="line"><span class="comment"> * 则会通过调用&#123;<span class="doctag">@link</span> #initialValue&#125;进行再次初始化，</span></span><br><span class="line"><span class="comment"> * 除非此值value是通过当前线程内置调用 &#123;<span class="doctag">@linkplain</span> #set set&#125;设置的</span></span><br><span class="line"><span class="comment"> * 这可能会导致在当前线程中多次调用&#123;<span class="doctag">@code</span> initialValue&#125;方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前线程对象中维护的ThreadLocalMap对象</span></span><br><span class="line">     <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">    <span class="comment">// 如果此map存在</span></span><br><span class="line">     <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 存在则调用map.remove</span></span><br><span class="line">        <span class="comment">// 以当前ThreadLocal为key删除对应的实体entry</span></span><br><span class="line">         m.remove(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4、应用场景？"><a href="#4、应用场景？" class="headerlink" title="4、应用场景？"></a>4、应用场景？</h2><p>可以将类变量放到ThreadLocal类型的对象中，使变量在每个线程中都有独立拷贝，不会出现一个线程读取变量时而被另一个线程修改的现象。最常见的ThreadLocal使用场景为用来解决数据库连接、Session管理、 多线程、<code>动态多数据源切换</code>等。</p>
<h2 id="5、代码示例"><a href="#5、代码示例" class="headerlink" title="5、代码示例"></a>5、代码示例</h2><p>多线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.lxiaol.xiancheng;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.classfile.LocalVariable;</span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.xpath.internal.operations.Variable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lxiaol</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021年08月02日 16:42</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建ThreadLocal 变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; localVariable = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//打印当前线程本地内存中localVariable变量的值</span></span><br><span class="line">        System.out.println(str + <span class="string">&quot;:&quot;</span> + localVariable.get());</span><br><span class="line">        <span class="comment">//清除当前线程本地内存中的localVariable 交量</span></span><br><span class="line">        <span class="comment">//localVariable.remove();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建多个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 设置线程t1中的本地变量localVariable的值</span></span><br><span class="line">            localVariable.set(<span class="string">&quot;t1 local variable&quot;</span>);</span><br><span class="line">            print(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;t1 remove after&quot;</span> + <span class="string">&quot;:&quot;</span> + localVariable.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建多个线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 设置线程t1中的本地变量localVariable的值</span></span><br><span class="line">            localVariable.set(<span class="string">&quot;t2 local variable&quot;</span>);</span><br><span class="line">            print(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;t2 remove after&quot;</span> + <span class="string">&quot;:&quot;</span> + localVariable.get());</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此在不同的线程中访问同一个 ThreadLocal 对象的 set 和 get 进行存取数据是不会相互干扰的。</p>
<h2 id="6、ThreadLocalMap"><a href="#6、ThreadLocalMap" class="headerlink" title="6、ThreadLocalMap"></a>6、ThreadLocalMap</h2><p>从上面的分析我们已经知道，数据其实都放在了threadLocalMap中，threadLocal的get，set和remove方法实际上具体是通过threadLocalMap的getEntry,set和remove方法实现的。如果想真正全方位的弄懂threadLocal，势必得在对threadLocalMap做一番理解。</p>
<p>ThreadLocalMap是threadLocal一个静态内部类，和大多数容器一样内部维护了一个数组，同样的threadLocalMap内部维护了一个Entry类型的table数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary.</span></span><br><span class="line"><span class="comment"> * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br></pre></td></tr></table></figure>



<p>通过注释可以看出，table数组的长度为2的幂次方。接下来看下Entry数据结构是什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 实体entries在此hash map中是继承弱引用 WeakReference, </span></span><br><span class="line"><span class="comment">* 使用ThreadLocal 作为 key 键.  请注意，当key为null（i.e. entry.get()</span></span><br><span class="line"><span class="comment">* == null) 意味着此key不再被引用,此时实体entry 会从哈希表中删除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">/** 当前 ThreadLocal 对应储存的值value. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Entry是一个以ThreadLocal为key,Object为value的键值对。</p>
<p>注意：这里的<strong>threadLocal是弱引用，因为Entry继承了WeakReference，在Entry的构造方法中，调用了super(k)方法就会将threadLocal实例包装成一个WeakReferenece。</strong></p>
<h2 id="7、造成内存泄漏的原因"><a href="#7、造成内存泄漏的原因" class="headerlink" title="7、造成内存泄漏的原因"></a>7、造成内存泄漏的原因</h2><p>这里我们用一个图来理解下thread,threadLocal,threadLocalMap，Entry之间的关系：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214523.jpg" alt="ThreadLocal各引用间的关系"></p>
<p><em>注意图中的实线表示强引用，虚线表示弱引用。</em></p>
<p>如图所示，每个线程实例中可以通过threadLocals获取到threadLocalMap，而threadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry数组。</p>
<p>当我们为threadLocal变量赋值，实际上就是以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放。</p>
<p>注意：<strong>Entry中的key是弱引用</strong>，当threadLocal外部强引用被置为null(<code>threadLocalInstance=null</code>)，那么系统 GC 的时候，根据<code>可达性分析</code>，这个threadLocal实例就没有任何一条链路能够引用到它，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value。</p>
<p>如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value永远无法回收，造成内存泄漏。当然，如果当前thread运行结束，threadLocal，threadLocalMap,Entry没有引用链可达，在垃圾回收的时候都会被系统进行回收。</p>
<p>在实际开发中，会使用<code>线程池</code>去维护线程的创建和复用，比如固定大小的线程池，线程为了复用是不会主动结束的，所以，threadLocal的内存泄漏问题，是应该值得我们思考和注意的问题</p>
<h2 id="8、尽可能解决内存泄漏所做的改进？"><a href="#8、尽可能解决内存泄漏所做的改进？" class="headerlink" title="8、尽可能解决内存泄漏所做的改进？"></a>8、尽可能解决内存泄漏所做的改进？</h2><p>实际上，为了解决threadLocal潜在的内存泄漏的问题，Josh Bloch and Doug Lea大师已经做了一些改进。在threadLocal的set和get方法中都有相应的处理。下文为了叙述，针对key为null的entry，源码注释为stale entry，直译为不新鲜的entry，这里我就称之为“脏entry”。比如在ThreadLocalMap的set方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置对应ThreadLocal的值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 当前thread local 对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要设置的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们不会像get()方法那样使用快速设置的方式，</span></span><br><span class="line">    <span class="comment">// 因为通常很少使用set()方法去创建新的实体</span></span><br><span class="line">    <span class="comment">// 相对于替换一个已经存在的实体, 在这种情况下,</span></span><br><span class="line">    <span class="comment">// 快速设置方案会经常失败。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的底层哈希表 table</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">// 获取哈希表长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 计算对应threalocal的存储位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历table对应该位置的实体，查找对应的threadLocal</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];e != <span class="literal">null</span>;e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// 获取当前位置的ThreadLocal</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 如果key threadLocal一致，则证明找到对应的threadLocal</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">// 赋予新值</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="comment">// 结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前位置的key threadLocal为null</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 替换该位置key == null 的实体为当前要设置的实体</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="comment">// 结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前位置的k ！= key  &amp;&amp; k != null</span></span><br><span class="line">    <span class="comment">// 创建新的实体，并存放至当前位置i</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line">    <span class="comment">// 实际存储键值对元素个数 + 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> ++size;</span><br><span class="line">    <span class="comment">// 由于弱引用带来了这个问题，所以先要清除无用数据，才能判断现在的size有没有达到阀值threshhold</span></span><br><span class="line">    <span class="comment">// 如果没有要清除的数据，存储元素个数仍然 大于 阈值 则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        <span class="comment">// 扩容</span></span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中针对脏entry做了这样的处理：</p>
<ol>
<li>如果当前table[i]！=null的话说明hash冲突就需要向后环形查找，若在查找过程中遇到脏entry就通过<code>replaceStaleEntry</code>进行处理；</li>
<li>如果当前table[i]==null的话说明新的entry可以直接插入，但是插入后会调用<code>cleanSomeSlots</code>方法检测并清除脏entry</li>
</ol>
<h3 id="8-1、cleanSomeSlots"><a href="#8-1、cleanSomeSlots" class="headerlink" title="8.1、cleanSomeSlots"></a>8.1、cleanSomeSlots</h3><p>该方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 启发式的扫描查找一些过期的实体并清除，</span></span><br><span class="line"><span class="comment">* 此方法会再添加新实体的时候被调用, </span></span><br><span class="line"><span class="comment">* 或者过期的元素被清除时也会被调用.</span></span><br><span class="line"><span class="comment">* 如果实在没有过期数据，那么这个算法的时间复杂度就是O(log n)</span></span><br><span class="line"><span class="comment">* 如果有过期数据，那么这个算法的时间复杂度就是O(n)</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> i 一个确定不是过期的实体的位置，从这个位置i开始扫描</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> n 扫描控制: 有&#123;<span class="doctag">@code</span> log2(n)&#125; 单元会被扫描,除非找到了过期的实体, 在这种情况下</span></span><br><span class="line"><span class="comment">* 有&#123;<span class="doctag">@code</span> log2(table.length)-1&#125; 的格外单元会被扫描.</span></span><br><span class="line"><span class="comment">* 当调用插入时, 这个参数的值是存储实体的个数，</span></span><br><span class="line"><span class="comment">* 但如果调用 replaceStaleEntry方法, 这个值是哈希表table的长度</span></span><br><span class="line"><span class="comment">* (注意: 所有的这些都可能或多或少的影响n的权重但是这个版本简单，快速，而且似乎执行效率还可以）</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> true 返回true，如果有任何过期的实体被删除。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">cleanSomeSlots</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        i = nextIndex(i, len);</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == <span class="literal">null</span>) &#123;</span><br><span class="line">            n = len;</span><br><span class="line">            removed = <span class="literal">true</span>;</span><br><span class="line">            i = expungeStaleEntry(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i表示：插入entry的位置i，很显然在上述情况2（table[i]==null）中，entry刚插入后该位置i很显然不是脏entry;</p>
<p><strong>参数n</strong></p>
<p>n的用途</p>
<p>主要用于<strong>扫描控制（scan control），从while中是通过n来进行条件判断的说明n就是用来控制扫描趟数（循环次数）的</strong>。在扫描过程中，如果没有遇到脏entry就整个扫描过程持续log2(n)次，log2(n)的得来是因为<code>n &gt;&gt;&gt;= 1</code>，每次n右移一位相当于n除以2。如果在扫描过程中遇到脏entry的话就会令n为当前hash表的长度（<code>n=len</code>），再扫描log2(n)趟，注意此时n增加无非就是多增加了循环次数从而通过nextIndex往后搜索的范围扩大，示意图如下</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214544.png" alt="cleanSomeSlots示意图.png"></p>
<p>按照n的初始值，搜索范围为黑线，当遇到了脏entry，此时n变成了哈希数组的长度（n取值增大），搜索范围log2(n)增大，红线表示。如果在整个搜索过程没遇到脏entry的话，搜索结束，采用这种方式的主要是用于时间效率上的平衡。</p>
<p>n的取值</p>
<p>如果是在set方法插入新的entry后调用（上述情况2），n位当前已经插入的entry个数size；如果是在replaceSateleEntry方法中调用，n为哈希表的长度len。</p>
<h3 id="8-2、expungeStaleEntry"><a href="#8-2、expungeStaleEntry" class="headerlink" title="8.2、expungeStaleEntry"></a>8.2、expungeStaleEntry</h3><p>如果对输入参数能够理解的话，那么cleanSomeSlots方法搜索基本上清除了，但是全部搞定还需要掌握expungeStaleEntry方法，当在搜索过程中遇到了脏entry的话就会调用该方法去清理掉脏entry。源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除对应位置的过期实体，并删除此位置后对应相关联位置key = null的实体</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> staleSlot 已知的key = null 的对应的位置索引</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 对应过期实体位置索引的下一个key = null的位置</span></span><br><span class="line"><span class="comment">* (所有的对应位置都会被检查)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expungeStaleEntry</span><span class="params">(<span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">     </span><br><span class="line">    Entry[] tab = table;<span class="comment">// 获取对应的底层哈希表 table</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;<span class="comment">// 获取哈希表长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.清除当前脏entry</span></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;<span class="comment">// 擦除这个位置上的脏数据</span></span><br><span class="line">    tab[staleSlot] = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//2.往后环形继续查找,直到遇到table[i]==null时结束</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">//3. 如果在向后搜索过程中再次遇到脏entry，同样将其清理掉</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>) &#123;</span><br><span class="line">            e.value = <span class="literal">null</span>;</span><br><span class="line">            tab[i] = <span class="literal">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//处理rehash的情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="comment">// 我们必须一直遍历直到最后</span></span><br><span class="line">                <span class="comment">// 因为还可能存在多个过期的实体</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="literal">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法逻辑请看注释（第1,2,3步），主要做了这么几件事情：</p>
<ol>
<li>清理当前脏entry，即将其value引用置为null，并且将table[staleSlot]也置为null。value置为null后该value域变为不可达，在下一次gc的时候就会被回收掉，同时table[staleSlot]为null后以便于存放新的entry;</li>
<li>从当前staleSlot位置向后环形（nextIndex）继续搜索，直到遇到哈希桶（tab[i]）为null的时候退出；</li>
<li>若在搜索过程再次遇到脏entry，继续将其清除。</li>
</ol>
<p>也就是说该方法，<strong>清理掉当前脏entry后，并没有闲下来继续向后搜索，若再次遇到脏entry继续将其清理，直到哈希桶（table[i]）为null时退出</strong>。因此方法执行完的结果为 <strong>从当前脏entry（staleSlot）位到返回的i位，这中间所有的entry不是脏entry</strong>。为什么是遇到null退出呢？原因是存在脏entry的前提条件是 <strong>当前哈希桶（table[i]）不为null</strong>,只是该entry的key域为null。如果遇到哈希桶为null,很显然它连成为脏entry的前提条件都不具备。</p>
<p>现在对cleanSomeSlot方法做一下总结，其方法执行示意图如下：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214553.png" alt="cleanSomeSlots示意图.png"></p>
<p>如图所示，cleanSomeSlot方法主要有这样几点：</p>
<ol>
<li>从当前位置i处（位于i处的entry一定不是脏entry）为起点在初始小范围（log2(n)，n为哈希表已插入entry的个数size）开始向后搜索脏entry，若在整个搜索过程没有脏entry，方法结束退出</li>
<li>如果在搜索过程中遇到脏entryt通过expungeStaleEntry方法清理掉当前脏entry，并且该方法会返回下一个哈希桶(table[i])为null的索引位置为i。这时重新令搜索起点为索引位置i，n为哈希表的长度len，再次扩大搜索范围为log2(n’)继续搜索。</li>
</ol>
<p>下面，以一个例子更清晰的来说一下，假设当前table数组的情况如下图。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214600.png" alt="img"></p>
<ol>
<li>如图当前n等于hash表的size即n=10，i=1,在第一趟搜索过程中通过nextIndex,i指向了索引为2的位置，此时table[2]为null，说明第一趟未发现脏entry,则第一趟结束进行第二趟的搜索。</li>
<li>第二趟所搜先通过nextIndex方法，索引由2的位置变成了i=3,当前table[3]!=null但是该entry的key为null，说明找到了一个脏entry，<strong>先将n置为哈希表的长度len,然后继续调用expungeStaleEntry方法</strong>，该方法会将当前索引为3的脏entry给清除掉（令value为null，并且table[3]也为null）,但是<strong>该方法可不想偷懒，它会继续往后环形搜索</strong>，往后会发现索引为4,5的位置的entry同样为脏entry，索引为6的位置的entry不是脏entry保持不变，直至i=7的时候此处table[7]位null，该方法就以i=7返回。至此，第二趟搜索结束；</li>
<li>由于在第二趟搜索中发现脏entry，n增大为数组的长度len，因此扩大搜索范围（增大循环次数）继续向后环形搜索；</li>
<li>直到在整个搜索范围里都未发现脏entry，cleanSomeSlot方法执行结束退出。</li>
</ol>
<h3 id="8-3、replaceStaleEntry"><a href="#8-3、replaceStaleEntry" class="headerlink" title="8.3、replaceStaleEntry"></a>8.3、replaceStaleEntry</h3><p>先来看replaceStaleEntry 方法，该方法源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当执行set操作时，获取对应的key threadLocal，并替换过期的实体</span></span><br><span class="line"><span class="comment">* 将这个value值存储在对应key threadLocal的实体中，无论是否已经存在体</span></span><br><span class="line"><span class="comment">* 对应的key threadLocal</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 有一个副作用, 此方法会删除该位置下和该位置nextIndex对应的所有过期的实体</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  key 当前thread local 对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  value 当前thread local 对象对应存储的值</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  staleSlot 第一次找到此过期的实体对应的位置索引index</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span><br><span class="line"><span class="params">                               <span class="type">int</span> staleSlot)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取对应的底层哈希表 table</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">// 获取哈希表长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往前找，找到table中第一个过期的实体的下标</span></span><br><span class="line">    <span class="comment">// 清理整个table是为了避免因为垃圾回收带来的连续增长哈希的危险</span></span><br><span class="line">    <span class="comment">// 也就是说，哈希表没有清理干净，当GC到来的时候，后果很严重</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录要清除的位置的起始首位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="comment">// 从该位置开始，往前遍历查找第一个过期的实体的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到key一致的ThreadLocal或找到一个key为 null的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果我们找到了key，那么我们就需要把它跟新的过期数据交换来保持哈希表的顺序</span></span><br><span class="line">        <span class="comment">// 那么剩下的过期Entry呢，就可以交给expungeStaleEntry方法来擦除掉</span></span><br><span class="line">        <span class="comment">// 将新设置的实体放置在此过期的实体的位置上</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">// 替换，将要设置的值放在此过期的实体中</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果存在，则开始清除之前过期的实体</span></span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 在这里开始清除过期数据</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// / 如果我们没有在往后查找中找没有找到过期的实体，</span></span><br><span class="line">        <span class="comment">// 那么slotToExpunge就是第一个过期Entry的下标了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后key仍没有找到，则将要设置的新实体放置</span></span><br><span class="line">    <span class="comment">// 在原过期的实体对应的位置上。</span></span><br><span class="line">    tab[staleSlot].value = <span class="literal">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该位置对应的其他关联位置存在过期实体，则清除</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的逻辑请看注释，下面我结合各种情况详细说一下该方法的执行过程。首先先看这一部分的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">slotToExpunge</span> <span class="operator">=</span> staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> prevIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="literal">null</span>;</span><br><span class="line">         i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="literal">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br></pre></td></tr></table></figure>

<p>这部分代码通过PreIndex方法实现往前环形搜索脏entry的功能，初始时slotToExpunge和staleSlot相同，若在搜索过程中发现了脏entry，则更新slotToExpunge为当前索引i。另外，说明replaceStaleEntry并不仅仅局限于处理当前已知的脏entry，它认为在出<strong>现脏entry的相邻位置也有很大概率出现脏entry，所以为了一次处理到位，就需要向前环形搜索，找到前面的脏entry</strong>。那么根据在向前搜索中是否还有脏entry以及在for循环后向环形查找中是否找到可覆盖的entry，我们分这四种情况来充分理解这个方法：</p>
<ul>
<li><p>1.前向有脏entry</p>
<ul>
<li><p>1.1后向环形查找找到可覆盖的entry</p>
<p>  该情形如下图所示。</p>
<p>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214607.png" alt="img"></p>
<p>  向前环形搜索到脏entry，向后环形查找到可覆盖的entry的情况.png</p>
<p>  如图，slotToExpunge初始状态和staleSlot相同，当前向环形搜索遇到脏entry时，在第1行代码中slotToExpunge会更新为当前脏entry的索引i，直到遇到哈希桶（table[i]）为null的时候，前向搜索过程结束。在接下来的for循环中进行后向环形查找，若查找到了可覆盖的entry，第2,3,4行代码先覆盖当前位置的entry，然后再与staleSlot位置上的脏entry进行交换。交换之后脏entry就更换到了i处，最后使用cleanSomeSlots方法从slotToExpunge为起点开始进行清理脏entry的过程</p>
</li>
<li><p>1.2后向环形查找未找到可覆盖的entry<br>   该情形如下图所示。</p>
<p>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214610.png" alt="img"></p>
<p>  前向环形搜索到脏entry,向后环形未搜索可覆盖entry.png</p>
<p>  如图，slotToExpunge初始状态和staleSlot相同，当前向环形搜索遇到脏entry时，在第1行代码中slotToExpunge会更新为当前脏entry的索引i，直到遇到哈希桶（table[i]）为null的时候，前向搜索过程结束。在接下来的for循环中进行后向环形查找，若没有查找到了可覆盖的entry，哈希桶（table[i]）为null的时候，后向环形查找过程结束。那么接下来在8,9行代码中，将插入的新entry直接放在staleSlot处即可，最后使用cleanSomeSlots方法从slotToExpunge为起点开始进行清理脏entry的过程</p>
</li>
</ul>
</li>
<li><p>2.前向没有脏entry</p>
<ul>
<li><p>2.1后向环形查找找到可覆盖的entry<br>   该情形如下图所示。</p>
<p>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214614.png" alt="img"></p>
<p>  前向未搜索到脏entry，后向环形搜索到可覆盖的entry.png</p>
<p>  如图，slotToExpunge初始状态和staleSlot相同，当前向环形搜索直到遇到哈希桶（table[i]）为null的时候，前向搜索过程结束，若在整个过程未遇到脏entry，slotToExpunge初始状态依旧和staleSlot相同。在接下来的for循环中进行后向环形查找，若遇到了脏entry，在第7行代码中更新slotToExpunge为位置i。若查找到了可覆盖的entry，第2,3,4行代码先覆盖当前位置的entry，然后再与staleSlot位置上的脏entry进行交换，交换之后脏entry就更换到了i处。如果在整个查找过程中都还没有遇到脏entry的话，会通过第5行代码，将slotToExpunge更新当前i处，最后使用cleanSomeSlots方法从slotToExpunge为起点开始进行清理脏entry的过程。</p>
</li>
<li><p>2.2后向环形查找未找到可覆盖的entry<br>   该情形如下图所示。</p>
<p>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214619.png" alt="img"></p>
<p>  前向环形未搜索到脏entry,后向环形查找未查找到可覆盖的entry.png</p>
<p>  如图，slotToExpunge初始状态和staleSlot相同，当前向环形搜索直到遇到哈希桶（table[i]）为null的时候，前向搜索过程结束，若在整个过程未遇到脏entry，slotToExpunge初始状态依旧和staleSlot相同。在接下来的for循环中进行后向环形查找，若遇到了脏entry，在第7行代码中更新slotToExpunge为位置i。若没有查找到了可覆盖的entry，哈希桶（table[i]）为null的时候，后向环形查找过程结束。那么接下来在8,9行代码中，将插入的新entry直接放在staleSlot处即可。另外，如果发现slotToExpunge被重置，则第10行代码if判断为true,就使用cleanSomeSlots方法从slotToExpunge为起点开始进行清理脏entry的过程。</p>
</li>
</ul>
</li>
</ul>
<p>下面用一个实例来有个直观的感受，示例代码就不给出了，代码debug时table状态如下图所示：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B/20220325214622.png" alt="img"></p>
<p>如图所示，当前的staleSolt为i=4，首先先进行前向搜索脏entry，当i=3的时候遇到脏entry，slotToExpung更新为3，当i=2的时候tabel[2]为null，因此前向搜索脏entry的过程结束。然后进行后向环形查找，知道i=7的时候遇到table[7]为null，结束后向查找过程，并且在该过程并没有找到可以覆盖的entry。最后只能在staleSlot（4）处插入新entry，然后从slotToExpunge（3）为起点进行cleanSomeSlots进行脏entry的清理。是不是上面的1.2的情况。</p>
<p>这些核心方法，通过源码又给出示例图，应该最终都能掌握了，也还挺有意思的。若觉得不错，对我的辛劳付出能给出鼓励欢迎点赞，给小弟鼓励，在此谢过 :)。</p>
<p><strong>当我们调用threadLocal的get方法</strong>时，当table[i]不是和所要找的key相同的话，会继续通过threadLocalMap的<br> getEntryAfterMiss方法向后环形去找，该方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 当根据key找不到对应的实体entry 时，调用此方法。</span></span><br><span class="line"><span class="comment">* 直接定位到对应的哈希表位置</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  key 当前thread local 对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  i 此对象在哈希表 table中的存储位置 index</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>  e the entry 实体对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the entry 对应key的 实体entry, 如果不存在，则返回null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> &#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 循环遍历当前位置的所有实体entry</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前entry 的 key ThreadLocal</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 比较key是否一致，一致则返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="comment">// 找到对应的entry ，但其key 为 null，则证明引用已经不存在</span></span><br><span class="line">        <span class="comment">// 这是因为Entry继承的是WeakReference，这是弱引用带来的坑</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 删除过期(stale)的entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// key不一致 ，key也不为空，则遍历下一个位置，继续查找</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        <span class="comment">// 获取下一个位置的实体 entry</span></span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历完毕，找不到则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当key==null的时候，即遇到脏entry也会调用expungeStleEntry对脏entry进行清理。</p>
<p><strong>当我们调用threadLocal.remove方法时候</strong>，实际上会调用threadLocalMap的remove方法，该方法的源码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 移除对应ThreadLocal的实体</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取对应的底层哈希表 table</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="comment">// 获取哈希表长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line">    <span class="comment">// 计算对应threalocal的存储位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 循环遍历table对应该位置的实体，查找对应的threadLocal</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> tab[i];e != <span class="literal">null</span>;e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">// 如果key threadLocal一致，则证明找到对应的threadLocal</span></span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            <span class="comment">// 执行清除操作</span></span><br><span class="line">            e.clear();</span><br><span class="line">            <span class="comment">// 清除此位置的实体</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">            <span class="comment">// 结束</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的可以看出，当遇到了key为null的脏entry的时候，也会调用expungeStaleEntry清理掉脏entry。</p>
<p>从以上set,getEntry,remove方法看出，<strong>在threadLocal的生命周期里，针对threadLocal存在的内存泄漏的问题，都会通过expungeStaleEntry，cleanSomeSlots,replaceStaleEntry这三个方法清理掉key为null的脏entry</strong>。</p>
<h3 id="8-4-为什么使用弱引用？"><a href="#8-4-为什么使用弱引用？" class="headerlink" title="8.4 为什么使用弱引用？"></a>8.4 为什么使用弱引用？</h3><p>从文章开头通过threadLocal,threadLocalMap,entry的引用关系看起来threadLocal存在内存泄漏的问题似乎是因为threadLocal是被弱引用修饰的。那为什么要使用弱引用呢？</p>
<p><em>如果使用强引用</em></p>
<p>假设threadLocal使用的是强引用，在业务代码中执行<code>threadLocalInstance==null</code>操作，以清理掉threadLocal实例的目的，但是因为threadLocalMap的Entry强引用threadLocal，因此在gc的时候进行可达性分析，threadLocal依然可达，对threadLocal并不会进行垃圾回收，这样就无法真正达到业务逻辑的目的，出现逻辑错误</p>
<p><em>如果使用弱引用</em></p>
<p>假设Entry弱引用threadLocal，尽管会出现内存泄漏的问题，但是在threadLocal的生命周期里（set,getEntry,remove）里，都会针对key为null的脏entry进行处理。</p>
<p>从以上的分析可以看出，使用弱引用的话在threadLocal生命周期里会尽可能的保证不出现内存泄漏的问题，达到安全的状态。</p>
<h3 id="8-5-Thread-exit"><a href="#8-5-Thread-exit" class="headerlink" title="8.5 Thread.exit()"></a>8.5 Thread.exit()</h3><p>当线程退出时会执行exit方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">exit</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="literal">null</span>) &#123;</span><br><span class="line">        group.threadTerminated(<span class="built_in">this</span>);</span><br><span class="line">        group = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Aggressively null out all reference fields: see bug 4006245 */</span></span><br><span class="line">    target = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">/* Speed the release of some of these resources */</span></span><br><span class="line">    threadLocals = <span class="literal">null</span>;</span><br><span class="line">    inheritableThreadLocals = <span class="literal">null</span>;</span><br><span class="line">    inheritedAccessControlContext = <span class="literal">null</span>;</span><br><span class="line">    blocker = <span class="literal">null</span>;</span><br><span class="line">    uncaughtExceptionHandler = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从源码可以看出当线程结束时，会令threadLocals=null，也就意味着GC的时候就可以将threadLocalMap进行垃圾回收，换句话说threadLocalMap生命周期实际上thread的生命周期相同。</p>
<h2 id="9、使用注意事项"><a href="#9、使用注意事项" class="headerlink" title="9、使用注意事项"></a>9、使用注意事项</h2><p>通过这篇文章对threadLocal的内存泄漏做了很详细的分析，我们可以完全理解threadLocal内存泄漏的前因后果，那么实践中我们应该怎么做？</p>
<ol>
<li>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</li>
<li>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</li>
</ol>
]]></content>
      <categories>
        <category>并发多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第 11 章 树结构实际应用【3、赫夫曼编码】</title>
    <url>/posts/92bcf9da8939/</url>
    <content><![CDATA[<h1 id="第-11-章-树结构实际应用【3、赫夫曼编码】"><a href="#第-11-章-树结构实际应用【3、赫夫曼编码】" class="headerlink" title="第 11 章 树结构实际应用【3、赫夫曼编码】"></a>第 11 章 树结构实际应用【3、赫夫曼编码】</h1><h2 id="3、赫夫曼编码"><a href="#3、赫夫曼编码" class="headerlink" title="3、赫夫曼编码"></a>3、赫夫曼编码</h2><h3 id="3-1、赫夫曼编码基本介绍"><a href="#3-1、赫夫曼编码基本介绍" class="headerlink" title="3.1、赫夫曼编码基本介绍"></a>3.1、赫夫曼编码基本介绍</h3><ul>
<li>赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式，属于一种程序算法</li>
<li>赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间</li>
<li>赫夫曼码是<strong>可变字长编码(VLC)的一种</strong>。Huffman于1952年提出一种编码方法，称之为最佳编码</li>
</ul>
<h3 id="3-2、定长编码与变长编码"><a href="#3-2、定长编码与变长编码" class="headerlink" title="3.2、定长编码与变长编码"></a>3.2、定长编码与变长编码</h3><h4 id="3-2-1、定长编码"><a href="#3-2-1、定长编码" class="headerlink" title="3.2.1、定长编码"></a>3.2.1、定长编码</h4><ul>
<li>通信领域中信息的处理方式：定长编码，比如我需要发送如下字符串：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i like like like java <span class="keyword">do</span> you like a java    <span class="comment">// 共40个字符(包括空格)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>上述字符串对应的 ASCII 码为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">105</span> <span class="number">32</span> <span class="number">108</span> <span class="number">105</span> <span class="number">107</span> <span class="number">101</span> <span class="number">32</span> <span class="number">108</span> <span class="number">105</span> <span class="number">107</span> <span class="number">101</span> <span class="number">32</span> <span class="number">108</span> <span class="number">105</span> <span class="number">107</span> <span class="number">101</span> <span class="number">32</span> <span class="number">106</span> <span class="number">97</span> <span class="number">118</span> <span class="number">97</span> <span class="number">32</span> <span class="number">100</span> <span class="number">111</span> <span class="number">32</span> <span class="number">121</span> <span class="number">111</span> <span class="number">117</span> <span class="number">32</span> <span class="number">108</span> <span class="number">105</span> <span class="number">107</span> <span class="number">101</span> <span class="number">32</span> <span class="number">97</span> <span class="number">32</span> <span class="number">106</span> <span class="number">97</span> <span class="number">118</span> <span class="number">97</span> <span class="comment">//对应Ascii码</span></span><br><span class="line"></span><br><span class="line"><span class="number">01101001</span> <span class="number">00100000</span> <span class="number">01101100</span> <span class="number">01101001</span> <span class="number">01101011</span> <span class="number">01100101</span> <span class="number">00100000</span> <span class="number">01101100</span> <span class="number">01101001</span> <span class="number">01101011</span> <span class="number">01100101</span> <span class="number">00100000</span> <span class="number">01101100</span> <span class="number">01101001</span> <span class="number">01101011</span> <span class="number">01100101</span> <span class="number">00100000</span> <span class="number">01101010</span> <span class="number">01100001</span> <span class="number">01110110</span> <span class="number">01100001</span> <span class="number">00100000</span> <span class="number">01100100</span> <span class="number">01101111</span> <span class="number">00100000</span> <span class="number">01111001</span> <span class="number">01101111</span> <span class="number">01110101</span> <span class="number">00100000</span> <span class="number">01101100</span> <span class="number">01101001</span> <span class="number">01101011</span> <span class="number">01100101</span> <span class="number">00100000</span> <span class="number">01100001</span> <span class="number">00100000</span> <span class="number">01101010</span> <span class="number">01100001</span> <span class="number">01110110</span> <span class="number">01100001</span>   <span class="comment">//对应的二进制 </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>•按照二进制来传递信息，总的长度是 359 (包括空格)</p>
<h4 id="3-2-2、变长编码"><a href="#3-2-2、变长编码" class="headerlink" title="3.2.2、变长编码"></a>3.2.2、变长编码</h4><ul>
<li>通信领域中信息的处理方式：变长编码，比如我需要发送如下字符串：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i like like like java <span class="keyword">do</span> you like a java    <span class="comment">// 共40个字符(包括空格)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>统计上述字符串出现的各字符出现的次数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">d:<span class="number">1</span> y:<span class="number">1</span> u:<span class="number">1</span> j:<span class="number">2</span>  v:<span class="number">2</span>  o:<span class="number">2</span>  l:<span class="number">4</span>  k:<span class="number">4</span>  e:<span class="number">4</span> i:<span class="number">5</span>  a:<span class="number">5</span>   :<span class="number">9</span>  <span class="comment">// 各个字符对应的个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>•按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>=  ,  <span class="number">1</span>=a, <span class="number">10</span>=i, <span class="number">11</span>=e, <span class="number">100</span>=k, <span class="number">101</span>=l, <span class="number">110</span>=o, <span class="number">111</span>=v, <span class="number">1000</span>=j, <span class="number">1001</span>=u, <span class="number">1010</span>=y, <span class="number">1011</span>=d</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>按照上面给各个字符规定的编码，则我们在传输数据时，编码就是：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">10010110100.</span>..  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>•缺点：我怎么解码嘞？我是取 1 、还是取 10 、还是取 100 、还是取 1001？</p>
<h3 id="3-3、赫夫曼编码原理剖析"><a href="#3-3、赫夫曼编码原理剖析" class="headerlink" title="3.3、赫夫曼编码原理剖析"></a>3.3、赫夫曼编码原理剖析</h3><ul>
<li>通信领域中信息的处理方式：赫夫曼编码</li>
<li><strong>字符的编码都不能是其他字符编码的前缀，符合此要求的编码叫做前缀编码</strong>， 即不能匹配到重复的编码</li>
<li>比如我们处理如下字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i like like like java <span class="keyword">do</span> you like a java       <span class="comment">// 共40个字符(包括空格)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>统计各字符</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">d:<span class="number">1</span> y:<span class="number">1</span> u:<span class="number">1</span> j:<span class="number">2</span>  v:<span class="number">2</span>  o:<span class="number">2</span>  l:<span class="number">4</span>  k:<span class="number">4</span>  e:<span class="number">4</span> i:<span class="number">5</span>  a:<span class="number">5</span>   :<span class="number">9</span>  <span class="comment">// 各个字符对应的个数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>按照上面字符出现的次数构建一颗赫夫曼树， 次数作为权值，根据赫夫曼编码表确定具体字符的编码</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fa76bcc865a30b08960c290d1380acde.png" alt="image-20200813153949697"></p>
<ul>
<li>根据赫夫曼树，给各个字符的编码 ：向左的路径为 0 ；向右的路径为1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">o: <span class="number">1000</span>   u: <span class="number">10010</span>  d: <span class="number">100110</span>  y: <span class="number">100111</span>  i: <span class="number">101</span></span><br><span class="line">a: <span class="number">110</span>    k: <span class="number">1110</span>   e: <span class="number">1111</span>    j: <span class="number">0000</span>    v: <span class="number">0001</span></span><br><span class="line">l: <span class="number">001</span>     : <span class="number">01</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>按照上面的赫夫曼编码，我们的”i like like like java do you like a java” 字符串对应的编码为 (注意这里我们使用的无损压缩)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>编码后长度为 133 ，原来长度是 359 , 压缩了 (359-133) / 359 = 62.9% ，此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀，不会造成匹配的多义性</li>
<li>想想为啥赫夫曼编码就是前缀比编码？<strong>从根节点向左（右）走，只有走到叶子节点才是真正需要编码的字符</strong>，看图即可明白~</li>
<li>注意，这个赫夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的<ul>
<li>比如: 如果我们让每次生成的新的二叉树总是排在权值相同的二叉树的最后一个，则生成的二叉树如下，所以我们生成二叉树时，一定要记录该二叉树对应的赫夫曼编码表~~~</li>
<li>为什么会这样捏？权重相同的节点都位于二叉树的同一层，虽然编码具体值会发生变化，但是编码长度不会变化呀</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b328bb2f3c93c54fa6bf7243265592e2.png" alt="image-20200813154156592"></p>
<h3 id="3-4、赫夫曼编码思路"><a href="#3-4、赫夫曼编码思路" class="headerlink" title="3.4、赫夫曼编码思路"></a>3.4、赫夫曼编码思路</h3><ul>
<li>统计字节数组中各个数据的权重</li>
<li>将字节数组按照上面的权重值创建赫夫曼树</li>
<li>根据上面创建的赫夫曼树获得每个数值对应的可变长编码值（往左走为 0 ，往右走为 1）</li>
<li>以每个数值新的编码重新对字符数组进行编码，即可得到赫夫曼编码后的值</li>
</ul>
<h3 id="3-5、赫夫曼编码算法"><a href="#3-5、赫夫曼编码算法" class="headerlink" title="3.5、赫夫曼编码算法"></a>3.5、赫夫曼编码算法</h3><h4 id="3-5-1、赫夫曼节点定义"><a href="#3-5-1、赫夫曼节点定义" class="headerlink" title="3.5.1、赫夫曼节点定义"></a>3.5.1、赫夫曼节点定义</h4><ul>
<li>每个 data 值对应着一个权重值 weight</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建Node ,待数据和权值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data; <span class="comment">// 存放数据(字符)本身，比如&#x27;a&#x27; =&gt; 97 &#x27; &#x27; =&gt; 32</span></span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">//权值, 表示字符出现的次数</span></span><br><span class="line">    Node left;<span class="comment">//</span></span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="comment">// 从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node [data = &quot;</span> + data + <span class="string">&quot; weight=&quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-2、获取数据权重"><a href="#3-5-2、获取数据权重" class="headerlink" title="3.5.2、获取数据权重"></a>3.5.2、获取数据权重</h4><ul>
<li>获取字节数组中每个数值对应的权重值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接收字节数组，统计字节数组中每个字节出现的次数，并根据字节和出现的次数，创建node集合</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回的就是 List 形式   [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]......],</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1创建一个ArrayList</span></span><br><span class="line">    ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历 bytes , 统计 每一个byte出现的次数-&gt;map[key,value]</span></span><br><span class="line">    Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">        <span class="comment">// Map没有这个字符数据,就存入这个字符，key是b，value是1，</span></span><br><span class="line">        <span class="comment">// 有这个字符就取出原value 与第二个参数1 相加，更新key对应的value</span></span><br><span class="line">        counts.merge(b, <span class="number">1</span>, Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把每一个键值对转成一个Node 对象，并加入到nodes集合</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nodes;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-3、创建赫夫曼树"><a href="#3-5-3、创建赫夫曼树" class="headerlink" title="3.5.3、创建赫夫曼树"></a>3.5.3、创建赫夫曼树</h4><ul>
<li>统计字节数组中每个数值出现的次数，即每个数值对应的权重值，并根据数值及其权重值，来创建赫夫曼树</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 可以通过List 创建对应的赫夫曼树</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> nodes list</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 赫夫曼树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//排序, 从小到大</span></span><br><span class="line">        Collections.sort(nodes);</span><br><span class="line">        <span class="comment">//取出第一颗最小的二叉树</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//取出第二颗最小的二叉树</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//创建一颗新的二叉树,它的根节点 没有data, 只有权值</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">        parent.left = leftNode;</span><br><span class="line">        parent.right = rightNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将已经处理的两颗二叉树从nodes删除</span></span><br><span class="line">        nodes.remove(leftNode);</span><br><span class="line">        nodes.remove(rightNode);</span><br><span class="line">        <span class="comment">//将新的二叉树，加入到nodes</span></span><br><span class="line">        nodes.add(parent);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//nodes 最后的结点，就是赫夫曼树的根结点</span></span><br><span class="line">    <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-4、生成赫夫曼编码表"><a href="#3-5-4、生成赫夫曼编码表" class="headerlink" title="3.5.4、生成赫夫曼编码表"></a>3.5.4、生成赫夫曼编码表</h4><ul>
<li>根据上面生成的赫夫曼树，获取字节数组中每个数值对应的可变长编码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line"><span class="comment">//思路:</span></span><br><span class="line"><span class="comment">//1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式</span></span><br><span class="line"><span class="comment">//   生成的赫夫曼编码表&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125;</span></span><br><span class="line"><span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodesMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 为了调用方便，我们重载 getCodes,</span></span><br><span class="line"><span class="comment">* 根据赫夫曼树得到赫夫曼编码</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> root 赫夫曼树的节点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node root)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理root的左子树</span></span><br><span class="line">    getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理root的右子树</span></span><br><span class="line">    getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">    <span class="keyword">return</span> huffmanCodesMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> node          传入结点</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> code          路径： 左子结点是 0, 右子结点 1</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到节点判断是不是叶子节点，是的话就直接取出来byte和对应的赫夫曼码，</span></span><br><span class="line">    <span class="comment">// 不是叶子节点就继续递归。 注意 需要将&quot;0&quot;或者&quot;1&quot;通过StringBuilder进行拼接</span></span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">    <span class="comment">//将code 加入到 sb</span></span><br><span class="line">    sb.append(code);</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//判断当前node 是叶子结点还是非叶子结点</span></span><br><span class="line">        <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123; <span class="comment">//非叶子结点，也就是父节点</span></span><br><span class="line">            <span class="comment">//向左递归</span></span><br><span class="line">            getCodes(node.left, <span class="string">&quot;0&quot;</span>, sb);</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            getCodes(node.right, <span class="string">&quot;1&quot;</span>, sb);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//说明是一个叶子结点</span></span><br><span class="line">            <span class="comment">//就表示找到某个叶子结点的最后，找到了叶子节点，记录下来他的字节和字节对应的赫夫曼编码</span></span><br><span class="line">            huffmanCodesMap.put(node.data, sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-5、生成赫夫曼编码"><a href="#3-5-5、生成赫夫曼编码" class="headerlink" title="3.5.5、生成赫夫曼编码"></a>3.5.5、生成赫夫曼编码</h4><ul>
<li>根据原字节数组及其对应的赫夫曼编码表，生成赫夫曼编码，我觉着老师的编码方式有问题，关键就在于最后一个字节，最后一个字节很有可能不满 8 个 bit</li>
<li>要么在前面填充 0 ，要么在后面填充 0 ，然后二进制字符串转换为 byte ，想想：<ul>
<li>如果在前面填充 0 ，解码的时候，你怎么知道前面的 0 ，从哪个 0 开始算起才是有效的 0 ？？？就比如说最后一个字节编码为 01100 ，好，我们就在前面全填充 0 ，即最后一个字节为 0001100<br>，来，你解码的时候，给我把它解出来，是 0001100 、还是 001100、 还是 01100 、还是 1100 ？根本无从下手。。。</li>
<li>如果在后面填充 0 ，解码的时候，你怎么知道后面的 0 ，从哪个 0 开始算起才是有效的 0 ？？？就比如说最后一个字节编码为 01100 ，好，我们就在后面全填充 0 ，即最后一个字节为 00110000<br>，来，你解码的时候，给我把它解出来，是 0011 、还是 00110、 还是 001100 、还是 0011000 、还是 00110000 ？根本无从下手。。。</li>
</ul>
</li>
<li>所以在赫夫曼编码生成的字节数组最后额外开辟了一个空间，用来存储最后一个字节的有效位数，这样就没得问题啦~~~</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> bytes           这时原始的字符串对应的 byte[]</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> huffmanCodesMap 生成的赫夫曼编码map</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 返回赫夫曼编码处理后的 byte[]</span></span><br><span class="line"><span class="comment">* 举例： String content = &quot;i like like like java do you like a java&quot;; =》 byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment">* 返回的是 字符串 &quot;10101000 10111111 110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100&quot;</span></span><br><span class="line"><span class="comment">* =&gt; 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes</span></span><br><span class="line"><span class="comment">* huffmanCodeBytes[0] =  10101000(补码) =&gt; byte  [推导  10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ]</span></span><br><span class="line"><span class="comment">* huffmanCodeBytes[1] = -88</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zipBytes(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodesMap) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.利用 生成的赫夫曼编码map 将  bytes 转成  赫夫曼编码对应的字符串</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">//遍历bytes 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">byte</span> key : bytes) &#123;</span><br><span class="line">        stringBuilder.append(huffmanCodesMap.get(key));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;测试 stringBuilder = &quot;</span> + stringBuilder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将 &quot;1010100010111111110...&quot; 转成 byte[]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计返回  byte[] huffmanCodeBytes 长度，也就是统计有多少字节。</span></span><br><span class="line">    <span class="comment">//因为一个字节是8位，所以取余8，;</span></span><br><span class="line">    <span class="type">int</span> len, sbLen;</span><br><span class="line">    <span class="keyword">if</span> ((sbLen = stringBuilder.length()) % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        len = sbLen / <span class="number">8</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        len = sbLen / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line">    <span class="type">byte</span>[] huffmanCodeBytesArr = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录是第几个byte</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//因为是每8位对应一个byte,所以步长 +8</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sbLen; i += <span class="number">8</span>) &#123;</span><br><span class="line">        String str;</span><br><span class="line">        <span class="comment">//这是找到最后了，不够8位，直接全部截取出来</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">8</span> &gt; sbLen) &#123;</span><br><span class="line">            str = stringBuilder.substring(i);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则就 截取8位</span></span><br><span class="line">            str = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将strByte 转成一个byte,放入到 huffmanCodeBytes</span></span><br><span class="line">        <span class="comment">// str转成二进制，再转成字节，然后存入对应的位置</span></span><br><span class="line">        huffmanCodeBytesArr[index] = (<span class="type">byte</span>) Integer.parseInt(str, <span class="number">2</span>);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> huffmanCodeBytesArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-6、代码测试"><a href="#3-5-6、代码测试" class="headerlink" title="3.5.6、代码测试"></a>3.5.6、代码测试</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//如何将 数据进行解压(解码)</span></span><br><span class="line">    <span class="comment">//分步过程</span></span><br><span class="line">    <span class="comment">// 根据赫夫曼编码压缩数据的原理，需要创建 &quot;i like like like java do you like a java&quot; 对应的赫夫曼树</span></span><br><span class="line">    <span class="comment">// (1) Node &#123; data (存放数据)， weight (权值)， left 和 right &#125;</span></span><br><span class="line">    <span class="comment">// (2) 得到 &quot;i like like like java do you like a java&quot; 对应的 byte[] 数组</span></span><br><span class="line">    <span class="comment">// (3) 编写一个方法，将准备构建赫夫曼树的Node 节点放到 List , 形式 [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]......], 体现 d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9</span></span><br><span class="line">    <span class="comment">// (4) 可以通过List 创建对应的赫夫曼树</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] contentBytes = content.getBytes();</span><br><span class="line">    System.out.println(<span class="string">&quot;原来的字节=&quot;</span> + Arrays.toString(contentBytes));</span><br><span class="line">    System.out.println(contentBytes.length); <span class="comment">//40</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、创建node数组</span></span><br><span class="line">    List&lt;Node&gt; nodes = getNodes(contentBytes);</span><br><span class="line">    System.out.println(<span class="string">&quot;nodes=&quot;</span> + nodes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、根据node数组，创建赫夫曼树</span></span><br><span class="line">    System.out.println(<span class="string">&quot;赫夫曼树&quot;</span>);</span><br><span class="line">    <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">    System.out.println(<span class="string">&quot;前序遍历&quot;</span>);</span><br><span class="line">    preOrder(huffmanTreeRoot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、测试一把是否生成了对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">// 根据赫夫曼树 生成对应的赫夫曼编码，里面是递归，</span></span><br><span class="line">    Map&lt;Byte, String&gt; huffmanCodesMap = getCodes(huffmanTreeRoot);</span><br><span class="line">    System.out.println(<span class="string">&quot;对应的赫夫曼编码表 = &quot;</span> + huffmanCodesMap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4、根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] huffmanCodesBytesArr = zipBytes(contentBytes, huffmanCodesMap);</span><br><span class="line">    System.out.println(<span class="string">&quot;压缩后的赫夫曼编码字节数组 = &quot;</span></span><br><span class="line">                       + Arrays.toString(huffmanCodesBytesArr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来将上方的 1、2、3、4 对数据进行压缩的分步过程封装一下</span></span><br><span class="line">    <span class="type">byte</span>[] huffmanCodesBytesArr2 = huffmanZip(contentBytes);</span><br><span class="line">    System.out.println(<span class="string">&quot;压缩后的结果是:&quot;</span> + Arrays.toString(huffmanCodesBytesArr) + <span class="string">&quot; 长度= &quot;</span> + huffmanCodesBytesArr.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来 对数据进行解压。</span></span><br><span class="line">    <span class="comment">// 将压缩后的数组的每一个数都转为 字节，</span></span><br><span class="line">    <span class="comment">// 根据字节去赫夫曼编码表中找对应的 key。</span></span><br><span class="line">    <span class="type">byte</span>[] sourceBytesArr = decode(huffmanCodesMap, huffmanCodesBytesArr2);</span><br><span class="line">    System.out.println(<span class="string">&quot;原来的字节=&quot;</span> + Arrays.toString(sourceBytesArr));</span><br><span class="line">    System.out.println(<span class="string">&quot;原来的字符串=&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(sourceBytesArr)); <span class="comment">// &quot;i like like like java do you like a java&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">原来的字节=[<span class="number">105</span>, <span class="number">32</span>, <span class="number">108</span>, <span class="number">105</span>, <span class="number">107</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">108</span>, <span class="number">105</span>, <span class="number">107</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">108</span>, <span class="number">105</span>, <span class="number">107</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">32</span>, <span class="number">100</span>, <span class="number">111</span>, <span class="number">32</span>, <span class="number">121</span>, <span class="number">111</span>, <span class="number">117</span>, <span class="number">32</span>, <span class="number">108</span>, <span class="number">105</span>, <span class="number">107</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">97</span>, <span class="number">32</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>]</span><br><span class="line"><span class="number">40</span></span><br><span class="line">nodes=[Node [data = <span class="number">32</span> weight=<span class="number">9</span>], Node [data = <span class="number">97</span> weight=<span class="number">5</span>], Node [data = <span class="number">100</span> weight=<span class="number">1</span>], Node [data = <span class="number">117</span> weight=<span class="number">1</span>], Node [data = <span class="number">101</span> weight=<span class="number">4</span>], Node [data = <span class="number">118</span> weight=<span class="number">2</span>], Node [data = <span class="number">121</span> weight=<span class="number">1</span>], Node [data = <span class="number">105</span> weight=<span class="number">5</span>], Node [data = <span class="number">106</span> weight=<span class="number">2</span>], Node [data = <span class="number">107</span> weight=<span class="number">4</span>], Node [data = <span class="number">108</span> weight=<span class="number">4</span>], Node [data = <span class="number">111</span> weight=<span class="number">2</span>]]</span><br><span class="line">赫夫曼树</span><br><span class="line">前序遍历</span><br><span class="line">Node [data = <span class="literal">null</span> weight=<span class="number">40</span>]</span><br><span class="line">Node [data = <span class="literal">null</span> weight=<span class="number">17</span>]</span><br><span class="line">Node [data = <span class="literal">null</span> weight=<span class="number">8</span>]</span><br><span class="line">Node [data = <span class="number">108</span> weight=<span class="number">4</span>]</span><br><span class="line">Node [data = <span class="literal">null</span> weight=<span class="number">4</span>]</span><br><span class="line">Node [data = <span class="number">106</span> weight=<span class="number">2</span>]</span><br><span class="line">Node [data = <span class="number">111</span> weight=<span class="number">2</span>]</span><br><span class="line">Node [data = <span class="number">32</span> weight=<span class="number">9</span>]</span><br><span class="line">Node [data = <span class="literal">null</span> weight=<span class="number">23</span>]</span><br><span class="line">Node [data = <span class="literal">null</span> weight=<span class="number">10</span>]</span><br><span class="line">Node [data = <span class="number">97</span> weight=<span class="number">5</span>]</span><br><span class="line">Node [data = <span class="number">105</span> weight=<span class="number">5</span>]</span><br><span class="line">Node [data = <span class="literal">null</span> weight=<span class="number">13</span>]</span><br><span class="line">Node [data = <span class="literal">null</span> weight=<span class="number">5</span>]</span><br><span class="line">Node [data = <span class="literal">null</span> weight=<span class="number">2</span>]</span><br><span class="line">Node [data = <span class="number">100</span> weight=<span class="number">1</span>]</span><br><span class="line">Node [data = <span class="number">117</span> weight=<span class="number">1</span>]</span><br><span class="line">Node [data = <span class="literal">null</span> weight=<span class="number">3</span>]</span><br><span class="line">Node [data = <span class="number">121</span> weight=<span class="number">1</span>]</span><br><span class="line">Node [data = <span class="number">118</span> weight=<span class="number">2</span>]</span><br><span class="line">Node [data = <span class="literal">null</span> weight=<span class="number">8</span>]</span><br><span class="line">Node [data = <span class="number">101</span> weight=<span class="number">4</span>]</span><br><span class="line">Node [data = <span class="number">107</span> weight=<span class="number">4</span>]</span><br><span class="line">对应的赫夫曼编码表 = &#123;<span class="number">32</span>=<span class="number">01</span>, <span class="number">97</span>=<span class="number">100</span>, <span class="number">100</span>=<span class="number">11000</span>, <span class="number">117</span>=<span class="number">11001</span>, <span class="number">101</span>=<span class="number">1110</span>, <span class="number">118</span>=<span class="number">11011</span>, <span class="number">105</span>=<span class="number">101</span>, <span class="number">121</span>=<span class="number">11010</span>, <span class="number">106</span>=<span class="number">0010</span>, <span class="number">107</span>=<span class="number">1111</span>, <span class="number">108</span>=<span class="number">000</span>, <span class="number">111</span>=<span class="number">0011</span>&#125;</span><br><span class="line">测试 stringBuilder = <span class="number">1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span></span><br><span class="line">压缩后的赫夫曼编码字节数组 = [-<span class="number">88</span>, -<span class="number">65</span>, -<span class="number">56</span>, -<span class="number">65</span>, -<span class="number">56</span>, -<span class="number">65</span>, -<span class="number">55</span>, <span class="number">77</span>, -<span class="number">57</span>, <span class="number">6</span>, -<span class="number">24</span>, -<span class="number">14</span>, -<span class="number">117</span>, -<span class="number">4</span>, -<span class="number">60</span>, -<span class="number">90</span>, <span class="number">28</span>]</span><br><span class="line">测试 stringBuilder = <span class="number">1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span></span><br><span class="line">压缩后的结果是:[-<span class="number">88</span>, -<span class="number">65</span>, -<span class="number">56</span>, -<span class="number">65</span>, -<span class="number">56</span>, -<span class="number">65</span>, -<span class="number">55</span>, <span class="number">77</span>, -<span class="number">57</span>, <span class="number">6</span>, -<span class="number">24</span>, -<span class="number">14</span>, -<span class="number">117</span>, -<span class="number">4</span>, -<span class="number">60</span>, -<span class="number">90</span>, <span class="number">28</span>] 长度= <span class="number">17</span></span><br><span class="line">原来的字节=[<span class="number">105</span>, <span class="number">32</span>, <span class="number">108</span>, <span class="number">105</span>, <span class="number">107</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">108</span>, <span class="number">105</span>, <span class="number">107</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">108</span>, <span class="number">105</span>, <span class="number">107</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>, <span class="number">32</span>, <span class="number">100</span>, <span class="number">111</span>, <span class="number">32</span>, <span class="number">121</span>, <span class="number">111</span>, <span class="number">117</span>, <span class="number">32</span>, <span class="number">108</span>, <span class="number">105</span>, <span class="number">107</span>, <span class="number">101</span>, <span class="number">32</span>, <span class="number">97</span>, <span class="number">32</span>, <span class="number">106</span>, <span class="number">97</span>, <span class="number">118</span>, <span class="number">97</span>]</span><br><span class="line">原来的字符串=i like like like java <span class="keyword">do</span> you like a java</span><br></pre></td></tr></table></figure>

<h4 id="3-5-7、封装赫夫曼编码函数"><a href="#3-5-7、封装赫夫曼编码函数" class="headerlink" title="3.5.7、封装赫夫曼编码函数"></a>3.5.7、封装赫夫曼编码函数</h4><ul>
<li>将上述操作封装成一个函数，对外暴露该方法即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将前面的方法封装起来，便于我们的调用.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 是经过 赫夫曼编码处理后的字节数组(压缩后的数组)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">    <span class="comment">//字节和出现的次数，创建node集合</span></span><br><span class="line">    List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">    <span class="comment">//根据 nodes 创建的赫夫曼树</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">    <span class="comment">//对应的赫夫曼编码(根据 赫夫曼树)</span></span><br><span class="line">    Map&lt;Byte, String&gt; huffmanCodesMap = getCodes(huffmanTreeRoot);</span><br><span class="line">    <span class="comment">//根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] huffmanCodeBytesArr = zipBytes(bytes, huffmanCodesMap);</span><br><span class="line">    <span class="keyword">return</span> huffmanCodeBytesArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6、赫夫曼解码"><a href="#3-6、赫夫曼解码" class="headerlink" title="3.6、赫夫曼解码"></a>3.6、赫夫曼解码</h3><h4 id="3-6-1、字节转二进制字符串"><a href="#3-6-1、字节转二进制字符串" class="headerlink" title="3.6.1、字节转二进制字符串"></a>3.6.1、字节转二进制字符串</h4><h5 id="1、字节转二进制字符串方法"><a href="#1、字节转二进制字符串方法" class="headerlink" title="1、字节转二进制字符串方法"></a>1、字节转二进制字符串方法</h5><ul>
<li>编写将字节转换为二进制字符串的方法<ul>
<li><strong>正数：高位补 0 即可，然后截取低八位即可</strong>；</li>
<li><strong>负数直接截取低八位即可</strong>，其实往第八位（索引从 0 开始）补个 1 也没事儿。。。8 位的负数转为 32 位的负数，其 8~31 位都是 1</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> b    传入的 byte</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 是该b 对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">    <span class="comment">//使用变量保存 b</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b; <span class="comment">//将 b 转成 int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是正数我们还存在补高位</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        temp |= <span class="number">1</span> &lt;&lt; <span class="number">8</span>; <span class="comment">//0x100 按位与 256  1 0000 0000  | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp); <span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2、关于二进制的理解"><a href="#2、关于二进制的理解" class="headerlink" title="2、关于二进制的理解"></a>2、关于二进制的理解</h5><ul>
<li>测试代码 1：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) Integer.parseInt(<span class="string">&quot;11110000&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	System.out.println(b);</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">byteToBitString</span> <span class="operator">=</span> byteToBitString(b);</span><br><span class="line">	System.out.println(byteToBitString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 byte 转换为对应的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">	<span class="comment">// 使用变量保存 b</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b; <span class="comment">// 将 b 转成 int		</span></span><br><span class="line">	temp |= <span class="number">0x100</span>; <span class="comment">// 如果是正数我们需要将高位补零</span></span><br><span class="line">	<span class="comment">// 转换为二进制字符串，正数：高位补 0 即可，然后截取低八位即可；负数直接截取低八位即可</span></span><br><span class="line">	<span class="comment">// 负数在计算机内存储的是补码，补码转原码：先 -1 ，再取反</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">binaryStr</span> <span class="operator">=</span> Integer.toBinaryString(temp);</span><br><span class="line">	<span class="keyword">return</span> binaryStr.substring(binaryStr.length() - <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-<span class="number">16</span></span><br><span class="line"><span class="number">11110000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>测试代码 2：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>) Integer.parseInt(<span class="string">&quot;01110000&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	System.out.println(b);</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">byteToBitString</span> <span class="operator">=</span> byteToBitString(b);</span><br><span class="line">	System.out.println(byteToBitString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 byte 转换为对应的字符串</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">byte</span> b)</span> &#123;</span><br><span class="line">	<span class="comment">// 使用变量保存 b</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b; <span class="comment">// 将 b 转成 int		</span></span><br><span class="line">	temp |= <span class="number">0x100</span>; <span class="comment">// 如果是正数我们需要将高位补零</span></span><br><span class="line">	<span class="comment">// 转换为二进制字符串，正数：高位补 0 即可，然后截取低八位即可；负数直接截取低八位即可</span></span><br><span class="line">	<span class="comment">// 负数在计算机内存储的是补码，补码转原码：先 -1 ，再取反</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">binaryStr</span> <span class="operator">=</span> Integer.toBinaryString(temp);</span><br><span class="line">	<span class="keyword">return</span> binaryStr.substring(binaryStr.length() - <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">112</span></span><br><span class="line"><span class="number">01110000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>关于字节转二进制字符串的总结：<ul>
<li>为什么要在正数的第八位（索引从 0 开始）补个 1 ，就能实现高位补零的效果？<ul>
<li>因为如果不补零，调用 Integer.toBinaryString(temp); 方法，只会从第一个非零元素开始输出，<strong>会将高位的 0 抹去</strong></li>
<li>8 位的正数转为 32 位正数，其 8<del>31 2位都是零 ，**在其的第八位补个 1 ，就能输出 0</del>7 位的零呀**~~~</li>
</ul>
</li>
<li>为什么负数的第八位（索引从 0 开始）补个 1 ，无关紧要？<ul>
<li>首先搞清楚，负数在计算机中是以补码形式存储，何为补码：原码取反码 + 1</li>
<li>分析分析：<ul>
<li>-16 的原码（8 位）：1001 0000</li>
<li>-16 的反码（8 位）：1110 1111</li>
<li>-16 的补码（8 位）：1111 0000</li>
<li>-16 的原码（32 位）：1000 0000 0000 0000 0000 0000 0001 0000</li>
<li>-16 的反码（32 位）：1111 1111 1111 1111 1111 1111 1110 1111</li>
<li>-16 的补码（32 位）：1111 1111 1111 1111 1111 1111 1111 0000</li>
</ul>
</li>
<li>结论：<strong>8 位的负数转为 32 位负数，其 8~31 位都是 1 ，在其的第八位补个 1 ，无关紧要呀</strong>~~~</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-6-2、编写赫夫曼解码"><a href="#3-6-2、编写赫夫曼解码" class="headerlink" title="3.6.2、编写赫夫曼解码"></a>3.6.2、编写赫夫曼解码</h4><ul>
<li>编码思路<ul>
<li>首先根据赫夫曼编码得到的字符数组，反解出赫夫曼编码对应的字符串 huffmanStr</li>
<li>因为现在要拿着赫夫曼编码值去找恢复对应的数值，所以我们需要拿到各个编码对应着哪个数值（将赫夫曼码表反转一下就行）</li>
<li>在 huffmanStr 中匹配编码值，逐个恢复数据，处理完毕后，便解码得到了原字节数组</li>
</ul>
</li>
<li>注意：我这里做了调整，huffmanBytes 中最后一个字节记录了 huffmanBytes 倒数第二个字节的有效位数（从高位开始的有效位数）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 完成对压缩数据的解码</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> huffmanCodes    赫夫曼编码表 map</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> huffmanBytesArr 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="type">byte</span>[] huffmanBytesArr) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">//将byte数组转成二进制的字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; huffmanBytesArr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 取出来字节</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> huffmanBytesArr[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (i == huffmanBytesArr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// byte 转成一个二进制的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> byteToBitString(!flag, b);</span><br><span class="line"></span><br><span class="line">        stringBuilder.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//        System.out.println(&quot;将byte数组转成二进制的字符串 = &quot; + stringBuilder);</span></span><br><span class="line">    <span class="comment">//        将byte数组转成二进制的字符串 = 1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a</span></span><br><span class="line">    Map&lt;String, Byte&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">        map.put(entry.getValue(), entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建集合，存放byte</span></span><br><span class="line">    List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//i 可以理解成就是索引,扫描 stringBuilder</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 小的计数器</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//1010100010111...</span></span><br><span class="line">            <span class="comment">//递增的取出 key 1</span></span><br><span class="line">            <span class="comment">// 例如，看第一个字符map中有没有，有的话停止while，并且i后移到，下次for循环从第二个字符开始，</span></span><br><span class="line">            <span class="comment">// 如果第一个字符map中不存在，那count后移，然后在取前两个作为key去查找，找到的话就退出while，i后移，</span></span><br><span class="line">            <span class="comment">//至于i后移多少位，需要看count在哪个，然后加上i 的当前值，就是i的新位置</span></span><br><span class="line">            <span class="comment">// 存在的key，将key对应的value取出来，放入集合</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);<span class="comment">//i 不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">            b = map.get(key);</span><br><span class="line">            <span class="comment">//说明没有匹配到</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">                count++;<span class="comment">// count 后移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//匹配到</span></span><br><span class="line">                flag = <span class="literal">false</span>; <span class="comment">// 停止while</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(b);<span class="comment">// 将key对应的value取出来，放入集合</span></span><br><span class="line">        i += count;<span class="comment">// i后移，后移多少需要看count在哪个位置，然后i挪到count目前所在的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当for循环结束后，我们list中就存放了所有的字符  &quot;i like like like java do you like a java&quot;</span></span><br><span class="line">    <span class="comment">//把list 中的数据放入到byte[] 并返回</span></span><br><span class="line">    <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">        b[i] = list.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-6-3、代码测试"><a href="#3-6-3、代码测试" class="headerlink" title="3.6.3、代码测试"></a>3.6.3、代码测试</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] contentBytes = content.getBytes();</span><br><span class="line">    System.out.println(<span class="string">&quot;原来的字符串=&quot;</span> + content);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] huffmanCodesBytes = huffmanZip(contentBytes);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] sourceBytes = decode(huffmanCodes, huffmanCodesBytes);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;解码后的字符串=&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(sourceBytes)); <span class="comment">// &quot;i like like like java do you like a java&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">原来的字符串=i like like like java <span class="keyword">do</span> you like a java</span><br><span class="line">解码后的字符串=i like like like java <span class="keyword">do</span> you like a java</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-7、文件压缩与解压"><a href="#3-7、文件压缩与解压" class="headerlink" title="3.7、文件压缩与解压"></a>3.7、文件压缩与解压</h3><h4 id="3-7-1、文件压缩"><a href="#3-7-1、文件压缩" class="headerlink" title="3.7.1、文件压缩"></a>3.7.1、文件压缩</h4><ul>
<li>将赫夫曼编码得到的字节数组、赫夫曼编码表都要写入到文件中（使用 ObjectOutputStream 流包装 FileOutputStream 流，可直接写入对象）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将一个文件进行压缩</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">zipFile</span><span class="params">(String srcFile, String dstFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建输出流</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//创建文件的输入流</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        <span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        is.read(b);</span><br><span class="line">        <span class="comment">//直接对源文件压缩</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">        <span class="comment">//创建文件的输出流, 存放压缩文件</span></span><br><span class="line">        os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">        <span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">        <span class="comment">//把 赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">        oos.writeObject(huffmanBytes); <span class="comment">//我们是把</span></span><br><span class="line">        <span class="comment">//这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line">        <span class="comment">//注意一定要把赫夫曼编码 写入压缩文件</span></span><br><span class="line">        oos.writeObject(huffmanCodesMap);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is.close();</span><br><span class="line">            oos.close();</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-2、文件解压"><a href="#3-7-2、文件解压" class="headerlink" title="3.7.2、文件解压"></a>3.7.2、文件解压</h4><ul>
<li>先要得到编码后的字节数组和赫夫曼编码表（使用 ObjectInputStream 流封装 FileInputStream 流 可直接读取对象）</li>
<li>再调用赫夫曼解码方法，进行解码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 编写一个方法，完成对压缩文件的解压</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义文件输入流</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//定义一个对象输入流</span></span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//定义文件的输出流</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件输入流</span></span><br><span class="line">        is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipFile);</span><br><span class="line">        <span class="comment">//创建一个和  is关联的对象输入流</span></span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">        <span class="comment">//读取byte数组  huffmanBytes</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanBytes = (<span class="type">byte</span>[]) ois.readObject();</span><br><span class="line">        <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解码</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">        <span class="comment">//将bytes 数组写入到目标文件</span></span><br><span class="line">        os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">        <span class="comment">//写数据到 dstFile 文件</span></span><br><span class="line">        os.write(bytes);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            os.close();</span><br><span class="line">            ois.close();</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            System.out.println(e2.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-3、代码测试"><a href="#3-7-3、代码测试" class="headerlink" title="3.7.3、代码测试"></a>3.7.3、代码测试</h4><ul>
<li>压缩与解压缩</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试压缩文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="string">&quot;d://Uninstall.xml&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">dstFile</span> <span class="operator">=</span> <span class="string">&quot;d://Uninstall.zip&quot;</span>;</span><br><span class="line"></span><br><span class="line">        zipFile(srcFile, dstFile);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩文件ok~~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试解压文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">unZipFile</span> <span class="operator">=</span> <span class="string">&quot;d://Uninstall.zip&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">unDstFile</span> <span class="operator">=</span> <span class="string">&quot;d://Uninstall2.xml&quot;</span>;</span><br><span class="line">        unZipFile(unZipFile, unDstFile);</span><br><span class="line">        System.out.println(<span class="string">&quot;解压成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>莫得问题啊</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6bab0631e840448bedf04ba8810ea658.png" alt="image-20200719153023658"></p>
<h3 id="3-8、赫夫曼编解码全部代码"><a href="#3-8、赫夫曼编解码全部代码" class="headerlink" title="3.8、赫夫曼编解码全部代码"></a>3.8、赫夫曼编解码全部代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuffmanCode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//如何将 数据进行解压(解码)</span></span><br><span class="line">        <span class="comment">//分步过程</span></span><br><span class="line"><span class="comment">//        根据赫夫曼编码压缩数据的原理，需要创建 &quot;i like like like java do you like a java&quot; 对应的赫夫曼树</span></span><br><span class="line"><span class="comment">//        (1) Node &#123; data (存放数据)， weight (权值)， left 和 right &#125;</span></span><br><span class="line"><span class="comment">//        (2) 得到 &quot;i like like like java do you like a java&quot; 对应的 byte[] 数组</span></span><br><span class="line"><span class="comment">//        (3) 编写一个方法，将准备构建赫夫曼树的Node 节点放到 List , 形式 [Node[date=97 ,weight = 5],</span></span><br><span class="line"><span class="comment">//        Node[]date=32,weight = 9]......], 体现 d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9</span></span><br><span class="line"><span class="comment">//        (4) 可以通过List 创建对应的赫夫曼树</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] contentBytes = content.getBytes();</span><br><span class="line">        System.out.println(<span class="string">&quot;原来的字节=&quot;</span> + Arrays.toString(contentBytes));</span><br><span class="line">        System.out.println(contentBytes.length); <span class="comment">//40</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、创建node数组</span></span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(contentBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;nodes=&quot;</span> + nodes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、根据node数组，创建赫夫曼树</span></span><br><span class="line">        System.out.println(<span class="string">&quot;赫夫曼树&quot;</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历&quot;</span>);</span><br><span class="line">        preOrder(huffmanTreeRoot);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、测试一把是否生成了对应的赫夫曼编码</span></span><br><span class="line">        <span class="comment">// 根据赫夫曼树 生成对应的赫夫曼编码，里面是递归，</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodesMap = getCodes(huffmanTreeRoot);</span><br><span class="line">        System.out.println(<span class="string">&quot;对应的赫夫曼编码表 = &quot;</span> + huffmanCodesMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4、根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodesBytesArr = zipBytes(contentBytes, huffmanCodesMap);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩后的赫夫曼编码字节数组 = &quot;</span></span><br><span class="line">                + Arrays.toString(huffmanCodesBytesArr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来将上方的 1、2、3、4 对数据进行压缩的分步过程封装一下</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodesBytesArr2 = huffmanZip(contentBytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩后的结果是:&quot;</span> +</span><br><span class="line">                Arrays.toString(huffmanCodesBytesArr) + <span class="string">&quot; 长度= &quot;</span> + huffmanCodesBytesArr.length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来 对数据进行解压。</span></span><br><span class="line">        <span class="comment">// 将压缩后的数组的每一个数都转为 字节，</span></span><br><span class="line">        <span class="comment">// 根据字节去赫夫曼编码表中找对应的 key。</span></span><br><span class="line">        <span class="type">byte</span>[] sourceBytesArr = decode(huffmanCodesMap, huffmanCodesBytesArr2);</span><br><span class="line">        System.out.println(<span class="string">&quot;原来的字节=&quot;</span> + Arrays.toString(sourceBytesArr));</span><br><span class="line">        System.out.println(<span class="string">&quot;原来的字符串=&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(sourceBytesArr)); <span class="comment">// &quot;i like like like java do you like a java&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试压缩文件</span></span><br><span class="line"><span class="comment">//        String srcFile = &quot;d://Uninstall.xml&quot;;</span></span><br><span class="line"><span class="comment">//        String dstFile = &quot;d://Uninstall.zip&quot;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        zipFile(srcFile, dstFile);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;压缩文件ok~~&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //测试解压文件</span></span><br><span class="line"><span class="comment">//        String unZipFile = &quot;d://Uninstall.zip&quot;;</span></span><br><span class="line"><span class="comment">//        String unDstFile = &quot;d://Uninstall2.xml&quot;;</span></span><br><span class="line"><span class="comment">//        unZipFile(unZipFile, unDstFile);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;解压成功!&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个方法，完成对压缩文件的解压</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile 准备解压的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 将文件解压到哪个路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义文件输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//定义一个对象输入流</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//定义文件的输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件输入流</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(zipFile);</span><br><span class="line">            <span class="comment">//创建一个和  is关联的对象输入流</span></span><br><span class="line">            ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(is);</span><br><span class="line">            <span class="comment">//读取byte数组  huffmanBytes</span></span><br><span class="line">            <span class="type">byte</span>[] huffmanBytes = (<span class="type">byte</span>[]) ois.readObject();</span><br><span class="line">            <span class="comment">//读取赫夫曼编码表</span></span><br><span class="line">            Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">            <span class="comment">//将bytes 数组写入到目标文件</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">            <span class="comment">//写数据到 dstFile 文件</span></span><br><span class="line">            os.write(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">                ois.close();</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                System.out.println(e2.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个文件进行压缩</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">zipFile</span><span class="params">(String srcFile, String dstFile)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//创建文件的输入流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建文件的输入流</span></span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">            <span class="comment">//创建一个和源文件大小一样的byte[]</span></span><br><span class="line">            <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[is.available()];</span><br><span class="line">            <span class="comment">//读取文件</span></span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="comment">//直接对源文件压缩</span></span><br><span class="line">            <span class="type">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">            <span class="comment">//创建文件的输出流, 存放压缩文件</span></span><br><span class="line">            os = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dstFile);</span><br><span class="line">            <span class="comment">//创建一个和文件输出流关联的ObjectOutputStream</span></span><br><span class="line">            oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(os);</span><br><span class="line">            <span class="comment">//把 赫夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanBytes); <span class="comment">//我们是把</span></span><br><span class="line">            <span class="comment">//这里我们以对象流的方式写入 赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line">            <span class="comment">//注意一定要把赫夫曼编码 写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanCodesMap);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                oos.close();</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                System.out.println(e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成数据的解压</span></span><br><span class="line">    <span class="comment">//思路</span></span><br><span class="line">    <span class="comment">//1. 将huffmanCodeBytes [-88, -65, -56, -65, -56, -65, -55, 77, -57, 6, -24, -14, -117, -4, -60, -90, 28]</span></span><br><span class="line">    <span class="comment">//   重写先转成 赫夫曼编码对应的二进制的字符串 &quot;1010100010111...&quot;</span></span><br><span class="line">    <span class="comment">//2.  赫夫曼编码对应的二进制的字符串 &quot;1010100010111...&quot; =》 对照 赫夫曼编码  =》 &quot;i like like like java do you like a java&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成对压缩数据的解码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes    赫夫曼编码表 map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytesArr 赫夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 就是原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="type">byte</span>[] huffmanBytesArr) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先得到 huffmanBytes 对应的 二进制的字符串 ， 形式 1010100010111...</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//将byte数组转成二进制的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; huffmanBytesArr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 取出来字节</span></span><br><span class="line">            <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> huffmanBytesArr[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> (i == huffmanBytesArr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// byte 转成一个二进制的字符串</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> byteToBitString(!flag, b);</span><br><span class="line"></span><br><span class="line">            stringBuilder.append(s);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;将byte数组转成二进制的字符串 = &quot; + stringBuilder);</span></span><br><span class="line"><span class="comment">//        将byte数组转成二进制的字符串 = 1010100010111111110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//把赫夫曼编码表进行调换，因为反向查询 a-&gt;100 100-&gt;a</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建集合，存放byte</span></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//i 可以理解成就是索引,扫描 stringBuilder</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 小的计数器</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="type">Byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//1010100010111...</span></span><br><span class="line">                <span class="comment">//递增的取出 key 1</span></span><br><span class="line">                <span class="comment">// 例如，看第一个字符map中有没有，有的话停止while，并且i后移到，下次for循环从第二个字符开始，</span></span><br><span class="line">                <span class="comment">// 如果第一个字符map中不存在，那count后移，然后在取前两个作为key去查找，找到的话就退出while，i后移，</span></span><br><span class="line">                <span class="comment">//至于i后移多少位，需要看count在哪个，然后加上i 的当前值，就是i的新位置</span></span><br><span class="line">                <span class="comment">// 存在的key，将key对应的value取出来，放入集合</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> stringBuilder.substring(i, i + count);<span class="comment">//i 不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="comment">//说明没有匹配到</span></span><br><span class="line">                <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">                    count++;<span class="comment">// count 后移</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//匹配到</span></span><br><span class="line">                    flag = <span class="literal">false</span>; <span class="comment">// 停止while</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);<span class="comment">// 将key对应的value取出来，放入集合</span></span><br><span class="line">            i += count;<span class="comment">// i后移，后移多少需要看count在哪个位置，然后i挪到count目前所在的位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当for循环结束后，我们list中就存放了所有的字符  &quot;i like like like java do you like a java&quot;</span></span><br><span class="line">        <span class="comment">//把list 中的数据放入到byte[] 并返回</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            b[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个byte 转成一个二进制的字符串, 如果看不懂，可以参考我讲的Java基础 二进制的原码，反码，补码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b    传入的 byte</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true ，表示需要补高位，如果是false表示不补, 如果是最后一个字节，无需补高位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是该b 对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">byteToBitString</span><span class="params">(<span class="type">boolean</span> flag, <span class="type">byte</span> b)</span> &#123;</span><br><span class="line">        <span class="comment">//使用变量保存 b</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b; <span class="comment">//将 b 转成 int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是正数我们还存在补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp |= <span class="number">1</span> &lt;&lt; <span class="number">8</span>; <span class="comment">//按位与 256  1 0000 0000  | 0000 0001 =&gt; 1 0000 0001</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Integer.toBinaryString(temp); <span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">return</span> str.substring(str.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将前面的方法封装起来，便于我们的调用.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是经过 赫夫曼编码处理后的字节数组(压缩后的数组)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] huffmanZip(<span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">        <span class="comment">//字节和出现的次数，创建node集合</span></span><br><span class="line">        List&lt;Node&gt; nodes = getNodes(bytes);</span><br><span class="line">        <span class="comment">//根据 nodes 创建的赫夫曼树</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">huffmanTreeRoot</span> <span class="operator">=</span> createHuffmanTree(nodes);</span><br><span class="line">        <span class="comment">//对应的赫夫曼编码(根据 赫夫曼树)</span></span><br><span class="line">        Map&lt;Byte, String&gt; huffmanCodesMap = getCodes(huffmanTreeRoot);</span><br><span class="line">        <span class="comment">//根据生成的赫夫曼编码，压缩得到压缩后的赫夫曼编码字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytesArr = zipBytes(bytes, huffmanCodesMap);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytesArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串对应的byte[] 数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码 压缩后的byte[]</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes           这时原始的字符串对应的 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodesMap 生成的赫夫曼编码map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回赫夫曼编码处理后的 byte[]</span></span><br><span class="line"><span class="comment">     * 举例： String content = &quot;i like like like java do you like a java&quot;; =》 byte[] contentBytes = content.getBytes();</span></span><br><span class="line"><span class="comment">     * 返回的是 字符串 &quot;10101000 10111111 110010001011111111001000101111111100100101001101110001110000011011101000111100101000101111111100110001001010011011100&quot;</span></span><br><span class="line"><span class="comment">     * =&gt; 对应的 byte[] huffmanCodeBytes  ，即 8位对应一个 byte,放入到 huffmanCodeBytes</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[0] =  10101000(补码) =&gt; byte  [推导  10101000=&gt; 10101000 - 1 =&gt; 10100111(反码)=&gt; 11011000= -88 ]</span></span><br><span class="line"><span class="comment">     * huffmanCodeBytes[1] = -88</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] zipBytes(<span class="type">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodesMap) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.利用 生成的赫夫曼编码map 将  bytes 转成  赫夫曼编码对应的字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">//遍历bytes 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> key : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodesMap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;测试 stringBuilder = &quot;</span> + stringBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 &quot;1010100010111111110...&quot; 转成 byte[]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计返回  byte[] huffmanCodeBytes 长度，也就是统计有多少字节。</span></span><br><span class="line">        <span class="comment">//因为一个字节是8位，所以取余8，;</span></span><br><span class="line">        <span class="type">int</span> len, sbLen;</span><br><span class="line">        <span class="keyword">if</span> ((sbLen = stringBuilder.length()) % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = sbLen / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = sbLen / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 存储压缩后的 byte数组</span></span><br><span class="line">        <span class="type">byte</span>[] huffmanCodeBytesArr = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录是第几个byte</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为是每8位对应一个byte,所以步长 +8</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sbLen; i += <span class="number">8</span>) &#123;</span><br><span class="line">            String str;</span><br><span class="line">            <span class="comment">//这是找到最后了，不够8位，直接全部截取出来</span></span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; sbLen) &#123;</span><br><span class="line">                str = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则就 截取8位</span></span><br><span class="line">                str = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将strByte 转成一个byte,放入到 huffmanCodeBytes</span></span><br><span class="line">            <span class="comment">// str转成二进制，再转成字节，然后存入对应的位置</span></span><br><span class="line">            huffmanCodeBytesArr[index] = (<span class="type">byte</span>) Integer.parseInt(str, <span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytesArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成赫夫曼树对应的赫夫曼编码</span></span><br><span class="line">    <span class="comment">//思路:</span></span><br><span class="line">    <span class="comment">//1. 将赫夫曼编码表存放在 Map&lt;Byte,String&gt; 形式</span></span><br><span class="line">    <span class="comment">//   生成的赫夫曼编码表&#123;32=01, 97=100, 100=11000, 117=11001, 101=1110, 118=11011, 105=101, 121=11010, 106=0010, 107=1111, 108=000, 111=0011&#125;</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodesMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//2. 在生成赫夫曼编码表示，需要去拼接路径, 定义一个StringBuilder 存储某个叶子结点的路径</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了调用方便，我们重载 getCodes,</span></span><br><span class="line"><span class="comment">     * 根据赫夫曼树得到赫夫曼编码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 赫夫曼树的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title function_">getCodes</span><span class="params">(Node root)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理root的左子树</span></span><br><span class="line">        getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理root的右子树</span></span><br><span class="line">        getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodesMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：将传入的node结点的所有叶子结点的赫夫曼编码得到，并放入到huffmanCodes集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          路径： 左子结点是 0, 右子结点 1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getCodes</span><span class="params">(Node node, String code, StringBuilder stringBuilder)</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到节点判断是不是叶子节点，是的话就直接取出来byte和对应的赫夫曼码，</span></span><br><span class="line">        <span class="comment">// 不是叶子节点就继续递归。 注意 需要将&quot;0&quot;或者&quot;1&quot;通过StringBuilder进行拼接</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stringBuilder);</span><br><span class="line">        <span class="comment">//将code 加入到 sb</span></span><br><span class="line">        sb.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//判断当前node 是叶子结点还是非叶子结点</span></span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="literal">null</span>) &#123; <span class="comment">//非叶子结点，也就是父节点</span></span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, sb);</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, sb);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//说明是一个叶子结点</span></span><br><span class="line">                <span class="comment">//就表示找到某个叶子结点的最后，找到了叶子节点，记录下来他的字节和字节对应的赫夫曼编码</span></span><br><span class="line">                huffmanCodesMap.put(node.data, sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;赫夫曼树为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收字节数组，统计字节数组中每个字节出现的次数，并根据字节和出现的次数，创建node集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 接收字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的就是 List 形式   [Node[date=97 ,weight = 5], Node[]date=32,weight = 9]......],</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">getNodes</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1创建一个ArrayList</span></span><br><span class="line">        ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 bytes , 统计 每一个byte出现的次数-&gt;map[key,value]</span></span><br><span class="line">        Map&lt;Byte, Integer&gt; counts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">byte</span> b : bytes) &#123;</span><br><span class="line">            <span class="comment">// Map没有这个字符数据,就存入这个字符，key是b，value是1，</span></span><br><span class="line">            <span class="comment">// 有这个字符就取出原value 与第二个参数1 相加，更新key对应的value</span></span><br><span class="line">            counts.merge(b, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把每一个键值对转成一个Node 对象，并加入到nodes集合</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> <span class="title class_">Node</span>(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以通过List 创建对应的赫夫曼树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nodes list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 赫夫曼树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title function_">createHuffmanTree</span><span class="params">(List&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//排序, 从小到大</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            <span class="comment">//取出第一颗最小的二叉树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出第二颗最小的二叉树</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建一颗新的二叉树,它的根节点 没有data, 只有权值</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="literal">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将已经处理的两颗二叉树从nodes删除</span></span><br><span class="line">            nodes.remove(leftNode);</span><br><span class="line">            nodes.remove(rightNode);</span><br><span class="line">            <span class="comment">//将新的二叉树，加入到nodes</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//nodes 最后的结点，就是赫夫曼树的根结点</span></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node ,待数据和权值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    Byte data; <span class="comment">// 存放数据(字符)本身，比如&#x27;a&#x27; =&gt; 97 &#x27; &#x27; =&gt; 32</span></span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">//权值, 表示字符出现的次数</span></span><br><span class="line">    Node left;<span class="comment">//</span></span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Byte data, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node o)</span> &#123;</span><br><span class="line">        <span class="comment">// 从小到大排序</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node [data = &quot;</span> + data + <span class="string">&quot; weight=&quot;</span> + weight + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-9、赫夫曼编解码总结"><a href="#3-9、赫夫曼编解码总结" class="headerlink" title="3.9、赫夫曼编解码总结"></a>3.9、赫夫曼编解码总结</h3><ul>
<li>如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化，比如视频，ppt 等等文件</li>
<li>赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件)</li>
<li>如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显</li>
</ul>
]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第 5 章 栈</title>
    <url>/posts/7ea2276f8a90/</url>
    <content><![CDATA[<h1 id="第-5-章-栈"><a href="#第-5-章-栈" class="headerlink" title="第 5 章 栈"></a>第 5 章 栈</h1><h2 id="1、栈的基本介绍"><a href="#1、栈的基本介绍" class="headerlink" title="1、栈的基本介绍"></a>1、栈的基本介绍</h2><h3 id="1-1、栈的实际需求"><a href="#1-1、栈的实际需求" class="headerlink" title="1.1、栈的实际需求"></a>1.1、栈的实际需求</h3><ul>
<li>请计算表达式：[7 * 2 * 2-5+1-5+3-3] 的值</li>
<li>请问: 计算机<strong>底层</strong>是如何运算得到结果的？ 注意不是简单的把算式列出运算，因为我们看这个算式 7 * 2 * 2 - 5，但是计算机怎么理解这个算式的</li>
<li>对计算机而言， 它接收到的就是一个<strong>字符串</strong>， 我们讨论的是这个问题：<strong>栈</strong></li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MTQxNzAyMTczLnBuZw?x-oss-process=image/format,png" alt="image-20200714141702173"></p>
<h3 id="1-2、栈的基本性质"><a href="#1-2、栈的基本性质" class="headerlink" title="1.2、栈的基本性质"></a>1.2、栈的基本性质</h3><ul>
<li>栈的英文为(stack)</li>
<li><strong>栈是一个先入后出(FILO-First In Last Out)的有序列表</strong></li>
<li>栈(stack)是限制线性表中元素的插入和删除只能在线性表的<strong>同一端</strong>进行的一种特殊线性表。 允许插入和删除的一端， 为<strong>变化的一端</strong>， 称为栈顶(Top)， 另一端为<strong>固定的一端</strong>， 称为栈底(Bottom)。</li>
<li>根据栈的定义可知， 最先放入栈中元素在栈底， 最后放入的元素在栈顶， 而删除元素刚好相反， 最后放入的元素最先删除， 最先放入的元素最后删除</li>
<li>图解方式说明出栈(pop)和入栈(push)的概念</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MTQxODE4NTQ4LnBuZw?x-oss-process=image/format,png" alt="image-20200714141818548"></p>
<h3 id="1-3、栈的应用场景"><a href="#1-3、栈的应用场景" class="headerlink" title="1.3、栈的应用场景"></a>1.3、栈的应用场景</h3><ul>
<li><strong>子程序的调用：</strong> 在跳往子程序前， 会先将下个指令的地址存到堆栈中， 直到子程序执行完后再将地址取出， 以回到原来的程序中。</li>
<li><strong>处理递归调用：</strong> 和子程序的调用类似， 只是除了储存下一个指令的地址外， 也将参数、 区域变量等数据存入栈中。</li>
<li><strong>表达式的转换：</strong>[中缀表达式转后缀表达式]与求值(实际解决)。</li>
<li><strong>二叉树的遍历</strong>。</li>
<li><strong>图形的深度优先(depth 一 first)搜索法</strong>。</li>
</ul>
<h2 id="2、数组模拟栈"><a href="#2、数组模拟栈" class="headerlink" title="2、数组模拟栈"></a>2、数组模拟栈</h2><h3 id="2-1、代码思路"><a href="#2-1、代码思路" class="headerlink" title="2.1、代码思路"></a>2.1、代码思路</h3><ul>
<li>maxSize ：栈的大小（数组的大小）</li>
<li>arr ：用来模拟栈的数组</li>
<li>top ：指向当前栈顶元素，初始值为 -1 ，表示栈空</li>
<li>判断栈满：<strong>top == maxSize</strong> ，即已经到达数组最后一个位置</li>
<li>判断栈空：<strong>top == -1</strong></li>
<li>入栈：<strong>arr[++top] = arr;</strong></li>
<li>出栈：<strong>return arr[top–] ;</strong></li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTU0MjE4NzIyLnBuZw?x-oss-process=image/format,png" alt="image-20200806154218722"></p>
<h3 id="2-2、代码实现"><a href="#2-2、代码实现" class="headerlink" title="2.2、代码实现"></a>2.2、代码实现</h3><ul>
<li>栈的定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个 ArrayStack 表示栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> maxSize; <span class="comment">// 栈的大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] stack; <span class="comment">// 数组，数组模拟栈，数据就放在该数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">		stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈满</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 入栈-push</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		<span class="comment">// 先判断栈是否满</span></span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		top++;</span><br><span class="line">		stack[top] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 出栈-pop, 将栈顶的数据返回</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 先判断栈是否空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 抛出异常</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空，没有数据~&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">		top--;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;栈空，没有数据~~&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 需要从栈顶开始显示数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 测试一下ArrayStack 是否正确</span></span><br><span class="line">    <span class="comment">// 先创建一个ArrayStack对象-&gt;表示栈</span></span><br><span class="line">    <span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 控制是否退出菜单</span></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show: 表示显示栈&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;exit: 退出程序&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;push: 表示添加数据到栈(入栈)&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;pop: 表示从栈取出数据(出栈)&quot;</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入你的选择&quot;</span>);</span><br><span class="line">        key = scanner.next();</span><br><span class="line">        <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                stack.list();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                stack.push(value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    System.out.printf(<span class="string">&quot;出栈的数据是 %d\n&quot;</span>, res);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                    System.out.println(e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                scanner.close();</span><br><span class="line">                loop = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;程序退出~~~&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show: 表示显示栈</span><br><span class="line">exit: 退出程序</span><br><span class="line">push: 表示添加数据到栈(入栈)</span><br><span class="line">pop: 表示从栈取出数据(出栈)</span><br><span class="line"></span><br><span class="line">请输入你的选择</span><br><span class="line">push</span><br><span class="line">请输入一个数</span><br><span class="line">1</span><br><span class="line">show: 表示显示栈</span><br><span class="line">exit: 退出程序</span><br><span class="line">push: 表示添加数据到栈(入栈)</span><br><span class="line">pop: 表示从栈取出数据(出栈)</span><br><span class="line"></span><br><span class="line">请输入你的选择</span><br><span class="line">push</span><br><span class="line">请输入一个数</span><br><span class="line">2</span><br><span class="line">show: 表示显示栈</span><br><span class="line">exit: 退出程序</span><br><span class="line">push: 表示添加数据到栈(入栈)</span><br><span class="line">pop: 表示从栈取出数据(出栈)</span><br><span class="line"></span><br><span class="line">请输入你的选择</span><br><span class="line">push</span><br><span class="line">请输入一个数</span><br><span class="line">3</span><br><span class="line">show: 表示显示栈</span><br><span class="line">exit: 退出程序</span><br><span class="line">push: 表示添加数据到栈(入栈)</span><br><span class="line">pop: 表示从栈取出数据(出栈)</span><br><span class="line"></span><br><span class="line">请输入你的选择</span><br><span class="line">push</span><br><span class="line">请输入一个数</span><br><span class="line">4</span><br><span class="line">show: 表示显示栈</span><br><span class="line">exit: 退出程序</span><br><span class="line">push: 表示添加数据到栈(入栈)</span><br><span class="line">pop: 表示从栈取出数据(出栈)</span><br><span class="line"></span><br><span class="line">请输入你的选择</span><br><span class="line">push</span><br><span class="line">请输入一个数</span><br><span class="line">5</span><br><span class="line">栈满</span><br><span class="line">show: 表示显示栈</span><br><span class="line">exit: 退出程序</span><br><span class="line">push: 表示添加数据到栈(入栈)</span><br><span class="line">pop: 表示从栈取出数据(出栈)</span><br><span class="line"></span><br><span class="line">请输入你的选择</span><br><span class="line">show</span><br><span class="line">stack[3]=4</span><br><span class="line">stack[2]=3</span><br><span class="line">stack[1]=2</span><br><span class="line">stack[0]=1</span><br><span class="line">show: 表示显示栈</span><br><span class="line">exit: 退出程序</span><br><span class="line">push: 表示添加数据到栈(入栈)</span><br><span class="line">pop: 表示从栈取出数据(出栈)</span><br><span class="line"></span><br><span class="line">请输入你的选择</span><br><span class="line">pop</span><br><span class="line">出栈的数据是 4</span><br><span class="line">show: 表示显示栈</span><br><span class="line">exit: 退出程序</span><br><span class="line">push: 表示添加数据到栈(入栈)</span><br><span class="line">pop: 表示从栈取出数据(出栈)</span><br><span class="line"></span><br><span class="line">请输入你的选择</span><br><span class="line">pop</span><br><span class="line">出栈的数据是 3</span><br><span class="line">show: 表示显示栈</span><br><span class="line">exit: 退出程序</span><br><span class="line">push: 表示添加数据到栈(入栈)</span><br><span class="line">pop: 表示从栈取出数据(出栈)</span><br><span class="line"></span><br><span class="line">请输入你的选择</span><br><span class="line">pop</span><br><span class="line">出栈的数据是 2</span><br><span class="line">show: 表示显示栈</span><br><span class="line">exit: 退出程序</span><br><span class="line">push: 表示添加数据到栈(入栈)</span><br><span class="line">pop: 表示从栈取出数据(出栈)</span><br><span class="line"></span><br><span class="line">请输入你的选择</span><br><span class="line">pop</span><br><span class="line">出栈的数据是 1</span><br><span class="line">show: 表示显示栈</span><br><span class="line">exit: 退出程序</span><br><span class="line">push: 表示添加数据到栈(入栈)</span><br><span class="line">pop: 表示从栈取出数据(出栈)</span><br><span class="line"></span><br><span class="line">请输入你的选择</span><br><span class="line">pop</span><br><span class="line">栈空，没有数据~</span><br><span class="line">show: 表示显示栈</span><br><span class="line">exit: 退出程序</span><br><span class="line">push: 表示添加数据到栈(入栈)</span><br><span class="line">pop: 表示从栈取出数据(出栈)</span><br><span class="line"></span><br><span class="line">请输入你的选择</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-3、数组模拟栈全部代码"><a href="#2-3、数组模拟栈全部代码" class="headerlink" title="2.3、数组模拟栈全部代码"></a>2.3、数组模拟栈全部代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStackDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 测试一下ArrayStack 是否正确</span></span><br><span class="line">		<span class="comment">// 先创建一个ArrayStack对象-&gt;表示栈</span></span><br><span class="line">		<span class="type">ArrayStack</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayStack</span>(<span class="number">4</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>; <span class="comment">// 控制是否退出菜单</span></span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (loop) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;show: 表示显示栈&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;exit: 退出程序&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;push: 表示添加数据到栈(入栈)&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;pop: 表示从栈取出数据(出栈)&quot;</span>);</span><br><span class="line">			System.out.println();</span><br><span class="line">			System.out.println(<span class="string">&quot;请输入你的选择&quot;</span>);</span><br><span class="line">			key = scanner.next();</span><br><span class="line">			<span class="keyword">switch</span> (key) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">				stack.list();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">				System.out.println(<span class="string">&quot;请输入一个数&quot;</span>);</span><br><span class="line">				<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">				stack.push(value);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">					System.out.printf(<span class="string">&quot;出栈的数据是 %d\n&quot;</span>, res);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">					System.out.println(e.getMessage());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">				scanner.close();</span><br><span class="line">				loop = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;程序退出~~~&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个 ArrayStack 表示栈</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> maxSize; <span class="comment">// 栈的大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] stack; <span class="comment">// 数组，数组模拟栈，数据就放在该数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">		stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈满</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 入栈-push</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		<span class="comment">// 先判断栈是否满</span></span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		top++;</span><br><span class="line">		stack[top] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 出栈-pop, 将栈顶的数据返回</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 先判断栈是否空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 抛出异常</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空，没有数据~&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">		top--;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;栈空，没有数据~~&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 需要从栈顶开始显示数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-4、课后练习"><a href="#2-4、课后练习" class="headerlink" title="2.4、课后练习"></a>2.4、课后练习</h3><ul>
<li>使用链表模拟栈</li>
</ul>
<h2 id="3、栈实现综合计算器-中缀表达式"><a href="#3、栈实现综合计算器-中缀表达式" class="headerlink" title="3、栈实现综合计算器(中缀表达式)"></a>3、栈实现综合计算器(中缀表达式)</h2><h3 id="3-1、代码思路"><a href="#3-1、代码思路" class="headerlink" title="3.1、代码思路"></a>3.1、代码思路</h3><ul>
<li><p>栈分为两个栈：</p>
<ul>
<li><strong>数栈（numStack）</strong>：存储表达式中的数字</li>
<li><strong>符号栈（operStack）</strong>：存储表达式中的符号</li>
</ul>
</li>
<li><p>扫描表达式（这里并没有考虑括号）：</p>
<ul>
<li><p><strong>对于数：扫描到数，则直接压入数栈</strong></p>
</li>
<li><p>对于运算符：扫描到运算符，分为如下几种情况：</p>
<ul>
<li><p><strong>如果符号栈为空，则直接入栈</strong></p>
</li>
<li><p>如果符号栈不为空</p>
<p>：</p>
<ul>
<li><p>如果当前扫描到的运算符的优先级 &lt;= 符号栈栈顶的运算符的优先级</p>
<p>，说明上次的运算符优先级较高，先执行优先级高的运算</p>
<ul>
<li>从数栈中弹出两个数，根据符号栈栈顶的运算符进行运算（优先级高，就先算出来）</li>
<li>然后将计算的结果压入栈中</li>
<li>再将当前运算符压入符号栈</li>
</ul>
</li>
<li><p><strong>如果当前扫描到的运算符的优先级 &gt; 符号栈栈顶的运算符的优先级</strong>，说明上次的运算符优先级较低，直接压入符号栈</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>何时停止循环？</p>
<ul>
<li>处理完表达式，退出循环</li>
<li>即表达式下标（index）的值大于表达式（expression）的长度</li>
<li>代码：<strong>index &gt;= expression.length()</strong></li>
</ul>
</li>
<li><p>表达式扫描完成：</p>
<ul>
<li>此时符号栈中的运算符优先级都相同</li>
<li>从数栈中弹出两个数，再从符号栈中弹出一个运算符，进行运算，计算结果放回数栈中</li>
<li>何时停止循环？符号栈为空则停止：<strong>operStack.isEmpty()</strong></li>
<li>表达式的值？符号栈为空时，数栈栈顶还有一个元素，这个元素的值就是表达式的值</li>
</ul>
</li>
<li><p>举例：3+2*6-2</p>
<ul>
<li>首先<ul>
<li>将 3 压入数栈</li>
<li>将 + 压入符号栈</li>
<li>将 2 压入数栈</li>
</ul>
</li>
</ul>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3	  +</span><br><span class="line">数栈	符号栈</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<ul>
<li>由于 * 优先级大于 + ，所以将 * 压入 符号栈，然后将 6 压入数栈</li>
</ul>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2	  *</span><br><span class="line">3	  +</span><br><span class="line">数栈	符号栈</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>由于 - 优先级低于 * ，所以从数栈中弹出两个数（6 和 2），从符号栈中弹出一个运算符（*），进行运算，运算结果再压入数栈，然后将 - 压入符号栈</li>
</ul>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">12	  -</span><br><span class="line">3	  +</span><br><span class="line">数栈	符号栈</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将 2 压入数栈，表达式处理完毕</li>
</ul>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">12	  -</span><br><span class="line">3	  +</span><br><span class="line">数栈	符号栈</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>重复此过程，直至符号栈为空：从数栈中弹出两个数，再从符号栈中弹出一个运算符，进行运算，计算结果放回数栈中</li>
</ul>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">3	  +</span><br><span class="line">数栈	符号栈</span><br><span class="line"></span><br></pre></td></tr></table></figure>

  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">13</span><br><span class="line">数栈	符号栈</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTU0NzM1NzkwLnBuZw?x-oss-process=image/format,png" alt="image-20200806154735790"></p>
<h3 id="3-2、代码实现"><a href="#3-2、代码实现" class="headerlink" title="3.2、代码实现"></a>3.2、代码实现</h3><ul>
<li><p>栈的定义：专为计算器而生的栈</p>
</li>
<li><p>对于乘除法特别说明：由于</p>
<p>栈先进后</p>
<p>出的特点，num1 是运算符后面的数（减数、除数），num2 是运算符前的数（被减数、被除数），</p>
<p>特别需要注意减法与除法的顺序</p>
<ul>
<li><strong>res = num2 - num1;</strong></li>
<li><strong>res = num2 / num1;</strong></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建一个栈,直接使用前面创建好</span></span><br><span class="line"><span class="comment">//定义一个 CalcStack 表示栈, 需要扩展功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalcStack</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> maxSize; <span class="comment">// 栈的大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] stack; <span class="comment">// 数组，数组模拟栈，数据就放在该数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CalcStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">		stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加一个方法，可以返回当前栈顶的值, 但是不是真正的pop</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> stack[top];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈满</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 入栈-push</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		<span class="comment">// 先判断栈是否满</span></span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		top++;</span><br><span class="line">		stack[top] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 出栈-pop, 将栈顶的数据返回</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 先判断栈是否空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 抛出异常</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空，没有数据~&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">		top--;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;栈空，没有数据~~&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 需要从栈顶开始显示数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示</span></span><br><span class="line">	<span class="comment">// 数字越大，则优先级就越高.</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">int</span> oper)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&#x27;+&#x27;</span> || oper == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 假定目前的表达式只有 +, - , * , /</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是不是一个运算符</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOper</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> val == <span class="string">&#x27;+&#x27;</span> || val == <span class="string">&#x27;-&#x27;</span> || val == <span class="string">&#x27;*&#x27;</span> || val == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, <span class="type">int</span> oper)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// res 用于存放计算的结果</span></span><br><span class="line">		<span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">			res = num1 + num2;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">			res = num2 - num1;<span class="comment">// 注意顺序</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">			res = num1 * num2;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">			res = num2 / num1;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>综合计算器代码：对多位数进行了判断，使得程序可处理多位数的运算</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据前面老师思路，完成表达式的运算</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;7*2*2-5+1-5+3-4&quot;</span>; <span class="comment">// 如何处理多位数的问题？</span></span><br><span class="line">    <span class="comment">// 创建两个栈，一个数栈，一个符号栈</span></span><br><span class="line">    <span class="type">CalcStack</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalcStack</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">CalcStack</span> <span class="variable">operStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalcStack</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 定义需要的相关变量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 用于扫描</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>; <span class="comment">// 将每次扫描得到char保存到ch</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">keepNum</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 用于拼接 多位数</span></span><br><span class="line">    <span class="comment">// 开始while循环的扫描expression</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 依次得到expression 的每一个字符</span></span><br><span class="line">        ch = expression.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 判断ch是什么，然后做相应的处理</span></span><br><span class="line">        <span class="keyword">if</span> (operStack.isOper(ch)) &#123;<span class="comment">// 如果是运算符</span></span><br><span class="line">            <span class="comment">// 判断当前的符号栈是否为空</span></span><br><span class="line">            <span class="keyword">if</span> (!operStack.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数,</span></span><br><span class="line">                <span class="comment">// 在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈</span></span><br><span class="line">                <span class="keyword">if</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">                    num1 = numStack.pop();</span><br><span class="line">                    num2 = numStack.pop();</span><br><span class="line">                    oper = operStack.pop();</span><br><span class="line">                    res = numStack.cal(num1, num2, oper);</span><br><span class="line">                    <span class="comment">// 把运算的结果如数栈</span></span><br><span class="line">                    numStack.push(res);</span><br><span class="line">                    <span class="comment">// 然后将当前的操作符入符号栈</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果为空直接入符号栈..</span></span><br><span class="line">                operStack.push(ch); <span class="comment">// 1 + 3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是数，则直接入数栈</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// numStack.push(ch - 48); //? &quot;1+3&quot; &#x27;1&#x27; =&gt; 1</span></span><br><span class="line">            <span class="comment">// 分析思路</span></span><br><span class="line">            <span class="comment">// 1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span></span><br><span class="line">            <span class="comment">// 2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line">            <span class="comment">// 3. 因此我们需要定义一个变量 字符串，用于拼接</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理多位数</span></span><br><span class="line">            keepNum += ch;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果ch已经是expression的最后一位，就直接入栈</span></span><br><span class="line">            <span class="keyword">if</span> (index == expression.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈</span></span><br><span class="line">                <span class="comment">// 注意是看后一位，不是index++</span></span><br><span class="line">                <span class="keyword">if</span> (operStack.isOper(expression.substring(index + <span class="number">1</span>, index + <span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="comment">// 如果后一位是运算符，则入栈 keepNum = &quot;1&quot; 或者 &quot;123&quot;</span></span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                    <span class="comment">// 重要的!!!!!!, keepNum清空</span></span><br><span class="line">                    keepNum = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 让index + 1, 并判断是否扫描到expression最后.</span></span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= expression.length()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】</span></span><br><span class="line">        <span class="keyword">if</span> (operStack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num1 = numStack.pop();</span><br><span class="line">        num2 = numStack.pop();</span><br><span class="line">        oper = operStack.pop();</span><br><span class="line">        res = numStack.cal(num1, num2, oper);</span><br><span class="line">        numStack.push(res);<span class="comment">// 入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数栈的最后数，pop出，就是结果</span></span><br><span class="line">    res = numStack.pop();</span><br><span class="line">    System.out.printf(<span class="string">&quot;表达式 %s = %d&quot;</span>, expression, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">表达式 7*2*2-5+1-5+3-4 = 18</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-3、综合计算器全部代码"><a href="#3-3、综合计算器全部代码" class="headerlink" title="3.3、综合计算器全部代码"></a>3.3、综合计算器全部代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 根据前面老师思路，完成表达式的运算</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;7*2*2-5+1-5+3-4&quot;</span>; <span class="comment">// 如何处理多位数的问题？</span></span><br><span class="line">		<span class="comment">// 创建两个栈，一个数栈，一个符号栈</span></span><br><span class="line">		<span class="type">CalcStack</span> <span class="variable">numStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalcStack</span>(<span class="number">10</span>);</span><br><span class="line">		<span class="type">CalcStack</span> <span class="variable">operStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CalcStack</span>(<span class="number">10</span>);</span><br><span class="line">		<span class="comment">// 定义需要的相关变量</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 用于扫描</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">oper</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> <span class="string">&#x27; &#x27;</span>; <span class="comment">// 将每次扫描得到char保存到ch</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">keepNum</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>; <span class="comment">// 用于拼接 多位数</span></span><br><span class="line">		<span class="comment">// 开始while循环的扫描expression</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 依次得到expression 的每一个字符</span></span><br><span class="line">			ch = expression.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">			<span class="comment">// 判断ch是什么，然后做相应的处理</span></span><br><span class="line">			<span class="keyword">if</span> (operStack.isOper(ch)) &#123;<span class="comment">// 如果是运算符</span></span><br><span class="line">				<span class="comment">// 判断当前的符号栈是否为空</span></span><br><span class="line">				<span class="keyword">if</span> (!operStack.isEmpty()) &#123;</span><br><span class="line">					<span class="comment">// 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符,就需要从数栈中pop出两个数,</span></span><br><span class="line">					<span class="comment">// 在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈</span></span><br><span class="line">					<span class="keyword">if</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">						num1 = numStack.pop();</span><br><span class="line">						num2 = numStack.pop();</span><br><span class="line">						oper = operStack.pop();</span><br><span class="line">						res = numStack.cal(num1, num2, oper);</span><br><span class="line">						<span class="comment">// 把运算的结果如数栈</span></span><br><span class="line">						numStack.push(res);</span><br><span class="line">						<span class="comment">// 然后将当前的操作符入符号栈</span></span><br><span class="line">						operStack.push(ch);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</span></span><br><span class="line">						operStack.push(ch);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 如果为空直接入符号栈..</span></span><br><span class="line">					operStack.push(ch); <span class="comment">// 1 + 3</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是数，则直接入数栈</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// numStack.push(ch - 48); //? &quot;1+3&quot; &#x27;1&#x27; =&gt; 1</span></span><br><span class="line">				<span class="comment">// 分析思路</span></span><br><span class="line">				<span class="comment">// 1. 当处理多位数时，不能发现是一个数就立即入栈，因为他可能是多位数</span></span><br><span class="line">				<span class="comment">// 2. 在处理数，需要向expression的表达式的index 后再看一位,如果是数就进行扫描，如果是符号才入栈</span></span><br><span class="line">				<span class="comment">// 3. 因此我们需要定义一个变量 字符串，用于拼接</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 处理多位数</span></span><br><span class="line">				keepNum += ch;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 如果ch已经是expression的最后一位，就直接入栈</span></span><br><span class="line">				<span class="keyword">if</span> (index == expression.length() - <span class="number">1</span>) &#123;</span><br><span class="line">					numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">					<span class="comment">// 判断下一个字符是不是数字，如果是数字，就继续扫描，如果是运算符，则入栈</span></span><br><span class="line">					<span class="comment">// 注意是看后一位，不是index++</span></span><br><span class="line">					<span class="keyword">if</span> (operStack.isOper(expression.substring(index + <span class="number">1</span>, index + <span class="number">2</span>).charAt(<span class="number">0</span>))) &#123;</span><br><span class="line">						<span class="comment">// 如果后一位是运算符，则入栈 keepNum = &quot;1&quot; 或者 &quot;123&quot;</span></span><br><span class="line">						numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">						<span class="comment">// 重要的!!!!!!, keepNum清空</span></span><br><span class="line">						keepNum = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 让index + 1, 并判断是否扫描到expression最后.</span></span><br><span class="line">			index++;</span><br><span class="line">			<span class="keyword">if</span> (index &gt;= expression.length()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果符号栈为空，则计算到最后的结果, 数栈中只有一个数字【结果】</span></span><br><span class="line">			<span class="keyword">if</span> (operStack.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			num1 = numStack.pop();</span><br><span class="line">			num2 = numStack.pop();</span><br><span class="line">			oper = operStack.pop();</span><br><span class="line">			res = numStack.cal(num1, num2, oper);</span><br><span class="line">			numStack.push(res);<span class="comment">// 入栈</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将数栈的最后数，pop出，就是结果</span></span><br><span class="line">		res = numStack.pop();</span><br><span class="line">		System.out.printf(<span class="string">&quot;表达式 %s = %d&quot;</span>, expression, res);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建一个栈,直接使用前面创建好</span></span><br><span class="line"><span class="comment">//定义一个 CalcStack 表示栈, 需要扩展功能</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalcStack</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> maxSize; <span class="comment">// 栈的大小</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] stack; <span class="comment">// 数组，数组模拟栈，数据就放在该数组</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> -<span class="number">1</span>;<span class="comment">// top表示栈顶，初始化为-1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">CalcStack</span><span class="params">(<span class="type">int</span> maxSize)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.maxSize = maxSize;</span><br><span class="line">		stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="built_in">this</span>.maxSize];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 增加一个方法，可以返回当前栈顶的值, 但是不是真正的pop</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> stack[top];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈满</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈空</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 入栈-push</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		<span class="comment">// 先判断栈是否满</span></span><br><span class="line">		<span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		top++;</span><br><span class="line">		stack[top] = value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 出栈-pop, 将栈顶的数据返回</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 先判断栈是否空</span></span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			<span class="comment">// 抛出异常</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;栈空，没有数据~&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> stack[top];</span><br><span class="line">		top--;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 显示栈的情况[遍历栈]， 遍历时，需要从栈顶开始显示数据</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;栈空，没有数据~~&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 需要从栈顶开始显示数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			System.out.printf(<span class="string">&quot;stack[%d]=%d\n&quot;</span>, i, stack[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回运算符的优先级，优先级是程序员来确定, 优先级使用数字表示</span></span><br><span class="line">	<span class="comment">// 数字越大，则优先级就越高.</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">priority</span><span class="params">(<span class="type">int</span> oper)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&#x27;+&#x27;</span> || oper == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 假定目前的表达式只有 +, - , * , /</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断是不是一个运算符</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOper</span><span class="params">(<span class="type">char</span> val)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> val == <span class="string">&#x27;+&#x27;</span> || val == <span class="string">&#x27;-&#x27;</span> || val == <span class="string">&#x27;*&#x27;</span> || val == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cal</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2, <span class="type">int</span> oper)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// res 用于存放计算的结果</span></span><br><span class="line">		<span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">			res = num1 + num2;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">			res = num2 - num1;<span class="comment">// 注意顺序</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">			res = num1 * num2;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">			res = num2 / num1;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4、课后练习"><a href="#3-4、课后练习" class="headerlink" title="3.4、课后练习"></a>3.4、课后练习</h3><ul>
<li>加入小括号的判断：小括号内的运算需要优先执行，也即小括号的优先级最高</li>
<li>我的代码思路如下：<ul>
<li><strong>但凡遇到左括号，直接入符号栈</strong>，之后的操作和之前的一样</li>
<li><strong>直至遇到右括号</strong>，此时可以依次将符号栈中的符号弹出，与数栈中的数做运算</li>
<li><strong>直至符号栈弹出左括号为止，此时，括号内的运算已执行完毕</strong></li>
</ul>
</li>
</ul>
<h2 id="4、前缀-中缀-后缀表达式"><a href="#4、前缀-中缀-后缀表达式" class="headerlink" title="4、前缀 中缀 后缀表达式"></a>4、前缀 中缀 后缀表达式</h2><h3 id="4-1、前缀表达式-波兰表达式"><a href="#4-1、前缀表达式-波兰表达式" class="headerlink" title="4.1、前缀表达式(波兰表达式)"></a>4.1、前缀表达式(波兰表达式)</h3><h4 id="4-1-1、前缀表达式"><a href="#4-1-1、前缀表达式" class="headerlink" title="4.1.1、前缀表达式"></a>4.1.1、前缀表达式</h4><ul>
<li><strong>前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前</strong></li>
<li>举例说明： (3+4)×5-6 对应的前缀表达式就是 <strong>- × + 3 4 5 6</strong></li>
</ul>
<h4 id="4-1-2、前缀表达式的计算机求值"><a href="#4-1-2、前缀表达式的计算机求值" class="headerlink" title="4.1.2、前缀表达式的计算机求值"></a>4.1.2、前缀表达式的计算机求值</h4><ul>
<li><strong>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈</strong>；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</li>
<li>例如：(3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:<ul>
<li>从右至左扫描，将6、5、4、3压入堆栈</li>
<li>遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈</li>
<li>接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈</li>
<li>最后是-运算符，计算出35-6的值，即29，由此得出最终结果</li>
</ul>
</li>
</ul>
<h3 id="4-2、中缀表达式"><a href="#4-2、中缀表达式" class="headerlink" title="4.2、中缀表达式"></a>4.2、中缀表达式</h3><ul>
<li>中缀表达式就是常见的运算表达式，如(3+4)×5-6</li>
<li><strong>中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作</strong>(前面我们讲的案例就能看的这个问题，因为中缀表达式存在运算符优先级的问题)，因此，<strong>在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式)</strong></li>
</ul>
<h3 id="4-3、后缀表达式"><a href="#4-3、后缀表达式" class="headerlink" title="4.3、后缀表达式"></a>4.3、后缀表达式</h3><h4 id="4-3-1、后缀表达式"><a href="#4-3-1、后缀表达式" class="headerlink" title="4.3.1、后缀表达式"></a>4.3.1、后缀表达式</h4><ul>
<li><strong>后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后</strong></li>
<li>中缀表达式举例说明： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –</li>
<li>再比如:</li>
</ul>
<table>
<thead>
<tr>
<th>正常的表达式</th>
<th>逆波兰表达式</th>
</tr>
</thead>
<tbody><tr>
<td>a+b</td>
<td>a b +</td>
</tr>
<tr>
<td>a+(b-c)</td>
<td>a b c - +</td>
</tr>
<tr>
<td>a+(b-c)*d</td>
<td>a b c – d * +</td>
</tr>
<tr>
<td>a+d*(b-c)</td>
<td>a d b c - * +</td>
</tr>
<tr>
<td>a=1+3</td>
<td>a 1 3 + =</td>
</tr>
</tbody></table>
<h4 id="4-3-2、后缀表达式的计算机求值"><a href="#4-3-2、后缀表达式的计算机求值" class="headerlink" title="4.3.2、后缀表达式的计算机求值"></a>4.3.2、后缀表达式的计算机求值</h4><ul>
<li><strong>从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈</strong>；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</li>
<li>例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:<ul>
<li>从左至右扫描，将3和4压入堆栈；</li>
<li>遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</li>
<li>将5入栈；</li>
<li>接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</li>
<li>将6入栈；</li>
<li>最后是-运算符，计算出35-6的值，即29，由此得出最终结果</li>
</ul>
</li>
</ul>
<h2 id="5、逆波兰计算器"><a href="#5、逆波兰计算器" class="headerlink" title="5、逆波兰计算器"></a>5、逆波兰计算器</h2><h3 id="5-1、计算器说明"><a href="#5-1、计算器说明" class="headerlink" title="5.1、计算器说明"></a>5.1、计算器说明</h3><ul>
<li>输入一个逆波兰表达式(后缀表达式)， 使用栈(Stack)，计算其结果</li>
<li>支持小括号和多位数整数， 因为这里我们主要讲的是数据结构， 因此计算器进行简化， 只支持对整数的计算</li>
</ul>
<h3 id="5-2、代码思路"><a href="#5-2、代码思路" class="headerlink" title="5.2、代码思路"></a>5.2、代码思路</h3><ul>
<li><strong>计算后缀表达式无需考虑运算符优先级问题，所以只需要一个数栈即可</strong></li>
<li>分为两种情况：<ul>
<li><strong>遇到数：压入数栈</strong></li>
<li><strong>遇到运算符：从数栈中弹出两个数，进行计算，计算结果压入数栈</strong></li>
</ul>
</li>
<li>何时计算完成？处理完表达式就代表计算完成</li>
</ul>
<h3 id="5-3、代码实现"><a href="#5-3、代码实现" class="headerlink" title="5.3、代码实现"></a>5.3、代码实现</h3><ul>
<li>出栈的两个数：num2 和 num1<ul>
<li>num2 先出栈，所以 num2 是减数或除数</li>
<li>num1 后出栈，所以 num1 是被减数或被除数</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//先定义给逆波兰表达式</span></span><br><span class="line">		<span class="comment">// 4 * 5 - 8 + 60 + 8 / 2 =&gt; 4 5 * 8 - 60 + 8 2 / + </span></span><br><span class="line">		<span class="comment">//说明为了方便，逆波兰表达式 的数字和符号使用空格隔开</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">suffixExpression</span> <span class="operator">=</span> <span class="string">&quot;4 5 * 8 - 60 + 8 2 / +&quot;</span>; <span class="comment">// 76</span></span><br><span class="line">		<span class="comment">//思路</span></span><br><span class="line">		<span class="comment">//1. 先将逆波兰表达式 =&gt; 放到ArrayList中</span></span><br><span class="line">		<span class="comment">//2. 将 ArrayList 传递给一个方法，遍历 ArrayList 配合栈 完成计算</span></span><br><span class="line">		</span><br><span class="line">		List&lt;String&gt; list = getListString(suffixExpression);</span><br><span class="line">		System.out.println(<span class="string">&quot;rpnList=&quot;</span> + list);</span><br><span class="line">		<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> calculate(list);</span><br><span class="line">		System.out.println(<span class="string">&quot;计算的结果是=&quot;</span> + res);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//将一个逆波兰表达式， 依次将数据和运算符 放入到 ArrayList中</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getListString</span><span class="params">(String suffixExpression)</span> &#123;</span><br><span class="line">		<span class="comment">//将 suffixExpression 分割</span></span><br><span class="line">		String[] split = suffixExpression.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">		<span class="keyword">for</span>(String ele: split) &#123;</span><br><span class="line">			list.add(ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//完成对逆波兰表达式的运算</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1)从左至右扫描，将3和4压入堆栈；</span></span><br><span class="line"><span class="comment">		2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment">		3)将5入栈；</span></span><br><span class="line"><span class="comment">		4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</span></span><br><span class="line"><span class="comment">		5)将6入栈；</span></span><br><span class="line"><span class="comment">		6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; ls)</span> &#123;</span><br><span class="line">		<span class="comment">// 创建给栈, 只需要一个栈即可</span></span><br><span class="line">		Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();</span><br><span class="line">		<span class="comment">// 遍历 ls</span></span><br><span class="line">		<span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">			<span class="comment">// 这里使用正则表达式来取出数</span></span><br><span class="line">			<span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123; <span class="comment">// 匹配的是多位数</span></span><br><span class="line">				<span class="comment">// 入栈</span></span><br><span class="line">				stack.push(item);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// pop出两个数，并运算， 再入栈</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">				<span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">				<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">					res = num1 + num2;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">					res = num1 - num2;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">					res = num1 * num2;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">					res = num1 / num2;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//把res 入栈</span></span><br><span class="line">				stack.push(<span class="string">&quot;&quot;</span> + res);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//最后留在stack中的数据是运算结果</span></span><br><span class="line">		<span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpnList=[4, 5, *, 8, -, 60, +, 8, 2, /, +]</span><br><span class="line">计算的结果是=76</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6、中缀表达式转后缀表达式"><a href="#6、中缀表达式转后缀表达式" class="headerlink" title="6、中缀表达式转后缀表达式"></a>6、中缀表达式转后缀表达式</h2><h3 id="6-1、代码思路"><a href="#6-1、代码思路" class="headerlink" title="6.1、代码思路"></a>6.1、代码思路</h3><ul>
<li>大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，<strong>因此在开发中，我们需要将中缀表达式转成后缀表达式。</strong></li>
<li>具体步骤如下:</li>
</ul>
<ol>
<li><p>初始化两个栈：<strong>运算符栈operStack</strong>和<strong>储存中间结果的栈tempStack</strong>；</p>
</li>
<li><p><strong>从左至右扫描中缀表达式；</strong></p>
</li>
<li><p><strong>遇到操作数时，将其压tempStack；</strong></p>
</li>
<li><p>遇到运算符时，比较其与operStack栈顶运算符的优先级：</p>
<ol>
<li><p>如果operStack为空，或栈顶运算符为左括号“(”，则直接将此运算符入tempStack栈（分如下两种情况）</p>
<ul>
<li>operStack 栈顶为空：之前的优先级别高的运算已经处理完成，已经得到了一个结果，将当前运算符直接压入 operStack 栈即可</li>
<li>operStack 栈顶为左括号：我都挨着左括号了，我要和它同生共死！当把我从operStack 出栈，用于运算后，这对括号中的表达式的值也就计算出来了</li>
</ul>
</li>
<li><p><strong>如果当前运算符优先级比栈顶运算符的高，也将运算符压入tempStack（当前运算符优先级高，先执行运算）</strong></p>
</li>
<li><p>否则，当前运算符优先级 &lt;= 栈顶运算符优先级，将operStack栈顶的运算符弹出并压入到tempStack中（operStack 栈顶运算符优先级高，先执行运算），再次转到(4.1)<br>与operStack中新的栈顶运算符相比较</p>
<p>（分如下两种情况）；</p>
<ul>
<li>一直循环，将 tempStack 栈顶元素取出，直到在 operStack 栈中找到比当前运算符优先级高的运算符，让其先执行运算</li>
<li>如果在 tempStack 栈中找不到比当前运算符优先级高的运算符，则会直接将 operStack 栈掏空，然后将当前运算符压入 tempStack 栈中（放在栈底）</li>
</ul>
</li>
</ol>
</li>
<li><p>遇到括号时：</p>
<ol>
<li>如果是左括号“(”，则直接压入operStack，等待与其配对的右括号，因为括号中的表达式需要优先运算</li>
<li>如果是右括号“)”，则依次弹出operStack栈顶的运算符，并压入tempStack，直到遇到左括号为止，此时将这一对括号丢弃（此时括号内的运算完成，并将结果压入了tempStack）</li>
</ol>
</li>
<li><p>重复步骤2至5，直到表达式的最右边</p>
</li>
<li><p><strong>将operStack中剩余的运算符依次弹出并压入tempStack</strong>（operStack 栈中剩下的运算都是优先级相同的运算符，按顺序执行即可）</p>
</li>
<li><p><strong>依次弹出tempStack中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</strong></p>
</li>
</ol>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTYzMTUwODg2LnBuZw?x-oss-process=image/format,png" alt="image-20200806163150886"></p>
<h3 id="6-2、举例说明"><a href="#6-2、举例说明" class="headerlink" title="6.2、举例说明"></a>6.2、举例说明</h3><ul>
<li>举例说明：将中缀表达 式“1+((2+3)×4)-5”转换为后缀表达式的过程如下</li>
<li>因此结果为：“1 2 3 + 4 × + 5 –”</li>
</ul>
<table>
<thead>
<tr>
<th>扫描到的元素</th>
<th>tempStack(栈底-&gt;栈顶)</th>
<th>operStack(栈底-&gt;栈顶)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>空</td>
<td>数字，直接入栈</td>
</tr>
<tr>
<td>+</td>
<td>1</td>
<td>+</td>
<td>s1为空，运算符直接入栈</td>
</tr>
<tr>
<td>(</td>
<td>1</td>
<td>+ (</td>
<td>左括号，直接入栈</td>
</tr>
<tr>
<td>(</td>
<td>1</td>
<td>+ ( (</td>
<td>同上</td>
</tr>
<tr>
<td>2</td>
<td>1 2</td>
<td>+ ( (</td>
<td>数字</td>
</tr>
<tr>
<td>+</td>
<td>1 2</td>
<td>+ ( ( +</td>
<td>s1栈顶为左括号，运算符直接入栈</td>
</tr>
<tr>
<td>3</td>
<td>1 2 3</td>
<td>+ ( ( +</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>1 2 3 +</td>
<td>+ (</td>
<td>右括号，弹出运算符直至遇到左括号</td>
</tr>
<tr>
<td>×</td>
<td>1 2 3 +</td>
<td>+ ( ×</td>
<td>s1栈顶为左括号，运算符直接入栈</td>
</tr>
<tr>
<td>4</td>
<td>1 2 3 + 4</td>
<td>+ ( ×</td>
<td>数字</td>
</tr>
<tr>
<td>)</td>
<td>1 2 3 + 4 ×</td>
<td>+</td>
<td>右括号，弹出运算符直至遇到左括号</td>
</tr>
<tr>
<td>-</td>
<td>1 2 3 + 4 × +</td>
<td>-</td>
<td>-与+优先级相同，因此弹出+，再压入-</td>
</tr>
<tr>
<td>5</td>
<td>1 2 3 + 4 × + 5</td>
<td>-</td>
<td>数字</td>
</tr>
<tr>
<td>到达最右端</td>
<td><strong>1 2 3 + 4 × + 5 -</strong></td>
<td>空</td>
<td>s1中剩余的运算符</td>
</tr>
</tbody></table>
<h3 id="6-3、代码实现"><a href="#6-3、代码实现" class="headerlink" title="6.3、代码实现"></a>6.3、代码实现</h3><ul>
<li>将中缀表达式转为对应的 List ：将数字和运算符分开，存储在 <code>List&lt;String&gt;</code> 对象中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 中缀表达式转成对应的List</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s s=&quot;1+((2+3)*4)-5&quot;;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">toInfixExpressionList</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    <span class="comment">//定义一个List,存放中缀表达式 对应的内容</span></span><br><span class="line">    List&lt;String&gt; ls=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>; <span class="comment">//这时是一个指针，用于遍历 中缀表达式字符串</span></span><br><span class="line">    String str; <span class="comment">// 对多位数的拼接</span></span><br><span class="line">    <span class="type">char</span> c; <span class="comment">// 每遍历到一个字符，就放入到c</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="comment">//如果c是一个非数字，我需要加入到ls</span></span><br><span class="line">        <span class="keyword">if</span>((c=s.charAt(i))&lt; <span class="number">48</span>||(c=s.charAt(i))&gt;<span class="number">57</span>)&#123;</span><br><span class="line">            ls.add(<span class="string">&quot;&quot;</span>+c);</span><br><span class="line">            i++; <span class="comment">//i需要后移</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//如果是一个数，需要考虑多位数</span></span><br><span class="line">            str=<span class="string">&quot;&quot;</span>; <span class="comment">//先将str 置成&quot;&quot; &#x27;0&#x27;[48]-&gt;&#x27;9&#x27;[57]</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;s.length()&amp;&amp;s.charAt(i)&gt;=<span class="number">48</span>&amp;&amp;(c=s.charAt(i))&lt;=<span class="number">57</span>)&#123;</span><br><span class="line">                str+=c;<span class="comment">//拼接</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ls.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(i&lt;s.length());</span><br><span class="line">    <span class="keyword">return</span> ls;<span class="comment">//返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>将中缀表达式（List）转为后缀表达式（List）<ul>
<li>如果是一个数，加入tempList</li>
<li>如果是 ( ，则直接入operStack（括号内的表达式优先计算）</li>
<li>如果是 ) ，则依次弹出 operStack 栈顶的运算符，并压入 tempList ，直到遇到左括号为止，此时将这一对括号丢弃（括号内的表达式优先计算）</li>
<li>否则比较当前运算符和栈顶运算符优先级<ul>
<li>当前运算符优先级 &gt; 栈顶运算符，将当前运算符压入 operStack 栈中（当前运算符优先级较高，先进行运算）</li>
<li>当前运算符优先级 &lt;= 栈顶运算符，将 operStack 栈顶运算符取出，压入 tempList 中，再次对新的栈顶元素进行优先级判断（之前的运算符优先级较高，先进行运算）</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line"><span class="comment">// 方法：将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">parseSuffixExpreesionList</span><span class="params">(List&lt;String&gt; ls)</span>&#123;</span><br><span class="line">    <span class="comment">// 定义两个栈</span></span><br><span class="line">    Stack&lt;String&gt; operStack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;(); <span class="comment">// 符号栈</span></span><br><span class="line">    <span class="comment">// 说明：因为tempList 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span></span><br><span class="line">    <span class="comment">// 因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; tempList</span></span><br><span class="line">    <span class="comment">// Stack&lt;String&gt; tempStack = new Stack&lt;String&gt;(); // 储存中间结果的栈tempStack</span></span><br><span class="line">    List&lt;String&gt; tempList=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">// 储存中间结果的tempList</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历ls</span></span><br><span class="line">    <span class="keyword">for</span>(String item:ls)&#123;</span><br><span class="line">        <span class="keyword">if</span>(item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123; <span class="comment">// 如果是一个数，加入tempList</span></span><br><span class="line">            tempList.add(item);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;(&quot;</span>))&#123; <span class="comment">// 如果是 ( ，则直接入operStack</span></span><br><span class="line">            operStack.push(item);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(item.equals(<span class="string">&quot;)&quot;</span>))&#123; <span class="comment">// 如果是 ) ，则将括号内的值算出，并压入 tempList）</span></span><br><span class="line">            <span class="comment">// 如果是右括号“)”，则依次弹出operStack栈顶的运算符，并压入tempList，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">            <span class="keyword">while</span>(!operStack.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                tempList.add(operStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            operStack.pop();<span class="comment">// !!! 将 ( 弹出 s1栈， 消除小括号</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">// 否则比较当前运算符和栈顶运算符优先级</span></span><br><span class="line">            <span class="comment">// 当item的优先级小于等于operStack栈顶运算符,</span></span><br><span class="line">            <span class="comment">// 将operStack栈顶的运算符弹出并加入到tempList中，再次转到(4.1)与operStack中新的栈顶运算符相比较</span></span><br><span class="line">            <span class="comment">// 问题：我们缺少一个比较优先级高低的方法</span></span><br><span class="line">            <span class="keyword">while</span>(operStack.size()!=<span class="number">0</span>&amp;&amp;Operation.getValue(operStack.peek())&gt;=Operation.getValue(item))&#123;</span><br><span class="line">                tempList.add(operStack.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还需要将item压入栈</span></span><br><span class="line">            operStack.push(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将operStack中剩余的运算符依次弹出并加入tempList</span></span><br><span class="line">    <span class="keyword">while</span>(operStack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">        tempList.add(operStack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tempList; <span class="comment">// 注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码：<ul>
<li>将中缀表达式转为对应的 List</li>
<li>将中缀表达式 List 转为后缀表达式 List</li>
<li>调用逆波兰计算器执行计算</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成将一个中缀表达式转成后缀表达式的功能</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1. 1+((2+3)×4)-5 =&gt; 转成 1 2 3 + 4 × + 5 –</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 因为直接对str 进行操作，不方便，因此 先将 &quot;1+((2+3)×4)-5&quot; =》 中缀的表达式对应的List</span></span><br><span class="line">    <span class="comment">// 即 &quot;1+((2+3)×4)-5&quot; =&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">    <span class="comment">// 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line"></span><br><span class="line">    String expression=<span class="string">&quot;1+((2+3)*4)-5&quot;</span>;<span class="comment">// 注意表达式</span></span><br><span class="line">    List&lt;String&gt; infixExpressionList=toInfixExpressionList(expression);</span><br><span class="line">    System.out.println(<span class="string">&quot;中缀表达式对应的List=&quot;</span>+infixExpressionList); <span class="comment">// ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">    List&lt;String&gt; suffixExpreesionList=parseSuffixExpreesionList(infixExpressionList);</span><br><span class="line">    System.out.println(<span class="string">&quot;后缀表达式对应的List&quot;</span>+suffixExpreesionList); <span class="comment">// ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line">    System.out.printf(<span class="string">&quot;expression=%d&quot;</span>,calculate(suffixExpreesionList)); <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">中缀表达式对应的List=[1, +, (, (, 2, +, 3, ), *, 4, ), -, 5]</span><br><span class="line">后缀表达式对应的List[1, 2, 3, +, 4, *, +, 5, -]</span><br><span class="line">expression=16</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-4、中缀表达式转后缀表达式完整代码"><a href="#6-4、中缀表达式转后缀表达式完整代码" class="headerlink" title="6.4、中缀表达式转后缀表达式完整代码"></a>6.4、中缀表达式转后缀表达式完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PolandNotation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成将一个中缀表达式转成后缀表达式的功能</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 说明</span></span><br><span class="line">        <span class="comment">// 1. 1+((2+3)×4)-5 =&gt; 转成 1 2 3 + 4 × + 5 –</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 因为直接对str 进行操作，不方便，因此 先将 &quot;1+((2+3)×4)-5&quot; =》 中缀的表达式对应的List</span></span><br><span class="line">        <span class="comment">// 即 &quot;1+((2+3)×4)-5&quot; =&gt; ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">        <span class="comment">// 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">expression</span> <span class="operator">=</span> <span class="string">&quot;1+((2+3)*4)-5&quot;</span>;<span class="comment">// 注意表达式</span></span><br><span class="line">        List&lt;String&gt; infixExpressionList = toInfixExpressionList(expression);</span><br><span class="line">        System.out.println(<span class="string">&quot;中缀表达式对应的List=&quot;</span> + infixExpressionList); <span class="comment">// ArrayList [1,+,(,(,2,+,3,),*,4,),-,5]</span></span><br><span class="line">        List&lt;String&gt; suffixExpreesionList = parseSuffixExpreesionList(infixExpressionList);</span><br><span class="line">        System.out.println(<span class="string">&quot;后缀表达式对应的List&quot;</span> + suffixExpreesionList); <span class="comment">// ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;expression=%d&quot;</span>, calculate(suffixExpreesionList)); <span class="comment">// ?</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：将 中缀表达式转成对应的List</span></span><br><span class="line">    <span class="comment">// s=&quot;1+((2+3)×4)-5&quot;;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">toInfixExpressionList</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义一个List,存放中缀表达式 对应的内容</span></span><br><span class="line">        List&lt;String&gt; ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 这时是一个指针，用于遍历 中缀表达式字符串</span></span><br><span class="line">        String str; <span class="comment">// 对多位数的拼接</span></span><br><span class="line">        <span class="type">char</span> c; <span class="comment">// 每遍历到一个字符，就放入到c</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 如果c是一个非数字，我需要加入到ls</span></span><br><span class="line">            <span class="keyword">if</span> ((c = s.charAt(i)) &lt; <span class="number">48</span> || (c = s.charAt(i)) &gt; <span class="number">57</span>) &#123;</span><br><span class="line">                ls.add(<span class="string">&quot;&quot;</span> + c);</span><br><span class="line">                i++; <span class="comment">// i需要后移</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果是一个数，需要考虑多位数</span></span><br><span class="line">                str = <span class="string">&quot;&quot;</span>; <span class="comment">// 先将str 置成&quot;&quot; &#x27;0&#x27;[48]-&gt;&#x27;9&#x27;[57]</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= <span class="number">48</span> &amp;&amp; (c = s.charAt(i)) &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">                    str += c;<span class="comment">// 拼接</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ls.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; s.length());</span><br><span class="line">        <span class="keyword">return</span> ls;<span class="comment">// 返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 即 ArrayList [1,+,(,(,2,+,3,),*,4,),-,5] =》 ArrayList [1,2,3,+,4,*,+,5,–]</span></span><br><span class="line">    <span class="comment">// 方法：将得到的中缀表达式对应的List =&gt; 后缀表达式对应的List</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">parseSuffixExpreesionList</span><span class="params">(List&lt;String&gt; ls)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义两个栈</span></span><br><span class="line">        Stack&lt;String&gt; operStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;(); <span class="comment">// 符号栈</span></span><br><span class="line">        <span class="comment">// 说明：因为tempList 这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span></span><br><span class="line">        <span class="comment">// 因此比较麻烦，这里我们就不用 Stack&lt;String&gt; 直接使用 List&lt;String&gt; tempList</span></span><br><span class="line">        <span class="comment">// Stack&lt;String&gt; tempStack = new Stack&lt;String&gt;(); // 储存中间结果的栈tempStack</span></span><br><span class="line">        List&lt;String&gt; tempList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(); <span class="comment">// 储存中间结果的tempList</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123; <span class="comment">// 如果是一个数，加入tempList</span></span><br><span class="line">                tempList.add(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;(&quot;</span>)) &#123; <span class="comment">// 如果是 ( ，则直接入operStack</span></span><br><span class="line">                operStack.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;)&quot;</span>)) &#123; <span class="comment">// 如果是 ) ，则将括号内的值算出，并压入 tempList）</span></span><br><span class="line">                <span class="comment">// 如果是右括号“)”，则依次弹出operStack栈顶的运算符，并压入tempList，直到遇到左括号为止，此时将这一对括号丢弃</span></span><br><span class="line">                <span class="keyword">while</span> (!operStack.peek().equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                    tempList.add(operStack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                operStack.pop();<span class="comment">// !!! 将 ( 弹出 s1栈， 消除小括号</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则比较当前运算符和栈顶运算符优先级</span></span><br><span class="line">                <span class="comment">// 当item的优先级小于等于operStack栈顶运算符,</span></span><br><span class="line">                <span class="comment">// 将operStack栈顶的运算符弹出并加入到tempList中，再次转到(4.1)与operStack中新的栈顶运算符相比较</span></span><br><span class="line">                <span class="comment">// 问题：我们缺少一个比较优先级高低的方法</span></span><br><span class="line">                <span class="keyword">while</span> (operStack.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(operStack.peek()) &gt;= Operation.getValue(item)) &#123;</span><br><span class="line">                    tempList.add(operStack.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 还需要将item压入栈</span></span><br><span class="line">                operStack.push(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将operStack中剩余的运算符依次弹出并加入tempList</span></span><br><span class="line">        <span class="keyword">while</span> (operStack.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            tempList.add(operStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tempList; <span class="comment">// 注意因为是存放到List, 因此按顺序输出就是对应的后缀表达式对应的List</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成对逆波兰表达式的运算</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 1)从左至右扫描，将3和4压入堆栈； 2)遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈； 3)将5入栈；</span></span><br><span class="line"><span class="comment">	 * 4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈； 5)将6入栈； 6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(List&lt;String&gt; ls)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建给栈, 只需要一个栈即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 遍历 ls</span></span><br><span class="line">        <span class="keyword">for</span> (String item : ls) &#123;</span><br><span class="line">            <span class="comment">// 这里使用正则表达式来取出数</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123; <span class="comment">// 匹配的是多位数</span></span><br><span class="line">                <span class="comment">// 入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// pop出两个数，并运算， 再入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 把res 入栈</span></span><br><span class="line">                stack.push(<span class="string">&quot;&quot;</span> + res);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后留在stack中的数据是运算结果</span></span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个类 Operation 可以返回一个运算符 对应的优先级</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Operation</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">LEFT_BRACKET</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ADD</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SUB</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MUL</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">DIV</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写一个方法，返回对应的优先级数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">(String operation)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;(&quot;</span>:</span><br><span class="line">                result = LEFT_BRACKET;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                result = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                result = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                result = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                result = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;不存在该运算符&quot;</span> + operation);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7、完整版逆波兰计算器"><a href="#7、完整版逆波兰计算器" class="headerlink" title="7、完整版逆波兰计算器"></a>7、完整版逆波兰计算器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReversePolishMultiCalc</span> &#123;</span><br><span class="line"></span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配 + - * / ( ) 运算符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SYMBOL</span> <span class="operator">=</span> <span class="string">&quot;\\+|-|\\*|/|\\(|\\)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LEFT</span> <span class="operator">=</span> <span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RIGHT</span> <span class="operator">=</span> <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ADD</span> <span class="operator">=</span> <span class="string">&quot;+&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String MINUS= <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TIMES</span> <span class="operator">=</span> <span class="string">&quot;*&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DIVISION</span> <span class="operator">=</span> <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加減 + -</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEVEL_01</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 乘除 * /</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEVEL_02</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 括号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LEVEL_HIGH</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Stack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; data = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去除所有空白符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceAllBlank</span><span class="params">(String s )</span>&#123;</span><br><span class="line">        <span class="comment">// \\s+ 匹配任何空白字符，包括空格、制表符、换页符等等, 等价于[ \f\n\r\t\v]</span></span><br><span class="line">        <span class="keyword">return</span> s.replaceAll(<span class="string">&quot;\\s+&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是数字 int double long float</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;^[-\\+]?[.\\d]*$&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> pattern.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是不是运算符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymbol</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(SYMBOL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配运算等级</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calcLevel</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;+&quot;</span>.equals(s) || <span class="string">&quot;-&quot;</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_01;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;*&quot;</span>.equals(s) || <span class="string">&quot;/&quot;</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> LEVEL_02;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> LEVEL_HIGH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匹配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">doMatch</span> <span class="params">(String s)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(s.trim())) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;data is empty&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!isNumber(s.charAt(<span class="number">0</span>)+<span class="string">&quot;&quot;</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;data illeagle,start not with a number&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s = replaceAllBlank(s);</span><br><span class="line"></span><br><span class="line">        String each;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(s.charAt(i)+<span class="string">&quot;&quot;</span>))&#123;</span><br><span class="line">                each = s.charAt(i)+<span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="comment">//栈为空，(操作符，或者 操作符优先级大于栈顶优先级 &amp;&amp; 操作符优先级不是( )的优先级 及是 ) 不能直接入栈</span></span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty() || LEFT.equals(each)</span><br><span class="line">                        || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH))&#123;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>( !stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                    <span class="comment">//栈非空，操作符优先级小于等于栈顶优先级时出栈入列，直到栈为空，或者遇到了(，最后操作符入栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek()) )&#123;</span><br><span class="line">                        <span class="keyword">if</span>(calcLevel(stack.peek()) == LEVEL_HIGH)&#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(each);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(RIGHT.equals(each))&#123;</span><br><span class="line">                    <span class="comment">// ) 操作符，依次出栈入列直到空栈或者遇到了第一个)操作符，此时)出栈</span></span><br><span class="line">                    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek()))&#123;</span><br><span class="line">                        <span class="keyword">if</span>(LEVEL_HIGH == calcLevel(stack.peek()))&#123;</span><br><span class="line">                            stack.pop();</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        data.add(stack.pop());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                start = i ;    <span class="comment">//前一个运算符的位置</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( i == s.length()-<span class="number">1</span> || isSymbol(s.charAt(i+<span class="number">1</span>)+<span class="string">&quot;&quot;</span>) )&#123;</span><br><span class="line">                each = start == <span class="number">0</span> ? s.substring(start,i+<span class="number">1</span>) : s.substring(start+<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isNumber(each)) &#123;</span><br><span class="line">                    data.add(each);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;data not match number&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果栈里还有元素，此时元素需要依次出栈入列，可以想象栈里剩下栈顶为/，栈底为+，应该依次出栈入列，可以直接翻转整个stack 添加到队列</span></span><br><span class="line">        Collections.reverse(stack);</span><br><span class="line">        data.addAll(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stack));</span><br><span class="line"></span><br><span class="line">        System.out.println(data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 算出结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title function_">doCalc</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0d</span>;</span><br><span class="line">        <span class="keyword">if</span>(list == <span class="literal">null</span> || list.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(list);</span><br><span class="line">            d = Double.valueOf(list.get(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">return</span> d;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list1.add(list.get(i));</span><br><span class="line">            <span class="keyword">if</span>(isSymbol(list.get(i)))&#123;</span><br><span class="line">                <span class="type">Double</span> <span class="variable">d1</span> <span class="operator">=</span> doTheMath(list.get(i - <span class="number">2</span>), list.get(i - <span class="number">1</span>), list.get(i));</span><br><span class="line">                list1.remove(i);</span><br><span class="line">                list1.remove(i-<span class="number">1</span>);</span><br><span class="line">                list1.set(i-<span class="number">2</span>,d1+<span class="string">&quot;&quot;</span>);</span><br><span class="line">                list1.addAll(list.subList(i+<span class="number">1</span>,list.size()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        doCalc(list1);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运算</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> symbol</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Double <span class="title function_">doTheMath</span><span class="params">(String s1,String s2,String symbol)</span>&#123;</span><br><span class="line">        Double result ;</span><br><span class="line">        <span class="keyword">switch</span> (symbol)&#123;</span><br><span class="line">            <span class="keyword">case</span> ADD : result = Double.valueOf(s1) + Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MINUS : result = Double.valueOf(s1) - Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TIMES : result = Double.valueOf(s1) * Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DIVISION : result = Double.valueOf(s1) / Double.valueOf(s2); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> : result = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//String math = &quot;9+(3-1)*3+10/2&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">math</span> <span class="operator">=</span> <span class="string">&quot;12.8 + (2 - 3.55)*4+10/5.0&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doCalc(doMatch(math));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>第 10 章 树结构的基础部分</title>
    <url>/posts/c259c9e2b688/</url>
    <content><![CDATA[<h1 id="第-10-章-树结构的基础部分"><a href="#第-10-章-树结构的基础部分" class="headerlink" title="第 10 章 树结构的基础部分"></a>第 10 章 树结构的基础部分</h1><h2 id="1、二叉树"><a href="#1、二叉树" class="headerlink" title="1、二叉树"></a>1、二叉树</h2><h3 id="1-1、为什么需要二叉树"><a href="#1-1、为什么需要二叉树" class="headerlink" title="1.1、为什么需要二叉树"></a>1.1、为什么需要二叉树</h3><h4 id="1-1-1、数组存储方式的分析"><a href="#1-1-1、数组存储方式的分析" class="headerlink" title="1.1.1、数组存储方式的分析"></a>1.1.1、数组存储方式的分析</h4><ul>
<li>优点： 通过下标方式访问元素， 速度快。 对于有序数组， 还可使用二分查找提高检索速度</li>
<li>缺点： 如果要检索具体某个值， 或者插入值(按一定顺序)会整体移动，效率较低</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTE0MDU1NDYzLnBuZw?x-oss-process=image/format,png" alt="image-20200717114055463"></p>
<h4 id="1-1-2、链式存储方式的分析"><a href="#1-1-2、链式存储方式的分析" class="headerlink" title="1.1.2、链式存储方式的分析"></a>1.1.2、链式存储方式的分析</h4><ul>
<li>优点： 在一定程度上对数组存储方式有优化(比如： 插入一个数值节点， 只需要将插入节点， 链接到链表中即可，删除效率也很好)。</li>
<li>缺点： 在进行检索时， 效率仍然较低， 比如(检索某个值， 需要从头节点开始遍历)</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTE0MTE3NzEyLnBuZw?x-oss-process=image/format,png" alt="image-20200717114117712"></p>
<h4 id="1-1-3、树存储方式的分析"><a href="#1-1-3、树存储方式的分析" class="headerlink" title="1.1.3、树存储方式的分析"></a>1.1.3、树存储方式的分析</h4><ul>
<li>能提高数据存储， 读取的效率, 比如利用 二叉排序树(Binary Sort Tree)， 既可以保证数据的检索速度， 同时也可以保证数据的插入， 删除， 修改的速度。 【示意图，后面详讲】</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTE0MTMzNTg0LnBuZw?x-oss-process=image/format,png" alt="image-20200717114133584"></p>
<h3 id="1-2、树的常用术语"><a href="#1-2、树的常用术语" class="headerlink" title="1.2、树的常用术语"></a>1.2、树的常用术语</h3><ul>
<li>节点</li>
<li>根节点</li>
<li>父节点</li>
<li>子节点</li>
<li>叶子节点 (没有子节点的节点)</li>
<li>节点的权(节点值)</li>
<li>路径(从 root 节点找到该节点的路线)</li>
<li>层</li>
<li>子树</li>
<li>树的高度(最大层数)</li>
<li>森林 :多颗子树构成森林</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTE0MjI4NjQ3LnBuZw?x-oss-process=image/format,png" alt="image-20200717114228647"></p>
<blockquote>
<p>上图有错误，此处更正，上图中的==H、E、F、G== 没有子节点，他们是叶子节点，</p>
</blockquote>
<h3 id="1-3、二叉树的概念"><a href="#1-3、二叉树的概念" class="headerlink" title="1.3、二叉树的概念"></a>1.3、二叉树的概念</h3><ul>
<li>树有很多种， 每个节点最多只能有两个子节点的一种形式称为二叉树，二叉树的子节点分为左节点和右节点</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODEyMjE1MTM3NTY4LnBuZw?x-oss-process=image/format,png" alt="image-20200812215137568"></p>
<ul>
<li><strong>如果该二叉树的所有叶子节点都在最后一层， 并且结点总数= 2^n -1， n 为层数， 则我们称为满二叉树</strong></li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODEyMjE1MTQ2MjUxLnBuZw?x-oss-process=image/format,png" alt="image-20200812215146251"></p>
<ul>
<li><strong>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层， 而且最后一层的叶子节点在左边连续， 倒数第二层的叶子节点在右边连续， 我们称为完全二叉树</strong></li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODEyMjE1MTU2NTE3LnBuZw?x-oss-process=image/format,png" alt="image-20200812215156517"></p>
<h3 id="1-4、二叉树的遍历"><a href="#1-4、二叉树的遍历" class="headerlink" title="1.4、二叉树的遍历"></a>1.4、二叉树的遍历</h3><h4 id="1-4-1、代码思路"><a href="#1-4-1、代码思路" class="headerlink" title="1.4.1、代码思路"></a>1.4.1、代码思路</h4><ul>
<li>前序遍历: <strong>先输出父节点</strong>， 再遍历左子树和右子树</li>
<li>中序遍历: 先遍历左子树， <strong>再输出父节点</strong>， 再遍历右子树</li>
<li>后序遍历: 先遍历左子树， 再遍历右子树， <strong>最后输出父节点</strong></li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTMxMTMxOTYzLnBuZw?x-oss-process=image/format,png" alt="image-20200717131131963"></p>
<h4 id="1-4-2、前-中-后序遍历"><a href="#1-4-2、前-中-后序遍历" class="headerlink" title="1.4.2、前 中 后序遍历"></a>1.4.2、前 中 后序遍历</h4><ul>
<li>定义二叉树节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建 HeroNode 结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> HeroNode left; <span class="comment">// 默认null</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode right; <span class="comment">// 默认null</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.no = no;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> no;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.left = left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编写前序遍历的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>); <span class="comment">// 先输出父结点</span></span><br><span class="line">		<span class="comment">// 递归向左子树前序遍历</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.left.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 递归向右子树前序遍历</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.right.preOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 中序遍历</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 递归向左子树中序遍历</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出父结点</span></span><br><span class="line">		System.out.println(<span class="built_in">this</span>);</span><br><span class="line">		<span class="comment">// 递归向右子树中序遍历</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 后序遍历</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.left.postOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.right.postOrder();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义二叉树：二叉树需要一个根节点 root 作为整个树的入口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义 BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-4-3、代码测试"><a href="#1-4-3、代码测试" class="headerlink" title="1.4.3、代码测试"></a>1.4.3、代码测试</h4><ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 先需要创建一颗二叉树</span></span><br><span class="line">    <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">    <span class="comment">// 创建需要的结点</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;关胜&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">    root.setLeft(node2);</span><br><span class="line">    root.setRight(node3);</span><br><span class="line">    node3.setRight(node4);</span><br><span class="line">    node3.setLeft(node5);</span><br><span class="line">    binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    System.out.println(<span class="string">&quot;前序遍历&quot;</span>); <span class="comment">// 1,2,3,5,4</span></span><br><span class="line">    binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">    binaryTree.infixOrder(); <span class="comment">// 2,1,5,3,4</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;后序遍历&quot;</span>);</span><br><span class="line">    binaryTree.postOrder(); <span class="comment">// 2,5,4,3,1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODEyMjE1NjQ5NjE5LnBuZw?x-oss-process=image/format,png" alt="image-20200812215649619"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">前序遍历</span><br><span class="line">HeroNode [no=1, name=宋江]</span><br><span class="line">HeroNode [no=2, name=吴用]</span><br><span class="line">HeroNode [no=3, name=卢俊义]</span><br><span class="line">HeroNode [no=5, name=关胜]</span><br><span class="line">HeroNode [no=4, name=林冲]</span><br><span class="line">中序遍历</span><br><span class="line">HeroNode [no=2, name=吴用]</span><br><span class="line">HeroNode [no=1, name=宋江]</span><br><span class="line">HeroNode [no=5, name=关胜]</span><br><span class="line">HeroNode [no=3, name=卢俊义]</span><br><span class="line">HeroNode [no=4, name=林冲]</span><br><span class="line">后序遍历</span><br><span class="line">HeroNode [no=2, name=吴用]</span><br><span class="line">HeroNode [no=5, name=关胜]</span><br><span class="line">HeroNode [no=4, name=林冲]</span><br><span class="line">HeroNode [no=3, name=卢俊义]</span><br><span class="line">HeroNode [no=1, name=宋江]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-4-4、总结"><a href="#1-4-4、总结" class="headerlink" title="1.4.4、总结"></a>1.4.4、总结</h4><ul>
<li>看<strong>输出父节点的顺序</strong>， 就确定是前序， 中序还是后序</li>
<li>前序遍历递归图解</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTMyMDMxMjIxLnBuZw?x-oss-process=image/format,png" alt="image-20200717132031221"></p>
<ul>
<li>中序遍历递归图解</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTMzODU5MDE4LnBuZw?x-oss-process=image/format,png" alt="image-20200717132518380"></p>
<ul>
<li>后序遍历递归图解</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTMzMDAzOTU4LnBuZw?x-oss-process=image/format,png" alt="image-20200717133003958"></p>
<h3 id="1-5、二叉树的查找"><a href="#1-5、二叉树的查找" class="headerlink" title="1.5、二叉树的查找"></a>1.5、二叉树的查找</h3><h4 id="1-5-1、代码思路"><a href="#1-5-1、代码思路" class="headerlink" title="1.5.1、代码思路"></a>1.5.1、代码思路</h4><ul>
<li>将二叉树的前、中、后序遍历改为查找即可</li>
<li>编码思路：<ul>
<li>如果查找到目标节点，直接返回，结束递归</li>
<li>如果找不到，继续递归执行前（中、后）序查找</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTM0NTQzMzI5LnBuZw?x-oss-process=image/format,png" alt="image-20200717134543329"></p>
<h4 id="1-5-2、前-中-后序查找"><a href="#1-5-2、前-中-后序查找" class="headerlink" title="1.5.2、前 中 后序查找"></a>1.5.2、前 中 后序查找</h4><ul>
<li>定义二叉树节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建 HeroNode 结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left; <span class="comment">// 默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">// 默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">// 比较当前结点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">        <span class="comment">// 2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;<span class="comment">// 说明我们左子树找到</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">        <span class="comment">// 2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则继续进行右递归的中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前结点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;<span class="comment">// 说明在左子树找到</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左子树没有找到，则向右子树递归进行后序遍历查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左右子树都没有找到，就比较当前结点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义二叉树：二叉树需要一个根节点 root 作为整个树的入口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义 BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line">            <span class="keyword">if</span> (root.getNo() == no) &#123;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 递归删除</span></span><br><span class="line">                root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空树，不能删除~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.postOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-5-3、测试代码"><a href="#1-5-3、测试代码" class="headerlink" title="1.5.3、测试代码"></a>1.5.3、测试代码</h4><ul>
<li>测试代码：测试前序、中序、后序查找</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="comment">// 先需要创建一颗二叉树</span></span><br><span class="line">    BinaryTree binaryTree=<span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">    <span class="comment">// 创建需要的结点</span></span><br><span class="line">    HeroNode root=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">    HeroNode node2=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">    HeroNode node3=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">    HeroNode node4=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">    HeroNode node5=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>,<span class="string">&quot;关胜&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">    root.setLeft(node2);</span><br><span class="line">    root.setRight(node3);</span><br><span class="line">    node3.setRight(node4);</span><br><span class="line">    node3.setLeft(node5);</span><br><span class="line">    binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    System.out.println(<span class="string">&quot;前序遍历方式~~~&quot;</span>);</span><br><span class="line">    HeroNode resNode=binaryTree.preOrderSearch(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span>(resNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;找到了，信息为 no=%d name=%s\n&quot;</span>,resNode.getNo(),resNode.getName());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;没有找到 no = %d 的英雄\n&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历查找</span></span><br><span class="line">    System.out.println(<span class="string">&quot;中序遍历方式~~~&quot;</span>);</span><br><span class="line">    resNode=binaryTree.infixOrderSearch(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span>(resNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;找到了，信息为 no=%d name=%s\n&quot;</span>,resNode.getNo(),resNode.getName());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;没有找到 no = %d 的英雄\n&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历查找</span></span><br><span class="line">    System.out.println(<span class="string">&quot;后序遍历方式~~~&quot;</span>);</span><br><span class="line">    resNode=binaryTree.postOrderSearch(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">if</span>(resNode!=<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;找到了，信息为 no=%d name=%s\n&quot;</span>,resNode.getNo(),resNode.getName());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;没有找到 no = %d 的英雄\n&quot;</span>,<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">前序遍历方式~~~</span><br><span class="line">找到了，信息为 no=4 name=林冲</span><br><span class="line"></span><br><span class="line">中序遍历方式~~~</span><br><span class="line">找到了，信息为 no=5 name=关胜</span><br><span class="line"></span><br><span class="line">后序遍历方式~~~</span><br><span class="line">没有找到 no = 6 的英雄</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-6、二叉树的删除"><a href="#1-6、二叉树的删除" class="headerlink" title="1.6、二叉树的删除"></a>1.6、二叉树的删除</h3><h4 id="1-6-1、二叉树删除的要求"><a href="#1-6-1、二叉树删除的要求" class="headerlink" title="1.6.1、二叉树删除的要求"></a>1.6.1、二叉树删除的要求</h4><ul>
<li>如果删除的节点是叶子节点， 则删除该节点</li>
<li>如果删除的节点是非叶子节点， 则删除该子树</li>
</ul>
<h4 id="1-6-2、代码思路"><a href="#1-6-2、代码思路" class="headerlink" title="1.6.2、代码思路"></a>1.6.2、代码思路</h4><ul>
<li>由于树的本质还是单向链表：<ul>
<li>单向链表无法实现自删除，我们需要定位至待删除节点的前一个节点，才能执行删除</li>
<li>同样，如果我们直接定位至二叉树中待删除的节点，那么其父节点信息便会丢失，所以我们一定要定位至待删除节点的父节点</li>
</ul>
</li>
<li>编码思路：<ul>
<li>先判断根节点 root 是不是待删除的节点，如果是，则删除根节点，否则开始执行递归</li>
<li>判断当前节点（this）的左节点是否为待删除的节点，如果是，删除 this.left ，然后返回，结束递归</li>
<li>判断当前节点（this）的左节点是否为待删除的节点，如果是，删除 this.right，然后返回，结束递归</li>
<li>否则继续执行左递归，左递归执行完后，执行右递归</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTYzNjMxNDYyLnBuZw?x-oss-process=image/format,png" alt="image-20200717163631462"></p>
<h4 id="1-6-3、二叉树的递归删除"><a href="#1-6-3、二叉树的递归删除" class="headerlink" title="1.6.3、二叉树的递归删除"></a>1.6.3、二叉树的递归删除</h4><ul>
<li>定义二叉树节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建 HeroNode 结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> HeroNode left; <span class="comment">// 默认null</span></span><br><span class="line">	<span class="keyword">private</span> HeroNode right; <span class="comment">// 默认null</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.no = no;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> no;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.no = no;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.left = left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.right = right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 递归删除结点</span></span><br><span class="line">	<span class="comment">// 1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line">	<span class="comment">// 2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 思路</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点. </span></span><br><span class="line"><span class="comment">		 * 2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) </span></span><br><span class="line"><span class="comment">		 * 3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除) </span></span><br><span class="line"><span class="comment">		 * 4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除 5. 如果第4步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// 2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.no == no) &#123;</span><br><span class="line">			<span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.no == no) &#123;</span><br><span class="line">			<span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 4.我们就需要向左子树进行递归删除</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.left.delNode(no);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 5.则应当向右子树进行递归删除</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.right.delNode(no);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>定义二叉树：二叉树需要一个根节点 root 作为整个树的入口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义 BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.root = root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除结点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line">			<span class="keyword">if</span> (root.getNo() == no) &#123;</span><br><span class="line">				root = <span class="literal">null</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 递归删除</span></span><br><span class="line">				root.delNode(no);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;空树，不能删除~&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-6-4、测试代码"><a href="#1-6-4、测试代码" class="headerlink" title="1.6.4、测试代码"></a>1.6.4、测试代码</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先需要创建一颗二叉树</span></span><br><span class="line">    <span class="type">BinaryTree</span> <span class="variable">binaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">    <span class="comment">// 创建需要的结点</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;关胜&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 说明，我们先手动创建该二叉树，后面我们学习递归的方式创建二叉树</span></span><br><span class="line">    root.setLeft(node2);</span><br><span class="line">    root.setRight(node3);</span><br><span class="line">    node3.setRight(node4);</span><br><span class="line">    node3.setLeft(node5);</span><br><span class="line">    binaryTree.setRoot(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试一把删除结点</span></span><br><span class="line">    System.out.println(<span class="string">&quot;删除前,前序遍历&quot;</span>);</span><br><span class="line">    binaryTree.preOrder(); <span class="comment">// 1,2,3,5,4</span></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    binaryTree.delNode(<span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除节点 5 后，前序遍历&quot;</span>);</span><br><span class="line">    binaryTree.preOrder(); <span class="comment">// 1,2,3,4</span></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    binaryTree.delNode(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除子树 3  后，前序遍历&quot;</span>);</span><br><span class="line">    binaryTree.preOrder(); <span class="comment">// 1,2</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">删除前,前序遍历</span><br><span class="line">HeroNode [no=1, name=宋江]</span><br><span class="line">HeroNode [no=2, name=吴用]</span><br><span class="line">HeroNode [no=3, name=卢俊义]</span><br><span class="line">HeroNode [no=5, name=关胜]</span><br><span class="line">HeroNode [no=4, name=林冲]</span><br><span class="line"></span><br><span class="line">删除节点 5 后，前序遍历</span><br><span class="line">HeroNode [no=1, name=宋江]</span><br><span class="line">HeroNode [no=2, name=吴用]</span><br><span class="line">HeroNode [no=3, name=卢俊义]</span><br><span class="line">HeroNode [no=4, name=林冲]</span><br><span class="line"></span><br><span class="line">删除子树 3  后，前序遍历</span><br><span class="line">HeroNode [no=1, name=宋江]</span><br><span class="line">HeroNode [no=2, name=吴用]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-7、二叉树的全部代码"><a href="#1-7、二叉树的全部代码" class="headerlink" title="1.7、二叉树的全部代码"></a>1.7、二叉树的全部代码</h3><ul>
<li>叶子节点的定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建 HeroNode 结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left; <span class="comment">// 默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">// 默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编写前序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>); <span class="comment">// 先输出父结点</span></span><br><span class="line">        <span class="comment">// 递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 递归向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出父结点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">// 递归向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">// 比较当前结点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">        <span class="comment">// 2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;<span class="comment">// 说明我们左子树找到</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">        <span class="comment">// 2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则继续进行右递归的中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断当前结点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;<span class="comment">// 说明在左子树找到</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果左子树没有找到，则向右子树递归进行后序遍历查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果左右子树都没有找到，就比较当前结点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归删除结点</span></span><br><span class="line">    <span class="comment">// 1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line">    <span class="comment">// 2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 思路</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点. 2.</span></span><br><span class="line"><span class="comment">         * 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除) 3.</span></span><br><span class="line"><span class="comment">         * 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除) 4.</span></span><br><span class="line"><span class="comment">         * 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除 5. 如果第4步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.no == no) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.no == no) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.我们就需要向左子树进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.则应当向右子树进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>二叉树的定义</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义 BinaryTree 二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.preOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.infixOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.root.postOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除结点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果只有一个root结点, 这里立即判断root是不是就是要删除结点</span></span><br><span class="line">            <span class="keyword">if</span> (root.getNo() == no) &#123;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 递归删除</span></span><br><span class="line">                root.delNode(no);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空树，不能删除~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-8、课后练习"><a href="#1-8、课后练习" class="headerlink" title="1.8、课后练习"></a>1.8、课后练习</h3><ul>
<li>如果要删除的节点是非叶子节点， 现在我们不希望将该非叶子节点为根节点的子树删除， 需要指定规则, 假如规定如下:</li>
<li>如果该非叶子节点 A 只有一个子节点 B， 则子节点 B 替代节点 A</li>
<li>如果该非叶子节点 A 有左子节点 B 和右子节点 C， 则让左子节点 B 替代节点 A。</li>
<li>请大家思考， 如何完成该删除功能，后面在讲解二叉排序树时， 在给大家讲解具体的删除方法</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODEyMjIwNTUxNDUwLnBuZw?x-oss-process=image/format,png" alt="image-20200812220551450"></p>
<h2 id="2、顺序存储二叉树"><a href="#2、顺序存储二叉树" class="headerlink" title="2、顺序存储二叉树"></a>2、顺序存储二叉树</h2><h3 id="2-1、顺序存储二叉树的概念"><a href="#2-1、顺序存储二叉树的概念" class="headerlink" title="2.1、顺序存储二叉树的概念"></a>2.1、顺序存储二叉树的概念</h3><h4 id="2-1-1、顺序存储二叉树与数组的转换"><a href="#2-1-1、顺序存储二叉树与数组的转换" class="headerlink" title="2.1.1、顺序存储二叉树与数组的转换"></a>2.1.1、顺序存储二叉树与数组的转换</h4><ul>
<li><p>基本说明：从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可</p>
<p>以转换成树，树也可以转换成数组。</p>
</li>
<li><p>要求：</p>
<ul>
<li>右图的二叉树的结点，要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 6]</li>
<li>要求在遍历数组 arr时，仍然可以用前序遍历，中序遍历和后序遍历的方式完成结点的遍历</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTcyMjQxODU3LnBuZw?x-oss-process=image/format,png" alt="image-20200717172241857"></p>
<h4 id="2-1-2、顺序存储二叉树的特点"><a href="#2-1-2、顺序存储二叉树的特点" class="headerlink" title="2.1.2、顺序存储二叉树的特点"></a>2.1.2、顺序存储二叉树的特点</h4><ul>
<li><p>顺序存储二叉树特点</p>
<ul>
<li>顺序二叉树通常只考虑完全二叉树</li>
<li><strong>顺序存储二叉树中第 n 个元素的左子节点对应的数组下标为 2 * n + 1</strong></li>
<li><strong>顺序存储二叉树中第 n 个元素的右子节点对应的数组下标为 2 * n + 2</strong></li>
<li><strong>顺序存储二叉树中第 n 个元素的父节点对应的数组下标为 (n-1) / 2</strong></li>
<li>n 的含义： 表示二叉树中的第几个元素（按0开始编号，如图所示）</li>
</ul>
</li>
<li><p>下标怎么来的？</p>
<ul>
<li><p>顺序存储二叉树通常只考虑完全二叉树，完全二叉树的节点个数规律为：1, 2, 4, 8, 12 , … 即 2 的 n 次方</p>
</li>
<li><p>每个父节点都会延伸出两个子节点，假设当前节点编号为 n （索引从 0 开始），设当前节点在第 x 层（索引从 1 开始），可得如下数据：</p>
<ul>
<li><p>1~(x-1) 层所拥有的的节点个数：2n-1 -1</p>
</li>
<li><p>1~x 层所拥有的节点个数：2n - 1</p>
</li>
<li><p>在第 x 层，节点 n 后面有多少个节点：</p>
<p>back = 2n - 1 - n - 1 = 2n -n - 2</p>
</li>
<li><p>在第 x 层，节点 n 前面有多少个节点：</p>
<p>front = n - (2n-1 -1) = n - 2n-1 + 1</p>
</li>
<li><p>在第 x+1 层，节点 n 左节点前面有多少个节点：</p>
<p>frontDouble = 2 * (n - 2n-1 + 1) = 2n - 2n + 2</p>
</li>
<li><p>所以节点 n 左节点的索引为：</p>
<p>index = n + back + frontDouble + 1 = n + (2n -n - 2) + (2n - 2n + 2) + 1 = 2*n + 1</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MTgzMTE3NzExLnBuZw?x-oss-process=image/format,png" alt="image-20200717183117711"></p>
<h3 id="2-2、顺序存储二叉树的遍历"><a href="#2-2、顺序存储二叉树的遍历" class="headerlink" title="2.2、顺序存储二叉树的遍历"></a>2.2、顺序存储二叉树的遍历</h3><h4 id="2-2-1、代码思路"><a href="#2-2-1、代码思路" class="headerlink" title="2.2.1、代码思路"></a>2.2.1、代码思路</h4><ul>
<li>和之前链表二叉树一样，之前用 left 指针和 right 指针寻找左右子节点，实现递归，只不过顺序存储二叉树使用数组下标寻找左右子节点</li>
<li>何时结束递归？<strong>当数组下标越界时，说明当前节点已经没有左节点或右节点，已经递归至最深处</strong>，此时就应该停止递归，开始回溯</li>
</ul>
<h4 id="2-2-2、前-中-后序遍历"><a href="#2-2-2、前-中-后序遍历" class="headerlink" title="2.2.2、前 中 后序遍历"></a>2.2.2、前 中 后序遍历</h4><ul>
<li>编写顺序存储二叉树的前序、中序、后序遍历</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写一个ArrayBinaryTree, 实现顺序存储二叉树遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrBinaryTree</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span>[] arr;<span class="comment">// 存储数据结点的数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ArrBinaryTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.arr = arr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载preOrder</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 顺序存储二叉树的前序遍历</span></span><br><span class="line">	<span class="comment">// index ：数组下标</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="comment">// 如果数组为空，或者 arr.length = 0</span></span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;数组为空，不能执行二叉树的前序遍历&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出当前这个元素</span></span><br><span class="line">		System.out.println(arr[index]);</span><br><span class="line">		<span class="comment">// 向左递归遍历</span></span><br><span class="line">		<span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">			preOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 向右递归遍历</span></span><br><span class="line">		<span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">			preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.infixOrder(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 顺序存储二叉树的中序遍历</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="comment">// 如果数组为空，或者 arr.length = 0</span></span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;数组为空，不能执行二叉树的前序遍历&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 向左递归遍历</span></span><br><span class="line">		<span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">			infixOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出当前这个元素</span></span><br><span class="line">		System.out.println(arr[index]);</span><br><span class="line">		<span class="comment">// 向右递归遍历</span></span><br><span class="line">		<span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">			infixOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.postOrder(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 顺序存储二叉树的中序遍历</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">		<span class="comment">// 如果数组为空，或者 arr.length = 0</span></span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="literal">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;数组为空，不能执行二叉树的前序遍历&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 向左递归遍历</span></span><br><span class="line">		<span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">			postOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 向右递归遍历</span></span><br><span class="line">		<span class="keyword">if</span> ((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">			postOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出当前这个元素</span></span><br><span class="line">		System.out.println(arr[index]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-2-3、测试代码"><a href="#2-2-3、测试代码" class="headerlink" title="2.2.3、测试代码"></a>2.2.3、测试代码</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="comment">// 创建一个 ArrBinaryTree</span></span><br><span class="line">    <span class="type">ArrBinaryTree</span> <span class="variable">arrBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrBinaryTree</span>(arr);</span><br><span class="line">    arrBinaryTree.preOrder(); <span class="comment">// 1,2,4,5,3,6,7</span></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    arrBinaryTree.infixOrder(); <span class="comment">// 4,2,5,1,6,3,7</span></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    arrBinaryTree.postOrder(); <span class="comment">// 4,5,2,6,7,3,1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-3、顺序存储二叉树应用实例"><a href="#2-3、顺序存储二叉树应用实例" class="headerlink" title="2.3、顺序存储二叉树应用实例"></a>2.3、顺序存储二叉树应用实例</h3><ul>
<li>八大排序算法中的<strong>堆排序</strong>，就会使用到顺序存储二叉树， 关于堆排序，我们放在【树结构实际应用】章节讲解。</li>
</ul>
<h2 id="3、线索化二叉树"><a href="#3、线索化二叉树" class="headerlink" title="3、线索化二叉树"></a>3、线索化二叉树</h2><h3 id="3-1、引出问题"><a href="#3-1、引出问题" class="headerlink" title="3.1、引出问题"></a>3.1、引出问题</h3><ul>
<li>将数列 {1, 3, 6, 8, 10, 14 } 构建成一颗二叉树，当我们对这颗二叉树进行中序遍历时， 输出数列为 {8, 3, 10, 1, 6, 14 }</li>
<li>但是 6, 8, 10, 14 这几个节点的左右指针，并没有完全的利用上，如果我们希望充分的利用 各个节点的左右指针， 让各个节点可以指向自己的前后节点，怎么办?</li>
<li>解决方案：线索二叉树</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODEyMjIxMDQ1MjMwLnBuZw?x-oss-process=image/format,png" alt="image-20200812221045230"></p>
<h3 id="3-2、线索二叉树基本介绍"><a href="#3-2、线索二叉树基本介绍" class="headerlink" title="3.2、线索二叉树基本介绍"></a>3.2、线索二叉树基本介绍</h3><ul>
<li>n 个结点的二叉链表中含有 n+1 【公式 2n-(n-1)=n+1】 个空指针域。 利用二叉链表中的空指针域， 存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”）</li>
<li>这种加上了线索的二叉链表称为线索链表， 相应的二叉树称为线索二叉树(Threaded BinaryTree)。</li>
<li>根据线索性质的不同， 线索二叉树可分为前序线索二叉树、 中序线索二叉树和后序线索二叉树三种</li>
<li>前驱结点和后继节点：<ul>
<li>一个结点的前一个结点， 称为前驱结点</li>
<li>一个结点的后一个结点， 称为后继结点</li>
</ul>
</li>
<li>当我们对二叉树进行中序遍历时， 得到的数列为 {8, 3, 10, 1, 6, 14 }<ul>
<li>那么 8 节点的前驱结点为 null ，8 和后驱节点为 3</li>
<li>那么 3 节点的前驱结点为 8 ，3 和后驱节点为 10</li>
<li>以此类推…</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MjAyNjQ5MzA2LnBuZw?x-oss-process=image/format,png" alt="image-20200717202649306"></p>
<h3 id="3-3、线索二叉树的生成"><a href="#3-3、线索二叉树的生成" class="headerlink" title="3.3、线索二叉树的生成"></a>3.3、线索二叉树的生成</h3><h4 id="3-3-1、代码思路"><a href="#3-3-1、代码思路" class="headerlink" title="3.3.1、代码思路"></a>3.3.1、代码思路</h4><ul>
<li><p>如何实现线索二叉树？以中序线索化为例，按照上面的步骤操作即可</p>
</li>
<li><p>怎么知道当前节点的前驱结点和后继节点？</p>
<ul>
<li>想想单链表的删除是怎么做的？我们记录当前节点的前一个节点，在程序中使用 pre 指针记录当前正在遍历的节点 curNode ，以及其前驱结点 preNode</li>
<li>如果条件满足，preNode 就是 curNode 的前驱结点：<code>curNode.left = pre;</code></li>
<li>如果条件满足，curNode 节点就是 preNode 的后继节点：<code>pre.right = curNode;</code></li>
</ul>
</li>
<li><p>何时递归完毕？当前递归至最深层，curNode 为空时开始回溯：<code>curNode == null</code></p>
</li>
<li><p>举例说明：</p>
<ul>
<li>我们进行中序遍历时，先执行左递归至最深层</li>
<li>对于图例来说，就是递归到节点 8 左节点，满足 <code>node.left == null</code> ，开始执行回溯</li>
<li>于是我们回到节点8 ，该节点并没有前驱结点，即前驱结点为 null ，恰好此时 pre 也为 null</li>
<li>设置节点 8 的前驱结点：<code>node.left = pre;</code></li>
<li>操作完成后，pre 和 node 指针向后移动一步</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MjA0MzUwNjgyLnBuZw?x-oss-process=image/format,png" alt="image-20200717204350682"></p>
<ul>
<li>回溯到节点 3 ，节点 3 的 pre 节点是节点 8</li>
<li>设置节点 8 的后继节点：<code>pre.right = node;</code></li>
<li>操作完成后，pre 和 node 指针向后移动一步</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MjA0NDM0NTkzLnBuZw?x-oss-process=image/format,png" alt="image-20200717204434593"></p>
<ul>
<li>继续执行右递归，节点 10 的前驱结点为 3</li>
<li>设置节点 10 的前驱结点：<code>node.left = pre;</code></li>
<li>操作完成后，pre 和 node 指针向后移动一步</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MjA1NDQyMDg4LnBuZw?x-oss-process=image/format,png" alt="image-20200717205442088"></p>
<ul>
<li>以此类推，递归至最后，所有线索都已设置完毕</li>
<li>操作完成后，pre 和 node 指针向后移动一步，此时 <code>node == null</code> ，递归完毕，节点 6 的 right 指针的类型为真正的子节点，并非</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MjEwNTAxNjQwLnBuZw?x-oss-process=image/format,png" alt="image-20200717210501640"></p>
</li>
<li><p>大致流程：</p>
<ul>
<li>递归结束条件：<code>node == null</code></li>
<li>执行左递归</li>
<li>设置前驱结点、后继节点，并后移 pre 和 node 指针（pre 指针需手动移动，node 指针其实是通过递归来移动的）</li>
<li>执行右递归</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MjExNjE5Mjc0LnBuZw?x-oss-process=image/format,png" alt="image-20200717211619274"></p>
<ul>
<li>关于线索化之后的二叉树：只有一个右节点的 right 域为 null ，这个右节点是整棵树最深层的右节点，遍历到该右节点时，表示整棵树遍历完成</li>
</ul>
<h4 id="3-3-2、代码实现"><a href="#3-3-2、代码实现" class="headerlink" title="3.3.2、代码实现"></a>3.3.2、代码实现</h4><ul>
<li>由于将原有的指针域（left 和 right 指针）指向了前驱节点和后继节点，所以代码里面需要表示当前指针到底是指向了真正的子节点还是前驱节点或后继节点</li>
<li>leftType 、rightType：0 表示指向真正的子节点，1 表示指向前驱节点或后继节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left; <span class="comment">// 默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">// 默认null</span></span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点</span></span><br><span class="line">    <span class="comment">// 2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>线索二叉树的定义：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义ThreadedBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了实现线索化，需要创建一个指向当前结点的前驱结点的指针</span></span><br><span class="line">	<span class="comment">// 在递归进行线索化时，pre 总是保留前一个结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.root = root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载一把threadedNodes方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodes</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.threadedNodes(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编写对二叉树进行中序线索化的方法</span></span><br><span class="line">	<span class="comment">// node 就是当前需要线索化的结点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodes</span><span class="params">(HeroNode node)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果node==null, 不能线索化</span></span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (一)先线索化左子树</span></span><br><span class="line">		threadedNodes(node.getLeft());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// (二)线索化当前结点[有难度]</span></span><br><span class="line">		<span class="comment">// 处理当前结点的前驱结点</span></span><br><span class="line">		<span class="comment">// 以8结点来理解</span></span><br><span class="line">		<span class="comment">// 8结点的.left = null , 8结点的.leftType = 1</span></span><br><span class="line">		<span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 让当前结点的左指针指向前驱结点</span></span><br><span class="line">			node.setLeft(pre);</span><br><span class="line">			<span class="comment">// 修改当前结点的左指针的类型,指向前驱结点</span></span><br><span class="line">			node.setLeftType(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理后继结点</span></span><br><span class="line">		<span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 让前驱结点的右指针指向当前结点</span></span><br><span class="line">			pre.setRight(node);</span><br><span class="line">			<span class="comment">// 修改前驱结点的右指针类型</span></span><br><span class="line">			pre.setRightType(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// !!! 每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">		pre = node;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (三)在线索化右子树</span></span><br><span class="line">		threadedNodes(node.getRight());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-3-3、测试代码"><a href="#3-3-3、测试代码" class="headerlink" title="3.3.3、测试代码"></a>3.3.3、测试代码</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试一把中序线索二叉树的功能</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;smith&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">8</span>, <span class="string">&quot;mary&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">10</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">14</span>, <span class="string">&quot;dim&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树，后面我们要递归创建, 现在简单处理使用手动创建</span></span><br><span class="line">    root.setLeft(node2);</span><br><span class="line">    root.setRight(node3);</span><br><span class="line">    node2.setLeft(node4);</span><br><span class="line">    node2.setRight(node5);</span><br><span class="line">    node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试中序线索化</span></span><br><span class="line">    <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line">    threadedBinaryTree.setRoot(root);</span><br><span class="line">    threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试: 以10号节点测试</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> node5.getLeft();</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> node5.getRight();</span><br><span class="line">    System.out.println(<span class="string">&quot;10号结点的前驱结点是 =&quot;</span> + leftNode); <span class="comment">// 3</span></span><br><span class="line">    System.out.println(<span class="string">&quot;10号结点的后继结点是=&quot;</span> + rightNode); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">10号结点的前驱结点是 =HeroNode [no=3, name=jack]</span><br><span class="line">10号结点的后继结点是=HeroNode [no=1, name=tom]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4、线索二叉树的遍历"><a href="#3-4、线索二叉树的遍历" class="headerlink" title="3.4、线索二叉树的遍历"></a>3.4、线索二叉树的遍历</h3><h4 id="3-4-1、代码思路"><a href="#3-4-1、代码思路" class="headerlink" title="3.4.1、代码思路"></a>3.4.1、代码思路</h4><ul>
<li><p>为什么我们要做线索化？</p>
<ul>
<li>因为线索化后， 各个结点指向有变化， 因此原来的遍历方式不能使用， 这时需要使用新的方式遍历线索化二叉树， 各个节点可以通过线性方式遍历， 因此无需使用递归方式， 这样也提高了遍历的效率。 遍历的次序应当和中序遍历保持一致。</li>
<li>以中序遍历为例，线索化可以让每个<strong>具有前驱结点的左节点</strong>的 <strong>right 指针</strong>都能指向其下一个要遍历的节点（后继节点）</li>
<li>我们先找到第一个具有前驱结点的左节点（整棵树最深层的左叶子节点），我们沿着该左叶子节点的后继节点遍历，可以中序遍历的结果</li>
<li>如果遍历到的节点没有后继节点，那么说明该节点 left 和 right<br>都有节点，直接输出其右节点，并以该右节点根节点，继续执行上一步操作，往最深处寻找第一个具有前驱结点的左节点（当前步骤最深层的左叶子节点），我们继续沿着左叶子节点的后继节点遍历</li>
<li>如此往复，直到最后得到的右节点为 null，上面有讲过，线索二叉树有且只有一个为 null 的 right 指针，该值为 null 时代表整棵树的结束</li>
</ul>
</li>
<li><p>举例说明：</p>
<ul>
<li>因为执行的中序遍历：左 –&gt; 中 –&gt; 后，先执行深度搜索，找到第一个有前驱结点的节点，第一次搜索找到节点 8 ，其前驱结点为 null ，从节点 8 的后继节点为节点 3</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MjE1NjE5Nzg0LnBuZw?x-oss-process=image/format,png" alt="image-20200717215619784"></p>
<ul>
<li>节点 3 并没有后继节点，只有右节点 10 ，我们拿到节点 10</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MjE1NzEyMTA5LnBuZw?x-oss-process=image/format,png" alt="image-20200717215712109"></p>
<ul>
<li>寻找节点 10 下第一个具有前驱结点的节点，恰好就是它本身，然后寻找其后继节点</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MjIwMjU1OTQwLnBuZw?x-oss-process=image/format,png" alt="image-20200717220255940"></p>
<ul>
<li>以此类推…</li>
</ul>
</li>
<li><p>大致思路：</p>
<ul>
<li>寻找最深层的具有前驱结点的左节点</li>
<li>沿着左节点遍历其后继节点</li>
<li>如果没有后继节点，则直接输出其右节点，并以该右节点根节点，继续寻找最深层的具有前驱结点的左节点</li>
<li>如此往复，直到最后得到的右节点值为 null</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE3MjIzNTI2MDUwLnBuZw?x-oss-process=image/format,png" alt="image-20200717223526050"></p>
<h4 id="3-4-2、代码实现"><a href="#3-4-2、代码实现" class="headerlink" title="3.4.2、代码实现"></a>3.4.2、代码实现</h4><ul>
<li>HeroNode 节点的定义与之前一样</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left; <span class="comment">// 默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">// 默认null</span></span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点</span></span><br><span class="line">    <span class="comment">// 2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>在 ThreadedBinaryTree 类中添加遍历方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义ThreadedBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了实现线索化，需要创建一个指向当前结点的前驱结点的指针</span></span><br><span class="line">	<span class="comment">// 在递归进行线索化时，pre 总是保留前一个结点</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.root = root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载一把threadedNodes方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodes</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.threadedNodes(root);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编写对二叉树进行中序线索化的方法</span></span><br><span class="line">	<span class="comment">// node 就是当前需要线索化的结点</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodes</span><span class="params">(HeroNode node)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果node==null, 不能线索化</span></span><br><span class="line">		<span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (一)先线索化左子树</span></span><br><span class="line">		threadedNodes(node.getLeft());</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// (二)线索化当前结点[有难度]</span></span><br><span class="line">		<span class="comment">// 处理当前结点的前驱结点</span></span><br><span class="line">		<span class="comment">// 以8结点来理解</span></span><br><span class="line">		<span class="comment">// 8结点的.left = null , 8结点的.leftType = 1</span></span><br><span class="line">		<span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 让当前结点的左指针指向前驱结点</span></span><br><span class="line">			node.setLeft(pre);</span><br><span class="line">			<span class="comment">// 修改当前结点的左指针的类型,指向前驱结点</span></span><br><span class="line">			node.setLeftType(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理后继结点</span></span><br><span class="line">		<span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 让前驱结点的右指针指向当前结点</span></span><br><span class="line">			pre.setRight(node);</span><br><span class="line">			<span class="comment">// 修改前驱结点的右指针类型</span></span><br><span class="line">			pre.setRightType(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// !!! 每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">		pre = node;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (三)在线索化右子树</span></span><br><span class="line">		threadedNodes(node.getRight());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 遍历线索化二叉树的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedList</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// 定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line">		<span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">		<span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 循环的找到leftType == 1的结点，第一个找到就是8结点</span></span><br><span class="line">			<span class="comment">// 后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化处理后的有效结点</span></span><br><span class="line">			<span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">				node = node.getLeft();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 打印当前这个结点</span></span><br><span class="line">			System.out.println(node);</span><br><span class="line">			<span class="comment">// 如果当前结点的右指针指向的是后继结点,就一直输出</span></span><br><span class="line">			<span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">// 获取到当前结点的后继结点</span></span><br><span class="line">				node = node.getRight();</span><br><span class="line">				System.out.println(node);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 替换这个遍历的结点</span></span><br><span class="line">			node = node.getRight();</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-4-3、测试代码"><a href="#3-4-3、测试代码" class="headerlink" title="3.4.3、测试代码"></a>3.4.3、测试代码</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试一把中序线索二叉树的功能</span></span><br><span class="line">    HeroNode root=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    HeroNode node2=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    HeroNode node3=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>,<span class="string">&quot;smith&quot;</span>);</span><br><span class="line">    HeroNode node4=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">8</span>,<span class="string">&quot;mary&quot;</span>);</span><br><span class="line">    HeroNode node5=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">10</span>,<span class="string">&quot;king&quot;</span>);</span><br><span class="line">    HeroNode node6=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">14</span>,<span class="string">&quot;dim&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树，后面我们要递归创建, 现在简单处理使用手动创建</span></span><br><span class="line">    root.setLeft(node2);</span><br><span class="line">    root.setRight(node3);</span><br><span class="line">    node2.setLeft(node4);</span><br><span class="line">    node2.setRight(node5);</span><br><span class="line">    node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试中序线索化</span></span><br><span class="line">    ThreadedBinaryTree threadedBinaryTree=<span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line">    threadedBinaryTree.setRoot(root);</span><br><span class="line">    threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试: 以10号节点测试</span></span><br><span class="line">    HeroNode leftNode=node5.getLeft();</span><br><span class="line">    HeroNode rightNode=node5.getRight();</span><br><span class="line">    System.out.println(<span class="string">&quot;10号结点的前驱结点是 =&quot;</span>+leftNode); <span class="comment">// 3</span></span><br><span class="line">    System.out.println(<span class="string">&quot;10号结点的后继结点是=&quot;</span>+rightNode); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当线索化二叉树后，不能再使用原来的遍历方法</span></span><br><span class="line">    System.out.println(<span class="string">&quot;使用线索化的方式遍历 线索化二叉树&quot;</span>);</span><br><span class="line">    threadedBinaryTree.threadedList(); <span class="comment">// 8, 3, 10, 1, 14, 6</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">使用线索化的方式遍历 线索化二叉树</span><br><span class="line">HeroNode [no=8, name=mary]</span><br><span class="line">HeroNode [no=3, name=jack]</span><br><span class="line">HeroNode [no=10, name=king]</span><br><span class="line">HeroNode [no=1, name=tom]</span><br><span class="line">HeroNode [no=14, name=dim]</span><br><span class="line">HeroNode [no=6, name=smith]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-4-4、课后作业"><a href="#3-4-4、课后作业" class="headerlink" title="3.4.4、课后作业"></a>3.4.4、课后作业</h4><ul>
<li>这里讲解了中序线索化二叉树，前序线索化二叉树和后序线索化二叉树的分析思路类似， 同学们作为课后作业完成</li>
</ul>
<h3 id="3-5、线索二叉树全部代码"><a href="#3-5、线索二叉树全部代码" class="headerlink" title="3.5、线索二叉树全部代码"></a>3.5、线索二叉树全部代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.tree.threadedbinarytree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线索化二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadedBinaryTreeDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//测试一把中序线索二叉树的功能</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;smith&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">8</span>, <span class="string">&quot;mary&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">10</span>, <span class="string">&quot;king&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">14</span>, <span class="string">&quot;dim&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二叉树，后面我们要递归创建, 现在简单处理使用手动创建</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试中序线索化</span></span><br><span class="line">        <span class="type">ThreadedBinaryTree</span> <span class="variable">threadedBinaryTree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadedBinaryTree</span>();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        <span class="comment">// 中序线索化</span></span><br><span class="line"><span class="comment">//        threadedBinaryTree.turnToIn();</span></span><br><span class="line">        <span class="comment">// 前序线索化</span></span><br><span class="line">        threadedBinaryTree.turnToPre();</span><br><span class="line">        <span class="comment">// 后序线索化</span></span><br><span class="line"><span class="comment">//        threadedBinaryTree.threadedNodesPost();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试: 以10号节点测试</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> node5.getLeft();</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> node5.getRight();</span><br><span class="line">        System.out.println(<span class="string">&quot;10号结点的前驱结点是 =&quot;</span> + leftNode); <span class="comment">//3</span></span><br><span class="line">        System.out.println(<span class="string">&quot;10号结点的后继结点是=&quot;</span> + rightNode); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当线索化二叉树后，不能再使用原来的遍历方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;使用线索化的方式遍历 线索化二叉树&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历中序线索化二叉树</span></span><br><span class="line"><span class="comment">//        threadedBinaryTree.inOrderThreaded(); // 8, 3, 10, 1, 14, 6</span></span><br><span class="line">        <span class="comment">// 遍历前序线索化二叉树</span></span><br><span class="line"><span class="comment">//        threadedBinaryTree.threadedListPre(); // 1,3,8,10,6,14,</span></span><br><span class="line">        <span class="comment">// 遍历后续线索化二叉树</span></span><br><span class="line">        threadedBinaryTree.preOrderThreaded(); <span class="comment">// 8,10,3,14,6,1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义ThreadedBinaryTree 实现了线索化功能的二叉树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadedBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了实现线索化，需要创建指针,指向当前结点的前驱结点。</span></span><br><span class="line">    <span class="comment">// 在递归进行线索化时，pre 总是等于便利过程中的前一个结点。</span></span><br><span class="line">    <span class="comment">// 比如 中序遍历，左中右，得到中节点的时候，前面那个左节点怎么拿到呢，所以需要pre提前存一下</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoot</span><span class="params">(HeroNode root)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ============================ 前序 ======================================</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 前序线索化二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnToPre</span><span class="params">()</span> &#123;</span><br><span class="line">        turnToPre(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序线索化二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnToPre</span><span class="params">(HeroNode node)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果node==null, 不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线索化当前结点[有难度]</span></span><br><span class="line">        <span class="comment">//处理当前结点的前驱结点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让当前结点的左指针指向前驱结点</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">//修改当前结点的左指针的类型,前驱结点</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理后继结点,处理后继结点的时候需要等到下一个node的时候在处理，</span></span><br><span class="line">        <span class="comment">// 因为下一个node 的时候，pre指向了前一个node，</span></span><br><span class="line">        <span class="comment">// 这里`前一个`指的是按照中序查找时候当前node的前面那个node，</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让前驱结点的右指针指向当前结点</span></span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            <span class="comment">//修改前驱结点的右指针类型</span></span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">        <span class="comment">// 提前存储父节点，以便下一个子节点找到他的父节点</span></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            turnToPre(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRightType() == <span class="number">0</span>) &#123;</span><br><span class="line">            turnToPre(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历 前序线索化二叉树的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderThreaded</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//如果存在左子节点就往左走，否则往右走，此时右指针一定是前序遍历的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span> (temp.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                temp = temp.getLeft();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp.getRight();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历 前序线索化二叉树的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderThreaded2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(node);</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">//替换这个遍历的结点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ============================ 中序 ======================================</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 中序线索化二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnToIn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.turnToIn(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turnToIn</span><span class="params">(HeroNode node)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果node==null, 不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 中序线索化 左=&gt;中=&gt;右</span></span><br><span class="line">        <span class="comment">//(一)先线索化左子树</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            turnToIn(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//(二)线索化当前结点[有难度]</span></span><br><span class="line">        <span class="comment">//处理当前结点的前驱结点</span></span><br><span class="line">        <span class="comment">//以8结点来理解</span></span><br><span class="line">        <span class="comment">//8结点的.left = null , 8结点的.leftType = 1</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让当前结点的左指针指向前驱结点</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">//修改当前结点的左指针的类型,前驱结点</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理后继结点,处理后继结点的时候需要等到下一个node的时候在处理，</span></span><br><span class="line">        <span class="comment">// 因为下一个node 的时候，pre指向了前一个node，</span></span><br><span class="line">        <span class="comment">// 这里`前一个`指的是按照中序查找时候当前node的前面那个node，</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让前驱结点的右指针指向当前结点</span></span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            <span class="comment">//修改前驱结点的右指针类型</span></span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">        <span class="comment">// 提前存储父节点，以便下一个子节点找到他的父节点</span></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(三)在线索化右子树</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRightType() == <span class="number">0</span>) &#123;</span><br><span class="line">            turnToIn(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历 中序线索化二叉树的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderThreaded</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//循环的找到leftType == 1的结点，第一个找到就是8结点</span></span><br><span class="line">            <span class="comment">//后面随着遍历而变化,因为当leftType==1时，说明该结点是按照线索化</span></span><br><span class="line">            <span class="comment">//处理后的有效结点</span></span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打印当前这个结点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果当前结点的右指针指向的是后继结点,就一直输出</span></span><br><span class="line">            <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//获取到当前结点的后继结点</span></span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换这个遍历的结点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历线索二叉树算法二</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inOrderThreaded2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                temp = temp.getLeft();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">                <span class="comment">//如果temp的右指针是线索指针，则需要先走一步，否则会陷入死循环</span></span><br><span class="line">                <span class="keyword">if</span> (temp.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                    temp = temp.getRight();</span><br><span class="line">                    System.out.println(temp);</span><br><span class="line">                &#125;</span><br><span class="line">                temp = temp.getRight();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ============================ 后序 ======================================</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 后序线索化二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodesPost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.threadedNodesPost(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序线索化二叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">threadedNodesPost</span><span class="params">(HeroNode node)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果node==null, 不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNodesPost(node.getLeft());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span> (node.getRightType() == <span class="number">0</span>) &#123;</span><br><span class="line">            threadedNodesPost(node.getRight());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理当前结点的前驱结点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让当前结点的左指针指向前驱结点</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">//修改当前结点的左指针的类型,前驱结点</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理后继结点,处理后继结点的时候需要等到下一个node的时候在处理，</span></span><br><span class="line">        <span class="comment">// 因为下一个node 的时候，pre指向了前一个node，</span></span><br><span class="line">        <span class="comment">// 这里`前一个`指的是按照中序查找时候当前node的前面那个node，</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.getRight() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让前驱结点的右指针指向当前结点</span></span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            <span class="comment">//修改前驱结点的右指针类型</span></span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//!!! 每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">        <span class="comment">// 提前存储父节点，以便下一个子节点找到他的父节点</span></span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历 后序线索化的二叉树时需要改造HeroNode 添加一个parent节点，作为父节点，这里就不做了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先创建HeroNode 结点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left; <span class="comment">//默认null</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right; <span class="comment">//默认null</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1. 如果leftType == 0 表示指向的是左子树, 如果 1 则表示指向前驱结点</span></span><br><span class="line">    <span class="comment">//2. 如果rightType == 0 表示指向是右子树, 如果 1表示指向后继结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> rightType;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLeftType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftType</span><span class="params">(<span class="type">int</span> leftType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRightType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightType</span><span class="params">(<span class="type">int</span> rightType)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getLeft</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeft</span><span class="params">(HeroNode left)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getRight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRight</span><span class="params">(HeroNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归删除结点</span></span><br><span class="line">    <span class="comment">//1.如果删除的节点是叶子节点，则删除该节点</span></span><br><span class="line">    <span class="comment">//2.如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delNode</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 	1. 因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结点.</span></span><br><span class="line"><span class="comment">			2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">			3. 如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line"><span class="comment">			4. 如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">			5.  如果第4步也没有删除结点，则应当向右子树进行递归删除.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">//2. 如果当前结点的左子结点不为空，并且左子结点 就是要删除结点，就将this.left = null; 并且就返回(结束递归删除)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.left.no == no) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.如果当前结点的右子结点不为空，并且右子结点 就是要删除结点，就将this.right= null ;并且就返回(结束递归删除)</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.right.no == no) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.我们就需要向左子树进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.则应当向右子树进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写前序遍历的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>); <span class="comment">//先输出父结点</span></span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">infixOrder</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归向左子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出父结点</span></span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历查找</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找no</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回该Node ,如果没有找到返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">preOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入前序遍历&quot;</span>);</span><br><span class="line">        <span class="comment">//比较当前结点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">        <span class="comment">//2.如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;<span class="comment">//说明我们左子树找到</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">        <span class="comment">//2.当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">infixOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入中序查找&quot;</span>);</span><br><span class="line">        <span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则继续进行右递归的中序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历查找</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">postOrderSearch</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归后序查找</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">resNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;<span class="comment">//说明在左子树找到</span></span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果左子树没有找到，则向右子树递归进行后序遍历查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            resNode = <span class="built_in">this</span>.right.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入后序查找&quot;</span>);</span><br><span class="line">        <span class="comment">//如果左右子树都没有找到，就比较当前结点是不是</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第 4 章 链表</title>
    <url>/posts/465bfaa4e528/</url>
    <content><![CDATA[<h1 id="第-4-章-链表"><a href="#第-4-章-链表" class="headerlink" title="第 4 章 链表"></a>第 4 章 链表</h1><h2 id="1、链表-Linked-List-介绍"><a href="#1、链表-Linked-List-介绍" class="headerlink" title="1、链表(Linked List)介绍"></a>1、链表(Linked List)介绍</h2><h3 id="1-1、内存结构"><a href="#1-1、内存结构" class="headerlink" title="1.1、内存结构"></a>1.1、内存结构</h3><ul>
<li><p>内存上来看：链表存储空间<strong>不连续</strong>（不像数组）</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325151715.png" alt="image-20210218212002331"></p>
</li>
</ul>
<h3 id="1-2、逻辑结构"><a href="#1-2、逻辑结构" class="headerlink" title="1.2、逻辑结构"></a>1.2、逻辑结构</h3><ul>
<li>逻辑上来看：链表属于<strong>线性</strong>结构</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325151720.png" alt="image-20210218212045041"></p>
<h3 id="1-3、链表特点"><a href="#1-3、链表特点" class="headerlink" title="1.3、链表特点"></a>1.3、链表特点</h3><ul>
<li>链表是以节点的方式来存储，是<strong>链式存储</strong></li>
<li>data 域存放数据，next 域<strong>指向下一个节点</strong></li>
<li>链表分<strong>带头节点</strong>的链表和<strong>没有头节点</strong>的链表， 根据实际的需求来确定</li>
</ul>
<h2 id="2、链表应用场景"><a href="#2、链表应用场景" class="headerlink" title="2、链表应用场景"></a>2、链表应用场景</h2><h3 id="2-1、水浒英雄榜"><a href="#2-1、水浒英雄榜" class="headerlink" title="2.1、水浒英雄榜"></a>2.1、水浒英雄榜</h3><ul>
<li>使用带 head 头的<strong>单向链表</strong>实现【水浒英雄排行榜管理】</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzEzMTkyOTUxNTg2LnBuZw?x-oss-process=image/format,png" alt="image-20200713192951586"></p>
<h3 id="2-2、链表节点定义"><a href="#2-2、链表节点定义" class="headerlink" title="2.2、链表节点定义"></a>2.2、链表节点定义</h3><ul>
<li>no ：英雄编号</li>
<li>name ：英雄名字</li>
<li>nickName ：英雄昵称</li>
<li>next ：指向下一个 HeroNode 节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义HeroNode ， 每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickName;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了显示方法，我们重新toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickName=&quot;</span> + nickName + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-3、链表定义"><a href="#2-3、链表定义" class="headerlink" title="2.3、链表定义"></a>2.3、链表定义</h3><ul>
<li>DummyHead ：<strong>头结点不存放数据</strong>，仅仅作为当前链表的入口</li>
<li>head 字段的值不能改变，一旦改变，就<strong>丢失了整个链表的入口</strong>，我们也就无法通过 head 找到链表了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义SingleLinkedList 管理我们的英雄</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回头节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-4、遍历链表"><a href="#2-4、遍历链表" class="headerlink" title="2.4、遍历链表"></a>2.4、遍历链表</h3><h4 id="2-4-1、代码思路"><a href="#2-4-1、代码思路" class="headerlink" title="2.4.1、代码思路"></a>2.4.1、代码思路</h4><ul>
<li>定义辅助变量 temp ，相当于一个指针，指向<strong>当前节点</strong></li>
<li>何时遍历完成？<strong>temp == null</strong> 表明当前节点为 null ，即表示已到链表末尾</li>
<li>如何遍历？<strong>temp = temp.next</strong> ，每次输出当前节点信息之后，temp 指针后移</li>
</ul>
<h4 id="2-4-2、代码实现"><a href="#2-4-2、代码实现" class="headerlink" title="2.4.2、代码实现"></a>2.4.2、代码实现</h4><ul>
<li>遍历链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显示链表[遍历]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">    HeroNode temp=head.next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断是否到链表最后</span></span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出节点的信息</span></span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        <span class="comment">// 将temp后移， 一定小心</span></span><br><span class="line">        temp=temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-5、尾部插入"><a href="#2-5、尾部插入" class="headerlink" title="2.5、尾部插入"></a>2.5、尾部插入</h3><h4 id="2-5-1、代码思路"><a href="#2-5-1、代码思路" class="headerlink" title="2.5.1、代码思路"></a>2.5.1、代码思路</h4><ul>
<li>定义辅助变量 temp ，相当于一个指针，指向<strong>当前节点</strong></li>
<li>如何在链表末尾插入节点？<ul>
<li>首先需要遍历链表，找到链表最后一个节点，当 <strong>temp.next == null</strong>时，temp 节点指向链表最后一个节点</li>
<li>然后在 temp 节点之后插入节点即可：<strong>temp.next = heroNode</strong></li>
</ul>
</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325151746.png" alt="image-20210218212101295"></p>
<h4 id="2-5-2、代码实现"><a href="#2-5-2、代码实现" class="headerlink" title="2.5.2、代码实现"></a>2.5.2、代码实现</h4><ul>
<li>在链表尾部插入节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加节点到单向链表</span></span><br><span class="line"><span class="comment">// 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">// 1. 找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">// 2. 将最后这个节点的next 指向 新的节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">    HeroNode temp=head;</span><br><span class="line">    <span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 找到链表的最后</span></span><br><span class="line">        <span class="keyword">if</span>(temp.next==<span class="literal">null</span>)&#123;<span class="comment">//</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到最后, 将将temp后移</span></span><br><span class="line">        temp=temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">    <span class="comment">// 将最后这个节点的next 指向 新的节点</span></span><br><span class="line">    temp.next=heroNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="comment">// 进行测试</span></span><br><span class="line">    <span class="comment">// 先创建节点</span></span><br><span class="line">    HeroNode hero1=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">    HeroNode hero2=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">    HeroNode hero3=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">    HeroNode hero4=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建要给链表</span></span><br><span class="line">    SingleLinkedList singleLinkedList=<span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line">    <span class="comment">// 加入</span></span><br><span class="line">    singleLinkedList.add(hero1);</span><br><span class="line">    singleLinkedList.add(hero2);</span><br><span class="line">    singleLinkedList.add(hero3);</span><br><span class="line">    singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">    singleLinkedList.list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HeroNode [no=1, name=宋江, nickName=及时雨]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickName=玉麒麟]</span><br><span class="line">HeroNode [no=3, name=吴用, nickName=智多星]</span><br><span class="line">HeroNode [no=4, name=林冲, nickName=豹子头]</span><br></pre></td></tr></table></figure>

<h3 id="2-6、按顺序插入"><a href="#2-6、按顺序插入" class="headerlink" title="2.6、按顺序插入"></a>2.6、按顺序插入</h3><h4 id="2-6-1、代码思路"><a href="#2-6-1、代码思路" class="headerlink" title="2.6.1、代码思路"></a>2.6.1、代码思路</h4><ul>
<li>定义辅助变量 temp ，相当于一个指针，指向<strong>当前节点</strong></li>
<li>应该如何执行插入？（待插入节点为 heroNode）<ul>
<li>首先需要遍历链表，找到链表中编号值比 heroNode.no 大的节点，暂且叫它 biggerNode ，然后把 heroNode 插入到 biggerNode 之前即可</li>
<li>怎么找 biggerNode ？当 <strong>temp.next.no &gt; heroNode.no</strong> 时，这时 temp.next 节点就是 biggerNode 节点。</li>
<li>为什么是 temp.next 节点？只有找到 temp 节点和 temp.next（biggerNode ）节点，才能在 temp 节点和 temp.next 节点之间插入 heroNode 节点</li>
<li>怎么插入？<ul>
<li>heroNode .next = temp.next;</li>
<li>temp.next = heroNode;</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325151755.png" alt="image-20210218212203682"></p>
<h4 id="2-6-2、代码实现"><a href="#2-6-2、代码实现" class="headerlink" title="2.6.2、代码实现"></a>2.6.2、代码实现</h4><ul>
<li>按照英雄排名的顺序进行插入</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">// (如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span>&#123;</span><br><span class="line">    <span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line">    <span class="comment">// 因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span></span><br><span class="line">    HeroNode temp=head;</span><br><span class="line">    <span class="type">boolean</span> flag=<span class="literal">false</span>; <span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.next==<span class="literal">null</span>)&#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line">        	<span class="keyword">break</span>; <span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.next.no&gt;heroNode.no)&#123; <span class="comment">// 位置找到，就在temp的后面插入</span></span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no==heroNode.no)&#123;<span class="comment">// 说明希望添加的heroNode的编号已然存在</span></span><br><span class="line"></span><br><span class="line">            flag=<span class="literal">true</span>; <span class="comment">// 说明编号存在</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	temp=temp.next; <span class="comment">// 后移，遍历当前链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断flag 的值</span></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123; <span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">    	System.out.printf(<span class="string">&quot;准备插入的英雄的编号 %d 已经存在了, 不能加入\n&quot;</span>,heroNode.no);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 插入到链表中, temp的后面</span></span><br><span class="line">        heroNode.next=temp.next;</span><br><span class="line">        temp.next=heroNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">       <span class="comment">// 进行测试</span></span><br><span class="line">       <span class="comment">// 先创建节点</span></span><br><span class="line">       HeroNode hero1=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">       HeroNode hero2=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">       HeroNode hero3=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">       HeroNode hero4=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建要给链表</span></span><br><span class="line">       SingleLinkedList singleLinkedList=<span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 加入按照编号的顺序</span></span><br><span class="line">       singleLinkedList.addByOrder(hero1);</span><br><span class="line">       singleLinkedList.addByOrder(hero4);</span><br><span class="line">       singleLinkedList.addByOrder(hero2);</span><br><span class="line">       singleLinkedList.addByOrder(hero3);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 显示一把</span></span><br><span class="line">       singleLinkedList.list();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HeroNode [no=1, name=宋江, nickName=及时雨]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickName=玉麒麟]</span><br><span class="line">HeroNode [no=3, name=吴用, nickName=智多星]</span><br><span class="line">HeroNode [no=4, name=林冲, nickName=豹子头]</span><br></pre></td></tr></table></figure>

<h3 id="2-7、修改节点信息"><a href="#2-7、修改节点信息" class="headerlink" title="2.7、修改节点信息"></a>2.7、修改节点信息</h3><h4 id="2-7-1、代码思路"><a href="#2-7-1、代码思路" class="headerlink" title="2.7.1、代码思路"></a>2.7.1、代码思路</h4><ul>
<li>定义辅助变量 temp ，相当于一个指针，指向<strong>当前节点</strong></li>
<li>如何找到指定节点？<strong>temp.no = newHeroNode.no</strong></li>
</ul>
<h4 id="2-7-2、代码实现"><a href="#2-7-2、代码实现" class="headerlink" title="2.7.2、代码实现"></a>2.7.2、代码实现</h4><ul>
<li>修改指定节点信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改节点的信息, 根据no编号来修改，即no编号不能改.</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1. 根据 newHeroNode 的 no 来修改即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否空</span></span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;链表为空~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到需要修改的节点, 根据no编号</span></span><br><span class="line">    <span class="comment">// 定义一个辅助变量</span></span><br><span class="line">    HeroNode temp=head.next;</span><br><span class="line">    <span class="type">boolean</span> flag=<span class="literal">false</span>; <span class="comment">// 表示是否找到该节点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="literal">null</span>)&#123;</span><br><span class="line">        	<span class="keyword">break</span>; <span class="comment">// 已经遍历完链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">if</span>(temp.no==newHeroNode.no)&#123;</span><br><span class="line">            <span class="comment">// 找到</span></span><br><span class="line">            flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    	temp=temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据flag 判断是否找到要修改的节点</span></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        temp.name=newHeroNode.name;</span><br><span class="line">        temp.nickName=newHeroNode.nickName;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 没有找到</span></span><br><span class="line">    	System.out.printf(<span class="string">&quot;没有找到 编号 %d 的节点，不能修改\n&quot;</span>,newHeroNode.no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">       <span class="comment">// 进行测试</span></span><br><span class="line">       <span class="comment">// 先创建节点</span></span><br><span class="line">       HeroNode hero1=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">       HeroNode hero2=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">       HeroNode hero3=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">       HeroNode hero4=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 创建要给链表</span></span><br><span class="line">       SingleLinkedList singleLinkedList=<span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 加入按照编号的顺序</span></span><br><span class="line">       singleLinkedList.addByOrder(hero1);</span><br><span class="line">       singleLinkedList.addByOrder(hero4);</span><br><span class="line">       singleLinkedList.addByOrder(hero2);</span><br><span class="line">       singleLinkedList.addByOrder(hero3);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 测试修改节点的代码</span></span><br><span class="line">       HeroNode newHeroNode=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;小卢&quot;</span>,<span class="string">&quot;玉麒麟~~&quot;</span>);</span><br><span class="line">       singleLinkedList.update(newHeroNode);</span><br><span class="line"></span><br><span class="line">       singleLinkedList.list();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HeroNode [no=1, name=宋江, nickName=及时雨]</span><br><span class="line">HeroNode [no=2, name=小卢, nickName=玉麒麟~~]</span><br><span class="line">HeroNode [no=3, name=吴用, nickName=智多星]</span><br><span class="line">HeroNode [no=4, name=林冲, nickName=豹子头]</span><br></pre></td></tr></table></figure>

<h3 id="2-8、删除节点"><a href="#2-8、删除节点" class="headerlink" title="2.8、删除节点"></a>2.8、删除节点</h3><h4 id="2-8-1、代码思路"><a href="#2-8-1、代码思路" class="headerlink" title="2.8.1、代码思路"></a>2.8.1、代码思路</h4><ul>
<li>定义辅助变量 temp ，相当于一个指针，指向<strong>当前节点</strong></li>
<li>如何找到待删除的节点？遍历链表，当 <strong>temp.next == no</strong> 时，temp.next 节点就是待删除的节点</li>
<li>如何删除？<strong>temp = temp.next.next</strong> 即可删除 temp.next 节点，该节点没有引用指向它，会被垃圾回收机制回收</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325151804.png" alt="image-20210218212401882"></p>
<h4 id="2-8-2、代码实现"><a href="#2-8-2、代码实现" class="headerlink" title="2.8.2、代码实现"></a>2.8.2、代码实现</h4><ul>
<li>删除指定节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line"><span class="comment">// 2. 说明我们在比较时，是temp.next.no 和 需要删除的节点的no比较</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line">    HeroNode temp=head;</span><br><span class="line">    <span class="type">boolean</span> flag=<span class="literal">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.next==<span class="literal">null</span>)&#123; <span class="comment">// 已经到链表的最后</span></span><br><span class="line">        	<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.next.no==no)&#123;</span><br><span class="line">            <span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">            flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	temp=temp.next; <span class="comment">// temp后移，遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断flag</span></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123; <span class="comment">// 找到</span></span><br><span class="line">        <span class="comment">// 可以删除</span></span><br><span class="line">        temp.next=temp.next.next;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	System.out.printf(<span class="string">&quot;要删除的 %d 节点不存在\n&quot;</span>,no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 进行测试</span></span><br><span class="line">    <span class="comment">// 先创建节点</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建要给链表</span></span><br><span class="line">    <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入</span></span><br><span class="line">    singleLinkedList.add(hero1);</span><br><span class="line">    singleLinkedList.add(hero2);</span><br><span class="line">    singleLinkedList.add(hero3);</span><br><span class="line">    singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line">    singleLinkedList.del(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    singleLinkedList.list();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HeroNode [no=2, name=卢俊义, nickName=玉麒麟]</span><br><span class="line">HeroNode [no=3, name=吴用, nickName=智多星]</span><br></pre></td></tr></table></figure>

<h3 id="2-9、总结"><a href="#2-9、总结" class="headerlink" title="2.9、总结"></a>2.9、总结</h3><ul>
<li>遍历链表，执行操作时，判断条件有时候是 temp ，有时候是 temp.next ，Why？<ul>
<li>对于插入、删除节点来说，需要知道<strong>当前待操作的节点（heroNode）前一个节点的地址（指针）</strong>，如果直接定位至当前待操作的节点 heroNode ，那没得玩。。。因为不知道heroNode<br>前一个节点的地址，无法进行插入、删除操作，所以 while 循环中的条件使用 temp.next 进行判断</li>
<li>对于更新、遍历操作来说，我需要的仅仅就只是当前节点的信息，所以 while 循环中的条件使用 temp进行判断</li>
</ul>
</li>
<li>头结点与首节点<ul>
<li>参考资料：<a href="https://blog.csdn.net/WYpersist/article/details/80288056">https://blog.csdn.net/WYpersist/article/details/80288056</a></li>
<li>头结点是为了操作的统一与方便而设立的，放在第一个元素结点之前，其数据域一般无意义（当然有些情况下也可存放链表的长度、用做监视哨等等）。</li>
<li>首元结点也就是第一个元素的结点，它是头结点后边的第一个结点。</li>
</ul>
</li>
</ul>
<h2 id="3、单链表面试题"><a href="#3、单链表面试题" class="headerlink" title="3、单链表面试题"></a>3、单链表面试题</h2><h3 id="3-1、求单链表中有效节点的个数"><a href="#3-1、求单链表中有效节点的个数" class="headerlink" title="3.1、求单链表中有效节点的个数"></a>3.1、求单链表中有效节点的个数</h3><h4 id="3-1-1、代码思路"><a href="#3-1-1、代码思路" class="headerlink" title="3.1.1、代码思路"></a>3.1.1、代码思路</h4><ul>
<li>求单链表中有效节点的个数：遍历即可</li>
</ul>
<h4 id="3-1-2、代码实现"><a href="#3-1-2、代码实现" class="headerlink" title="3.1.2、代码实现"></a>3.1.2、代码实现</h4><ul>
<li>求单链表中有效节点的个数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123; <span class="comment">// 空链表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 定义一个辅助的变量, 这里我们没有统计头节点</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        cur = cur.next; <span class="comment">// 遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 进行测试</span></span><br><span class="line">    <span class="comment">// 先创建节点</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建要给链表</span></span><br><span class="line">    <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入</span></span><br><span class="line">    singleLinkedList.add(hero1);</span><br><span class="line">    singleLinkedList.add(hero2);</span><br><span class="line">    singleLinkedList.add(hero3);</span><br><span class="line">    singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">    singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试一下 求单链表中有效节点的个数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;有效的节点个数=&quot;</span> + getLength(singleLinkedList.getHead()));<span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HeroNode [no=1, name=宋江, nickName=及时雨]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickName=玉麒麟]</span><br><span class="line">HeroNode [no=3, name=吴用, nickName=智多星]</span><br><span class="line">HeroNode [no=4, name=林冲, nickName=豹子头]</span><br><span class="line">有效的节点个数=4</span><br></pre></td></tr></table></figure>

<h3 id="3-2、查找单链表中的倒数第-k-个结点"><a href="#3-2、查找单链表中的倒数第-k-个结点" class="headerlink" title="3.2、查找单链表中的倒数第 k 个结点"></a>3.2、查找单链表中的倒数第 k 个结点</h3><h4 id="3-2-1、代码思路"><a href="#3-2-1、代码思路" class="headerlink" title="3.2.1、代码思路"></a>3.2.1、代码思路</h4><ul>
<li>查找单链表中的倒数第k个结点 【新浪面试题】<ul>
<li>首先，获取整个链表中元素的个数 size</li>
<li>在使用 for 循环定位至倒数第 index（形参） 个节点，返回即可</li>
<li>for 循环的条件应如何确定？for (int i = 0; i &lt; x; i++) 中 x 的值应是多少？我们需要定位至倒数第 index 个节点，在 for 循环之前，我们已经定位置首节点，还需再走 (size -<br>index ) 步，定位至倒数第 index 个节点</li>
<li>举例说明：链表中一共有 4 个元素，想要定位至倒数第 2 个节点，那么需要在首节点之后走两步，到达倒数第 2 个节点</li>
</ul>
</li>
</ul>
<h4 id="3-2-2、代码实现"><a href="#3-2-2、代码实现" class="headerlink" title="3.2.2、代码实现"></a>3.2.2、代码实现</h4><ul>
<li>查找单链表中的倒数第k个结点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找单链表中的倒数第k个结点 【新浪面试题】</span></span><br><span class="line"><span class="comment">// 思路</span></span><br><span class="line"><span class="comment">// 1. 编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">// 2. index 表示是倒数第index个节点</span></span><br><span class="line"><span class="comment">// 3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span></span><br><span class="line"><span class="comment">// 4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span></span><br><span class="line"><span class="comment">// 5. 如果找到了，则返回该节点，否则返回nulll</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode head, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断如果链表为空，返回null</span></span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">// 没有找到</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一个遍历得到链表的长度(节点个数)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">    <span class="comment">// 第二次遍历 size-index 位置，就是我们倒数的第K个节点</span></span><br><span class="line">    <span class="comment">// 先做一个index的校验</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 定义给辅助变量， for 循环定位到倒数的index</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next; <span class="comment">// 3 // 3 - 1 = 2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 进行测试</span></span><br><span class="line">    <span class="comment">// 先创建节点</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建要给链表</span></span><br><span class="line">    <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入</span></span><br><span class="line">    singleLinkedList.add(hero1);</span><br><span class="line">    singleLinkedList.add(hero2);</span><br><span class="line">    singleLinkedList.add(hero3);</span><br><span class="line">    singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">    singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试一下看看是否得到了倒数第K个节点</span></span><br><span class="line">    <span class="type">HeroNode</span> <span class="variable">res</span> <span class="operator">=</span> findLastIndexNode(singleLinkedList.getHead(), <span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HeroNode [no=1, name=宋江, nickName=及时雨]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickName=玉麒麟]</span><br><span class="line">HeroNode [no=3, name=吴用, nickName=智多星]</span><br><span class="line">HeroNode [no=4, name=林冲, nickName=豹子头]</span><br><span class="line">res=HeroNode [no=3, name=吴用, nickName=智多星]</span><br></pre></td></tr></table></figure>

<h3 id="3-3、单链表的反转"><a href="#3-3、单链表的反转" class="headerlink" title="3.3、单链表的反转"></a>3.3、单链表的反转</h3><h4 id="3-3-1、代码思路"><a href="#3-3-1、代码思路" class="headerlink" title="3.3.1、代码思路"></a>3.3.1、代码思路</h4><ul>
<li>单链表的反转【腾讯面试题，有点难度】<ul>
<li>定义一个新的头结点 reverseHead ，一点一点将链表反转后，再串起来</li>
<li>怎么个串法？<ul>
<li>在原链表中每读取一个节点（cur），先保存其下一个节点的地址（next），然后将 cur 节点放在新链表的最前面</li>
<li>然后执行遍历：<strong>cur = next</strong> ，即指针后移</li>
<li>遍历完成后，新链表即是反转后的链表</li>
</ul>
</li>
<li>如何将 cur 节点插入在新链表的最前面<ul>
<li><strong>cur.next = reverseHead.next;</strong></li>
<li><strong>reverseHead.next = cur;</strong></li>
</ul>
</li>
<li>while 循环终止条件？ <strong>cur == null</strong> ：已遍历至链表尾部</li>
</ul>
</li>
<li>单链表的翻转可以参考我的这篇博文：<a href="https://blog.csdn.net/oneby1314/article/details/107577923">https://blog.csdn.net/oneby1314/article/details/107577923</a></li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325152000.png" alt="image-20200725212137897"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325152947.png" alt="image-20200726111854627"></p>
<h4 id="3-3-2、代码实现"><a href="#3-3-2、代码实现" class="headerlink" title="3.3.2、代码实现"></a>3.3.2、代码实现</h4><ul>
<li>单链表的反转</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将单链表反转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversetList</span><span class="params">(HeroNode head)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>||head.next.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">    HeroNode cur=head.next;</span><br><span class="line">    HeroNode next=<span class="literal">null</span>;<span class="comment">// 指向当前节点[cur]的下一个节点</span></span><br><span class="line">    HeroNode reverseHead=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">// 遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span></span><br><span class="line">    <span class="comment">// 动脑筋</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">        next=cur.next;<span class="comment">// 先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">        cur.next=reverseHead.next;<span class="comment">// 将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">        reverseHead.next=cur; <span class="comment">// 将cur 连接到新的链表上</span></span><br><span class="line">        cur=next;<span class="comment">// 让cur后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将head.next 指向 reverseHead.next , 实现单链表的反转</span></span><br><span class="line">    head.next=reverseHead.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="comment">// 进行测试</span></span><br><span class="line">    <span class="comment">// 先创建节点</span></span><br><span class="line">    HeroNode hero1=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">    HeroNode hero2=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">    HeroNode hero3=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">    HeroNode hero4=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建要给链表</span></span><br><span class="line">    SingleLinkedList singleLinkedList=<span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入</span></span><br><span class="line">    singleLinkedList.add(hero1);</span><br><span class="line">    singleLinkedList.add(hero2);</span><br><span class="line">    singleLinkedList.add(hero3);</span><br><span class="line">    singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试一下单链表的反转功能</span></span><br><span class="line">    System.out.println(<span class="string">&quot;原来链表的情况~~&quot;</span>);</span><br><span class="line">    singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;反转单链表~~&quot;</span>);</span><br><span class="line">    reversetList(singleLinkedList.getHead());</span><br><span class="line">    singleLinkedList.list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">原来链表的情况~~</span><br><span class="line">HeroNode [no=1, name=宋江, nickName=及时雨]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickName=玉麒麟]</span><br><span class="line">HeroNode [no=3, name=吴用, nickName=智多星]</span><br><span class="line">HeroNode [no=4, name=林冲, nickName=豹子头]</span><br><span class="line">反转单链表~~</span><br><span class="line">HeroNode [no=4, name=林冲, nickName=豹子头]</span><br><span class="line">HeroNode [no=3, name=吴用, nickName=智多星]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickName=玉麒麟]</span><br><span class="line">HeroNode [no=1, name=宋江, nickName=及时雨]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-4、单链表的反转（我的代码）"><a href="#3-4、单链表的反转（我的代码）" class="headerlink" title="3.4、单链表的反转（我的代码）"></a>3.4、单链表的反转（我的代码）</h3><h4 id="3-4-1、代码思路"><a href="#3-4-1、代码思路" class="headerlink" title="3.4.1、代码思路"></a>3.4.1、代码思路</h4><ul>
<li>单链表的反转【腾讯面试题，有点难度】<ul>
<li>原链表为 cur 指向 next ，反转链表不就是把 next 指向 cur 吗？</li>
<li>由于 next 指向 cur 时，next 将<strong>丢失</strong>其下一节点的地址，所以需要先将 nnext 保存起来</li>
<li><strong>next ==null</strong> 时链表已经反转完毕，最后将头结点指向 cur 节点即可</li>
</ul>
</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325153102.png" alt="image-20200713220627600"></p>
<h4 id="3-4-2、代码实现"><a href="#3-4-2、代码实现" class="headerlink" title="3.4.2、代码实现"></a>3.4.2、代码实现</h4><ul>
<li>单链表的反转</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将单链表反转</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myReversetList</span><span class="params">(HeroNode head)</span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>||head.next.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点</span></span><br><span class="line">    HeroNode cur=head.next;</span><br><span class="line">    <span class="comment">// 下一节点</span></span><br><span class="line">    HeroNode next=cur.next;</span><br><span class="line">    <span class="comment">// 首节点反转后为尾节点，需指向 null</span></span><br><span class="line">    cur.next=<span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next == null 时，链表已经反转完毕</span></span><br><span class="line">    <span class="keyword">while</span>(next!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 记录 next 的后一节点</span></span><br><span class="line">        HeroNode nnext=next.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转链表</span></span><br><span class="line">        next.next=cur;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指针后移</span></span><br><span class="line">        cur=next;</span><br><span class="line">        next=nnext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后加上首节点</span></span><br><span class="line">    head.next=cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="comment">// 进行测试</span></span><br><span class="line">    <span class="comment">// 先创建节点</span></span><br><span class="line">    HeroNode hero1=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">    HeroNode hero2=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">    HeroNode hero3=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">    HeroNode hero4=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建要给链表</span></span><br><span class="line">    SingleLinkedList singleLinkedList=<span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入</span></span><br><span class="line">    singleLinkedList.add(hero1);</span><br><span class="line">    singleLinkedList.add(hero2);</span><br><span class="line">    singleLinkedList.add(hero3);</span><br><span class="line">    singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试一下单链表的反转功能</span></span><br><span class="line">    System.out.println(<span class="string">&quot;原来链表的情况~~&quot;</span>);</span><br><span class="line">    singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;反转单链表~~&quot;</span>);</span><br><span class="line">    reversetList(singleLinkedList.getHead());</span><br><span class="line">    singleLinkedList.list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">原来链表的情况~~</span><br><span class="line">HeroNode [no=1, name=宋江, nickName=及时雨]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickName=玉麒麟]</span><br><span class="line">HeroNode [no=3, name=吴用, nickName=智多星]</span><br><span class="line">HeroNode [no=4, name=林冲, nickName=豹子头]</span><br><span class="line">反转单链表~~</span><br><span class="line">HeroNode [no=4, name=林冲, nickName=豹子头]</span><br><span class="line">HeroNode [no=3, name=吴用, nickName=智多星]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickName=玉麒麟]</span><br><span class="line">HeroNode [no=1, name=宋江, nickName=及时雨]</span><br><span class="line">12345678910</span><br></pre></td></tr></table></figure>

<h3 id="3-5、从尾到头打印单链表"><a href="#3-5、从尾到头打印单链表" class="headerlink" title="3.5、从尾到头打印单链表"></a>3.5、从尾到头打印单链表</h3><h4 id="3-5-1、栈的基本使用"><a href="#3-5-1、栈的基本使用" class="headerlink" title="3.5.1、栈的基本使用"></a>3.5.1、栈的基本使用</h4><ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    Stack&lt;String&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">    <span class="comment">// 入栈</span></span><br><span class="line">    stack.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">    stack.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">    stack.add(<span class="string">&quot;smith&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="comment">// smith, tom , jack</span></span><br><span class="line">    <span class="keyword">while</span>(stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(stack.pop());<span class="comment">//pop就是将栈顶的数据取出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">smith</span><br><span class="line">tom</span><br><span class="line">jack</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-5-2、代码思路"><a href="#3-5-2、代码思路" class="headerlink" title="3.5.2、代码思路"></a>3.5.2、代码思路</h4><ul>
<li>从尾到头打印单链表 【百度，要求方式1：反向遍历 。 方式2：Stack栈】<ul>
<li>方式一：先将单链表进行反转操作，然后再遍历输出，问题：<strong>破坏原链表结构</strong>，不可取</li>
<li>方式二：遍历链表，去除节点压入栈中，利用栈<strong>先进后出</strong>的特点，实现逆序打印</li>
</ul>
</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325153137.png" alt="image-20220325153135682"></p>
<h4 id="3-5-3、代码实现"><a href="#3-5-3、代码实现" class="headerlink" title="3.5.3、代码实现"></a>3.5.3、代码实现</h4><ul>
<li>从尾到头打印单链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式2：</span></span><br><span class="line"><span class="comment">// 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">// 空链表，不能打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建要给一个栈，将各个节点压入栈</span></span><br><span class="line">    Stack&lt;HeroNode&gt; stack=<span class="keyword">new</span> <span class="title class_">Stack</span>&lt;HeroNode&gt;();</span><br><span class="line">    HeroNode cur=head.next;</span><br><span class="line">    <span class="comment">// 将链表的所有节点压入栈</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur=cur.next; <span class="comment">// cur后移，这样就可以压入下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将栈中的节点进行打印,pop 出栈</span></span><br><span class="line">    <span class="keyword">while</span>(stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(stack.pop()); <span class="comment">// stack的特点是先进后出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="comment">//进行测试</span></span><br><span class="line">    <span class="comment">//先创建节点</span></span><br><span class="line">    HeroNode hero1=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">    HeroNode hero2=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">    HeroNode hero3=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">    HeroNode hero4=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建要给链表</span></span><br><span class="line">    SingleLinkedList singleLinkedList=<span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入</span></span><br><span class="line">    singleLinkedList.add(hero1);</span><br><span class="line">    singleLinkedList.add(hero2);</span><br><span class="line">    singleLinkedList.add(hero3);</span><br><span class="line">    singleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;原来链表的情况~~&quot;</span>);</span><br><span class="line">    singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;测试逆序打印单链表, 没有改变链表的结构~~&quot;</span>);</span><br><span class="line">    reversePrint(singleLinkedList.getHead());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">原来链表的情况~~</span><br><span class="line">HeroNode [no=1, name=宋江, nickName=及时雨]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickName=玉麒麟]</span><br><span class="line">HeroNode [no=3, name=吴用, nickName=智多星]</span><br><span class="line">HeroNode [no=4, name=林冲, nickName=豹子头]</span><br><span class="line">测试逆序打印单链表, 没有改变链表的结构~~</span><br><span class="line">HeroNode [no=4, name=林冲, nickName=豹子头]</span><br><span class="line">HeroNode [no=3, name=吴用, nickName=智多星]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickName=玉麒麟]</span><br><span class="line">HeroNode [no=1, name=宋江, nickName=及时雨]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-6、合并两个有序的单链表"><a href="#3-6、合并两个有序的单链表" class="headerlink" title="3.6、合并两个有序的单链表"></a>3.6、合并两个有序的单链表</h3><h4 id="3-6-1、代码思路"><a href="#3-6-1、代码思路" class="headerlink" title="3.6.1、代码思路"></a>3.6.1、代码思路</h4><ul>
<li>合并两个有序的单链表，合并之后的链表依然有序【课后练习】</li>
</ul>
<h4 id="3-6-2、代码实现"><a href="#3-6-2、代码实现" class="headerlink" title="3.6.2、代码实现"></a>3.6.2、代码实现</h4><ul>
<li>合并两个有序的单链表，合并之后的链表依然有序</li>
<li>具体讲解见我的一篇博客：<a href="https://blog.csdn.net/oneby1314/article/details/107590876">https://blog.csdn.net/oneby1314/article/details/107590876</a></li>
</ul>
<h3 id="3-7、单向链表所有代码"><a href="#3-7、单向链表所有代码" class="headerlink" title="3.7、单向链表所有代码"></a>3.7、单向链表所有代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedListDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//进行测试</span></span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建要给链表</span></span><br><span class="line">        <span class="type">SingleLinkedList</span> <span class="variable">singleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingleLinkedList</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入</span></span><br><span class="line">        singleLinkedList.add(hero1);</span><br><span class="line">        singleLinkedList.add(hero4);</span><br><span class="line">        singleLinkedList.add(hero2);</span><br><span class="line">        singleLinkedList.add(hero3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试一下单链表的反转功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;原来链表的情况~~&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;反转单链表~~&quot;</span>);</span><br><span class="line">        reversetList(singleLinkedList.getHead());</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;测试逆序打印单链表, 没有改变链表的结构~~&quot;</span>);</span><br><span class="line">        reversePrint(singleLinkedList.getHead());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入按照编号的顺序</span></span><br><span class="line">        singleLinkedList.addByOrder(hero1);</span><br><span class="line">        singleLinkedList.addByOrder(hero4);</span><br><span class="line">        singleLinkedList.addByOrder(hero2);</span><br><span class="line">        singleLinkedList.addByOrder(hero3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显示一把</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试修改节点的代码</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;小卢&quot;</span>, <span class="string">&quot;玉麒麟~~&quot;</span>);</span><br><span class="line">        singleLinkedList.update(newHeroNode);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的链表情况~~&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除一个节点</span></span><br><span class="line">        singleLinkedList.del(<span class="number">1</span>);</span><br><span class="line">        singleLinkedList.del(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的链表情况~~&quot;</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一下 求单链表中有效节点的个数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;有效的节点个数=&quot;</span> + getLength(singleLinkedList.getHead()));<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试一下看看是否得到了倒数第K个节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">res</span> <span class="operator">=</span> findLastIndexNode(singleLinkedList.getHead(), <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;res=&quot;</span> + res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式2：</span></span><br><span class="line">    <span class="comment">// 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就实现了逆序打印的效果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversePrint</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">// 空链表，不能打印</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建要给一个栈，将各个节点压入栈</span></span><br><span class="line">        Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;HeroNode&gt;();</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">// 将链表的所有节点压入栈</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next; <span class="comment">// cur后移，这样就可以压入下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将栈中的节点进行打印,pop 出栈</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(stack.pop()); <span class="comment">// stack的特点是先进后出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将单链表反转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reversetList</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个辅助的指针(变量)，帮助我们遍历原来的链表</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">// 指向当前节点[cur]的下一个节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">reverseHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reverseHead 的最前端</span></span><br><span class="line">        <span class="comment">// 动脑筋</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = cur.next;<span class="comment">// 先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">            cur.next = reverseHead.next;<span class="comment">// 将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">            reverseHead.next = cur; <span class="comment">// 将cur 连接到新的链表上</span></span><br><span class="line">            cur = next;<span class="comment">// 让cur后移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将head.next 指向 reverseHead.next , 实现单链表的反转</span></span><br><span class="line">        head.next = reverseHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将单链表反转</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">myReversetList</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前链表为空，或者只有一个节点，无需反转，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="comment">// 下一节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        <span class="comment">// 首节点反转后为尾节点，需指向 null</span></span><br><span class="line">        cur.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// next == null 时，链表已经反转完毕</span></span><br><span class="line">        <span class="keyword">while</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录 next 的后一节点</span></span><br><span class="line">            <span class="type">HeroNode</span> <span class="variable">nnext</span> <span class="operator">=</span> next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 反转链表</span></span><br><span class="line">            next.next = cur;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 指针后移</span></span><br><span class="line">            cur = next;</span><br><span class="line">            next = nnext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后加上头结点</span></span><br><span class="line">        head.next = cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找单链表中的倒数第k个结点 【新浪面试题】</span></span><br><span class="line">    <span class="comment">// 思路</span></span><br><span class="line">    <span class="comment">// 1. 编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line">    <span class="comment">// 2. index 表示是倒数第index个节点</span></span><br><span class="line">    <span class="comment">// 3. 先把链表从头到尾遍历，得到链表的总的长度 getLength</span></span><br><span class="line">    <span class="comment">// 4. 得到size 后，我们从链表的第一个开始遍历 (size-index)个，就可以得到</span></span><br><span class="line">    <span class="comment">// 5. 如果找到了，则返回该节点，否则返回nulll</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title function_">findLastIndexNode</span><span class="params">(HeroNode head, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断如果链表为空，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">// 没有找到</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个遍历得到链表的长度(节点个数)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">        <span class="comment">// 第二次遍历 size-index 位置，就是我们倒数的第K个节点</span></span><br><span class="line">        <span class="comment">// 先做一个index的校验</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义给辅助变量， for 循环定位到倒数的index</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next; <span class="comment">// 3 // 3 - 1 = 2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法：获取到单链表的节点的个数(如果是带头结点的链表，需求不统计头节点)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 链表的头节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的就是有效节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(HeroNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123; <span class="comment">// 空链表</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 定义一个辅助的变量, 这里我们没有统计头节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">cur</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur.next; <span class="comment">// 遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义SingleLinkedList 管理我们的英雄</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回头节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加节点到单向链表</span></span><br><span class="line">    <span class="comment">// 思路，当不考虑编号顺序时</span></span><br><span class="line">    <span class="comment">// 1. 找到当前链表的最后节点</span></span><br><span class="line">    <span class="comment">// 2. 将最后这个节点的next 指向 新的节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;<span class="comment">//</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有找到最后, 将将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">// 将最后这个节点的next 指向 新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">    <span class="comment">// (如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line">        <span class="comment">// 因为单链表，因为我们找的temp 是位于 添加位置的前一个节点，否则插入不了</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123; <span class="comment">// 位置找到，就在temp的后面插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">// 说明希望添加的heroNode的编号已然存在</span></span><br><span class="line"></span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">// 说明编号存在</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next; <span class="comment">// 后移，遍历当前链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断flag 的值</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;准备插入的英雄的编号 %d 已经存在了, 不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 插入到链表中, temp的后面</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改节点的信息, 根据no编号来修改，即no编号不能改.</span></span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1. 根据 newHeroNode 的 no 来修改即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要修改的节点, 根据no编号</span></span><br><span class="line">        <span class="comment">// 定义一个辅助变量</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 已经遍历完链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">// 找到</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据flag 判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickName = newHeroNode.nickName;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有找到</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到 编号 %d 的节点，不能修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="comment">// 思路</span></span><br><span class="line">    <span class="comment">// 1. head 不能动，因此我们需要一个temp辅助节点找到待删除节点的前一个节点</span></span><br><span class="line">    <span class="comment">// 2. 说明我们在比较时，是temp.next.no 和 需要删除的节点的no比较</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123; <span class="comment">// 已经到链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next; <span class="comment">// temp后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断flag</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// 找到</span></span><br><span class="line">            <span class="comment">// 可以删除</span></span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;要删除的 %d 节点不存在\n&quot;</span>, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示链表[遍历]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出节点的信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">// 将temp后移， 一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HeroNode ， 每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickName;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next; <span class="comment">// 指向下一个节点</span></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickName = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了显示方法，我们重新toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickName=&quot;</span> + nickName + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4、双向链表"><a href="#4、双向链表" class="headerlink" title="4、双向链表"></a>4、双向链表</h2><h3 id="4-1、与单向链表的比较"><a href="#4-1、与单向链表的比较" class="headerlink" title="4.1、与单向链表的比较"></a>4.1、与单向链表的比较</h3><ul>
<li>单向链表， 查找的方向只能是一个方向， 而双向链表可以向前或者向后查找</li>
<li>单向链表不能自我删除， 需要靠辅助节点 ， 而双向链表， 则可以<strong>自我删除</strong>， 所以前面我们单链表删除时节点， 总是找到 temp ，temp 是待删除节点的<strong>前一个节点</strong>(认真体会)</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325153240.png" alt="image-20220325153238698"></p>
<h3 id="4-2、链表节点定义"><a href="#4-2、链表节点定义" class="headerlink" title="4.2、链表节点定义"></a>4.2、链表节点定义</h3><ul>
<li>在单向链表节点的基础上，增加 pre ，用于指向前一个节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义HeroNode ， 每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next; <span class="comment">// 指向下一个节点, 默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode pre; <span class="comment">// 指向前一个节点, 默认为null</span></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了显示方法，我们重新toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-3、链表定义"><a href="#4-3、链表定义" class="headerlink" title="4.3、链表定义"></a>4.3、链表定义</h3><ul>
<li>定义整个链表的头结点，作为链表的入口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个双向链表的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回头节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4、链表遍历"><a href="#4-4、链表遍历" class="headerlink" title="4.4、链表遍历"></a>4.4、链表遍历</h3><h4 id="4-4-1、代码思路"><a href="#4-4-1、代码思路" class="headerlink" title="4.4.1、代码思路"></a>4.4.1、代码思路</h4><ul>
<li>定义辅助变量 temp ，相当于一个指针，指向<strong>当前节点</strong> ，用于遍历链表</li>
<li>何时停止 while 循环？<strong>temp == null</strong> ：已经遍历至链表尾部</li>
</ul>
<h4 id="4-4-2、代码实现"><a href="#4-4-2、代码实现" class="headerlink" title="4.4.2、代码实现"></a>4.4.2、代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历双向链表的方法</span></span><br><span class="line"><span class="comment">// 显示链表[遍历]</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">    HeroNode temp=head.next;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 判断是否到链表最后</span></span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出节点的信息</span></span><br><span class="line">        System.out.println(temp);</span><br><span class="line">        <span class="comment">// 将temp后移， 一定小心</span></span><br><span class="line">        temp=temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-5、尾部插入"><a href="#4-5、尾部插入" class="headerlink" title="4.5、尾部插入"></a>4.5、尾部插入</h3><h4 id="4-5-1、代码思路"><a href="#4-5-1、代码思路" class="headerlink" title="4.5.1、代码思路"></a>4.5.1、代码思路</h4><ul>
<li>定义辅助变量 temp ，相当于一个指针，指向<strong>当前节点</strong></li>
<li>何时停止 while 循环？<strong>temp.next == null</strong> ：temp 节点已经是链表最后一个节点，在 temp 节点之后插入 heroNode 节点即可</li>
<li>如何插入？<ul>
<li>temp.next 指向新的尾节点 heroNode ：<strong>temp.next = heroNode;</strong></li>
<li>heroNode .pre 指向旧的尾节点 temp ：<strong>heroNode.pre = temp;</strong></li>
</ul>
</li>
</ul>
<h4 id="4-5-2、代码实现"><a href="#4-5-2、代码实现" class="headerlink" title="4.5.2、代码实现"></a>4.5.2、代码实现</h4><ul>
<li>在链表尾部插入节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加一个节点到双向链表的最后.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">    HeroNode temp=head;</span><br><span class="line">    <span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 找到链表的最后</span></span><br><span class="line">        <span class="keyword">if</span>(temp.next==<span class="literal">null</span>)&#123;<span class="comment">//</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有找到最后, 将将temp后移</span></span><br><span class="line">        temp=temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">    <span class="comment">// 形成一个双向链表</span></span><br><span class="line">    temp.next=heroNode;</span><br><span class="line">    heroNode.pre=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-6、按顺序插入"><a href="#4-6、按顺序插入" class="headerlink" title="4.6、按顺序插入"></a>4.6、按顺序插入</h3><h4 id="4-6-1、代码思路"><a href="#4-6-1、代码思路" class="headerlink" title="4.6.1、代码思路"></a>4.6.1、代码思路</h4><ul>
<li><p>定义辅助变量 temp ，相当于一个指针，指向<strong>当前节点</strong></p>
</li>
<li><p>我们将 heroNode 节点插入到 temp 节点之后还是 temp 节点之前？</p>
<ul>
<li>如果插入到 temp 节点之后：<ul>
<li>判断条件：<strong>temp.next.no &gt; heroNode.no</strong> ，即 temp 的下一个节点的值比 heroNode 节点的值大，所以需要将 heroNode 插入到 temp 节点之后</li>
</ul>
</li>
<li>while 循环终止条件：<ul>
<li><strong>temp.next == null</strong> ：temp 节点已经是链表的尾节点</li>
</ul>
</li>
<li><strong>temp.next.no &gt; heroNode.no</strong> ：heroNode 节点的值介于 temp 节点的值和 temp 下一个节点的值之间</li>
<li><strong>temp.next.no == heroNode.no</strong> ：heroNode 节点的值等于 temp 下一个节点的值，不能进行插入<pre><code>![aHR0cDovL2hleWdvLm9zcy1jbi1zaGw](https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java数据结构与算法/20220325153408.png)
</code></pre>
</li>
</ul>
<ul>
<li>如果插入到 temp 节点之前：<ul>
<li>判断条件：<strong>temp.no &gt; heroNode.no</strong> ，即 temp 节点的值比 heroNode 节点的值大，所以需要将 heroNode 插入到 temp 节点之前</li>
<li>存在的问题：如果需要在链表尾部插入 heroNode 节点，即需要在 null 节点之前插入 heroNode 节点，<strong>定位至 null 节点将丢失其前一个节点的信息</strong><br>（除非使用一个变量保存起来），所以跳出循环的判断条件为：temp.next == null</li>
<li>所以我们选取：【插入到 temp 节点之后】方案</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-6-2、代码实现"><a href="#4-6-2、代码实现" class="headerlink" title="4.6.2、代码实现"></a>4.6.2、代码实现</h4><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line"><span class="comment">// (如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span>&#123;</span><br><span class="line">    <span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line">    <span class="comment">// 目标：在 temp 的后面插入节点</span></span><br><span class="line">    HeroNode temp=head;</span><br><span class="line">    <span class="type">boolean</span> flag=<span class="literal">false</span>; <span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.next==<span class="literal">null</span>)&#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.next.no&gt;heroNode.no)&#123; <span class="comment">// 位置找到，就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp.next.no==heroNode.no)&#123;<span class="comment">// 说明希望添加的heroNode的编号已然存在</span></span><br><span class="line">            flag=<span class="literal">true</span>; <span class="comment">// 说明编号存在</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp.next; <span class="comment">// 后移，遍历当前链表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断flag 的值</span></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123; <span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;准备插入的英雄的编号 %d 已经存在了, 不能加入\n&quot;</span>,heroNode.no);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 插入到链表中, temp的后面</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// heroNode 指向 temp 节点的下一个节点</span></span><br><span class="line">        heroNode.next=temp.next;</span><br><span class="line">        <span class="keyword">if</span>(temp.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            temp.next.pre=heroNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// temp 节点指向 heroNode 节点</span></span><br><span class="line">        temp.next=heroNode;</span><br><span class="line">        heroNode.pre=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-7、修改节点信息"><a href="#4-7、修改节点信息" class="headerlink" title="4.7、修改节点信息"></a>4.7、修改节点信息</h3><h4 id="4-7-1、代码思路"><a href="#4-7-1、代码思路" class="headerlink" title="4.7.1、代码思路"></a>4.7.1、代码思路</h4><ul>
<li>定义辅助变量 temp ，相当于一个指针，指向<strong>当前节点</strong></li>
<li>如何找到指定节点？<strong>temp.no == no</strong></li>
</ul>
<h4 id="4-7-2、代码实现"><a href="#4-7-2、代码实现" class="headerlink" title="4.7.2、代码实现"></a>4.7.2、代码实现</h4><ul>
<li>修改指定节点的信息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样</span></span><br><span class="line"><span class="comment">// 只是 节点类型改成 HeroNode2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否空</span></span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;链表为空~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到需要修改的节点, 根据no编号</span></span><br><span class="line">    <span class="comment">// 定义一个辅助变量</span></span><br><span class="line">    HeroNode temp=head.next;</span><br><span class="line">    <span class="type">boolean</span> flag=<span class="literal">false</span>; <span class="comment">// 表示是否找到该节点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 已经遍历完链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.no==newHeroNode.no)&#123;</span><br><span class="line">            <span class="comment">// 找到</span></span><br><span class="line">            flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据flag 判断是否找到要修改的节点</span></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        temp.name=newHeroNode.name;</span><br><span class="line">        temp.nickname=newHeroNode.nickname;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 没有找到</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;没有找到 编号 %d 的节点，不能修改\n&quot;</span>,newHeroNode.no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-8、删除节点"><a href="#4-8、删除节点" class="headerlink" title="4.8、删除节点"></a>4.8、删除节点</h3><h4 id="4-8-1、代码思路"><a href="#4-8-1、代码思路" class="headerlink" title="4.8.1、代码思路"></a>4.8.1、代码思路</h4><ul>
<li><p>定义辅助变量 temp ，相当于一个指针，指向<strong>当前节点</strong></p>
</li>
<li><p>while 循环的终止条件？由于 temp 节点就是待删除节点，所以终止条件是：<strong>temp == null</strong></p>
</li>
<li><p>为何双向链表，可以实现<strong>自我删除</strong>？定位至待删除的节点 temp ，由于temp 节点有其前一个节点和后一个节点的信息，所以可实现自我删除</p>
</li>
<li><p>如何删除？</p>
<ul>
<li><p>temp 的前一个节点的 next 域指向 temp 的后一个节点：<strong>temp.pre.next = temp.next;</strong></p>
</li>
<li><p>temp 的后一个节点的 pre 域指向 temp 的前一个节点：</p>
<p>temp.next.pre = temp.pre;</p>
<ul>
<li>有个地方需要注意，如果 temp 已经是链表尾节点，temp 已经没有下一个节点</li>
<li>这时只需要将 temp 的前一个节点的 next 指向 null 即可</li>
<li>所以 <strong>temp.next.pre = temp.pre;</strong> 执行的前提条件是 <strong>temp.next != null</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-8-2、代码实现"><a href="#4-8-2、代码实现" class="headerlink" title="4.8.2、代码实现"></a>4.8.2、代码实现</h4><ul>
<li>删除指定节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从双向链表中删除一个节点,</span></span><br><span class="line"><span class="comment">// 说明</span></span><br><span class="line"><span class="comment">// 1 对于双向链表，我们可以直接找到要删除的这个节点</span></span><br><span class="line"><span class="comment">// 2 找到后，自我删除即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>)&#123;<span class="comment">// 空链表</span></span><br><span class="line">        System.out.println(<span class="string">&quot;链表为空，无法删除&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HeroNode temp=head.next; <span class="comment">// 辅助变量(指针)</span></span><br><span class="line">    <span class="type">boolean</span> flag=<span class="literal">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="literal">null</span>)&#123; <span class="comment">// 已经到链表的最后</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp.no==no)&#123;</span><br><span class="line">            <span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">            flag=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp=temp.next; <span class="comment">// temp后移，遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断flag</span></span><br><span class="line">    <span class="keyword">if</span>(flag)&#123; <span class="comment">// 找到</span></span><br><span class="line">        <span class="comment">// 可以删除</span></span><br><span class="line">        <span class="comment">// temp.next = temp.next.next;[单向链表]</span></span><br><span class="line">        temp.pre.next=temp.next;</span><br><span class="line">        <span class="comment">// 这里我们的代码有问题?</span></span><br><span class="line">        <span class="comment">// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span></span><br><span class="line">        <span class="keyword">if</span>(temp.next!=<span class="literal">null</span>)&#123;</span><br><span class="line">            temp.next.pre=temp.pre;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;要删除的 %d 节点不存在\n&quot;</span>,no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-9、双向链表测试"><a href="#4-9、双向链表测试" class="headerlink" title="4.9、双向链表测试"></a>4.9、双向链表测试</h3><h4 id="4-9-1、测试代码"><a href="#4-9-1、测试代码" class="headerlink" title="4.9.1、测试代码"></a>4.9.1、测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    System.out.println(<span class="string">&quot;双向链表的测试&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先创建节点</span></span><br><span class="line">    HeroNode hero1=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>,<span class="string">&quot;宋江&quot;</span>,<span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">    HeroNode hero2=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>,<span class="string">&quot;卢俊义&quot;</span>,<span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">    HeroNode hero3=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>,<span class="string">&quot;吴用&quot;</span>,<span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">    HeroNode hero4=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>,<span class="string">&quot;林冲&quot;</span>,<span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个双向链表</span></span><br><span class="line">    DoubleLinkedList doubleLinkedList=<span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">    doubleLinkedList.add(hero1);</span><br><span class="line">    doubleLinkedList.add(hero2);</span><br><span class="line">    doubleLinkedList.add(hero3);</span><br><span class="line">    doubleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">    doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试按需插入</span></span><br><span class="line">    doubleLinkedList.addByOrder(<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>,<span class="string">&quot;Heygo&quot;</span>,<span class="string">&quot;Heygogo&quot;</span>));</span><br><span class="line">    doubleLinkedList.addByOrder(<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>,<span class="string">&quot;Oneby&quot;</span>,<span class="string">&quot;Onebyone&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;按顺序插入后的情况&quot;</span>);</span><br><span class="line">    doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改</span></span><br><span class="line">    HeroNode newHeroNode=<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>,<span class="string">&quot;公孙胜&quot;</span>,<span class="string">&quot;入云龙&quot;</span>);</span><br><span class="line">    doubleLinkedList.update(newHeroNode);</span><br><span class="line">    System.out.println(<span class="string">&quot;修改后的链表情况&quot;</span>);</span><br><span class="line">    doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;删除后的链表情况~~&quot;</span>);</span><br><span class="line">    doubleLinkedList.list();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-9-2、程序运行结果"><a href="#4-9-2、程序运行结果" class="headerlink" title="4.9.2、程序运行结果"></a>4.9.2、程序运行结果</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">双向链表的测试</span><br><span class="line">HeroNode [no=1, name=宋江, nickname=及时雨]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickname=玉麒麟]</span><br><span class="line">HeroNode [no=3, name=吴用, nickname=智多星]</span><br><span class="line">HeroNode [no=5, name=林冲, nickname=豹子头]</span><br><span class="line">按顺序插入后的情况</span><br><span class="line">HeroNode [no=1, name=宋江, nickname=及时雨]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickname=玉麒麟]</span><br><span class="line">HeroNode [no=3, name=吴用, nickname=智多星]</span><br><span class="line">HeroNode [no=4, name=Heygo, nickname=Heygogo]</span><br><span class="line">HeroNode [no=5, name=林冲, nickname=豹子头]</span><br><span class="line">HeroNode [no=6, name=Oneby, nickname=Onebyone]</span><br><span class="line">修改后的链表情况</span><br><span class="line">HeroNode [no=1, name=宋江, nickname=及时雨]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickname=玉麒麟]</span><br><span class="line">HeroNode [no=3, name=吴用, nickname=智多星]</span><br><span class="line">HeroNode [no=4, name=Heygo, nickname=Heygogo]</span><br><span class="line">HeroNode [no=5, name=公孙胜, nickname=入云龙]</span><br><span class="line">HeroNode [no=6, name=Oneby, nickname=Onebyone]</span><br><span class="line">删除后的链表情况~~</span><br><span class="line">HeroNode [no=1, name=宋江, nickname=及时雨]</span><br><span class="line">HeroNode [no=2, name=卢俊义, nickname=玉麒麟]</span><br><span class="line">HeroNode [no=4, name=Heygo, nickname=Heygogo]</span><br><span class="line">HeroNode [no=5, name=公孙胜, nickname=入云龙]</span><br><span class="line">HeroNode [no=6, name=Oneby, nickname=Onebyone]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-10、双向链表所有代码"><a href="#4-10、双向链表所有代码" class="headerlink" title="4.10、双向链表所有代码"></a>4.10、双向链表所有代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleLinkedListDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试</span></span><br><span class="line">        System.out.println(<span class="string">&quot;双向链表的测试&quot;</span>);</span><br><span class="line">        <span class="comment">// 先创建节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">hero4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个双向链表</span></span><br><span class="line">        <span class="type">DoubleLinkedList</span> <span class="variable">doubleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleLinkedList</span>();</span><br><span class="line">        doubleLinkedList.add(hero1);</span><br><span class="line">        doubleLinkedList.add(hero2);</span><br><span class="line">        doubleLinkedList.add(hero3);</span><br><span class="line">        doubleLinkedList.add(hero4);</span><br><span class="line"></span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试按需插入</span></span><br><span class="line">        doubleLinkedList.addByOrder(<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;Kobe&quot;</span>, <span class="string">&quot;BlackMamba&quot;</span>));</span><br><span class="line">        doubleLinkedList.addByOrder(<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">4</span>, <span class="string">&quot;Heygo&quot;</span>, <span class="string">&quot;Heygogo&quot;</span>));</span><br><span class="line">        doubleLinkedList.addByOrder(<span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">6</span>, <span class="string">&quot;Oneby&quot;</span>, <span class="string">&quot;Onebyone&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;按顺序插入后的情况&quot;</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">newHeroNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">5</span>, <span class="string">&quot;公孙胜&quot;</span>, <span class="string">&quot;入云龙&quot;</span>);</span><br><span class="line">        doubleLinkedList.update(newHeroNode);</span><br><span class="line">        System.out.println(<span class="string">&quot;修改后的链表情况&quot;</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        doubleLinkedList.del(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的链表情况~~&quot;</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个双向链表的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleLinkedList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先初始化一个头节点, 头节点不要动, 不存放具体的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">HeroNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeroNode</span>(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回头节点</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode <span class="title function_">getHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历双向链表的方法</span></span><br><span class="line">    <span class="comment">// 显示链表[遍历]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为头节点，不能动，因此我们需要一个辅助变量来遍历</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否到链表最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 输出节点的信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">// 将temp后移， 一定小心</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个节点到双向链表的最后.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为head节点不能动，因此我们需要一个辅助遍历 temp</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;<span class="comment">//</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有找到最后, 将将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">// 形成一个双向链表</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种方式在添加英雄时，根据排名将英雄插入到指定位置</span></span><br><span class="line">    <span class="comment">// (如果有这个排名，则添加失败，并给出提示)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addByOrder</span><span class="params">(HeroNode heroNode)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为头节点不能动，因此我们仍然通过一个辅助指针(变量)来帮助找到添加的位置</span></span><br><span class="line">        <span class="comment">// 目标：在 temp 的后面插入节点</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// flag标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="literal">null</span>) &#123;<span class="comment">// 说明temp已经在链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123; <span class="comment">// 位置找到，就在temp的后面插入</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;<span class="comment">// 说明希望添加的heroNode的编号已然存在</span></span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">// 说明编号存在</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next; <span class="comment">// 后移，遍历当前链表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断flag 的值</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// 不能添加，说明编号存在</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;准备插入的英雄的编号 %d 已经存在了, 不能加入\n&quot;</span>, heroNode.no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 插入到链表中, temp的后面</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// heroNode 指向 temp 节点的下一个节点</span></span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                temp.next.pre = heroNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// temp 节点指向 heroNode 节点</span></span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">            heroNode.pre = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改一个节点的内容, 可以看到双向链表的节点内容修改和单向链表一样</span></span><br><span class="line">    <span class="comment">// 只是 节点类型改成 HeroNode2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(HeroNode newHeroNode)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断是否空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到需要修改的节点, 根据no编号</span></span><br><span class="line">        <span class="comment">// 定义一个辅助变量</span></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 表示是否找到该节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 已经遍历完链表</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">// 找到</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据flag 判断是否找到要修改的节点</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有找到</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;没有找到 编号 %d 的节点，不能修改\n&quot;</span>, newHeroNode.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从双向链表中删除一个节点,</span></span><br><span class="line">    <span class="comment">// 说明</span></span><br><span class="line">    <span class="comment">// 1 对于双向链表，我们可以直接找到要删除的这个节点</span></span><br><span class="line">    <span class="comment">// 2 找到后，自我删除即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) &#123;<span class="comment">// 空链表</span></span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空，无法删除&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">HeroNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next; <span class="comment">// 辅助变量(指针)</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 标志是否找到待删除节点的</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">null</span>) &#123; <span class="comment">// 已经到链表的最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">                <span class="comment">// 找到的待删除节点的前一个节点temp</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next; <span class="comment">// temp后移，遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断flag</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// 找到</span></span><br><span class="line">            <span class="comment">// 可以删除</span></span><br><span class="line">            <span class="comment">// temp.next = temp.next.next;[单向链表]</span></span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="comment">// 这里我们的代码有问题?</span></span><br><span class="line">            <span class="comment">// 如果是最后一个节点，就不需要执行下面这句话，否则出现空指针</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;要删除的 %d 节点不存在\n&quot;</span>, no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义HeroNode ， 每个HeroNode 对象就是一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HeroNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next; <span class="comment">// 指向下一个节点, 默认为null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode pre; <span class="comment">// 指向前一个节点, 默认为null</span></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeroNode</span><span class="params">(<span class="type">int</span> no, String name, String nickname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了显示方法，我们重新toString</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode [no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickname=&quot;</span> + nickname + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-11、总结"><a href="#4-11、总结" class="headerlink" title="4.11、总结"></a>4.11、总结</h3><ul>
<li>辅助变量 temp ，相当于一个指针，指向<strong>当前节点</strong></li>
<li>如果定位至当前节点会丢失前一个节点的信息，那么我们只能定位至待操作节点的前一个节点：使用 <strong>temp.next</strong> 进行条件判断</li>
</ul>
<h2 id="5、单向环形链表"><a href="#5、单向环形链表" class="headerlink" title="5、单向环形链表"></a>5、单向环形链表</h2><h3 id="5-1、单向环形链表应用场景"><a href="#5-1、单向环形链表应用场景" class="headerlink" title="5.1、单向环形链表应用场景"></a>5.1、单向环形链表应用场景</h3><ul>
<li>Josephu 问题为： 设编号为 1， 2， … n 的 n 个人围坐一圈， 约定编号为 k（1&lt;=k&lt;=n） 的人从 1 开始报数， 数到 m 的那个人出列， 它的下一位又从 1 开始报数， 数到 m 的那个人又出列， 依次类推，<br>直到所有人出列为止， 由此产生一个出队编号的序列。</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325153539.png" alt="image-20200714115400947"></p>
<h3 id="5-2、单向环形链表图解"><a href="#5-2、单向环形链表图解" class="headerlink" title="5.2、单向环形链表图解"></a>5.2、单向环形链表图解</h3><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325153612.png" alt="image-20200714115444129"></p>
<h3 id="5-3、Josephu-问题"><a href="#5-3、Josephu-问题" class="headerlink" title="5.3、Josephu 问题"></a>5.3、Josephu 问题</h3><ul>
<li>用一个不带头结点的循环链表来处理 Josephu 问题： 先构成一个有 n 个结点的<strong>单循环链表</strong>， 然后由 k 结点起从 1 开始计数， 计到 m 时， 对应结点从链表中删除， 然后再从被删除结点的下一个结点又从 1 开始计数，<br>直到最后一个结点从链表中删除算法结束。</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325153703.png" alt="image-20200726113254075"></p>
<h3 id="5-4、环形链表的构建与遍历"><a href="#5-4、环形链表的构建与遍历" class="headerlink" title="5.4、环形链表的构建与遍历"></a>5.4、环形链表的构建与遍历</h3><h4 id="5-4-1、Boy-节点的定义"><a href="#5-4-1、Boy-节点的定义" class="headerlink" title="5.4.1、Boy 节点的定义"></a>5.4.1、Boy 节点的定义</h4><ul>
<li>Boy 节点就是个普普通通的单向链表节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;<span class="comment">// 编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next; <span class="comment">// 指向下一个节点,默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boy <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Boy next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-4-2、单向循环链表的定义"><a href="#5-4-2、单向循环链表的定义" class="headerlink" title="5.4.2、单向循环链表的定义"></a>5.4.2、单向循环链表的定义</h4><ul>
<li>first 节点为单向循环链表的<strong>首节点</strong>，是真实<strong>存放数据</strong>的节点，不是头结点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个环形的单向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleSingleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个first节点,当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boy</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-4-3、构建单向循环链表"><a href="#5-4-3、构建单向循环链表" class="headerlink" title="5.4.3、构建单向循环链表"></a>5.4.3、构建单向循环链表</h4><h5 id="1、代码思路"><a href="#1、代码思路" class="headerlink" title="1、代码思路"></a>1、代码思路</h5><ul>
<li>长度为 1 的情况：<ul>
<li>新创建的 boy 节点即是首节点：<strong>first = boy;</strong></li>
<li>自封闭（自己构成环形链表）：<strong>first.setNext(first);</strong></li>
<li>此时 first 节点既是首节点，也是尾节点，辅助指针也指向 first ：<strong>curBoy = first;</strong></li>
</ul>
</li>
<li>长度不为 1 的情况：<ul>
<li>将 boy 节点添加至环形链表的最后：<strong>curBoy.setNext(boy);</strong> ，curBoy 节点永远是环形链表的尾节点</li>
<li>构成环形链表（最）：<strong>boy.setNext(first);</strong></li>
<li>辅助指针后移，指向环形链表的尾节点：<strong>curBoy = boy;</strong></li>
</ul>
</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325153754.png" alt="image-20200726113301153"></p>
<h5 id="2、代码实现"><a href="#2、代码实现" class="headerlink" title="2、代码实现"></a>2、代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加小孩节点，构建成一个环形的链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBoy</span><span class="params">(<span class="type">int</span> nums)</span>&#123;</span><br><span class="line">    <span class="comment">// nums 做一个数据校验</span></span><br><span class="line">    <span class="keyword">if</span>(nums&lt; <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;nums的值不正确&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Boy curBoy=<span class="literal">null</span>; <span class="comment">// 辅助指针，帮助构建环形链表</span></span><br><span class="line">    <span class="comment">// 使用for来创建我们的环形链表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums;i++)&#123;</span><br><span class="line">        <span class="comment">// 根据编号，创建小孩节点</span></span><br><span class="line">        Boy boy=<span class="keyword">new</span> <span class="title class_">Boy</span>(i);</span><br><span class="line">        <span class="comment">// 如果是第一个小孩</span></span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">            first=boy; <span class="comment">// 初始化 first 节点</span></span><br><span class="line">            first.setNext(first); <span class="comment">// 构成环</span></span><br><span class="line">            curBoy=first; <span class="comment">// 让curBoy指向第一个小孩</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            curBoy.setNext(boy); <span class="comment">// 将 boy 节点加到链表尾部</span></span><br><span class="line">            boy.setNext(first); <span class="comment">// 构成环</span></span><br><span class="line">            curBoy=boy; <span class="comment">// curBoy 指针后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-4-4、遍历单向循环链表"><a href="#5-4-4、遍历单向循环链表" class="headerlink" title="5.4.4、遍历单向循环链表"></a>5.4.4、遍历单向循环链表</h4><h5 id="1、代码思路-1"><a href="#1、代码思路-1" class="headerlink" title="1、代码思路"></a>1、代码思路</h5><ul>
<li>定义辅助变量 curBoy ，相当于一个指针，指向<strong>当前节点</strong></li>
<li>何时退出 while 循环？当 curBoy 已经指向环形链表的尾节点：<strong>curBoy.getNext() == first</strong></li>
</ul>
<h5 id="2、代码实现-1"><a href="#2、代码实现-1" class="headerlink" title="2、代码实现"></a>2、代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历当前的环形链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBoy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 判断链表是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(first==<span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;没有任何小孩~~&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">    Boy curBoy=first;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;小孩的编号 %d \n&quot;</span>,curBoy.getNo());</span><br><span class="line">        <span class="keyword">if</span>(curBoy.getNext()==first)&#123;<span class="comment">// 说明已经遍历完毕</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curBoy=curBoy.getNext(); <span class="comment">// curBoy后移</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-5、解决-Josephu-问题"><a href="#5-5、解决-Josephu-问题" class="headerlink" title="5.5、解决 Josephu 问题"></a>5.5、解决 Josephu 问题</h3><h4 id="5-5-1、代码思路"><a href="#5-5-1、代码思路" class="headerlink" title="5.5.1、代码思路"></a>5.5.1、代码思路</h4><ul>
<li>辅助变量 helper ：helper 永都指向<strong>环形链表的尾节点</strong>，环形链表的尾节点永远都指向首节点，可得出：<strong>helper.getNext() == first</strong></li>
<li>如何将 helper 定位至环形链表的尾节点？<ul>
<li>初始化时，让 <strong>helper = first</strong> ，此时 helper 指向环形链表的首节点</li>
<li>while 循环终止条件？<strong>helper.getNext() == first</strong> ：此时 helper 已经移动至环形链表的尾节点</li>
</ul>
</li>
<li>如何定位至第 startNo 个节点？如果想要定位至第 2 个节点，那么则需要让 first 和 helper 都移动 1 步，所以让 first 和 helper 都移动 (startNo - 1)步即可</li>
<li>如何数 nums 下？让 first 和 helper 都移动 (nums - 1)步即可</li>
<li>如何实现出圈？<ul>
<li>我们需要将 first 指向的节点出圈，first 前一个节点的地址在 helper 中存着（环形链表）</li>
<li>先让 first 后移一步：<strong>first = first.getNext;</strong></li>
<li>出圈：<strong>helper.setNext(first);</strong> ，原来的 first 节点由于没有任何引用，便会被垃圾回收机制回收</li>
</ul>
</li>
<li>while 循环终止条件？圈中只剩一人：<strong>helper == first</strong></li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/20220325153803.png" alt="image-20200726113448880"></p>
<h4 id="5-5-2、代码实现"><a href="#5-5-2、代码实现" class="headerlink" title="5.5.2、代码实现"></a>5.5.2、代码实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startNo  表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> countNum 表示数几下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums     表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span><span class="params">(<span class="type">int</span> startNo,<span class="type">int</span> countNum,<span class="type">int</span> nums)</span>&#123;</span><br><span class="line">    <span class="comment">// 先对数据进行校验</span></span><br><span class="line">    <span class="keyword">if</span>(first==<span class="literal">null</span>||startNo&lt; <span class="number">1</span>||startNo&gt;nums)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;参数输入有误， 请重新输入&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建要给辅助指针,帮助完成小孩出圈</span></span><br><span class="line">    Boy helper=first;</span><br><span class="line">    <span class="comment">// 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(helper.getNext()==first)&#123; <span class="comment">// 说明helper指向最后小孩节点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper=helper.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 小孩报数前，先让 first 和 helper 移动 k - 1次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;startNo -<span class="number">1</span>;j++)&#123;</span><br><span class="line">        first=first.getNext();</span><br><span class="line">        helper=helper.getNext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当小孩报数时，让first 和 helper 指针同时 的移动 m - 1 次, 然后出圈</span></span><br><span class="line">    <span class="comment">// 这里是一个循环操作，知道圈中只有一个节点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(helper==first)&#123; <span class="comment">// 说明圈中只有一个节点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 让 first 和 helper 指针同时 的移动 countNum - 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;countNum -<span class="number">1</span>;j++)&#123;</span><br><span class="line">            first=first.getNext();</span><br><span class="line">            helper=helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这时first指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;小孩%d出圈\n&quot;</span>,first.getNo());</span><br><span class="line">        <span class="comment">// 这时将first指向的小孩节点出圈</span></span><br><span class="line">        first=first.getNext();</span><br><span class="line">        helper.setNext(first);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.printf(<span class="string">&quot;最后留在圈中的小孩编号%d \n&quot;</span>,first.getNo());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-6、Josephu-问题测试"><a href="#5-6、Josephu-问题测试" class="headerlink" title="5.6、Josephu 问题测试"></a>5.6、Josephu 问题测试</h3><h4 id="5-6-1、测试代码"><a href="#5-6-1、测试代码" class="headerlink" title="5.6.1、测试代码"></a>5.6.1、测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>&#123;</span><br><span class="line">    <span class="comment">// 测试一把看看构建环形链表，和遍历是否ok</span></span><br><span class="line">    CircleSingleLinkedList circleSingleLinkedList=<span class="keyword">new</span> <span class="title class_">CircleSingleLinkedList</span>();</span><br><span class="line">    circleSingleLinkedList.addBoy(<span class="number">5</span>);<span class="comment">// 加入5个小孩节点</span></span><br><span class="line">    circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试一把小孩出圈是否正确</span></span><br><span class="line">    circleSingleLinkedList.countBoy(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-6-2、程序运行结果"><a href="#5-6-2、程序运行结果" class="headerlink" title="5.6.2、程序运行结果"></a>5.6.2、程序运行结果</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">小孩的编号 1 </span><br><span class="line">小孩的编号 2 </span><br><span class="line">小孩的编号 3 </span><br><span class="line">小孩的编号 4 </span><br><span class="line">小孩的编号 5 </span><br><span class="line">小孩2出圈</span><br><span class="line">小孩4出圈</span><br><span class="line">小孩1出圈</span><br><span class="line">小孩5出圈</span><br><span class="line">最后留在圈中的小孩编号3 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-7、Josephu-问题所有代码"><a href="#5-7、Josephu-问题所有代码" class="headerlink" title="5.7、Josephu 问题所有代码"></a>5.7、Josephu 问题所有代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Josepfu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试一把看看构建环形链表，和遍历是否ok</span></span><br><span class="line">        <span class="type">CircleSingleLinkedList</span> <span class="variable">circleSingleLinkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CircleSingleLinkedList</span>();</span><br><span class="line">        circleSingleLinkedList.addBoy(<span class="number">5</span>);<span class="comment">// 加入5个小孩节点</span></span><br><span class="line">        circleSingleLinkedList.showBoy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试一把小孩出圈是否正确</span></span><br><span class="line">        circleSingleLinkedList.countBoy(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 2-&gt;4-&gt;1-&gt;5-&gt;3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个环形的单向链表</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleSingleLinkedList</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个first节点,当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Boy</span> <span class="variable">first</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加小孩节点，构建成一个环形的链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addBoy</span><span class="params">(<span class="type">int</span> nums)</span> &#123;</span><br><span class="line">        <span class="comment">// nums 做一个数据校验</span></span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;nums的值不正确&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 辅助指针，帮助构建环形链表</span></span><br><span class="line">        <span class="comment">// 使用for来创建我们的环形链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">            <span class="comment">// 根据编号，创建小孩节点</span></span><br><span class="line">            <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>(i);</span><br><span class="line">            <span class="comment">// 如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = boy; <span class="comment">// 初始化 first 节点</span></span><br><span class="line">                first.setNext(first); <span class="comment">// 构成环</span></span><br><span class="line">                curBoy = first; <span class="comment">// 让curBoy指向第一个小孩</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curBoy.setNext(boy); <span class="comment">// 将 boy 节点加到链表尾部</span></span><br><span class="line">                boy.setNext(first); <span class="comment">// 构成环</span></span><br><span class="line">                curBoy = boy; <span class="comment">// curBoy 指针后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历当前的环形链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showBoy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有任何小孩~~&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">curBoy</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩的编号 %d \n&quot;</span>, curBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span> (curBoy.getNext() == first) &#123;<span class="comment">// 说明已经遍历完毕</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy = curBoy.getNext(); <span class="comment">// curBoy后移</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNo  表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNum 表示数几下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums     表示最初有多少小孩在圈中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countBoy</span><span class="params">(<span class="type">int</span> startNo, <span class="type">int</span> countNum, <span class="type">int</span> nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 先对数据进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;参数输入有误， 请重新输入&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建要给辅助指针,帮助完成小孩出圈</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">helper</span> <span class="operator">=</span> first;</span><br><span class="line">        <span class="comment">// 需求创建一个辅助指针(变量) helper , 事先应该指向环形链表的最后这个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.getNext() == first) &#123; <span class="comment">// 说明helper指向最后小孩节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 小孩报数前，先让 first 和 helper 移动 k - 1次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; startNo - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当小孩报数时，让first 和 helper 指针同时 的移动 m - 1 次, 然后出圈</span></span><br><span class="line">        <span class="comment">// 这里是一个循环操作，知道圈中只有一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper == first) &#123; <span class="comment">// 说明圈中只有一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 让 first 和 helper 指针同时 的移动 countNum - 1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; countNum - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这时first指向的节点，就是要出圈的小孩节点</span></span><br><span class="line">            System.out.printf(<span class="string">&quot;小孩%d出圈\n&quot;</span>, first.getNo());</span><br><span class="line">            <span class="comment">// 这时将first指向的小孩节点出圈</span></span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">&quot;最后留在圈中的小孩编号%d \n&quot;</span>, first.getNo());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Boy类，表示一个节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> no;<span class="comment">// 编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy next; <span class="comment">// 指向下一个节点,默认null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNo</span><span class="params">(<span class="type">int</span> no)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Boy <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Boy next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-8、总结"><a href="#5-8、总结" class="headerlink" title="5.8、总结"></a>5.8、总结</h3><ul>
<li>操作单向链表：对于插入、删除操作，只能定位至待操作节点的前一个节点，如果定位至当前节点，那么其上一个节点的信息便会丢失</li>
</ul>
]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码分析</title>
    <url>/posts/60ecd9a6f387/</url>
    <content><![CDATA[<h1 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h1><blockquote>
<p>以下代码都是基于java8的版本</p>
</blockquote>
<h1 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h1><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221017.png" alt="img"></p>
<p>jdk1.7和jdk1.8的差距还是比较大的，1.8引入了红黑树，尾插入</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221024.jpg" alt="img"></p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221037.png" alt="img"></p>
<h1 id="HashMap主要使用API"><a href="#HashMap主要使用API" class="headerlink" title="HashMap主要使用API"></a>HashMap主要使用API</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得指定键的值</span></span><br><span class="line">V <span class="title function_">get</span><span class="params">(Object key)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加键值对</span></span><br><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定Map中的键值对 复制到 此Map中</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除该键值对</span></span><br><span class="line">V <span class="title function_">remove</span><span class="params">(Object key)</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在该键的键值对；是 则返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否存在该值的键值对；是 则返回true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span>;  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 单独抽取key序列，将所有key生成一个Set</span></span><br><span class="line">Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独value序列，将所有value生成一个Collection</span></span><br><span class="line">Collection&lt;V&gt; <span class="title function_">values</span><span class="params">()</span>;  </span><br><span class="line"><span class="comment">// 清除哈希表中的所有键值对</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回哈希表中所有 键值对的数量 = 数组中的键值对 + 链表中的键值对</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断HashMap是否为空；size == 0时 表示为 空</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>; </span><br></pre></td></tr></table></figure>



<h1 id="HashMap的属性"><a href="#HashMap的属性" class="headerlink" title="HashMap的属性"></a>HashMap的属性</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认初始容量 - 必须是 2 的幂。，通过位移运算得到是16.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最大容量，在两个带参数的构造函数中的任何一个隐式指定更高的值时使用。 必须是 2 的幂 &lt;= 1&lt;&lt;30。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在构造函数中未指定时使用的负载因子。为什么是0.75 ，元素的空间利用率</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用树而不是列表的 bin 计数阈值。 将元素添加到至少具有这么多节点的 bin 时，bin 会转换为树。 该值必须大于 2 且至少应为 8，以与树移除中关于在收缩时转换回普通 bin 的假设相匹配。 （就是数组==&gt;树的阈值之一）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在调整大小操作期间取消（拆分）bin 的 bin 计数阈值。 应小于 TREEIFY_THRESHOLD，最多为 6 以在移除下进行收缩检测，（就是树==&gt;数组的阈值）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以将 bin 树化的最小表容量。 （否则，如果 bin 中的节点过多，则表将调整大小。） 应至少为 4 * TREEIFY_THRESHOLD，以避免调整大小和树化阈值之间发生冲突，（就是数组==&gt;树的阈值之一）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表，在第一次使用时初始化，并根据需要调整大小。 分配时，长度始终是 2 的幂。 （我们还在某些操作中容忍长度为零，以允许当前不需要的引导机制。）</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存缓存的 entrySet()。 请注意，AbstractMap 字段用于 keySet() 和 values()。</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此映射中包含的键值映射的数量。  也就是常用的 map.size() 返回的那个数，表示目前里面有多少个键值对</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该 HashMap 被结构修改的次数，该字段用于在 HashMap 的 Collection-views 上创建迭代器快速失败。 （请参阅 ConcurrentModificationException）</span></span><br><span class="line"><span class="keyword">transient</span> <span class="type">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要调整大小的下一个大小值（容量 * 负载因子）。</span></span><br><span class="line"><span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表的负载因子。其实就是前面的那个0.75f</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="无参构造函数"><a href="#无参构造函数" class="headerlink" title="无参构造函数"></a>无参构造函数</h2><p>如果不传入参数，则使用默认无参构造方法创建HashMap对象，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造一个具有默认初始容量 (16) 和默认负载因子 (0.75) 的空HashMap 。</span></span><br><span class="line"><span class="comment">// 这里就看出来了其实loadFactor 就是 0.75f</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 加载因子 &amp; 容量 = 默认 = 0.75、16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted 所有其他字段默认</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="带初始容量的构造函数"><a href="#带初始容量的构造函数" class="headerlink" title="带初始容量的构造函数"></a>带初始容量的构造函数</h2><p>传入参数，代表指定HashMap的初始容量；如果参数小于0，则抛出 IllegalArgumentException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">构造一个具有指定初始容量和默认负载因子 (0.75) 的空HashMap 。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">initialCapacity – 初始容量。</span></span><br><span class="line"><span class="comment">抛出：</span></span><br><span class="line"><span class="comment">IllegalArgumentException – 如果初始容量为负</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="带初始容量和负载因子的构造函数"><a href="#带初始容量和负载因子的构造函数" class="headerlink" title="带初始容量和负载因子的构造函数"></a>带初始容量和负载因子的构造函数</h2><p><strong>初始容量</strong></p>
<ul>
<li>如果初始容量小于0，则抛出 IllegalArgumentException。</li>
<li>如果初始容量大于最大容量时，设置初始容量等于最大容量</li>
</ul>
<p><strong>负载因子</strong></p>
<ul>
<li>如果负载因子为非正数， 则抛出 IllegalArgumentException。</li>
<li> 设置负载因子为0.75f</li>
</ul>
<p><strong>调整容量</strong></p>
<ul>
<li>要调整大小的下一个大小值（容量 * 负载因子）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">构造一个具有指定初始容量和负载因子的空HashMap 。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">initialCapacity – 初始容量</span></span><br><span class="line"><span class="comment">loadFactor – 负载因子</span></span><br><span class="line"><span class="comment">抛出：</span></span><br><span class="line"><span class="comment">IllegalArgumentException – 如果初始容量为负或负载因子为非正</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="comment">//如果初始容量小于0，则抛出 IllegalArgumentException。</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果初始容量大于最大容量时，设置初始容量等于最大容量</span></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果负载因子为非正数， 则抛出 IllegalArgumentException。</span></span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> + loadFactor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置负载因子为0.75f</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调整阈值</span></span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Float.isNaN 如果指定的数字是非数字 (NaN) 值，则返回true否则返回false 。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isNaN</span><span class="params">(<span class="type">float</span> v)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (v != v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看一下 <strong>tableSizeFor</strong> 方法</p>
<p>根据我们传入的容量计算一个大于等于该容量的最小的2的N次方，例如传 9，容量为2^4=16</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回给定目标容量的二次幂。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们先不看第一行“int n = cap - 1”，先看下面的5行计算。</p>
<p>|=（或等于）：例如：a |= b ，可以转成：a = a | b。或运算规则：0|0=0； 0|1=1； 1|0=1；  1|1=1；有1为1。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221049.png" alt="img"></p>
<p>&gt;&gt;&gt;（无符号右移）：例如 a &gt;&gt;&gt; b 指的是将 a 向右移动 b 指定的位数，右移后左边空出的位用零来填充，移出右边的位被丢弃。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221052.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n |= n &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 等同于 n = n | (n &gt;&gt;&gt; 1)</span></span><br></pre></td></tr></table></figure>

<p>假设 n 的值为 0010 0001，则该计算如下图：</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221106.jpeg" alt="img"></p>
<p>相信你应该看出来，这5个公式会通过最高位的1，拿到2个1、4个1、8个1、16个1、32个1。当然，有多少个1，取决于我们的入参有多大，但肯定的是经过这5个计算，得到的值是一个低位全是1的值，最后返回的时候 +1，则会得到一个比n 大的 2 的N次方。</p>
<p>这时再看开头的 cap - 1 就很简单了，这是为了处理 cap 本身就是 2 的N次方的情况。</p>
<p>计算机底层是二进制的，移位和或运算是非常快的，所以这个方法的效率很高。（对于<strong>移位、 或运算</strong>   等不明白的小伙伴，这一块可是要费点力气了）</p>
<h2 id="带Map的构造函数"><a href="#带Map的构造函数" class="headerlink" title="带Map的构造函数"></a>带Map的构造函数</h2><p>使用与指定Map相同的映射构造一个新的HashMap 。 </p>
<p>新的HashMap是使用默认负载因子 (0.75) 创建的，初始容量足以在指定的Map 中保存映射。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用指定的map 创建新map</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认的负载因子 0.75f</span></span><br><span class="line">    <span class="built_in">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="putMapEntries"><a href="#putMapEntries" class="headerlink" title="putMapEntries"></a>putMapEntries</h3><p>下面看一下 <strong>putMapEntries</strong> 方法， 该方法的作用：将传入的子Map中的全部元素逐个添加到HashMap中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    <span class="comment">// 得到新传进来的m的大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> m.size();</span><br><span class="line">    <span class="comment">// 判断大小是否大于0</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断当前哈希表是否为null</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="literal">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">//计算容量 当前（当前m的大小/负载因子 = 最大容量） 然后在加一 得到m最大的容量</span></span><br><span class="line">            <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> ((<span class="type">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="comment">//判断传入的m的最大容量是否小于允许最大容量值，得到最终容量值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> ((ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="type">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">//判断容量t是否大于当前map 的阈值，</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                <span class="comment">// 重新计算得到一个大于等于t 的最小的2次幂，说白了就是调整map的阈值。</span></span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//传进来的m大小 大于当前 map 的阈值时，需要扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            <span class="comment">// 扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历传入的m，取出每一个键值对，存入当前map中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? <span class="keyword">extends</span> <span class="title class_">K</span>, ? <span class="keyword">extends</span> <span class="title class_">V</span>&gt; e : m.entrySet()) &#123;</span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resize-扩容"><a href="#resize-扩容" class="headerlink" title="resize 扩容"></a>resize 扩容</h3><p>下面看一下 <strong>resize</strong>  方法，面试时最经常问的hashmap扩容机制就在这个地方，注意<code>newCap = oldCap &lt;&lt; 1</code>这句，扩容就在这，扩大两倍。</p>
<p>下面看一下resize 的源码，注释基本写的很明白了。按照我自己的理解写的。如有不对的，欢迎指正。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 先创建一个临时变量，存储当前的table</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//获取原来的table的长度（大小）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 创建临时变量存储旧的阈值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="comment">// 创建新容量、阈值，默认都是0</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断旧容量是否大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断旧容量大于等于 允许的最大值，2^30</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 设置当前阈值为Integer的最大值。2^31-1</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">// 返回旧table</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置新容量是旧容量的两倍，新容量是否小于允许的最大值，旧容量是否大于默认的16.</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 设置新阈值是旧阈值的两倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 阈值翻倍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断旧阈值是否大于0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 旧容量和旧阈值都不大于0，则使用默认的大小和容量</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 设置新容量为默认容量16</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 设置新阈值为 负载因子0.75f * 默认容量 16 = 12;</span></span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新阈值 等于 0</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 临时阈值 = 新容量 * 负载因子0.75f </span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">// 设置新的阈值</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新map的阈值字段</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建新的table键值对，容量是刚刚确定的新容量</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将map 的table指向新table</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 旧table不为null</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历oldTab，取出每一个键值对，存入到新table,这里的 ++j  其实和j++没区别。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 创建一个临时变量指向oldTab中的第j个键值对，</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 将置为null，释放内存，方便gc</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果当前e 没有第二个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 计算新表的索引位置，直接该位置</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 判断当前的e是不是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 将 node 转为 treeNode，之所以能转换是因为 treeNode 是 node 的子类</span></span><br><span class="line">                    <span class="comment">// 拆分树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当前节不是红黑树，不是null，并且还有下一个元素。此时为链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 链表优化重hash的代码块</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 取出来该链表中的所有节点，</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 如果计算得到的是0，则新表索引位置为“原索引位置” </span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//此时loTail为null，意味着lo链表还没有元素，</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                <span class="comment">// loHead指向e，也就是设置第一个元素</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="comment">// lo链表追加</span></span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">// 赋值</span></span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 计算得到的索引不是0，则新表索引位置为“原索引 + oldCap 位置</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);<span class="comment">// 后移</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//不为null，表示新表索引位置为“原索引位置”</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 设置loTail为最后一个节点</span></span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 放入新数组中</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 新表索引位置为“原索引 + oldCap 位置”</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整体的resize方法，也就是扩容逻辑如下图</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221136.png" alt="img"></p>
<p>个人认为resize方法中有几个点需要注意：</p>
<ul>
<li><p>一个是计算新索引的位置（e.hash &amp; oldCap），</p>
</li>
<li><p>另一个是红黑树的处理（split）。</p>
</li>
</ul>
<h3 id="e-hash-amp-oldCap-0-的解释"><a href="#e-hash-amp-oldCap-0-的解释" class="headerlink" title="e.hash &amp; oldCap == 0 的解释"></a>e.hash &amp; oldCap == 0 的解释</h3><p><strong>我们来看一下为什么红黑树和链表都是通过 e.hash &amp; oldCap == 0 来定位在新表的索引位置？</strong></p>
<p>为什么是e.hash &amp; oldCap 得到索引位置呢，因为在put 的时候 (n - 1) &amp; hash 得到索引位置</p>
<p>举个例子，扩容前 table 的容量n为16，a 节点和 b 节点在扩容前处于同一索引位置。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221142.png" alt="img"></p>
<p>扩容后，table 长度n为32，新表的 n - 1 只比老表的 n - 1 在高位多了一个1（图中标红的1）。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221146.png" alt="img"></p>
<p>因为 2 个节点在老表是同一个索引位置，因此计算新表的索引位置时，只取决于新表在高位多出来的这一位（图中标红1），而这一位的值刚好等于 oldCap。</p>
<p>因此会存在两种情况：1）  (e.hash &amp; oldCap) == 0 ，则新表索引位置为“原索引位置” ；2）(e.hash &amp; oldCap) != 0，则新表索引位置为”原索引 + oldCap 位置”。</p>
<p>还不理解的话 网上还有一个说明，讲的比较详细的。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221151.png" alt="在这里插入图片描述"></p>
<h3 id="split-红黑树的拆分"><a href="#split-红黑树的拆分" class="headerlink" title="split 红黑树的拆分"></a>split 红黑树的拆分</h3><p><strong>再看一下红黑树的处理（split）。</strong></p>
<p>这一块难点就是 低位红黑树和高位红黑树的处理，至于(e.hash &amp; bit) == 0 这个刚刚已经讲过是为什么了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将红黑中的节点拆分为较高位红黑树和低位红黑树，或者如果树现在太小，则取消树化</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> index 当前红黑树所在位置</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> bit   数组容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> index, <span class="type">int</span> bit)</span> &#123;</span><br><span class="line">    <span class="comment">//获得调用此方法的节点b</span></span><br><span class="line">    TreeNode&lt;K,V&gt; b = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 重新链接到 lo 和 hi 列表，保留顺序</span></span><br><span class="line">    <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">    TreeNode&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>; <span class="comment">// 存储索引位置为:“原索引位置”的节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>; <span class="comment">// 存储索引位置为:“原索引+oldCap”的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//lc 低位红黑树的节点数，hc 高位红黑树的节点数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">lc</span> <span class="operator">=</span> <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从节点b开始，遍历整个红黑树节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="literal">null</span>; e = next) &#123;</span><br><span class="line">        <span class="comment">// next赋值为e的下个节点</span></span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)e.next; </span><br><span class="line">        <span class="comment">// 得到e的next后，将e的next指向null 以便垃圾收集器回收</span></span><br><span class="line">        e.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意此处&amp;运算的数组容量没有-1</span></span><br><span class="line">        <span class="comment">//那么数组的容量值二进制表达必定为：1000...，所以此处计算只有两个结果，1或者0</span></span><br><span class="line">        <span class="comment">//0：TreeNode在新数组的位置是原位置，1：原位置加上旧数组容量值的位置</span></span><br><span class="line">        <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//将loTail节点变成e节点的前节点，</span></span><br><span class="line">            <span class="comment">//若loTail节点不存在，代表该节点为第一个节点</span></span><br><span class="line">            <span class="keyword">if</span> ((e.prev = loTail) == <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">//将e节点赋值给loHead节点，loHead指向第一个节点</span></span><br><span class="line">                loHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//存在则将e节点赋值给loTail的后节点</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">            <span class="comment">//将e节点赋值给loTail节点</span></span><br><span class="line">            loTail = e;</span><br><span class="line">            <span class="comment">//计算低位红黑树的节点数</span></span><br><span class="line">            ++lc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以下操作和上方操作一样</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.prev = hiTail) == <span class="literal">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">            hiTail = e;</span><br><span class="line">            ++hc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果低位红黑树存在</span></span><br><span class="line">    <span class="keyword">if</span> (loHead != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果低位红黑树节点小于等于红黑树瓦解阈值6，</span></span><br><span class="line">        <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            <span class="comment">// 低位红黑树转为链表</span></span><br><span class="line">            tab[index] = loHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则将低位红黑树根节点放到数组上</span></span><br><span class="line">            tab[index] = loHead;</span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) <span class="comment">// (else is already treeified) 不存在则说明原先的节点都在当前红黑树上。不用变化</span></span><br><span class="line">                <span class="comment">//如果高位红黑树存在，则将低位红黑树重新树化，</span></span><br><span class="line">                <span class="comment">// 虽然当前已经是红黑树了，但是节点改变了，所以要重新再来一遍，梳理节点</span></span><br><span class="line">                loHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//以下操作与上方操作一样</span></span><br><span class="line">    <span class="keyword">if</span> (hiHead != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">            tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tab[index + bit] = hiHead;</span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="literal">null</span>)</span><br><span class="line">                hiHead.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上对红黑树的处理 涉及到 树化 和 反树化 ，也就是链表和红黑树的互相转换，下面我们来看一下树化的代码</p>
<h3 id="treeify"><a href="#treeify" class="headerlink" title="treeify"></a>treeify</h3><p>链表转红黑树，参数为HashMap的元素数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形成从此节点链接的树。 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; root = <span class="literal">null</span>; <span class="comment">// 定义树的根节点</span></span><br><span class="line">    <span class="comment">// 遍历链表，x指向当前节点、next指向下一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="built_in">this</span>, next; x != <span class="literal">null</span>; x = next) &#123; </span><br><span class="line">        next = (TreeNode&lt;K,V&gt;)x.next; <span class="comment">// 下一个节点</span></span><br><span class="line">        x.left = x.right = <span class="literal">null</span>; <span class="comment">// 设置当前节点的左右节点为空</span></span><br><span class="line">        <span class="comment">// 如果还没有根节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.parent = <span class="literal">null</span>; <span class="comment">// 当前节点的父节点设为空</span></span><br><span class="line">            x.red = <span class="literal">false</span>; <span class="comment">// 当前节点的红色属性设为false（把当前节点设为黑色）</span></span><br><span class="line">            root = x; <span class="comment">// 根节点指向到当前节点（当前节点设置为根节点）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经存在根节点了</span></span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="type">K</span> <span class="variable">k</span> <span class="operator">=</span> x.key; <span class="comment">// 取得当前链表节点的key</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> x.hash; <span class="comment">// 取得当前链表节点的hash值</span></span><br><span class="line">            Class&lt;?&gt; kc = <span class="literal">null</span>; <span class="comment">// 定义key所属的Class</span></span><br><span class="line">            <span class="comment">// 从根节点开始遍历，此遍历没有设置边界，只能从内部跳出</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123; </span><br><span class="line">                <span class="comment">// GOTO1</span></span><br><span class="line">                <span class="comment">// dir 标识方向（左右）、ph标识当前树节点的hash值</span></span><br><span class="line">                <span class="type">int</span> dir, ph; </span><br><span class="line">                <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="comment">// 当前树节点的key</span></span><br><span class="line">                <span class="comment">// 如果当前树节点hash值 大于 当前链表节点的hash值</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h) </span><br><span class="line">                    dir = -<span class="number">1</span>; <span class="comment">// 标识当前链表节点会放到当前树节点的左侧</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>; <span class="comment">// 右侧</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果两个节点的key的hash值相等，那么还要通过其他方式再进行比较</span></span><br><span class="line"><span class="comment">                 * 如果当前链表节点的key实现了comparable接口，</span></span><br><span class="line"><span class="comment">                 * 并且当前树节点和链表节点是相同Class的实例，那么通过comparable的方式再比较两者。</span></span><br><span class="line"><span class="comment">                 * 如果还是相等，最后再通过tieBreakOrder比较一次</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                            (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                            (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line"> </span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p; <span class="comment">// 保存当前树节点</span></span><br><span class="line"> </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 如果dir 小于等于0 ： 当前链表节点一定放置在当前树节点的左侧，但不一定是该树节点的左孩子，也可能是左孩子的右孩子 或者 更深层次的节点。</span></span><br><span class="line"><span class="comment">                 * 如果dir 大于0 ： 当前链表节点一定放置在当前树节点的右侧，但不一定是该树节点的右孩子，也可能是右孩子的左孩子 或者 更深层次的节点。</span></span><br><span class="line"><span class="comment">                 * 如果当前树节点不是叶子节点，那么最终会以当前树节点的左孩子或者右孩子 为 起始节点  再从GOTO1 处开始 重新寻找自己（当前链表节点）的位置</span></span><br><span class="line"><span class="comment">                 * 如果当前树节点就是叶子节点，那么根据dir的值，就可以把当前链表节点挂载到当前树节点的左或者右侧了。</span></span><br><span class="line"><span class="comment">                 * 挂载之后，还需要重新把树进行平衡。平衡之后，就可以针对下一个链表节点进行处理了。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    x.parent = xp; <span class="comment">// 当前链表节点 作为 当前树节点的子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x; <span class="comment">// 作为左孩子</span></span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x; <span class="comment">// 作为右孩子</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 进行红黑树的插入平衡(通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求)</span></span><br><span class="line">                    root = balanceInsertion(root, x); </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 把所有的链表节点都遍历完之后，最终构造出来的树可能经历多个平衡操作，根节点目前到底是链表的哪一个节点是不确定的</span></span><br><span class="line">    <span class="comment">// 因为我们要基于树来做查找， 确保给定的根是其 tab 的第一个节点。</span></span><br><span class="line">    moveRootToFront(tab, root); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tieBreakOrder"><a href="#tieBreakOrder" class="headerlink" title="tieBreakOrder"></a>tieBreakOrder</h3><p>比较a和b的大小，-1：a&lt;=b；1：a&gt;b</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">tieBreakOrder</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span> || (d = a.getClass().getName().compareTo(b.getClass().getName())) == <span class="number">0</span>)&#123;</span><br><span class="line">        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="balanceInsertion"><a href="#balanceInsertion" class="headerlink" title="balanceInsertion"></a>balanceInsertion</h3><p>红黑树的插入平衡(通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 红黑树的插入平衡(通过左旋、右旋和改变节点颜色来保证当前树符合红黑树的要求</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    x.red = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 从内部终止循环</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;</span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="literal">null</span> &amp;&amp; xppr.red) &#123;</span><br><span class="line">                xppr.red = <span class="literal">false</span>;</span><br><span class="line">                xp.red = <span class="literal">false</span>;</span><br><span class="line">                xpp.red = <span class="literal">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</span><br><span class="line">                    root = rotateLeft(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (xppl != <span class="literal">null</span> &amp;&amp; xppl.red) &#123;</span><br><span class="line">                xppl.red = <span class="literal">false</span>;</span><br><span class="line">                xp.red = <span class="literal">false</span>;</span><br><span class="line">                xpp.red = <span class="literal">true</span>;</span><br><span class="line">                x = xpp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</span><br><span class="line">                    root = rotateRight(root, x = xp);</span><br><span class="line">                    xpp = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.parent;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                    xp.red = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (xpp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xpp.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="moveRootToFront"><a href="#moveRootToFront" class="headerlink" title="moveRootToFront"></a>moveRootToFront</h3><p>该方法的作用是， 确保给定的根是其 tab 的第一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将root放到头节点的位置, 原头节点放在root的next节点上</span></span><br><span class="line"><span class="comment"> * 如果当前索引位置的头节点不是root节点, 则将root的上一个节点和下一个节点进行关联,</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">moveRootToFront</span><span class="params">(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; tab != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; root.hash;</span><br><span class="line">        TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">        <span class="keyword">if</span> (root != first) &#123;</span><br><span class="line">            Node&lt;K,V&gt; rn;</span><br><span class="line">            tab[index] = root;</span><br><span class="line">            TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">            <span class="keyword">if</span> ((rn = root.next) != <span class="literal">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">            <span class="keyword">if</span> (rp != <span class="literal">null</span>)</span><br><span class="line">                rp.next = rn;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">                first.prev = root;</span><br><span class="line">            root.next = first;</span><br><span class="line">            root.prev = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> <span class="title function_">checkInvariants</span><span class="params">(root)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="checkInvariants"><a href="#checkInvariants" class="headerlink" title="checkInvariants"></a>checkInvariants</h3><p>检查不变的节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">checkInvariants</span><span class="params">(TreeNode&lt;K,V&gt; t)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">        tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">    <span class="keyword">if</span> (tb != <span class="literal">null</span> &amp;&amp; tb.next != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tn != <span class="literal">null</span> &amp;&amp; tn.prev != t)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tp != <span class="literal">null</span> &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="literal">null</span> &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="literal">null</span> &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t.red &amp;&amp; tl != <span class="literal">null</span> &amp;&amp; tl.red &amp;&amp; tr != <span class="literal">null</span> &amp;&amp; tr.red)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tl != <span class="literal">null</span> &amp;&amp; !checkInvariants(tl))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (tr != <span class="literal">null</span> &amp;&amp; !checkInvariants(tr))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="untreeify"><a href="#untreeify" class="headerlink" title="untreeify"></a>untreeify</h3><p>将红黑树节点转为链表节点, 当节点&lt;=6个时会被触发。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将红黑树节点转为链表节点, 当节点&lt;=6个时会被触发</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>; <span class="comment">// hd指向头节点, tl指向尾节点</span></span><br><span class="line">    <span class="comment">// 从调用该方法的节点, 即链表的头节点开始遍历, 将所有节点全转为链表节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">        <span class="comment">// 调用replacementNode方法，将树节点构建成链表节点</span></span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 如果tl为null, 则代表当前节点为第一个节点, 将hd指向p</span></span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="comment">// 否则, 将尾节点的next指向当前节点p，也就是进行链表追加</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每次循环q都会后移一个，同理p也就是后移之后构建出来的链表节点</span></span><br><span class="line">        tl = p; <span class="comment">// 将tl节点指向链表节点p, 即尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回转换后的链表的头节点</span></span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建链表节点</span></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><p>jdk1.7和jdk1.8的区别</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221219.png" alt="img"></p>
<h2 id="put流程图"><a href="#put流程图" class="headerlink" title="put流程图"></a>put流程图</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221222.png" alt="img"></p>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><p>将指定的键值对添加到map中，真正初始化哈希表（初始化存储数组table）的时候就在第1次添加键值对时，即第1次调用put()时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="hash-–-计算-key-的-hash-值"><a href="#hash-–-计算-key-的-hash-值" class="headerlink" title="hash – 计算 key 的 hash 值"></a>hash – 计算 key 的 hash 值</h2><p>拿到 key 的 hashCode，并将 hashCode 的高16位和 hashCode 进行异或（XOR）运算，得到最终的 hash 值。</p>
<p> 该函数在JDK 1.7 和 1.8 中的实现不同，但原理一样 = 扰动函数 = 使得根据key生成的哈希码（hash值）分布更加均匀、更具备随机性，避免出现hash值冲突（即指不同key但生成同1个hash值）     </p>
<p>JDK 1.7 做了9次扰动处理（4次位运算 + 5次异或运算）</p>
<p>JDK 1.8 简化了扰动函数 , 只做了2次扰动（1次位运算 + 1次异或运算）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JDK 1.7实现：将 键key 转换成 哈希码（hash值）操作  = 使用hashCode() + 4次位运算 + 5次异或运算（9次扰动）</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    h ^= k.hashCode(); </span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// JDK 1.8实现：将 键key 转换成 哈希码（hash值）操作 = 使用hashCode() + 1次位运算 + 1次异或运算（2次扰动）</span></span><br><span class="line"><span class="comment">// 1. 取hashCode值： h = key.hashCode() </span></span><br><span class="line"><span class="comment">// 2. 高位参与低位的运算：h ^ (h &gt;&gt;&gt; 16)  </span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    <span class="comment">// a. 当key = null时，hash值 = 0，所以HashMap的key 可为null      </span></span><br><span class="line">    <span class="comment">// 注：对比HashTable，HashTable对key直接hashCode（），若key为null时，会抛出异常，所以HashTable的key不可为null</span></span><br><span class="line">    <span class="comment">// b. 当key ≠ null时，则通过先计算出 key的 hashCode()（记为h），然后 对哈希码进行 扰动处理： 按位 异或（^） 哈希码自身右移16位后的二进制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221228.png" alt="img"></p>
<h2 id="hash常见疑惑"><a href="#hash常见疑惑" class="headerlink" title="hash常见疑惑"></a>hash常见疑惑</h2><p><strong>为什么要将 hashCode 的高16位参与运算？</strong></p>
<p>例如下图，在 table 的长度较小的时候，此处等于8。如果不加入高位运算，由于 n - 1 是 0000 0111，所以结果只取决于 hash 值的低3位，无论高位怎么变化，索引计算结果都是一样的。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221234.png" alt="img"></p>
<p>如果我们将高位参与运算，则索引计算结果就不会仅取决于低位。索引冲突的情况就会大大减少</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221239.png" alt="img"></p>
<p><strong>为什么不直接采用经过hashCode（）处理的哈希码 作为 存储数组table的下标位置？</strong></p>
<ul>
<li>结论：容易出现 哈希码 与 数组大小范围不匹配的情况，即 计算出来的哈希码可能 不在数组大小范围内，从而导致无法匹配存储位置</li>
</ul>
<p>原因描述</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221247.png" alt="img"></p>
<p><strong>为什么采用 哈希码 与运算(&amp;) （数组长度-1） 计算数组下标？</strong></p>
<ul>
<li>结论：根据HashMap的容量大小（数组长度），按需取 哈希码一定数量的低位 作为存储的数组下标位置，从而 解决 “哈希码与数组大小范围不匹配” 的问题</li>
<li>具体解决方案描述</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221254.png" alt="img"></p>
<p><strong>为什么在计算数组下标前，需对哈希码进行二次处理：扰动处理？</strong></p>
<ul>
<li>结论：加大哈希码低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性 &amp; 均匀性，最终减少Hash冲突</li>
</ul>
<h2 id="putVal"><a href="#putVal" class="headerlink" title="putVal"></a>putVal</h2><p>put的真正存放逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现 Map.put 及相关方法</span></span><br><span class="line"><span class="comment"> * 参数：</span></span><br><span class="line"><span class="comment"> * hash – 密钥的散列</span></span><br><span class="line"><span class="comment"> * 钥匙——钥匙</span></span><br><span class="line"><span class="comment"> * value – 要放置的值</span></span><br><span class="line"><span class="comment"> * onlyIfAbsent – 如果为真，则不更改现有值</span></span><br><span class="line"><span class="comment"> * evict – 如果为 false，则表处于创建模式。</span></span><br><span class="line"><span class="comment"> * 返回：</span></span><br><span class="line"><span class="comment"> * 以前的值，如果没有，则为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tab是当前table数组, n 是tab数组的长度，i为数组索引，p为数组索引i位置的节点</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 若哈希表的数组tab为空，则 通过resize() 创建,</span></span><br><span class="line">    <span class="comment">//所以，初始化哈希表的时机是第1次调用put函数时，初始化创建</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 计算数组索引i = (n - 1) &amp; hash，即插入数组的位置。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取到i位置的节点p，判断是否存在。</span></span><br><span class="line">    <span class="comment">// 若p为null，表示当前位置没有元素，则直接在该数组位置新建节点，插入完毕</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)&#123;</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p！=null，当前i位置有元素，此时发生了Hash冲突，需要在继续判断</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// e 临时存储当前节点p，k 当前节点p的key</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a. 若p节点的hash和key与新元素hash和key相同，就用e节点临时存储下p节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">            e = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// b. 若p节点是红黑树，则直接在树中插入或者更新键值对</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value); -&gt;&gt;分析<span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// c. 若p节点是链表,则在链表中插入 or 更新键值对</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// d. 从p结点的下一个节点开始遍历链表，</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 先将 e 指向p节点的下一个节点，再判断p节点是不是链表的最后一个节点，</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 进入到这里说明循环到最后一个节点了也没找到与新数据key相同的节点。</span></span><br><span class="line">                    <span class="comment">// 将新数据使用尾插入追加到p节点后面</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 插入节点后，判断是否需要链表转红黑树，</span></span><br><span class="line">                    <span class="comment">// 链表元素数大于8才转，因为这里是从第二个节点开始的，所以 TREEIFY_THRESHOLD - 1 = 7 ，又因为binCount是从0开始的，所以用的是&gt;=号。</span></span><br><span class="line">                    <span class="comment">// 例如bigCount=7，表示循环了进行了7次，加上原来的那个头节点，表示该链表原先有8个节点，然后新元素又进行了尾插入，此时该链表就有9个元素了，所以此时就得树化操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash); <span class="comment">// 树化操作</span></span><br><span class="line">                    <span class="comment">// 终止循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历链表的key找到与新数据key相同的节点，然后终止循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 本轮循环没找到与新数据key相同的节点，则节点后移，进行下次循环</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对d情况的后续操作：e != null 表示key已存在，直接用新value 覆盖 旧value &amp; 返回旧value</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">//此处onlyIfAbsent 是固定值 false，所以这个if是必进入的</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 直接用新value 覆盖 旧value &amp; 返回旧value</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            afterNodeAccess(e); <span class="comment">// 替换旧值时会调用的方法（默认实现为空）</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录该map被修改的次数，主要用于多线程并发时候</span></span><br><span class="line">    ++modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入成功后，若实际存在的键值对数量size &gt; 扩容阈值threshold 则进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)&#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    afterNodeInsertion(evict);<span class="comment">// 插入成功时会调用的方法（默认实现为空）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="putTreeVal"><a href="#putTreeVal" class="headerlink" title="putTreeVal"></a>putTreeVal</h2><p>向红黑树插入 or 更新数据（键值对），遍历红黑树，找到与新数据key相同的节点，新数据value替换旧数据的value，找不到相同的key则创建新节点并插入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">红黑树的put操作，红黑树插入会同时维护原来的链表属性, 即原来的next属性</span></span><br><span class="line"><span class="comment">map:当前调用该方法的对象实例，也就是当前map</span></span><br><span class="line"><span class="comment">tab：当前map里的数组，</span></span><br><span class="line"><span class="comment">h:新数据的key计算出来的hash，</span></span><br><span class="line"><span class="comment">k：新数据的key，</span></span><br><span class="line"><span class="comment">v：新数据的value </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="type">int</span> h, K k, V v)</span> &#123;</span><br><span class="line">    Class&lt;?&gt; kc = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 是否调用find方法进行查找，默认没调用</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">searched</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 查找根节点, 索引位置的头节点并不一定为红黑树的根节点，</span></span><br><span class="line">    <span class="comment">// 此处的this就是调用该方法的TreeNode实例，</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将根节点赋值给p节点，从根节点开始遍历红黑树，从内部终止遍历</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">        <span class="comment">//dir：表示向哪个子树查找，-1左，1右； ph：当前树节点的hash，pk：当前树节点的key</span></span><br><span class="line">        <span class="type">int</span> dir, ph; K pk;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前节点p的hash赋值给ph，</span></span><br><span class="line">        <span class="comment">// 并且新数据的hash小于当前树节点的hash，则向p的左子树查找</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            dir = -<span class="number">1</span>;<span class="comment">//dir赋值为-1，</span></span><br><span class="line">        <span class="comment">// 向p的右子树查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            dir = <span class="number">1</span>;<span class="comment">//dir赋值为1，</span></span><br><span class="line">        <span class="comment">// 当前树节点的key等于新数据的key，直接返回当前节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">// 如果k为null并且k所属的类没有实现Comparable接口 或者 k和p节点的key相等（dir==0）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                  (kc = comparableClassFor(k)) == <span class="literal">null</span>) ||</span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 还没有调用find方法进行查找</span></span><br><span class="line">            <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                searched = <span class="literal">true</span>;<span class="comment">// 改为已经调用find方法进行查找了，</span></span><br><span class="line">                <span class="comment">// 从p节点的左节点和右节点分别调用find方法进行查找, 如果查找到目标节点则并终止循环，返回q；</span></span><br><span class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>) ||</span><br><span class="line">                    ((ch = p.right) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                     (q = ch.find(h, k, kc)) != <span class="literal">null</span>))</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使用定义的一套规则来比较p节点的key和新数据的key大小, 用来决定向左还是向右查找</span></span><br><span class="line">            dir = tieBreakOrder(k, pk);<span class="comment">// dir&lt;0 则代表 k&lt;pk，则向p左边查找；反之亦然</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// x表示新元素构建出来的树节点</span></span><br><span class="line">        <span class="comment">// xp赋值为x的父节点,中间变量,用于下面给x的父节点赋值</span></span><br><span class="line">        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">        <span class="comment">// dir&lt;=0则向p左边查找,否则向p右边查找,如果为null,则代表该位置即为x的目标位置</span></span><br><span class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 走进来代表已经找到x的位置，只需将x放到该位置即可</span></span><br><span class="line">            Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">            <span class="comment">// 创建新的节点, 其中x的next节点为xpn, 即将x节点插入xp与xpn之间</span></span><br><span class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">            <span class="comment">// 调整x、xp、xpn之间的属性关系</span></span><br><span class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)   <span class="comment">// 如果时dir &lt;= 0, 则代表x节点为xp的左节点</span></span><br><span class="line">                xp.left = x;</span><br><span class="line">            <span class="keyword">else</span>        <span class="comment">// 如果时dir&gt; 0, 则代表x节点为xp的右节点</span></span><br><span class="line">                xp.right = x;</span><br><span class="line">            xp.next = x;    <span class="comment">// 将xp的next节点设置为x</span></span><br><span class="line">            x.parent = x.prev = xp; <span class="comment">// 将x的parent和prev节点设置为xp</span></span><br><span class="line">            <span class="comment">// 如果xpn不为空,则将xpn的prev节点设置为x节点,与上文的x节点的next节点对应</span></span><br><span class="line">            <span class="keyword">if</span> (xpn != <span class="literal">null</span>)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">            <span class="comment">// 进行红黑树的插入平衡调整</span></span><br><span class="line">            moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><p>查找红黑树的根节点，通过判断有没有父节点来找出根节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">root</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="built_in">this</span>, p;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>从调用此方法的节点开始查找, 通过hash值和key找到对应的节点。查找过程无非就是，比较hash，判断往左找还是往右找，特殊情况就是 一边为空 那就只往另一边找，比较key是否相等，相等就找到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从调用此方法的节点开始查找, 通过hash值和key找到对应的节点</span></span><br><span class="line"><span class="comment"> * 此方法是红黑树节点的查找, 红黑树是特殊的自平衡二叉查找树</span></span><br><span class="line"><span class="comment"> * 平衡二叉查找树的特点：左节点&lt;根节点&lt;右节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">find</span><span class="params">(<span class="type">int</span> h, Object k, Class&lt;?&gt; kc)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.将p节点赋值为调用此方法的节点，即为红黑树根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 2.从p节点开始向下遍历</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// ph p的hash，pk p的key</span></span><br><span class="line">        <span class="type">int</span> ph, dir; K pk;</span><br><span class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">        <span class="comment">// 3.如果传入的hash值小于p节点的hash值，则往p节点的左边遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">// 4.如果传入的hash值大于p节点的hash值，则往p节点的右边遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">// 5.如果传入的hash值和key值等于p节点的hash值和key值,则p节点为目标节点,返回p节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="literal">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">// 6.p节点的左节点为空则将向右遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="literal">null</span>)    </span><br><span class="line">            p = pr;</span><br><span class="line">        <span class="comment">// 7.p节点的右节点为空则向左遍历</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="literal">null</span>)    </span><br><span class="line">            p = pl;</span><br><span class="line">        <span class="comment">// 8.将p节点与k进行比较</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="literal">null</span> ||</span><br><span class="line">                  (kc = comparableClassFor(k)) != <span class="literal">null</span>) &amp;&amp; <span class="comment">// 8.1 kc不为空代表k实现了Comparable</span></span><br><span class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)<span class="comment">// 8.2 k&lt;pk则dir&lt;0, k&gt;pk则dir&gt;0</span></span><br><span class="line">            <span class="comment">// 8.3 k&lt;pk则向左遍历(p赋值为p的左节点), 否则向右遍历</span></span><br><span class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">        <span class="comment">// 9.代码走到此处, 代表key所属类没有实现Comparable, 向p的右边遍历查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        <span class="comment">// 10.代码走到此处代表上一步的向右边没找到“pr.find(h, k, kc)”为空, 因此向左遍历</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = pl;</span><br><span class="line">    &#125; <span class="keyword">while</span> (p != <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 没找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="treeifyBin"><a href="#treeifyBin" class="headerlink" title="treeifyBin"></a>treeifyBin</h2><p>将数组的某个索引里的链表转为红黑树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">将数组的某个索引里的链表转为红黑树</span></span><br><span class="line"><span class="comment">tab：数组</span></span><br><span class="line"><span class="comment">hash：新元素的hash值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="comment">// n：当前数组长度，index：hash经过计算得到的索引，e：index索引位置的元素</span></span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 当前数组为空或者当前数组长度小于数组转为红黑树的阈值64时，需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 计算得到索引index，并且取出来index索引对应的节点e，并且 e 不是null，</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="comment">// hd 存头节点，tl </span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从e节点开始遍历链表</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将链表节点e转红黑树节点p</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// 如果是第一次遍历，将头节点赋值给hd</span></span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="comment">// 如果不是第一次遍历，则处理当前节点的prev属性和上一个节点的next属性</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;    <span class="comment">// 当前节点的prev属性设为上一个节点</span></span><br><span class="line">                tl.next = p;    <span class="comment">// 上一个节点的next属性设置为当前节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将p节点赋值给tl，</span></span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>); <span class="comment">//后移，找下一个节点，再继续遍历</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将table该索引位置赋值为hd头节点，如果该节点不为空，则以头节点(hd)为根节点, 构建红黑树</span></span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For treeifyBin 将指定的链表节点转为树节点</span></span><br><span class="line">TreeNode&lt;K,V&gt; <span class="title function_">replacementTreeNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h1><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><p>根据指定的key，查找对应的value值，找不到返回null，后续操作geit的结果的时候一定要判断非null，否则会出现空指针异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getNode"><a href="#getNode" class="headerlink" title="getNode"></a>getNode</h2><p>根据key的hash和key，查找节点。找不到返回null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// tab：当前map的数组，first：当前hash对应的索引位置上的节点，e：遍历过程中临时存储的节点，</span></span><br><span class="line">    <span class="comment">// n：tab数组的长度，k：first节点的key</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.对table进行校验：table不为空 &amp;&amp; table长度大于0 &amp;&amp; </span></span><br><span class="line">    <span class="comment">// hash对应的索引位置上的节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断第一个节点是不是要找的元素，比较hash值和key是否和入参的一样，如果一样，直接返回第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个节点不是要找的元素，</span></span><br><span class="line">        <span class="comment">// 取出来第二个节点，并且第二个节点不为null，说明还没走到该节点链的最后</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果第一个节点是红黑树类型</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)&#123;</span><br><span class="line">                <span class="comment">// 调用红黑树的查找目标节点方法getTreeNode</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 前提条件：第一个节点不为null，并且也不是红黑树，而且还有下一个节点，那么该索引位置的元素类型就是链表，从第二个节点开始遍历该链表，</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 找到了，返回节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);<span class="comment">// e指针后移，并且下一个节点不为null则继续遍历，不为null表示没到链表最后呢</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="getTreeNode"><a href="#getTreeNode" class="headerlink" title="getTreeNode"></a>getTreeNode</h2><p>在红黑树中根据key和key的hash 查找对应的树节点，找不到返回null，这里要先找到根节点，然后从根节点再去查找树节点。root 和 find 方法之前已经讲解过了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">getTreeNode</span><span class="params">(<span class="type">int</span> h, Object k)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前调用该方法的红黑树节点还有父级节点，说明该红黑树节点不是根节点，所以需要调用 root() 方法找到根节点，</span></span><br><span class="line">    <span class="comment">// 如果当前调用该方法的红黑树节点没有父级节点，说明该红黑树节点就是根节点，</span></span><br><span class="line">    <span class="comment">// 找到根节点后，根节点调用find方法去查找目标节点</span></span><br><span class="line">    <span class="keyword">return</span> ((parent != <span class="literal">null</span>) ? root() : <span class="built_in">this</span>).find(h, k, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="判断key是否存在"><a href="#判断key是否存在" class="headerlink" title="判断key是否存在"></a>判断key是否存在</h1><h2 id="containsKey"><a href="#containsKey" class="headerlink" title="containsKey"></a>containsKey</h2><p>判断key是否存在，实际上调用的还是刚刚那个getNode，找到就返回ture，找不到返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="判断value是否存在"><a href="#判断value是否存在" class="headerlink" title="判断value是否存在"></a>判断value是否存在</h1><h2 id="containsValue"><a href="#containsValue" class="headerlink" title="containsValue"></a>containsValue</h2><p>根据给定的value查找当前map中是否有和value相同的节点，有的话返true，没有返回false；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="comment">// tab：当前map的数组，v：目标元素的value</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">    <span class="comment">// 首先判断当前数组不为null 并且 含有的元素大于0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历该数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tab.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 遍历数组中每个索引位置的的链表，并且该位置不为null，</span></span><br><span class="line">            <span class="comment">// 其实可以改成while循环的。不知为什么开发jdk的这帮人这么喜欢用for循环</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;K,V&gt; e = tab[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">                <span class="comment">// 如果节点的value与入参value相等，就直接返回true，return 会停止循环并且退出方法。</span></span><br><span class="line">                <span class="keyword">if</span> ((v = e.value) == value ||</span><br><span class="line">                    (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找不到则返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><h2 id="remove-Object-key"><a href="#remove-Object-key" class="headerlink" title="remove(Object key)"></a>remove(Object key)</h2><p>根据指定的key删除元素，若删除成功则返回被删除的元素的value，删除失败返回null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// 被删除的元素</span></span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode"></a>removeNode</h2><p>移除某个节点，根据指定的key hash 和另外的两个条件进行移除。</p>
<p>matchValue=true，表示仅在value相等时删除，=false，表示value不相等的时候也可以删除该节点。</p>
<p>HashMap.remove(key) 不去判断值相不相等。</p>
<p>HashMap.EntrySet.remove(key)、HashMap.remove(key,value)、LinkedHashMap.LinkedEntrySet.remove(key)需要判断value相不相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">移除某个节点，根据下面四个条件进行移除</span></span><br><span class="line"><span class="comment">hash - key 的hash值 </span></span><br><span class="line"><span class="comment">key - key</span></span><br><span class="line"><span class="comment">matchValue - 如果为真，则仅在值相等时删除</span></span><br><span class="line"><span class="comment">movable - 如果为false，则在删除时不移动其他节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    <span class="comment">// tab：当前map 的数组，p：hash对应的数组索引index位置上的节点，n：数组长度，index：hash对应的数组索引</span></span><br><span class="line">    <span class="comment">// 这几个值在hashMap的源码中很常见</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前提判断 数组不为空，并且长度大于0 并且</span></span><br><span class="line">    <span class="comment">// hash对应的数组索引位置上的节点p也不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// node：被移除的节点，e：当前头节点的下一个节点，k：e节点的key，v：被移除节点node 的value</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果第一个节点p就是目标节点，则将node指向第一个节点p</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))&#123;</span><br><span class="line">            node = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一个节点不是，那就看看第一个节点还有没有下一个元素。</span></span><br><span class="line">        <span class="comment">// 如果有第二个节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果刚刚第一个节点是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)&#123;</span><br><span class="line">                <span class="comment">// 调用红黑树的查询节点的方法，getTreeNode 已经在上文讲过了</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 第一个节点不是红黑树，并且还有第二个节点，那就说明，这里是链表了</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 那么开始循环链表，从第二个节点开始循环，因为第一个节点已经处理过了</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="comment">// 判断e节点是不是目标节点，是的话就将node指向e，并且终止循环</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// e节点不是目标节点，那就将p节点指向e节点，</span></span><br><span class="line">                    <span class="comment">// 然后while里面e节点后移，在进入循环后发现e是目标节点了，退出循环，退出后此时p节点还是e节点的前一个节点，也就保证了在整个循环的过程中，p节点始终是e节点的前一个节点。</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);<span class="comment">// e指针后移，并且下一个节点不为null则继续遍历，不为null表示没到链表最后呢。是不是似曾相识的感觉。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到目标节点了</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 如果目标节点是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)&#123;</span><br><span class="line">                <span class="comment">// 调用红黑树的删除节点方法</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 目标节点是p节点，</span></span><br><span class="line">            <span class="comment">// 还记得之前 如果第一个节点p就是目标节点，则将node指向第一个节点p</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)&#123;</span><br><span class="line">                <span class="comment">// 将目标节点的下一个节点作为该索引位置的第一个元素</span></span><br><span class="line">                <span class="comment">// 也就是跳过目标节点，指向目标节点的下一位</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里就是遍历链表找到了目标节点</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 注意 进入到这里 node 其实也是指向 e的，说白了 node 就是 e，下面用node来替代e的登场 </span></span><br><span class="line">                <span class="comment">// p节点始终作为node的上一个节点，p.next始终指向目标节点node</span></span><br><span class="line">                <span class="comment">// 现在将p.next 指向目标节点node的next，这样跳过了目标节点node，就把node移除掉了</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录map结构被修改的次数，主要用于并发编程</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">// 记录table存储了多少键值对，因为移除了一个，所以此处就减一，其实用size-- 也一样，不明白为啥非得用 --size</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">// 该方法在hashMap中是空方法，主要是供LinkedHashMap使用，因为LinkedHashMap重写了该方法</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="comment">//返回被移除的节点</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到 返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="removeTreeNode"><a href="#removeTreeNode" class="headerlink" title="removeTreeNode"></a>removeTreeNode</h2><p>红黑树的节点移除，还要根据movable判断删除时是否移动其他节点。谁调用该方法就删除谁，</p>
<p>movable - 如果为false，则在删除时不移动其他节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 红黑树的节点移除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">removeTreeNode</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span><br><span class="line"><span class="params">                          <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    <span class="comment">// --- 链表的处理start ---</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="comment">// 1.table为空或者length为0直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 2.根据调用者的hash计算出索引的位置，也就是 根据将要被移除的node节点的hash进行计算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (n - <span class="number">1</span>) &amp; hash;</span><br><span class="line">    <span class="comment">// 3.first：当前index位置的节点，root：当前index位置的节点，作为根节点，rl：root的左节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.succ：目标节点node.next节点，pred：目标节点node.prev节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">    <span class="comment">// 5.如果pred节点为空，则代表目标节点node为头节点，</span></span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 则将table索引位置和first都指向succ节点(node.next节点)</span></span><br><span class="line">        tab[index] = first = succ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.否则将pred的next属性指向succ节点(node.next节点)</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 这块有一点点饶，主要是因为他这个变量搞得，其实等同于 node.prev.next = node.next;</span></span><br><span class="line">        <span class="comment">// 原来是 pred.next=node-&gt;node.next=succ</span></span><br><span class="line">        <span class="comment">// 现在是 pred.next=      node.next=succ,跳过了node，也就相当于把node删除了</span></span><br><span class="line">        pred.next = succ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.如果succ节点(node.next节点)不为空，</span></span><br><span class="line">    <span class="keyword">if</span> (succ != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 则将succ.prev(node.next.prev)节点设置为pred(node.prev), 与前面对应</span></span><br><span class="line">        <span class="comment">// 等同于 node.next.prev = node.prev;</span></span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8.如果first节点为null，则代表该索引位置没有节点则直接返回</span></span><br><span class="line">    <span class="comment">// 这个if其实可以放在上方第3点后面，第4点前面，因为直接判断索引位置就是null，压根不用在找下个节点</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9.如果root的父节点不为空</span></span><br><span class="line">    <span class="keyword">if</span> (root.parent != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 则从该root节点开始去查找根节点，得到根节点之后，将root指向真正的根节点</span></span><br><span class="line">        root = root.root();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10.通过root节点来判断此红黑树是否太小, 如果是太小了则调用untreeify方法转为链表节点并返回</span></span><br><span class="line">    <span class="comment">// (转链表后就无需再进行下面的红黑树处理)</span></span><br><span class="line">    <span class="comment">// 太小的判定依据：根节点为null，或者根的右节点为null，或者根的左节点为null，或者根的左节点的左节点为null</span></span><br><span class="line">    <span class="comment">// 是根据节点数来判断的，并没有遍历整个红黑树去统计节点数是否小于等于阈值6</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.right == <span class="literal">null</span> ||</span><br><span class="line">        (rl = root.left) == <span class="literal">null</span> || rl.left == <span class="literal">null</span>) &#123;</span><br><span class="line">        tab[index] = first.untreeify(map);  <span class="comment">// too small</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// --- 链表的处理end ---</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 以下代码为红黑树的处理 ---</span></span><br><span class="line">    <span class="comment">// 11.p：目标节点node，pl：p的左节点，pr：p的右节点，replacement：被删除掉的节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; p = <span class="built_in">this</span>, pl = left, pr = right, replacement;</span><br><span class="line">    <span class="comment">// 12.如果p的左和右节点都不为空时</span></span><br><span class="line">    <span class="keyword">if</span> (pl != <span class="literal">null</span> &amp;&amp; pr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 12.1 将s指向pr(p的右节点)，sl：s的左节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">        <span class="comment">// 12.2 向左一直查找，跳出循环时,s为没有左节点的节点</span></span><br><span class="line">        <span class="keyword">while</span> ((sl = s.left) != <span class="literal">null</span>)&#123;</span><br><span class="line">            s = sl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 12.3 交换p节点和s节点的颜色</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> s.red; s.red = p.red; p.red = c;</span><br><span class="line">        TreeNode&lt;K,V&gt; sr = s.right; <span class="comment">// s的右节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;    <span class="comment">// p的父节点</span></span><br><span class="line">        <span class="comment">// --- 第一次调整和第二次调整：将p节点和s节点进行了位置调换 ---</span></span><br><span class="line">        <span class="comment">// 12.4 第一次调整</span></span><br><span class="line">        <span class="comment">// 如果p的右节点即为s节点，则将p和s交换位置，原先是s.parent = p；p.right = s；</span></span><br><span class="line">        <span class="keyword">if</span> (s == pr) &#123;</span><br><span class="line">            p.parent = s;</span><br><span class="line">            s.right = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将sp指向s的父节点</span></span><br><span class="line">            TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">            <span class="comment">// 将sp作为p的父节点</span></span><br><span class="line">            <span class="keyword">if</span> ((p.parent = sp) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果s节点为sp的左节点，则将sp的左节点指向p，此时sp的的左节点s变成了p节点</span></span><br><span class="line">                <span class="keyword">if</span> (s == sp.left)&#123;</span><br><span class="line">                    sp.left = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则s节点为sp的右节点，则将sp的右节点指向p，此时sp的的右节点s变成了p节点</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    sp.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 完成了p和s的交换位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// s的右节点指向p的右节点</span></span><br><span class="line">            <span class="keyword">if</span> ((s.right = pr) != <span class="literal">null</span>)</span><br><span class="line">                <span class="comment">// 如果pr不为空，则将pr的父节点指向s，此时p的右节点变成了s的右节点</span></span><br><span class="line">                pr.parent = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 12.5 第二次调整</span></span><br><span class="line">        <span class="comment">// 将p的左节点赋值为空，pl已经保存了该节点</span></span><br><span class="line">        p.left = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 将p节点的右节点指向sr，如果sr不为空，则将sr的父节点指向p节点，此时s的右节点变成了p的右节点</span></span><br><span class="line">        <span class="keyword">if</span> ((p.right = sr) != <span class="literal">null</span>)</span><br><span class="line">            sr.parent = p;</span><br><span class="line">        <span class="comment">// 将s节点的左节点赋值为pl，如果pl不为空，则将pl的父节点指向s节点，此时p的左节点变成了s的左节点</span></span><br><span class="line">        <span class="keyword">if</span> ((s.left = pl) != <span class="literal">null</span>)</span><br><span class="line">            pl.parent = s;</span><br><span class="line">        <span class="comment">// 将s的父节点赋值为p的父节点pp</span></span><br><span class="line">        <span class="comment">// 如果pp为空，则p节点为root节点, 交换后s成为新的root节点</span></span><br><span class="line">        <span class="keyword">if</span> ((s.parent = pp) == <span class="literal">null</span>)</span><br><span class="line">            root = s;</span><br><span class="line">        <span class="comment">// 如果p不为root节点, 并且p是pp的左节点，则将pp的左节点赋值为s节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = s;</span><br><span class="line">        <span class="comment">// 如果p不为root节点, 并且p是pp的右节点，则将pp的右节点赋值为s节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = s;</span><br><span class="line">        <span class="comment">// 12.6 寻找replacement节点，用来替换掉p节点</span></span><br><span class="line">        <span class="comment">// 12.6.1 如果sr不为空，则replacement节点为sr，因为s没有左节点，所以使用s的右节点来替换p的位置</span></span><br><span class="line">        <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">            replacement = sr;</span><br><span class="line">        <span class="comment">// 12.6.1 如果sr为空，则s为叶子节点，replacement为p本身，只需要将p节点直接去除即可</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            replacement = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 13.承接12点的判断，如果p的左节点不为空，右节点为空，replacement节点为p的左节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pl != <span class="literal">null</span>)</span><br><span class="line">        replacement = pl;</span><br><span class="line">    <span class="comment">// 14.如果p的右节点不为空,左节点为空，replacement节点为p的右节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pr != <span class="literal">null</span>)</span><br><span class="line">        replacement = pr;</span><br><span class="line">    <span class="comment">// 15.如果p的左右节点都为空, 即p为叶子节点, replacement节点为p节点本身</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        replacement = p;</span><br><span class="line">    <span class="comment">// 16.第三次调整：使用replacement节点替换掉p节点的位置，将p节点移除</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != p) &#123; <span class="comment">// 如果p节点不是叶子节点</span></span><br><span class="line">        <span class="comment">// 16.1 将p节点的父节点赋值给replacement节点的父节点, 同时赋值给pp节点</span></span><br><span class="line">        TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">        <span class="comment">// 16.2 如果p没有父节点, 即p为root节点，则将root节点赋值为replacement节点即可</span></span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="literal">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="comment">// 16.3 如果p不是root节点, 并且p为pp的左节点，则将pp的左节点赋值为替换节点replacement</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">            pp.left = replacement;</span><br><span class="line">        <span class="comment">// 16.4 如果p不是root节点, 并且p为pp的右节点，则将pp的右节点赋值为替换节点replacement</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = replacement;</span><br><span class="line">        <span class="comment">// 16.5 p节点的位置已经被完整的替换为replacement, 将p节点清空, 以便垃圾收集器回收</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 17.如果p节点不为红色则进行红黑树删除平衡调整</span></span><br><span class="line">    <span class="comment">// (如果删除的节点是红色则不会破坏红黑树的平衡无需调整)</span></span><br><span class="line">    TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 18.如果p节点为叶子节点, 则简单的将p节点去除即可</span></span><br><span class="line">    <span class="keyword">if</span> (replacement == p) &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">        <span class="comment">// 18.1 将p的parent属性设置为空</span></span><br><span class="line">        p.parent = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 18.2 如果p节点为父节点的左节点，则将父节点的左节点赋值为空</span></span><br><span class="line">            <span class="keyword">if</span> (p == pp.left)</span><br><span class="line">                pp.left = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 18.3 如果p节点为父节点的右节点， 则将父节点的右节点赋值为空</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == pp.right)</span><br><span class="line">                pp.right = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (movable)</span><br><span class="line">        <span class="comment">// 19.将root节点移到索引位置的头节点</span></span><br><span class="line">        moveRootToFront(tab, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="removeTreeNode-疑问"><a href="#removeTreeNode-疑问" class="headerlink" title="removeTreeNode 疑问"></a>removeTreeNode 疑问</h2><p>第一点：为什么 sr 是 replacement 的首选，p 为备选？</p>
<blockquote>
<p>解析：首先我们看 sr 是什么？从代码中可以看到 sr 第一次被赋值时，是在 s 节点进行了向左穷遍历结束后，因此此时 s 节点是没有左节点的，sr 即为 s 节点的右节点。而从上面的第一次调整和第二次调整我们知道，p 节点已经跟 s 节点进行了位置调换，所以此时 sr 其实是 p 节点的右节点，并且 p 节点没有左节点，因此要移除 p 节点，只需要将 p 节点的右节点 sr 覆盖掉 p 节点即可，因此 sr 是 replacement 的首选，而如果 sr 为空，则代表 p 节点为叶子节点，此时将 p 节点直接移除即可。</p>
</blockquote>
<p>第二点：关于红黑树的平衡调整？ 这点也是比较难的部分</p>
<blockquote>
<p>红黑树的操作涉及的操作比较复杂，三言两语无法说清。有兴趣的可以去单独学习，本文由于篇幅关系暂不详细介绍红黑树的具体操作，在这简单的介绍：红黑树是一种自平衡二叉树，拥有优秀的查询和插入/删除性能，广泛应用于关联数组。</p>
<p>对比 AVL 树，AVL 要求每个节点的左右子树的高度之差的绝对值（平衡因子）最多为 1，而红黑树通过适当的放低该条件（红黑树限制从根到叶子的最长的可能路径不多于最短的可能路径的两倍长，结果是这个树大致上是平衡的），以此来减少插入/删除时的平衡调整耗时，从而获取更好的性能，而这虽然会导致红黑树的查询会比 AVL 稍慢，但相比插入/删除时获取的时间，这个付出在大多数情况下显然是值得的。</p>
<p>在 HashMap 中的应用：HashMap 在进行插入和删除时有可能会触发红黑树的插入平衡调整（balanceInsertion 方法）或删除平衡调整（balanceDeletion 方法），调整的方式主要有以下手段：左旋转（rotateLeft 方法）、右旋转（rotateRight 方法）、改变节点颜色（x.red = false、x.red = true），进行调整的原因是为了维持红黑树的数据结构。</p>
</blockquote>
<h2 id="removeTreeNode-图解"><a href="#removeTreeNode-图解" class="headerlink" title="removeTreeNode 图解"></a>removeTreeNode 图解</h2><p>本图解忽略红黑树的颜色，请注意。</p>
<p>下面的图解是代码中的<strong>最复杂</strong>的情况，即流程最长的那个，p 节点不为根节点，p 节点有左右节点，s 节点不为 pr 节点，s 节点有右节点。</p>
<p>另外，第一次调整和第二次调整的是本人根据代码而设定的，将第一次和第二次调整合起来看会更容易理解（看第1和3两棵树）。</p>
<p>如下：第一次调整 + 第二次调整：将 p 节点和 s 节点进行了位置调换，选出要替换掉 p 节点的 replacement<br>第三次调整：将 replacement 节点覆盖掉 p 节点。</p>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221316.png" alt="img"></p>
<h2 id="balanceDeletion"><a href="#balanceDeletion" class="headerlink" title="balanceDeletion"></a>balanceDeletion</h2><p>红黑树的删除平衡调整，第一个输入参数是整棵红黑树的根节点，第二个输入参数是待删除节点或是其继承者，搞清楚了输入参数，下面我们就开始分析丧心病狂的balanceDeletion方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">balanceDeletion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span><br><span class="line"><span class="params">                                           TreeNode&lt;K,V&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">//注意，传进来的x节点子树的黑节点数，肯定是比x的兄弟节点子树的黑节点数少1</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span> || x == root)<span class="comment">//如果x是root</span></span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xp = x.parent) == <span class="literal">null</span>) &#123;<span class="comment">//（说明是循环后更新x后，使得x指向了root）但x没有父节点</span></span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x.red) &#123;<span class="comment">//如果x不是root(有父节点)，且x为红色（这好办，直接把x变成黑色，让x子树的黑节点+1.多次循环可到达此分支）</span></span><br><span class="line">            x.red = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接下来两个分支，x必为黑色</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((xpl = xp.left) == x) &#123;<span class="comment">//如果x是xp的左孩子</span></span><br><span class="line">            <span class="keyword">if</span> ((xpr = xp.right) != <span class="literal">null</span> &amp;&amp; xpr.red) &#123;</span><br><span class="line">                xpr.red = <span class="literal">false</span>;</span><br><span class="line">                xp.red = <span class="literal">true</span>;</span><br><span class="line">                root = rotateLeft(root, xp);</span><br><span class="line">                xpr = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (xpr == <span class="literal">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                <span class="keyword">if</span> ((sr == <span class="literal">null</span> || !sr.red) &amp;&amp;</span><br><span class="line">                    (sl == <span class="literal">null</span> || !sl.red)) &#123;</span><br><span class="line">                    xpr.red = <span class="literal">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sr == <span class="literal">null</span> || !sr.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sl != <span class="literal">null</span>)</span><br><span class="line">                            sl.red = <span class="literal">false</span>;</span><br><span class="line">                        xpr.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateRight(root, xpr);</span><br><span class="line">                        xpr = (xp = x.parent) == <span class="literal">null</span> ?</span><br><span class="line">                            <span class="literal">null</span> : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpr != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xpr.red = (xp == <span class="literal">null</span>) ? <span class="literal">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sr = xpr.right) != <span class="literal">null</span>)</span><br><span class="line">                            sr.red = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="literal">false</span>;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// symmetric//如果x是xp的右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (xpl != <span class="literal">null</span> &amp;&amp; xpl.red) &#123;</span><br><span class="line">                xpl.red = <span class="literal">false</span>;</span><br><span class="line">                xp.red = <span class="literal">true</span>;</span><br><span class="line">                root = rotateRight(root, xp);</span><br><span class="line">                xpl = (xp = x.parent) == <span class="literal">null</span> ? <span class="literal">null</span> : xp.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//经过上面if，不管它有没有执行，x的兄弟xpl肯定为黑色节点了</span></span><br><span class="line">            <span class="keyword">if</span> (xpl == <span class="literal">null</span>)</span><br><span class="line">                x = xp;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                <span class="comment">//这种情况说明xpl的孩子里没有红色节点</span></span><br><span class="line">                <span class="keyword">if</span> ((sl == <span class="literal">null</span> || !sl.red) &amp;&amp;</span><br><span class="line">                    (sr == <span class="literal">null</span> || !sr.red)) &#123;</span><br><span class="line">                    xpl.red = <span class="literal">true</span>;</span><br><span class="line">                    x = xp;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;<span class="comment">//这种情况说明xpl的孩子里有红色节点</span></span><br><span class="line">                    <span class="comment">//如果sr为红色，则走此分支；sr其他情况则不会</span></span><br><span class="line">                    <span class="keyword">if</span> (sl == <span class="literal">null</span> || !sl.red) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sr != <span class="literal">null</span>)</span><br><span class="line">                            sr.red = <span class="literal">false</span>;</span><br><span class="line">                        xpl.red = <span class="literal">true</span>;</span><br><span class="line">                        root = rotateLeft(root, xpl);</span><br><span class="line">                        xpl = (xp = x.parent) == <span class="literal">null</span> ?</span><br><span class="line">                            <span class="literal">null</span> : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xpl != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//xpl最终会旋转到之前xp的位置，并保持xp的颜色</span></span><br><span class="line">                        xpl.red = (xp == <span class="literal">null</span>) ? <span class="literal">false</span> : xp.red;</span><br><span class="line">                        <span class="keyword">if</span> ((sl = xpl.left) != <span class="literal">null</span>)</span><br><span class="line">                            sl.red = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (xp != <span class="literal">null</span>) &#123;</span><br><span class="line">                        xp.red = <span class="literal">false</span>;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                    &#125;</span><br><span class="line">                    x = root;<span class="comment">//下一次循环直接返回</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>提前说明一下，当说到“x节点子树的黑节点数n”是指：从x节点到它的子树的任意一个叶子节点的路径上的黑色节点个数都等于n。</li>
<li>整个函数是一个循环过程，可能会经过若干次循环。不管是刚调用此函数的第一次循环，或者是以后的循环，每次循环体刚开始时，x节点子树的黑节点数，肯定是比x的兄弟节点子树的黑节点数少1，这是由removeTreeNode函数来做保证的（由于删掉了一个黑色节点，所以黑节点数少1）。<strong>既然知道了x的黑节点数，比x的兄弟节点饿黑节点数少1，那么就需要通过调整来使得平衡。</strong></li>
<li><code>if (x == null || x == root)</code>分支，如果x是root，则直接返回root。上一次循环执行了<code>x = root</code>后，会进入此分支。</li>
<li><code>else if ((xp = x.parent) == null)</code>分支，x的父节点xp为null，但xp为null说明x为root，但这样的话则只会进入上面的<code>if (x == null || x == root)</code>分支了，所以我认为此分支不可能进入。</li>
<li><code>else if (x.red)</code>分支，说明x不是root节点，且x为红色。这好办，直接把x变成黑色，让x的黑节点数+1。这样x的黑节点数就和x的兄弟节点的黑节点数一样了，也就到达了平衡。</li>
<li>接下来的两个分支，说明x不是root节点，且x为黑色，所以调整过程要稍微复杂一点了。但这两个分支是完全对称的，所以我只会讲一个分支。由于removeTreeNode函数的保证（总是以删除节点的后继作为替换节点，这里后继是指刚好大于删除节点的那个节点），所以调用此函数时，x肯定是xp的右孩子，所以我接下来讲解<code>else if ((xpl = xp.left) == x)</code>的else分支。</li>
<li>接下来这个大图是整个函数的<code>else if ((xpl = xp.left) == x)</code>的else分支的所有<strong>过程</strong>，每个<strong>过程</strong>都有标号以方便讲解。节点除标明为黑色或者红色外，灰色则代表不清楚此节点的颜色。建议读者对照着大图、源码和本博客同时进行查阅。</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221356.jpg" alt="图片过大，加载失败"></p>
<ul>
<li><p><code>if (xpl != null &amp;&amp; xpl.red)</code>这个分支可能执行，可能不执行。</p>
</li>
<li><p><strong>如果xpl为红色，那么则会进入此<code>if (xpl != null &amp;&amp; xpl.red)</code>分支</strong>，如下图所示。如果xpl为红色，那么xp和xpl的孩子的颜色都必为黑色节点。而之前说过，刚开始时<strong>x的黑节点数，比x的兄弟节点饿黑节点数少1</strong>，我们假设x的黑节点数为n，那么xpl作为它的兄弟节点，xpl的黑节点数则为n+1，由于xpl是红色的不属于黑色节点，那么可推理出xpl的两个孩子的黑节点数也为n+1。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221451.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>如果xpl为红色，且执行完<code>if (xpl != null &amp;&amp; xpl.red)</code>分支后</strong>，如下图所示。调整后，x的兄弟节点变成了一个黑色节点。对比上下图发现，通过旋转操作后，使得x和一个黑节点数为n+1的黑色节点成为了兄弟。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221455.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>如果xpl为黑色，那么则不会进入此<code>if (xpl != null &amp;&amp; xpl.red)</code>分支</strong>，如下图所示。xpl的黑节点数为n+1，比x多1。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221459.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p>对比如果xpl为红色，和如果xpl为黑色的两种情况的最终结果，如下图所示，可以发现两种情况最终结果的共同点是：x的兄弟节点必为黑色，但此时兄弟节点的黑节点数多1，所以还需要调整。而两种情况的差异点是：xp的颜色。这也是后面要执行<code>xpl.red = (xp == null) ? false : xp.red</code>（把xp的颜色赋给xpl）的原因。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221502.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p><strong>如果xpl为null，那么则不会进入此<code>if (xpl != null &amp;&amp; xpl.red)</code>分支</strong>，如下图所示。我认为此分支不可能进入。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221504.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p>接下来讲解<code>if (xpl == null)</code>的else分支里的逻辑（根据上一条分析，所以是认为不可能进入<code>if (xpl == null)</code>分支的），在大图中是虚线以下的过程。</p>
</li>
<li><p>虚线下的过程，只能操作到x节点，xp节点（x的父节点），xpl节点（x的兄弟节点），sl节点（x的兄弟节点的左孩子）和sr节点（x的兄弟节点的右孩子），即只能操作这上下三层节点。这也是为什么虚线上的过程最后总会调整为xpl节点为黑色节点的情况，因为这样的话，xpl节点的两个孩子sl和sr的黑节点数就为n，而x节点本身的黑节点数也为n。只有找到了黑节点数都为n的节点们后，才方便进行调整，那之后就根据各种情况来再平衡就好了。</p>
</li>
<li><p><code>if (xpl == null)</code>的else分支的初始状态如下图（注意，此初始状态是从过程(4)(4)(4)而来的，所以虚线下的过程都是过程(4)(4)(4)接下来的过程。其实还可以画出从过程(6)(6)(6)而来的初始状态，但不必画出了）。由于xpl的黑节点数为n+1，则它自身为黑色，所以推理出，它的左右孩子的黑节点则为n。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221510.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p>很有必要说明一下<code>if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red))</code>分支和它的else分支的各种情况，如下图所示，它的else分支里，sl和sr中必有一个节点是红色的。而且在else分支里，当sr为红色时，必然还会进入<code>if (sl == null || !sl.red)</code>子分支。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221514.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p>如果进入了<code>if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red))</code>分支，如下图所示。那么说明“sl为null或sl为黑色”和“sr为null或sr为黑色”这两件事都成立，可见过程(8)(8)(8)时，x的兄弟节点的两个孩子都是黑色节点，这样的话根本没有操作空间使得x和x的兄弟节点平衡（但凡x的兄弟节点的两个孩子有一个红色节点，也不至于这样）。过程(9)(9)(9)里，所以只好另xpl为红色，这样xpl和它的兄弟节点平衡了（黑节点数一样），但由于这里是通过让xpl的黑节点数少1来使得平衡的，且xp的颜色我们又没有变过（<strong>这里考虑了虚线上的两种情况的差异点，即xp刚开始的颜色都有可能</strong>），所以不管xp的初始颜色是什么，xp必然比xp的兄弟节点的黑节点数少1，所以还是不平衡的，然后继续循环。如果考虑xp初始为黑色，那么过程(9)(9)(9)里，xp的黑节点数为n+1，xp的兄弟节点的黑节点数为n+2。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221518.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p>如果进入了<code>if ((sl == null || !sl.red) &amp;&amp; (sr == null || !sr.red))</code>的else分支，如下图所示。那么说明“sl为null或sl为黑色”和“sr为null或sr为黑色”这两件事不是都成立的。观察逻辑可以发现，else分支里可以分为两种情况：1.如果sr为红色，此时不管sl的颜色。 2.如果sr为黑色，sl为红色。其实这两种情况的共同点就是sr和sl中至少有一个红色节点了。</p>
</li>
<li><p>假设情况为“如果sr为红色，此时不管sl的颜色”，因为此时sl的颜色无论为什么对过程不会有影响。如下图所示，为这种情况的开始过程和结束过程。发现过程(16)(16)(16)时，整个树已经平衡了，结束后会将x指向root（<code>x = root</code>），下次循环就会直接退出啦。且过程(10)(10)(10)里xp这个位置，对应到过程(16)(16)(16)里则变成了xpl这个节点，且过程(10)(10)(10)里xp的颜色还可能为黑色，那么过程(16)(16)(16)的xpl会和过程(10)(10)(10)里xp的颜色一致（虚线下的三行过程都保证了这一点）。这是通过将xp的颜色赋给xpl（<code>xpl.red = (xp == null) ? false : xp.red</code>），再右旋xp（<code>rotateRight(root, xp)</code>）来保证的，这样，就把虚线上的差异点考虑在内了。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221523.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p>再假设情况为“如果sr为黑色，sl为红色”，如下图所示，为这种情况的开始过程和结束过程。发现过程(20)(20)(20)时，整个树已经平衡了，结束后会将x指向root（<code>x = root</code>），下次循环就会直接退出啦。同样的，过程(17)(17)(17)里xp这个位置对应过过程(20)(20)(20)里会保持相同位置的节点颜色一致。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221536.jpg" alt="在这里插入图片描述"></p>
</li>
<li><p>虚线下的第二行过程（过程(10)(10)(10)到过程(16)(16)(16)）和第三行过程（过程(17)(17)(17)到过程(20)(20)(20)），除了开始过程和结束过程外，中间过程里我只给那些调整过程中黑节点数不变的节点标注出来了黑节点数，其他没有标注出来的节点只需要在结束过程里进行确认就好了。</p>
</li>
<li><p>之所以虚线下的第二行过程和第三行过程要进行区分，是因为sr是否为红色，需要进行的调整操作是不一样的。比如过程过程(10)(10)(10)如果走的是第三行过程的流程，如下图所示，最终会造成sl和xp这两个兄弟节点不是平衡的。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221542.jpg" alt="在这里插入图片描述"></p>
</li>
</ul>
<p>总结一下：</p>
<ul>
<li>和balanceInsertion一样，此balanceDeletion函数同样只处理三层树的结构。</li>
<li>每次循环体里，除非进入那些直接return的终点，那么循环体开始时，x节点总是比x节点的兄弟节点的黑节点数少1的。</li>
<li>虚线下的过程，其主要技巧(指的是虚线下第二行和第三行。第一行是先让自己和兄弟平衡，但却是通过不是让自己加1，而是让兄弟减1，所以还需要x往上移动，往更高层借红色节点)是通过借用颜色为红色的兄弟节点的左右孩子，只要有一个孩子是红色的，就可以借用。而借用其实就是，通过旋转操作把红色节点弄到自己的子树里，然后通过红色变黑色，让自己子树的黑节点数加1，从达到平衡。</li>
<li>大图中，到达虚线时的过程，x的兄弟节点总会是黑色的。根据前提“x节点总是比x节点的兄弟节点的黑节点数少1”，而兄弟节点又是黑色，可以推理出“x的兄弟节点的两个孩子的黑节点数，和x节点一样大”，找到了一样大的节点，之后才好处理。</li>
</ul>
<h2 id="rotateLeft-左旋"><a href="#rotateLeft-左旋" class="headerlink" title="rotateLeft 左旋"></a>rotateLeft 左旋</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221603.webp" alt="img"></p>
<p>p：图示中的 E，r：图示中的 S</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p 图示中的 E，r 图示中的 S</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateLeft</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (r = p.right) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 3 结点的中间部分挂在左节点 p（原始父节点）下</span></span><br><span class="line">        <span class="keyword">if</span> ((rl = p.right = r.left) != <span class="literal">null</span>)</span><br><span class="line">            rl.parent = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将红链接中的右节点 r（原始子节点）上移，左节点（原始父节点）下移为右节点的子节点</span></span><br><span class="line">        <span class="comment">// 子树（可能是包含根节点的完整二叉树）在父节点 pp 中的位置保持不变</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = r.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">            (root = r).red = <span class="literal">false</span>;<span class="comment">// 原始父节点即为根节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">            pp.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.right = r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父子节点反转</span></span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始状态下：<code>r</code>为<code>p</code>的right child、<code>pp</code>为<code>p</code>的parent、<code>rl</code>为<code>r</code>的left child。</li>
<li><code>p</code>为rotateLeft函数要处理那个的节点。作为此函数的入参，一般认为<code>p</code>必有一个right child，即认为<code>if (p != null &amp;&amp; (r = p.right) != null)</code>分支一定能进入。</li>
<li><code>if ((rl = p.right = r.left) != null) rl.parent = p;</code>中，我们先认为<code>r.left</code>肯定不为null（其实无论它为不为null对旋转结果都没有影响，后面会讲到），那么把这一句拆成<code>rl = r.left</code>和<code>p.right = rl</code>，其过程如下图所示。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221613.jpg" alt="在这里插入图片描述"></li>
<li>示意图中，节点无颜色代表并不关心该节点的颜色，黑色箭头为左右孩子指针，绿色箭头为父亲指针。刚改变过指向的指针会用太阳标志标识出来。</li>
<li>接下来的if else嵌套有三个分支，这里不按照代码顺序分析，先假设程序会进入<code>else if (pp.left == p)</code>分支，此时说明之前的if分支没有进入，即<code>pp</code>不为null，<strong>且<code>p</code>为<code>pp</code>的左孩子</strong>。这里我们把<code>pp = r.parent = p.parent</code>拆分为<code>pp = p.parent</code>和<code>r.parent = pp</code>。这样，从<code>r.parent = pp</code>开始执行到最后的示意图如下：<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221618.jpg" alt="在这里插入图片描述"></li>
<li>再假设程序会进入最后的<code>else</code>分支，说明<code>pp</code>不为null，<strong>且<code>p</code>为<code>pp</code>的右孩子</strong>。同样的，我们把<code>pp = r.parent = p.parent</code>拆分为<code>pp = p.parent</code>和<code>r.parent = pp</code>。这样，从<code>r.parent = pp</code>开始执行到最后的示意图如下：<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221637.jpg" alt="在这里插入图片描述"></li>
<li>最后再假设程序会进入<code>if ((pp = r.parent = p.parent) == null)</code>分支，<strong>说明<code>pp</code>为null</strong>。同样的，我们把<code>pp = r.parent = p.parent</code>拆分为<code>pp = p.parent</code>和<code>r.parent = pp</code>。但进入这个分支说明<code>pp</code>为null，这样，从<code>r.parent = pp</code>（实际是<code>r.parent = null</code>）开始执行到最后的示意图如下：<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221643.jpg" alt="在这里插入图片描述"></li>
<li>此函数并不关心旋转后红黑树是否平衡，它只负责完成旋转的任务，所以，是此函数的调用者负责维持平衡。</li>
<li>此函数的完整流程示意图如下。将三种情况对比分析后，可以发现，第4步和第5步都是为了处理好<code>pp</code>和<code>r</code>之间的连接，<code>pp</code>作为<code>p</code>的父节点，是整个旋转部分的上层，旋转后<code>pp</code>还是会与下层保持相同的孩子关系（原来<code>p</code>是<code>pp</code>的什么孩子，现在<code>r</code>就会是<code>pp</code>的什么孩子）（第三种情况由于<code>pp</code>为null，所以就不用处理<code>pp</code>和<code>r</code>之间的连接）。</li>
<li>第6步和第7步都是为了完成旋转的后半部分，即处理好<code>p</code>与<code>r</code>之间的连接，让<code>p</code>成为<code>r</code>的左孩子，完成左旋的任务。由于之前（第4、5步）已经处理好了<code>p</code>的父节点<code>pp</code>的孩子关系，所以可以改变<code>p.parent</code>了（反过来想，如果先执行第6、7步再执行第4、5步会导致<code>pp</code>节点再也找不到了，因为第7步会改变<code>p.parent</code>）。</li>
<li>第3步都是为了完成旋转的前半部分，即处理好<code>p</code>与<code>rl</code>之间的连接，让<code>rl</code>成为<code>p</code>的右孩子。</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221651.jpg" alt="在这里插入图片描述"></p>
<ul>
<li>若将最终旋转的结果总结一下，再忽略掉<code>pp</code>节点（因为<code>pp</code>节点其实不属于旋转部分，它只是等旋转好了以后再与新的旋转部分维持相同的孩子关系），可得出如下示意图。可以发现这种旋转十分巧妙，旋转后<code>p</code>节点的左孩子不会受到影响、<code>r</code>节点的右孩子不会受到影响、<code>rl</code>节点的左右孩子都不会受到影响。</li>
<li><code>r.left</code>是否存在，对旋转结果也不会产生本质影响。它只是会让<code>p</code>节点的右孩子为null。</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221701.jpg" alt="在这里插入图片描述"></p>
<h2 id="rotateRight-右旋"><a href="#rotateRight-右旋" class="headerlink" title="rotateRight 右旋"></a>rotateRight 右旋</h2><p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221706.webp" alt="img"></p>
<p>p：图示中的 S，l：图示中的 E</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p 图示中的 S，l 图示中的 E</span></span><br><span class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeNode&lt;K,V&gt; <span class="title function_">rotateRight</span><span class="params">(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p)</span> &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">null</span> &amp;&amp; (l = p.left) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 3 结点的中间部分挂在右节点 p（原始父节点）下</span></span><br><span class="line">        <span class="keyword">if</span> ((lr = p.left = l.right) != <span class="literal">null</span>)</span><br><span class="line">            lr.parent = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将红链接中的左节点 l（原始子节点）上移，右节点（原始父节点）下移为左节点的子节点</span></span><br><span class="line">        <span class="comment">// 子树（可能是包含根节点的完整二叉树）在父节点 pp 中的位置保持不变</span></span><br><span class="line">        <span class="keyword">if</span> ((pp = l.parent = p.parent) == <span class="literal">null</span>)</span><br><span class="line">            (root = l).red = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pp.right == p)</span><br><span class="line">            pp.right = l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pp.left = l;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 父子节点反转</span></span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始状态下：<code>l</code>为<code>p</code>的left child、<code>pp</code>为<code>p</code>的parent、<code>lr</code>为<code>l</code>的right child。</li>
<li>由于右旋和左旋完全类似，分析过程完全和上面章节类似，所以接下来只做重要讲解。</li>
<li><code>if ((lr = p.left = l.right) != null)</code>分支：<code>lr = p.left = l.right</code>拆分为<code>lr = l.right</code>和<code>p.left = lr</code>，然后接下来执行<code>lr.parent = p</code>。<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221713.jpg" alt="在这里插入图片描述"></li>
<li>将<code>pp = l.parent = p.parent</code>拆分为<code>pp = p.parent</code>和<code>l.parent = pp</code>。</li>
<li>先假设进入最后的<code>else</code>分支（代表<code>pp.left == p</code>成立），示意图如下：<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221719.jpg" alt="在这里插入图片描述"></li>
<li>再假设进入<code>else if (pp.right == p)</code>分支，示意图如下：<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221730.jpg" alt="在这里插入图片描述"></li>
<li>最后假设进入<code>if ((pp = l.parent = p.parent) == null)</code>分支，示意图如下：<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221800.jpg" alt="在这里插入图片描述"></li>
<li>完整流程示意图：</li>
</ul>
<p><img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221833.jpg" alt="在这里插入图片描述"></p>
<ul>
<li>右旋总结示意图：<br>  <img src="https://lxiaol.oss-cn-beijing.aliyuncs.com/typora/blog/20220325221846.jpg" alt="在这里插入图片描述"></li>
</ul>
<h2 id="左旋右旋总结"><a href="#左旋右旋总结" class="headerlink" title="左旋右旋总结"></a>左旋右旋总结</h2><ul>
<li>不管是左旋还是右旋，<code>pp</code>节点其实都不算是旋转的部分，因为在旋转后，它只是与新的旋转部分保持相同的孩子关系。</li>
<li>从左旋、右旋的总结示意图里可以看出，没有画出来的子树部分之所以不用画，是因为在旋转后子树会保持相同的相对位置。比如，左旋总结示意图中：<code>p</code>的左子树还会是<code>p</code>的左子树，<code>r</code>的右子树还会是<code>r</code>的右子树。右旋总结示意图中：<code>p</code>的右子树还会是<code>p</code>的右子树，<code>l</code>的左子树还会是<code>l</code>的左子树。</li>
</ul>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>第 7 章 排序算法</title>
    <url>/posts/92e9d7099040/</url>
    <content><![CDATA[<h1 id="第-7-章-排序算法"><a href="#第-7-章-排序算法" class="headerlink" title="第 7 章 排序算法"></a>第 7 章 排序算法</h1><h2 id="1、排序算法介绍"><a href="#1、排序算法介绍" class="headerlink" title="1、排序算法介绍"></a>1、排序算法介绍</h2><h3 id="1-1、排序算法的简介"><a href="#1-1、排序算法的简介" class="headerlink" title="1.1、排序算法的简介"></a>1.1、排序算法的简介</h3><ul>
<li>排序也称排序算法(Sort Algorithm)， 排序是将一组数据， 依指定的顺序进行排列的过程。</li>
</ul>
<h3 id="1-2、排序算法的分类"><a href="#1-2、排序算法的分类" class="headerlink" title="1.2、排序算法的分类"></a>1.2、排序算法的分类</h3><ul>
<li><strong>内部排序</strong>：指将需要处理的所有数据都加载到内部存储器(内存)中进行排序。</li>
<li><strong>外部排序法</strong>：数据量过大， 无法全部加载到内存中， 需要借助外部存储(文件等)进行排序。</li>
<li>常见的排序算法分类</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIxMjE5NTM4LnBuZw?x-oss-process=image/format,png" alt="image-20200714221219538"></p>
<h2 id="2、算法的复杂度"><a href="#2、算法的复杂度" class="headerlink" title="2、算法的复杂度"></a>2、算法的复杂度</h2><h3 id="2-1、时间复杂度的度量方法"><a href="#2-1、时间复杂度的度量方法" class="headerlink" title="2.1、时间复杂度的度量方法"></a>2.1、时间复杂度的度量方法</h3><ul>
<li>事后统计的方法：这种方法可行, 但是有两个问题：<ul>
<li>一是要想对设计的算法的运行性能进行评测， 需要实际运行该程序；</li>
<li>二是所得时间的统计量依赖于计算机的硬件、 软件等环境因素, 这种方式， 要在同一台计算机的相同状态下运行， 才能比较哪个算法速度更快。</li>
</ul>
</li>
<li>事前估算的方法：通过分析某个算法的时间复杂度来判断哪个算法更优</li>
</ul>
<h3 id="2-2、时间频度"><a href="#2-2、时间频度" class="headerlink" title="2.2、时间频度"></a>2.2、时间频度</h3><ul>
<li>基本介绍时间频度： 一个算法花费的时间与算法中语句的执行次数成正比例， 哪个算法中语句执行次数多， 它花费时间就多。 一个算法中的语句执行次数称为语句频度或时间频度。 记为 T(n)。 [举例说明]</li>
<li>举例说明-基本案例：比如计算 1-100 所有数字之和，我们设计两种算法：</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIxMzUyNjIzLnBuZw?x-oss-process=image/format,png" alt="image-20200714221352623"></p>
<ul>
<li>举例说明-忽略常数项：<ul>
<li>2n+20 和 2n 随着 n 变大， 执行曲线无限接近, 20 可以忽略</li>
<li>3n+10 和 3n 随着 n 变大， 执行曲线无限接近, 10 可以忽略</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIxNDA0MzY3LnBuZw?x-oss-process=image/format,png" alt="image-20200714221404367"></p>
<ul>
<li>举例说明-忽略低次项：<ul>
<li>2n^2+3n+10 和 2n^2 随着 n 变大, 执行曲线无限接近, 可以忽略 3n+10</li>
<li>n^2+5n+20 和 n^2 随着 n 变大,执行曲线无限接近, 可以忽略 5n+20</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIxNDQxMzM1LnBuZw?x-oss-process=image/format,png" alt="image-20200714221441335"></p>
<ul>
<li>举例说明-忽略系数：<ul>
<li>随着 n 值变大， 5n^2+7n 和 3n^2 + 2n ， 执行曲线重合, 说明 这种情况下, 5 和 3 可以忽略。</li>
<li>而 n^3+5n 和 6n^3+4n ， 执行曲线分离， 说明多少次方式关键</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIxNTI5MTc1LnBuZw?x-oss-process=image/format,png" alt="image-20200714221529175"></p>
<h3 id="2-3、时间复杂度"><a href="#2-3、时间复杂度" class="headerlink" title="2.3、时间复杂度"></a>2.3、时间复杂度</h3><ul>
<li>一般情况下， 算法中的基本操作语句的重复执行次数是问题规模 n 的某个函数， 用 T(n)表示， 若有某个辅助函数 f(n)， 使得当 n 趋近于无穷大时， T(n) / f(n) 的极限值为不等于零的常数， 则称 f(n)是 T(n)<br>的同数量级函数。记作 T(n)=Ｏ ( f(n) )， 称Ｏ ( f(n) ) 为算法的渐进时间复杂度， 简称时间复杂度。</li>
<li>T(n) 不同， 但时间复杂度可能相同。 如： T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的 T(n) 不同， 但时间复杂度相同， 都为 O(n²)。</li>
<li>计算时间复杂度的方法：<ul>
<li>用常数 1 代替运行时间中的所有加法常数 T(n)=n²+7n+6 =&gt; T(n)=n²+7n+1</li>
<li>修改后的运行次数函数中， 只保留最高阶项 T(n)=n²+7n+1 =&gt; T(n) = n²</li>
<li>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li>
</ul>
</li>
</ul>
<h3 id="2-4、常见的时间复杂度"><a href="#2-4、常见的时间复杂度" class="headerlink" title="2.4、常见的时间复杂度"></a>2.4、常见的时间复杂度</h3><h4 id="2-4-1、常见时间复杂度概述"><a href="#2-4-1、常见时间复杂度概述" class="headerlink" title="2.4.1、常见时间复杂度概述"></a>2.4.1、常见时间复杂度概述</h4><ul>
<li>常见时间复杂度<ul>
<li>常数阶 O(1)</li>
<li>对数阶 O(log2n)</li>
<li>线性阶 O(n)</li>
<li>线性对数阶 O(nlog2n)</li>
<li>平方阶 O(n^2)</li>
<li>立方阶 O(n^3)</li>
<li>k 次方阶 O(n^k)</li>
<li>指数阶 O(2^n)</li>
</ul>
</li>
<li>结论：<ul>
<li>常见的算法时间复杂度由小到大依次为： Ο (1)＜Ο (log2n)＜Ο (n)＜Ο (nlog2n)＜Ο (n2)＜Ο (n3)＜ Ο (nk) ＜ Ο (2n) ， 随着问题规模 n 的不断增大， 上述时间复杂度不断增大，<br>算法的执行效率越低</li>
<li>从图中可见， 我们应该尽可能避免使用指数阶的算法</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIyNDE0NjY5LnBuZw?x-oss-process=image/format,png" alt="image-20200714222414669"></p>
<h4 id="2-4-2、常数阶-O-1"><a href="#2-4-2、常数阶-O-1" class="headerlink" title="2.4.2、常数阶 O(1)"></a>2.4.2、常数阶 O(1)</h4><ul>
<li>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</li>
<li>代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzMTM3NzU5LnBuZw?x-oss-process=image/format,png" alt="image-20200714223137759"></p>
<h4 id="2-4-3、对数阶-O-log2n"><a href="#2-4-3、对数阶-O-log2n" class="headerlink" title="2.4.3、对数阶 O(log2n)"></a>2.4.3、对数阶 O(log2n)</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzMjQ0MzgyLnBuZw?x-oss-process=image/format,png" alt="image-20200714223244382"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzMjI1NjA5LnBuZw?x-oss-process=image/format,png" alt="image-20200714223225609"></p>
<h4 id="2-4-4、线性阶-O-n"><a href="#2-4-4、线性阶-O-n" class="headerlink" title="2.4.4、线性阶 O(n)"></a>2.4.4、线性阶 O(n)</h4><ul>
<li><strong>说明</strong>：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzMjU1Mjg4LnBuZw?x-oss-process=image/format,png" alt="image-20200714223255288"></p>
<h4 id="2-4-5、线性对数阶-O-nlogN"><a href="#2-4-5、线性对数阶-O-nlogN" class="headerlink" title="2.4.5、线性对数阶 O(nlogN)"></a>2.4.5、线性对数阶 O(nlogN)</h4><ul>
<li><strong>说明</strong>：线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzMzExNDcyLnBuZw?x-oss-process=image/format,png" alt="image-20200714223311472"></p>
<h4 id="2-4-6、平方阶-O-n²"><a href="#2-4-6、平方阶-O-n²" class="headerlink" title="2.4.6、平方阶 O(n²)"></a>2.4.6、平方阶 O(n²)</h4><ul>
<li><strong>说明</strong>：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n<em>n)，即 O(n²)<br>如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m</em>n)</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzMzI5MjU0LnBuZw?x-oss-process=image/format,png" alt="image-20200714223329254"></p>
<h4 id="2-4-7、其他阶"><a href="#2-4-7、其他阶" class="headerlink" title="2.4.7、其他阶"></a>2.4.7、其他阶</h4><ul>
<li>立方阶 O(n³)、 K 次方阶 O(n^k)</li>
<li>说明： 参考上面的 O(n²) 去理解就好了， O(n³)相当于三层 n 循环， 其它的类似</li>
</ul>
<h3 id="2-5、平均和最坏时间复杂度"><a href="#2-5、平均和最坏时间复杂度" class="headerlink" title="2.5、平均和最坏时间复杂度"></a>2.5、平均和最坏时间复杂度</h3><ul>
<li>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下， 该算法的运行时间。</li>
<li>最坏情况下的时间复杂度称最坏时间复杂度。 一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是： 最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限， 这就保证了算法的运行时间不会比最坏情况更长。</li>
<li>平均时间复杂度和最坏时间复杂度是否一致， 和算法有关(如图)。</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE0MjIzNjE2NDM2LnBuZw?x-oss-process=image/format,png" alt="image-20200714223616436"></p>
<h3 id="2-6、算法的空间复杂度"><a href="#2-6、算法的空间复杂度" class="headerlink" title="2.6、算法的空间复杂度"></a>2.6、算法的空间复杂度</h3><ul>
<li>类似于时间复杂度的讨论， 一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间， 它也是问题规模 n 的函数。</li>
<li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。 有的算法需要占用的临时工作单元数与解决问题的规模 n 有关， 它随着 n 的增大而增大， 当 n 较大时， 将占用较多的存储单元，<br>例如快速排序和归并排序算法, 基数排序就属于这种情况</li>
<li>在做算法分析时， 主要讨论的是时间复杂度。 从用户使用体验上看， 更看重的程序执行的速度。 一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间</li>
</ul>
<h2 id="3、冒泡排序"><a href="#3、冒泡排序" class="headerlink" title="3、冒泡排序"></a>3、冒泡排序</h2><h3 id="3-1、基本介绍"><a href="#3-1、基本介绍" class="headerlink" title="3.1、基本介绍"></a>3.1、基本介绍</h3><ul>
<li>冒泡排序（Bubble Sorting） 的基本思想是： <strong>通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值， 若发现逆序则交换， 使值较大的元素逐渐从前移向后部， 就象水底下的气泡一样逐渐向上冒。</strong></li>
<li>优化：因为排序的过程中， 各元素不断接近自己的位置， 如果一趟比较下来没有进行过交换， 就说明序列有序， <strong>因此要在排序过程中设置一个标志 flag 判断元素是否进行过交换。 从而减少不必要的比较</strong>。 (这里说的优化，<br>可以在冒泡排序写好后， 再进行)</li>
</ul>
<h3 id="3-2、冒泡排序图解"><a href="#3-2、冒泡排序图解" class="headerlink" title="3.2、冒泡排序图解"></a>3.2、冒泡排序图解</h3><ul>
<li><p>第一趟：</p>
<ul>
<li>从数组 arr 第一个元素开始，与其后面一个元素比较大小</li>
<li>如果 arr[i] &gt; arr[i+1] ，则交换，将大的元素换到后面去</li>
<li>由于是当前元素与其后面一个元素比较大小，所以只需要执行 arr.length - 1 次循环</li>
</ul>
</li>
<li><p>第二趟：</p>
<ul>
<li>从数组 arr 第一个元素开始，与其后面一个元素比较大小</li>
<li>由于第一趟排序完成，数组最后一个元素已是最大元素，所以只需要执行 arr.length - 1 - 1 次循环</li>
</ul>
</li>
<li><p>啥时候完成？下面两个条件满足任意一个即可：</p>
<ul>
<li><p>当其中有一趟排序没有元素交换位置时，说明数组已经有序</p>
</li>
<li><p>或：按照上述流程，跑完第</p>
<p>  arr.length - 1</p>
<p>  趟之后</p>
<ul>
<li>这样来想：5 个元素的数组，最多只需要跑 4 趟</li>
<li>为什么最多只需要跑 4 趟？因为跑完 4 趟之后，数组第二个元素已经成为了数组第二小的元素，那么数组自然就是有序数组</li>
<li>即数组长度如果为 n ，那么则需要跑 n - 1 趟</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：两层 for 循环</p>
<ul>
<li><strong>第一层 for 循环控制走多少趟：for (int i = 0; i &lt; arr.length - 1; i++) {</strong></li>
<li><strong>第二层 for 循环实现针对该趟循环，进行冒泡：for (int j = 0; j &lt; arr.length - 1 - i; j++) {</strong></li>
</ul>
</li>
<li><p>伪代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">        <span class="comment">// 执行冒泡操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="comment">/* 该趟没有交换 */</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组已然有序，跳出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTcwNzMxMzc5LnBuZw?x-oss-process=image/format,png" alt="image-20200806170731379"></p>
<h3 id="3-3、代码实现"><a href="#3-3、代码实现" class="headerlink" title="3.3、代码实现"></a>3.3、代码实现</h3><h4 id="3-3-1、理解冒泡排序"><a href="#3-3-1、理解冒泡排序" class="headerlink" title="3.3.1、理解冒泡排序"></a>3.3.1、理解冒泡排序</h4><ul>
<li>上面的例子不好，我们把数组改成：int arr[] = { 3, 9, -1, 10, -2 }; 这样更能说明冒泡排序的特点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">10</span>, -<span class="number">2</span> &#125;;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了容量理解，我们把冒泡排序的演变过程，给大家展示</span></span><br><span class="line">	System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一趟排序，就是将最大的数排在倒数第一位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">		<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">		<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">			temp = arr[j];</span><br><span class="line">			arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;第一趟排序后的数组&quot;</span>);</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二趟排序，就是将第二大的数排在倒数第二位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - <span class="number">1</span>; j++) &#123;</span><br><span class="line">		<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">		<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">			temp = arr[j];</span><br><span class="line">			arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;第二趟排序后的数组&quot;</span>);</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三趟排序，就是将第三大的数排在倒数第三位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - <span class="number">2</span>; j++) &#123;</span><br><span class="line">		<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">		<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">			temp = arr[j];</span><br><span class="line">			arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;第三趟排序后的数组&quot;</span>);</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第四趟排序，就是将第4大的数排在倒数第4位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - <span class="number">3</span>; j++) &#123;</span><br><span class="line">		<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">		<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">			temp = arr[j];</span><br><span class="line">			arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;第四趟排序后的数组&quot;</span>);</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">排序前</span><br><span class="line">[3, 9, -1, 10, -2]</span><br><span class="line">第一趟排序后的数组</span><br><span class="line">[3, -1, 9, -2, 10]</span><br><span class="line">第二趟排序后的数组</span><br><span class="line">[-1, 3, -2, 9, 10]</span><br><span class="line">第三趟排序后的数组</span><br><span class="line">[-1, -2, 3, 9, 10]</span><br><span class="line">第四趟排序后的数组</span><br><span class="line">[-2, -1, 3, 9, 10]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-3-2、编写冒泡排序"><a href="#3-3-2、编写冒泡排序" class="headerlink" title="3.3.2、编写冒泡排序"></a>3.3.2、编写冒泡排序</h4><ul>
<li>测试极端情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了容量理解，我们把冒泡排序的演变过程，给大家展示</span></span><br><span class="line">	System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">	System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	bubbleSort(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将前面额冒泡排序算法，封装成一个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">	<span class="comment">// 冒泡排序 的时间复杂度 O(n^2), 自己写出</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 临时变量</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 标识变量，表示是否进行过交换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;趟排序后的数组&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123; <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			flag = <span class="literal">false</span>; <span class="comment">// 重置flag!!!, 进行下次判断</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">排序前</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">第1趟排序后的数组</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-3-3、测试冒泡排序性能"><a href="#3-3-3、测试冒泡排序性能" class="headerlink" title="3.3.3、测试冒泡排序性能"></a>3.3.3、测试冒泡排序性能</h4><ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试一下冒泡排序的速度O(n^2), 给80000个数据，测试</span></span><br><span class="line">	<span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line">	<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">80000</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">		arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">	<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">	<span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">	System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试冒泡排序</span></span><br><span class="line">	bubbleSort(arr);</span><br><span class="line"></span><br><span class="line">	<span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">	<span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(date2);</span><br><span class="line">	System.out.println(<span class="string">&quot;排序后的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将前面额冒泡排序算法，封装成一个方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">	<span class="comment">// 冒泡排序 的时间复杂度 O(n^2), 自己写出</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 临时变量</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 标识变量，表示是否进行过交换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="comment">// 如果前面的数比后面的数大，则交换</span></span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				temp = arr[j];</span><br><span class="line">				arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123; <span class="comment">// 在一趟排序中，一次交换都没有发生过</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			flag = <span class="literal">false</span>; <span class="comment">// 重置flag!!!, 进行下次判断</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">排序前的时间是=2020-07-15 11:44:08</span><br><span class="line">排序后的时间是=2020-07-15 11:44:16</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4、选择排序"><a href="#4、选择排序" class="headerlink" title="4、选择排序"></a>4、选择排序</h2><h3 id="4-1、选择排序基本介绍"><a href="#4-1、选择排序基本介绍" class="headerlink" title="4.1、选择排序基本介绍"></a>4.1、选择排序基本介绍</h3><ul>
<li>选择式排序也属于内部排序法， 是从欲排序的数据中， 按指定的规则选出某一元素， 再依规定交换位置后达到排序的目的。</li>
</ul>
<h3 id="4-2、选择排序思想"><a href="#4-2、选择排序思想" class="headerlink" title="4.2、选择排序思想"></a>4.2、选择排序思想</h3><ul>
<li>选择排序（select sorting） 也是一种简单的排序方法。 它的基本思想是（n 是数组大小）：<ul>
<li>第一次从 arr[0]~arr[n-1]中选取最小值，与 arr[0] 交换</li>
<li>第二次从 arr[1]~arr[n-1]中选取最小值， 与 arr[1] 交换</li>
<li>第三次从 arr[2]~arr[n-1]中选取最小值， 与 arr[2] 交换， …，</li>
<li>第 i 次从 arr[i-1]~arr[n-1]中选取最小值， 与 arr[i-1] 交换， …，</li>
<li>第 n-1 次从 arr[n-2]~arr[n-1]中选取最小值，与 arr[n-2] 交换，</li>
<li>总共通过 n-1 次， 得到一个按排序码从小到大排列的有序序列。</li>
</ul>
</li>
</ul>
<h3 id="4-3、选择排序图解"><a href="#4-3、选择排序图解" class="headerlink" title="4.3、选择排序图解"></a>4.3、选择排序图解</h3><ul>
<li>选择排序流程：<ul>
<li>第一次循环，默认 arr[0] 是最小的元素，将其与 arr[1]~arr[n-1] 进行比较，找到最小的元素，并与 arr[0] 的位置位置</li>
<li>第二次循环，默认 arr[1] 是最小的元素，将其与 arr[2]~arr[n-1] 进行比较，找到最小的元素，并与 arr[1] 的位置位置</li>
<li>第 i 次循环，默认 arr[i] 是最小的元素，将其与 arr[i+1]~arr[n-1] 进行比较，找到最小的元素，并与 arr[i] 的位置位置</li>
<li>直到循环执行 n - 1 次</li>
</ul>
</li>
<li>总结：两层 for 循环<ul>
<li>第一层 for 循环控制走多少趟：for (int i = 0; i &lt; arr.length - 1; i++) {<ul>
<li>从数组第一个元素开始，因为每次都是拿当前元素 arr[j] 和其后一个元素 arr[j+1] 进行比较</li>
<li>到数组倒数第二个元素结束，将 arr[arr.length - 2] 与 arr[arr.length - 1] 进行比较后，数组就已经是有序数组</li>
<li>如果数组大小为 n ，那么执行完第 n - 1 趟时，数组就已经是有序数组</li>
</ul>
</li>
<li>第二层 for 循环控制从第几个元素开始执行选择排序：for (int j = i + 1; j &lt; arr.length; j++)<ul>
<li>每次进入第二层 for 循环时，先假设当前元素 arr[i] 是最小的元素：<strong>min = arr[i];</strong> ，并记录最小元素的下标：<strong>index = i;</strong></li>
<li>然后依次和其后面的元素 arr[j] 比较，如果找到比 arr[i] 小的元素，则更新最小值和最小值的索引：<strong>min = arr[j]</strong>; <strong>index = j</strong> ;</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE1MTk1NDMxNTEwLnBuZw?x-oss-process=image/format,png" alt="image-20200715195431510"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTcxMDA5NzcyLnBuZw?x-oss-process=image/format,png" alt="image-20200806171009772"></p>
<h3 id="4-4、代码实现"><a href="#4-4、代码实现" class="headerlink" title="4.4、代码实现"></a>4.4、代码实现</h3><h4 id="4-4-1、理解选择排序"><a href="#4-4-1、理解选择排序" class="headerlink" title="4.4.1、理解选择排序"></a>4.4.1、理解选择排序</h4><ul>
<li>一步一步理解选择排序算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span> &#125;;</span><br><span class="line">		selectSort(arr);</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 使用逐步推导的方式来，讲解选择排序</span></span><br><span class="line">		<span class="comment">// 第1轮</span></span><br><span class="line">		<span class="comment">// 原始的数组 ： 101, 34, 119, 1</span></span><br><span class="line">		<span class="comment">// 第一轮排序 : 1, 34, 119, 101</span></span><br><span class="line">		<span class="comment">// 算法 先简单--》 做复杂， 就是可以把一个复杂的算法，拆分成简单的问题-》逐步解决</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第1轮</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">				min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">				minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">		<span class="keyword">if</span> (minIndex != <span class="number">0</span>) &#123;</span><br><span class="line">			arr[minIndex] = arr[<span class="number">0</span>];</span><br><span class="line">			arr[<span class="number">0</span>] = min;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;第1轮后~~&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));<span class="comment">// 1, 34, 119, 101</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第2轮</span></span><br><span class="line">		minIndex = <span class="number">1</span>;</span><br><span class="line">		min = arr[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span> + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">				min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">				minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">		<span class="keyword">if</span> (minIndex != <span class="number">1</span>) &#123;</span><br><span class="line">			arr[minIndex] = arr[<span class="number">1</span>];</span><br><span class="line">			arr[<span class="number">1</span>] = min;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;第2轮后~~&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));<span class="comment">// 1, 34, 119, 101</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第3轮</span></span><br><span class="line">		minIndex = <span class="number">2</span>;</span><br><span class="line">		min = arr[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">				min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">				minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">		<span class="keyword">if</span> (minIndex != <span class="number">2</span>) &#123;</span><br><span class="line">			arr[minIndex] = arr[<span class="number">2</span>];</span><br><span class="line">			arr[<span class="number">2</span>] = min;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;第3轮后~~&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));<span class="comment">// 1, 34, 101, 119</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">第1轮后~~</span><br><span class="line">[1, 34, 119, 101]</span><br><span class="line">第2轮后~~</span><br><span class="line">[1, 34, 119, 101]</span><br><span class="line">第3轮后~~</span><br><span class="line">[1, 34, 101, 119]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-4-2、编写选择排序"><a href="#4-4-2、编写选择排序" class="headerlink" title="4.4.2、编写选择排序"></a>4.4.2、编写选择排序</h4><ul>
<li>编写选择排序算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span> &#125;;</span><br><span class="line">		selectSort(arr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在推导的过程，我们发现了规律，因此，可以使用for来解决</span></span><br><span class="line">		<span class="comment">// 选择排序时间复杂度是 O(n^2)</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">			<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">					min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">					minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">			<span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">				arr[minIndex] = arr[i];</span><br><span class="line">				arr[i] = min;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;轮后~~&quot;</span>);</span><br><span class="line">			System.out.println(Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">第1轮后~~</span><br><span class="line">[1, 34, 119, 101]</span><br><span class="line">第2轮后~~</span><br><span class="line">[1, 34, 119, 101]</span><br><span class="line">第3轮后~~</span><br><span class="line">[1, 34, 101, 119]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-4-3、测试选择排序性能"><a href="#4-4-3、测试选择排序性能" class="headerlink" title="4.4.3、测试选择排序性能"></a>4.4.3、测试选择排序性能</h4><ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//创建要给80000个的随机的数组</span></span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">Date</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(data1);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">		selectSort(arr);</span><br><span class="line"></span><br><span class="line">		<span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 选择排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 在推导的过程，我们发现了规律，因此，可以使用for来解决</span></span><br><span class="line">		<span class="comment">// 选择排序时间复杂度是 O(n^2)</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">			<span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[i];</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">					min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">					minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">			<span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">				arr[minIndex] = arr[i];</span><br><span class="line">				arr[i] = min;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">排序前的时间是=2020-07-15 19:59:19</span><br><span class="line">排序前的时间是=2020-07-15 19:59:20</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="4-5、总结"><a href="#4-5、总结" class="headerlink" title="4.5、总结"></a>4.5、总结</h3><ul>
<li>由于选择排序算法在最内层的 for 循环中，满足 <code>if (min &gt; arr[j]) &#123;</code> 条件后，只需要记录最小值和最小值在数组中的索引，无需像冒泡排序那样每次都要执行交换操作，所以选择排序算法的执行速度比冒泡排序算法快一些</li>
</ul>
<h2 id="5、插入排序"><a href="#5、插入排序" class="headerlink" title="5、插入排序"></a>5、插入排序</h2><h3 id="5-1、插入排序基本介绍"><a href="#5-1、插入排序基本介绍" class="headerlink" title="5.1、插入排序基本介绍"></a>5.1、插入排序基本介绍</h3><ul>
<li>插入式排序属于内部排序法， 是对于欲排序的元素以插入的方式找寻该元素的适当位置， 以达到排序的目的。</li>
</ul>
<h3 id="5-2、插入排序思想"><a href="#5-2、插入排序思想" class="headerlink" title="5.2、插入排序思想"></a>5.2、插入排序思想</h3><ul>
<li>插入排序（Insertion Sorting） 的基本思想是： <strong>把 n 个待排序的元素看成为一个有序表和一个无序表</strong></li>
<li>开始时有序表中只包含一个元素， 无序表中包含有 n-1 个元素， <strong>排序过程中每次从无序表中取出第一个元素， 把它的排序码依次与有序表元素的排序码进行比较， 将它插入到有序表中的适当位置， 使之成为新的有序表</strong></li>
</ul>
<h3 id="5-3、插入排序图解"><a href="#5-3、插入排序图解" class="headerlink" title="5.3、插入排序图解"></a>5.3、插入排序图解</h3><ul>
<li><p>插入排序逻辑：</p>
<ul>
<li>首先，<strong>将数组分为两个数组，前部分有序数组，后部分是无序数组，我们的目的就是一点一点取出无序数组中的值，将其放到有序数组中区</strong></li>
<li>第一趟：arr[0] 作为有序数组的元素，arr[1] 作为无序数组中第一个元素，将 arr[1] 与 arr[0] 比较，目标是将 arr[1] 插入到有序数组中</li>
<li>第一趟：arr[0] 和 arr[1] 作为有序数组的元素，arr[2] 作为无序数组中第一个元素，将 arr[2] 与 arr[0] 和 arr[1] 比较，目标是将 arr[2] 插入到有序数组中</li>
<li>第 i 趟：arr[0]<del>arr[i] 作为有序数组的元素，arr[i+1] 作为无序数组中第一个元素，将 arr[i+1] 与 arr[0]</del>arr[i] 比较，目标是将 arr[i+1] 插入到有序数组中</li>
<li>第 n-1 趟：此时有序数组为 arr[0]~arr[n-2] ，无序数组为 arr[n-1] ，将无序数组中最后一个元素插入到有序数组中即可</li>
<li>如何进行插入？<ul>
<li><strong>假设有个指针（index），指向无序数组中的第一个元素，即 arr[index] 是无序数组中的第一个元素</strong>，我们定义一个变量来存储该值：int insertVal = arr[index]<br>;，现在要将其插入到前面的有序数组中</li>
<li>将 index 前移一步，则指向有序数组最后一个元素，我们定义一个新的变量来存储该指针：<strong>insertIndex = index - 1;</strong> ，即 arr[insertIndex] 是有序数组最后一个元素</li>
<li>我们需要找到一个比 insertVal 小的值，并将 insertVal 插入在该值后面：<ul>
<li>如果 insertVal &gt; arr[insertIndex] ，执行插入</li>
<li>如果 insertVal &lt; arr[insertIndex] ，将有序数组后移，腾出插入空间，insertIndex 指针前移，再看看前一个元素满不满足条件，直到找到插入位置</li>
<li>即循环终止条件为找到插入位置，又分为两种情况：<ul>
<li>在有序数组中间找到插入位置</li>
<li>insertVal 比有序数组中所有的数都小，插入在数组第一个位置（insertIndex = 0 的情况）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：两层循环</p>
<ul>
<li><p>for 循环控制走多少趟：<strong>for(int i = 1; i &lt; arr.length; i++) {</strong> ，从数组第一个元素开始到数组最后一个元素结束</p>
</li>
<li><p>while 循环不断将指针前移，在有序数组中寻找插入位置，并执行插入：</p>
<p><strong>while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) {</strong></p>
</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE1MjE0ODIyNDk4LnBuZw?x-oss-process=image/format,png" alt="image-20200715214822498"></p>
<h3 id="5-4、代码实现"><a href="#5-4、代码实现" class="headerlink" title="5.4、代码实现"></a>5.4、代码实现</h3><h4 id="5-4-1、理解插入排序"><a href="#5-4-1、理解插入排序" class="headerlink" title="5.4.1、理解插入排序"></a>5.4.1、理解插入排序</h4><ul>
<li>理解插入排序算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span> &#125;;</span><br><span class="line">		insertSort(arr);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用逐步推导的方式来讲解，便利理解</span></span><br><span class="line">		<span class="comment">// 第1轮 &#123;101, 34, 119, 1&#125;; =&gt; &#123;34, 101, 119, 1&#125;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// &#123;101, 34, 119, 1&#125;; =&gt; &#123;101,101,119,1&#125;</span></span><br><span class="line">		<span class="comment">// 定义待插入的数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> arr[<span class="number">1</span>];</span><br><span class="line">		<span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> <span class="number">1</span> - <span class="number">1</span>; <span class="comment">// 即arr[1]的前面这个数的下标</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line">		<span class="comment">// 说明</span></span><br><span class="line">		<span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line">		<span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line">		<span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line">		<span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">			arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];<span class="comment">// arr[insertIndex]</span></span><br><span class="line">			insertIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line">		<span class="comment">// 举例：理解不了，我们一会 debug</span></span><br><span class="line">		arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;第1轮插入&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第2轮</span></span><br><span class="line">		insertVal = arr[<span class="number">2</span>];</span><br><span class="line">		insertIndex = <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">			arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];<span class="comment">// arr[insertIndex]</span></span><br><span class="line">			insertIndex--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">		System.out.println(<span class="string">&quot;第2轮插入&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第3轮</span></span><br><span class="line">		insertVal = arr[<span class="number">3</span>];</span><br><span class="line">		insertIndex = <span class="number">3</span> - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">			arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];<span class="comment">// arr[insertIndex]</span></span><br><span class="line">			insertIndex--;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">		System.out.println(<span class="string">&quot;第3轮插入&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">第1轮插入</span><br><span class="line">[34, 101, 119, 1]</span><br><span class="line">第2轮插入</span><br><span class="line">[34, 101, 119, 1]</span><br><span class="line">第3轮插入</span><br><span class="line">[1, 34, 101, 119]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-4-2、编写插入排序"><a href="#5-4-2、编写插入排序" class="headerlink" title="5.4.2、编写插入排序"></a>5.4.2、编写插入排序</h4><ul>
<li>编写插入排序算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">101</span>, <span class="number">34</span>, <span class="number">119</span>, <span class="number">1</span> &#125;;</span><br><span class="line">		insertSort(arr);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//使用for循环来把代码简化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="comment">//定义待插入的数</span></span><br><span class="line">			insertVal = arr[i];</span><br><span class="line">			insertIndex = i - <span class="number">1</span>; <span class="comment">// 即arr[1]的前面这个数的下标</span></span><br><span class="line">	</span><br><span class="line">			<span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line">			<span class="comment">// 说明</span></span><br><span class="line">			<span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line">			<span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line">			<span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line">			<span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">				arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];<span class="comment">// arr[insertIndex]</span></span><br><span class="line">				insertIndex--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line">			<span class="comment">// 因为我们找到的元素，即下标为 insertIndex 的元素值比 insertVal 小</span></span><br><span class="line">             <span class="comment">// 所以我们要将 insertVal 插入到 insertIndex + 1 的位置</span></span><br><span class="line">			arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;轮插入&quot;</span>);</span><br><span class="line">			System.out.println(Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">第1轮插入</span><br><span class="line">[34, 101, 119, 1]</span><br><span class="line">第2轮插入</span><br><span class="line">[34, 101, 119, 1]</span><br><span class="line">第3轮插入</span><br><span class="line">[1, 34, 101, 119]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-4-3、测试插入排序性能"><a href="#5-4-3、测试插入排序性能" class="headerlink" title="5.4.3、测试插入排序性能"></a>5.4.3、测试插入排序性能</h4><ul>
<li>测试插入排序性能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;插入排序前&quot;</span>);</span><br><span class="line">		<span class="type">Date</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(data1);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">		insertSort(arr); <span class="comment">// 调用插入排序算法</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入排序</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">insertVal</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//使用for循环来把代码简化</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="comment">//定义待插入的数</span></span><br><span class="line">			insertVal = arr[i];</span><br><span class="line">			insertIndex = i - <span class="number">1</span>; <span class="comment">// 即arr[1]的前面这个数的下标</span></span><br><span class="line">	</span><br><span class="line">			<span class="comment">// 给insertVal 找到插入的位置</span></span><br><span class="line">			<span class="comment">// 说明</span></span><br><span class="line">			<span class="comment">// 1. insertIndex &gt;= 0 保证在给insertVal 找插入位置，不越界</span></span><br><span class="line">			<span class="comment">// 2. insertVal &lt; arr[insertIndex] 待插入的数，还没有找到插入位置</span></span><br><span class="line">			<span class="comment">// 3. 就需要将 arr[insertIndex] 后移</span></span><br><span class="line">			<span class="keyword">while</span> (insertIndex &gt;= <span class="number">0</span> &amp;&amp; insertVal &lt; arr[insertIndex]) &#123;</span><br><span class="line">				arr[insertIndex + <span class="number">1</span>] = arr[insertIndex];<span class="comment">// arr[insertIndex]</span></span><br><span class="line">				insertIndex--;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 当退出while循环时，说明插入的位置找到, insertIndex + 1</span></span><br><span class="line">			<span class="comment">// 举例：理解不了，我们一会 debug</span></span><br><span class="line">			<span class="comment">//这里我们判断是否需要赋值</span></span><br><span class="line">			arr[insertIndex + <span class="number">1</span>] = insertVal;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">插入排序前</span><br><span class="line">排序前的时间是=2020-07-15 21:49:48</span><br><span class="line">排序前的时间是=2020-07-15 21:49:50</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-5、总结"><a href="#5-5、总结" class="headerlink" title="5.5、总结"></a>5.5、总结</h3><ul>
<li>插入排序在寻找插入位置时，需要对数组元素进行整体挪位，所以效率比选择排序稍低</li>
</ul>
<h2 id="6、希尔排序"><a href="#6、希尔排序" class="headerlink" title="6、希尔排序"></a>6、希尔排序</h2><h3 id="6-1、简单插入排序问题"><a href="#6-1、简单插入排序问题" class="headerlink" title="6.1、简单插入排序问题"></a>6.1、简单插入排序问题</h3><ul>
<li>我们看简单的插入排序可能存在的问题，数组 arr = { 2, 3, 4, 5, 6, 1 } 这时需要插入的数 1(最小)，简单插入排序的过程如下</li>
<li>结论: 当需要插入的数是较小的数时， 后移的次数明显增多， 对效率有影响</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;2,3,4,5,6,6&#125;</span><br><span class="line">&#123;2,3,4,5,5,6&#125;</span><br><span class="line">&#123;2,3,4,4,5,6&#125;</span><br><span class="line">&#123;2,3,3,4,5,6&#125;</span><br><span class="line">&#123;2,2,3,4,5,6&#125;</span><br><span class="line">&#123;1,2,3,4,5,6&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-2、希尔排序基本介绍"><a href="#6-2、希尔排序基本介绍" class="headerlink" title="6.2、希尔排序基本介绍"></a>6.2、希尔排序基本介绍</h3><ul>
<li>希尔排序是希尔（Donald Shell） 于 1959 年提出的一种排序算法。 <strong>希尔排序也是一种插入排序， 它是简单插入排序经过改进之后的一个更高效的版本， 也称为缩小增量排序。</strong></li>
</ul>
<h3 id="6-3、希尔排序基本思想"><a href="#6-3、希尔排序基本思想" class="headerlink" title="6.3、希尔排序基本思想"></a>6.3、希尔排序基本思想</h3><ul>
<li><strong>希尔排序按照增量将数组进行分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止</strong></li>
</ul>
<h3 id="6-4、希尔排序图解（交换法）"><a href="#6-4、希尔排序图解（交换法）" class="headerlink" title="6.4、希尔排序图解（交换法）"></a>6.4、希尔排序图解（交换法）</h3><ul>
<li><p>第一次：<strong>gap = arr.length/5 = 5</strong> ， 将数组分为五组，每个数组元素的索引相差 5</p>
<ul>
<li>如何完成第一次的排序？<ul>
<li>仔细想想，我们需要用一次循环将每组中的元素排序</li>
<li>总共有五组，我们又需要一次循环</li>
<li>所以完成每次排序，需要两层循环</li>
</ul>
</li>
<li>程序代码如下，把 i ，j 都看作是辅助指针：<ul>
<li>i 与 j 配合使用，可以将指针从数组第一个元素，移动至最后一个元素，目的：把数组遍历一遍</li>
<li>j 与 i 配合使用，每次都从数组索引 i 处往前遍历，每次向前移动 gap 个位置，然后进行交换（冒泡排序的意思）：看看前面的元素有没有比我的值大，如果前面的元素比我的值大，我就要和他交换位置，跑到前面去</li>
</ul>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序的第1轮排序</span></span><br><span class="line"><span class="comment">// 因为第1轮排序，是将10个数据分成了 5组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">5</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">5</span>]) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">5</span>];</span><br><span class="line">            arr[j + <span class="number">5</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>第二次：<strong>gap = gap /2 = 2;</strong> ， 将数组分为两组，每个数组元素的索引相差 2</p>
<ul>
<li>第一组：<ul>
<li>i = 2 时，数组从索引 2 处往前遍历，间隔为 2 ：将 arr[0]、arr[2] 排序</li>
<li>i = 4 时，数组从索引 4 处往前遍历，间隔为 2 ：将 arr[0]、arr[2]、arr[4] 排序</li>
<li>i = 6 时，数组从索引 6 处往前遍历，间隔为 2 ：将 arr[0]、arr[2]、arr[4]、arr[6] 排序</li>
<li>i = 8 时，数组从索引 8 处往前遍历，间隔为 2 ：将 arr[0]、arr[2]、arr[4]、arr[6]、arr[8] 排序</li>
</ul>
</li>
<li>第二组：<ul>
<li>i = 3 时，数组从索引 3 处往前遍历，间隔为 2 ：将 arr[1]、arr[3] 排序</li>
<li>i = 5 时，数组从索引 5 处往前遍历，间隔为 2 ：将 arr[1]、arr[3]、arr[5] 排序</li>
<li>i = 7 时，数组从索引 7 处往前遍历，间隔为 2 ：将 arr[1]、arr[3]、arr[5]、arr[7] 排序</li>
<li>i = 9 时，数组从索引 9 处往前遍历，间隔为 2 ：将 arr[1]、arr[3]、arr[5]、arr[7]、arr[9] 排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序的第2轮排序</span></span><br><span class="line"><span class="comment">// 因为第2轮排序，是将10个数据分成了 5/2 = 2组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">2</span>]) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">2</span>];</span><br><span class="line">            arr[j + <span class="number">2</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;希尔排序2轮后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>第三次：</p>
<p>gap = gap /2 = 1;</p>
<p>  ， 将数组分为一组，每个数组元素的索引相差 1 ，对于交换法而言，这就是异常冒泡排序</p>
<ul>
<li>i = 1 时，数组从索引 1 处往前遍历，间隔为 1 ：将 arr[0]、arr[1] 排序</li>
<li>i = 2 时，数组从索引 2 处往前遍历，间隔为 1 ：将 arr[0]、arr[1]、arr[2] 排序</li>
<li>i = 3 时，数组从索引 3 处往前遍历，间隔为 1 ：将 arr[0]、arr[1]、arr[2]、arr[3] 排序</li>
<li>…</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序的第3轮排序</span></span><br><span class="line"><span class="comment">// 因为第3轮排序，是将10个数据分成了 2/2 = 1组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">            temp = arr[j];</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;希尔排序3轮后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>总结：每次使用循环改变 gap 的值（初始值：数组大小/2 ，之后：gap = gap/2），然后在改变 gap 的循环中嵌套上面的双层 for 循环</p>
<ul>
<li>改变 gap ：<strong>for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) {</strong></li>
<li>内层循环：实现对每组数组的排序</li>
</ul>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 遍历各组中所有的元素(共gap组，每组有？个元素), 步长gap</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">- 希尔排序伪代码</span><br><span class="line">    </span><br><span class="line">    ```java</span><br><span class="line">    for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123;</span><br><span class="line">        for (int i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">        	// 遍历各组中所有的元素(共gap组，每组有？个元素), 步长gap</span><br><span class="line">        	for (int j = i - gap; j &gt;= 0; j -= gap) &#123;</span><br><span class="line">                // 对每组进行冒泡排序</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE1MjIzNzA4MjcwLnBuZw?x-oss-process=image/format,png" alt="image-20200715223708270"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE1MjIzNzQwNjA3LnBuZw?x-oss-process=image/format,png" alt="image-20200715223740607"></p>
<h3 id="6-5、代码实现"><a href="#6-5、代码实现" class="headerlink" title="6.5、代码实现"></a>6.5、代码实现</h3><h4 id="6-5-1、理解希尔排序（交换法）"><a href="#6-5-1、理解希尔排序（交换法）" class="headerlink" title="6.5.1、理解希尔排序（交换法）"></a>6.5.1、理解希尔排序（交换法）</h4><ul>
<li>理解基于交换法的希尔排序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line">		shellSort(arr);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用逐步推导的方式来编写希尔排序</span></span><br><span class="line">	<span class="comment">// 希尔排序时， 对有序序列在插入时采用交换法,</span></span><br><span class="line">	<span class="comment">// 思路(算法) ===&gt; 代码</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 希尔排序的第1轮排序</span></span><br><span class="line">		<span class="comment">// 因为第1轮排序，是将10个数据分成了 5组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">5</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">5</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">5</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">				<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">5</span>]) &#123;</span><br><span class="line">					temp = arr[j];</span><br><span class="line">					arr[j] = arr[j + <span class="number">5</span>];</span><br><span class="line">					arr[j + <span class="number">5</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;希尔排序1轮后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 希尔排序的第2轮排序</span></span><br><span class="line">		<span class="comment">// 因为第2轮排序，是将10个数据分成了 5/2 = 2组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">2</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">				<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">2</span>]) &#123;</span><br><span class="line">					temp = arr[j];</span><br><span class="line">					arr[j] = arr[j + <span class="number">2</span>];</span><br><span class="line">					arr[j + <span class="number">2</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;希尔排序2轮后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 希尔排序的第3轮排序</span></span><br><span class="line">		<span class="comment">// 因为第3轮排序，是将10个数据分成了 2/2 = 1组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="comment">// 遍历各组中所有的元素(共5组，每组有2个元素), 步长5</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -= <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">				<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">					temp = arr[j];</span><br><span class="line">					arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">					arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;希尔排序3轮后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">希尔排序1轮后=[3, 5, 1, 6, 0, 8, 9, 4, 7, 2]</span><br><span class="line">希尔排序2轮后=[0, 2, 1, 4, 3, 5, 7, 6, 9, 8]</span><br><span class="line">希尔排序3轮后=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-5-2、编写希尔排序（交换法）"><a href="#6-5-2、编写希尔排序（交换法）" class="headerlink" title="6.5.2、编写希尔排序（交换法）"></a>6.5.2、编写希尔排序（交换法）</h4><ul>
<li>编写基于交换法的希尔排序算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line">		shellSort(arr);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用逐步推导的方式来编写希尔排序</span></span><br><span class="line">	<span class="comment">// 希尔排序时， 对有序序列在插入时采用交换法,</span></span><br><span class="line">	<span class="comment">// 思路(算法) ===&gt; 代码</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 根据前面的逐步分析，使用循环处理</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">				<span class="comment">// 遍历各组中所有的元素(共gap组，每组有？个元素), 步长gap</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">					<span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">					<span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">						temp = arr[j];</span><br><span class="line">						arr[j] = arr[j + gap];</span><br><span class="line">						arr[j + gap] = temp;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;希尔排序第&quot;</span> + (++count) + <span class="string">&quot;轮 =&quot;</span> + Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">希尔排序第1轮 =[3, 5, 1, 6, 0, 8, 9, 4, 7, 2]</span><br><span class="line">希尔排序第2轮 =[0, 2, 1, 4, 3, 5, 7, 6, 9, 8]</span><br><span class="line">希尔排序第3轮 =[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-5-3、测试希尔排序（交换法）性能"><a href="#6-5-3、测试希尔排序（交换法）性能" class="headerlink" title="6.5.3、测试希尔排序（交换法）性能"></a>6.5.3、测试希尔排序（交换法）性能</h4><ul>
<li>测试基于交换法的希尔排序算法性能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">		<span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">		shellSort(arr); <span class="comment">// 交换式</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用逐步推导的方式来编写希尔排序</span></span><br><span class="line">	<span class="comment">// 希尔排序时， 对有序序列在插入时采用交换法,</span></span><br><span class="line">	<span class="comment">// 思路(算法) ===&gt; 代码</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 根据前面的逐步分析，使用循环处理</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">				<span class="comment">// 遍历各组中所有的元素(共gap组，每组有？个元素), 步长gap</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">					<span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">					<span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">						temp = arr[j];</span><br><span class="line">						arr[j] = arr[j + gap];</span><br><span class="line">						arr[j + gap] = temp;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=2020-07-16 10:22:27</span><br><span class="line">排序前的时间是=2020-07-16 10:22:33</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>分析：由于使用交换法实现希尔排序算法，所以基于交换法的希尔排序算法比简单选择排序算法更慢，<strong>所以我们一定要编写基于插入法的希尔排序算法</strong></li>
</ul>
<h4 id="6-5-4、编写希尔排序（插入法）"><a href="#6-5-4、编写希尔排序（插入法）" class="headerlink" title="6.5.4、编写希尔排序（插入法）"></a>6.5.4、编写希尔排序（插入法）</h4><ul>
<li><p>编写基于插入法的希尔排序算法：</p>
<ul>
<li><p>记录当前位置的元素值</p>
<p>  int temp = arr[j]</p>
<p>  ; ，从当前元素前一个位置开始，往前寻找，每次移动 gap 个距离</p>
<ul>
<li>如果 temp &lt; arr[j - gap] ：<ul>
<li>将数组元素后移，腾出插入空间：<strong>arr[j] = arr[j - gap];</strong></li>
<li>然后继续往前找：<strong>j -= gap;</strong></li>
</ul>
</li>
<li>如果 <strong>temp &gt; arr[j - gap]</strong> ，找到插入位置，执行插入 <strong>arr[j] = temp;</strong> ，因为在上一步已经腾出了插入空间，并且将指针 j 前移，所以可直接插入</li>
<li>如果 找到数组最前面还是没有找到插入位置：<strong>j - gap &lt; 0</strong> ，则证明 temp 需要插入在数组最前面</li>
</ul>
</li>
<li><p>仅仅就是将之前交换法的冒泡操作替换成了插入操作</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span>[] arr = &#123; <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span> &#125;;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		</span><br><span class="line">		shellSort(arr);</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对交换式的希尔排序进行优化-&gt;移位法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		<span class="comment">// 增量gap, 并逐步的缩小增量</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment">// 从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">				<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">				<span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">					<span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line">						<span class="comment">// 移动</span></span><br><span class="line">						arr[j] = arr[j - gap];</span><br><span class="line">						j -= gap;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// temp 比 arr[j - gap] 大，所以需要插入在 j 的位置</span></span><br><span class="line">					arr[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">排序前</span><br><span class="line">[8, 9, 1, 7, 2, 3, 5, 4, 6, 0]</span><br><span class="line">排序前</span><br><span class="line">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-5-5、测试希尔排序（插入法）性能"><a href="#6-5-5、测试希尔排序（插入法）性能" class="headerlink" title="6.5.5、测试希尔排序（插入法）性能"></a>6.5.5、测试希尔排序（插入法）性能</h4><ul>
<li>测试基于插入法的希尔排序算法性能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">80000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">80000</span>; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">		<span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">		shellSort(arr); <span class="comment">// 交换式</span></span><br><span class="line"></span><br><span class="line">		<span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对交换式的希尔排序进行优化-&gt;移位法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		<span class="comment">// 增量gap, 并逐步的缩小增量</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="comment">// 从第gap个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">				<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">				<span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">					<span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line">						<span class="comment">// 移动</span></span><br><span class="line">						arr[j] = arr[j - gap];</span><br><span class="line">						j -= gap;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 当退出while后，就给temp找到插入的位置</span></span><br><span class="line">					arr[j] = temp;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果：1s 都不到，果然快啊</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=2020-07-16 11:02:20</span><br><span class="line">排序前的时间是=2020-07-16 11:02:20</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>八百万个数据的测试结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=2020-07-16 14:38:55</span><br><span class="line">排序前的时间是=2020-07-16 14:38:57</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7、快速排序"><a href="#7、快速排序" class="headerlink" title="7、快速排序"></a>7、快速排序</h2><h3 id="7-1、快排简介"><a href="#7-1、快排简介" class="headerlink" title="7.1、快排简介"></a>7.1、快排简介</h3><ol>
<li>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn)<br>算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</li>
<li>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</li>
<li><strong>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</strong></li>
<li>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。</li>
<li>虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N<br>多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</li>
<li>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn)<br>的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</li>
</ol>
<h3 id="7-2、代码思路"><a href="#7-2、代码思路" class="headerlink" title="7.2、代码思路"></a>7.2、代码思路</h3><ol>
<li><strong>从数列中挑出一个元素，称为 “基准”（pivot）;</strong> <em>个人喜欢用中间下标对应的数</em></li>
<li><strong>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。</strong></li>
<li>在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ol>
<hr>
<p><strong>快排流程分析</strong></p>
<p>快速排序（Quicksort）是对<strong>冒泡排序</strong>的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两 部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排 序，**<br>整个排序过程可以递归进行**，以此达到整个数据变成有序序列</p>
<h3 id="7-3、代码实现"><a href="#7-3、代码实现" class="headerlink" title="7.3、代码实现"></a>7.3、代码实现</h3><h4 id="7-3-1、编写快排算法"><a href="#7-3-1、编写快排算法" class="headerlink" title="7.3.1、编写快排算法"></a>7.3.1、编写快排算法</h4><ul>
<li>快排代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left; <span class="comment">//左下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right; <span class="comment">//右下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;(left + right) / 2 = &quot;</span> + (left + right) / <span class="number">2</span> + <span class="string">&quot; pivot = &quot;</span> + pivot);</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[l];</span><br><span class="line">        arr[l] = arr[r];</span><br><span class="line">        arr[r] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));<span class="comment">// 1, 34, 119, 101</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;===&quot;</span>);</span><br><span class="line">    <span class="comment">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向左递归</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向左递归&quot;</span>);</span><br><span class="line">        quickSort2(arr, left, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向右递归</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; right) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;向右递归&quot;</span>);</span><br><span class="line">        quickSort2(arr, l, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">4561</span>, -<span class="number">9</span>, <span class="number">78</span>, <span class="number">0</span>, <span class="number">23</span>, -<span class="number">567</span>, <span class="number">70</span>, -<span class="number">1</span>, <span class="number">900</span>&#125;;</span><br><span class="line">    quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序输出</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arr=[-567, -9, -1, 0, 23, 70, 78, 900, 4561]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="7-3-2、测试快速排序性能"><a href="#7-3-2、测试快速排序性能" class="headerlink" title="7.3.2、测试快速排序性能"></a>7.3.2、测试快速排序性能</h4><ul>
<li>编测试快速排序算法性能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//        int[] arr = &#123;4561, -9, 78, 0, 23, -567, 70, -1, 900&#125;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//        测试快排的执行速度</span></span><br><span class="line">        <span class="comment">//         创建要给80000个的随机的数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">800000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">800000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">80000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(data1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line">        <span class="comment">//        System.out.println(&quot;arr=&quot; + Arrays.toString(arr));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left; <span class="comment">//左下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> right; <span class="comment">//右下标</span></span><br><span class="line">        <span class="comment">//pivot 中轴值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//临时变量，作为交换时使用</span></span><br><span class="line">        <span class="comment">//while循环的目的是让比pivot 值小放到左边</span></span><br><span class="line">        <span class="comment">//比pivot 值大放到右边</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//在pivot的左边一直找,找到大于等于pivot值,才退出</span></span><br><span class="line">            <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在pivot的右边一直找,找到小于等于pivot值,才退出</span></span><br><span class="line">            <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果l &gt;= r说明pivot 的左右两的值，已经按照左边全部是</span></span><br><span class="line">            <span class="comment">//小于等于pivot值，右边全部是大于等于pivot值</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[l] == pivot值 相等 r--， 前移</span></span><br><span class="line">            <span class="comment">//当交换后 arr[l] == pivot 说明交换之前r下标已经指向了 pivot 所在的位置，</span></span><br><span class="line">            <span class="comment">//将r--是为了跳过这个pivot位置</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">                r -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[r] == pivot值 相等 l++， 后移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">                l += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 l == r, 必须l++, r--, 否则为出现栈溢出</span></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            l += <span class="number">1</span>;</span><br><span class="line">            r -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向左递归</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; r) &#123;</span><br><span class="line">            quickSort(arr, left, r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt; l) &#123;</span><br><span class="line">            quickSort(arr, l, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果：80万数据一秒钟，果然快。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=2021-11-11 16:47:19</span><br><span class="line">排序前的时间是=2021-11-11 16:47:20</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="8、归并排序"><a href="#8、归并排序" class="headerlink" title="8、归并排序"></a>8、归并排序</h2><h3 id="8-1、归并排序基本介绍"><a href="#8-1、归并排序基本介绍" class="headerlink" title="8.1、归并排序基本介绍"></a>8.1、归并排序基本介绍</h3><ul>
<li>归并排序（MERGE-SORT） 是利用归并的思想实现的排序方法， 该算法采用经典的分治（divide-and-conquer）策略</li>
<li><strong>分治法将问题分(divide)成一些小的问题然后递归求解， 而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起， 即分而治之</strong></li>
</ul>
<h3 id="8-2、归并排序思想"><a href="#8-2、归并排序思想" class="headerlink" title="8.2、归并排序思想"></a>8.2、归并排序思想</h3><ul>
<li>分 –&gt; 治</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE2MTU1MTM3NDcwLnBuZw?x-oss-process=image/format,png" alt="image-20200716155137470"></p>
<h3 id="8-3、归并排序代码思路"><a href="#8-3、归并排序代码思路" class="headerlink" title="8.3、归并排序代码思路"></a>8.3、归并排序代码思路</h3><ul>
<li><p>合并时，其实是拿着原数组（arr）中两个相邻的子数组（arr1、arr2）进行合并</p>
<p>，我们使用三个指针，来表示两个子数组在原数组中的位置</p>
<ul>
<li>arr[left] ~ arr[mid] 为 arr1</li>
<li>arr[mid + 1] ~ arr[right] 为 arr2</li>
</ul>
</li>
<li><p>如何合并？</p>
<ul>
<li>首先，需要一个临时的 temp 数组，其大小与原数组 arr 一样</li>
<li><strong>定义辅助指针 i 遍历 arr1 ，定义辅助指针 j 遍历 arr2 ，原则就是，把 arr1 和 arr2 中的数往 temp 中放，使得 temp[left] ~ temp[right] 是有序数组</strong></li>
<li>最后把 temp 临时数组中的数据拷贝回原数组中（个人认为，最后一下次再拷贝回去就行。。。）</li>
</ul>
</li>
<li><p>如何分？</p>
<ul>
<li>向左递归拆分：mergeSort(arr, left, mid, temp);</li>
<li>向右递归拆分：mergeSort(arr, mid + 1, right, temp);</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE2MTU1MjEwMTE1LnBuZw?x-oss-process=image/format,png" alt="image-20200716155210115"></p>
<h3 id="8-4、代码实现"><a href="#8-4、代码实现" class="headerlink" title="8.4、代码实现"></a>8.4、代码实现</h3><h4 id="8-4-1、编写归并排序算法"><a href="#8-4-1、编写归并排序算法" class="headerlink" title="8.4.1、编写归并排序算法"></a>8.4.1、编写归并排序算法</h4><ul>
<li>归并排序算法实现代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergetSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">		<span class="type">int</span> arr[] = &#123; <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span> &#125;;</span><br><span class="line">		<span class="type">int</span> temp[] = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length]; <span class="comment">// 归并排序需要一个额外空间</span></span><br><span class="line">		mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line">		System.out.println(<span class="string">&quot;归并排序后=&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 分+合方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>; <span class="comment">// 中间索引</span></span><br><span class="line">			<span class="comment">// 向左递归进行分解</span></span><br><span class="line">			mergeSort(arr, left, mid, temp);</span><br><span class="line">			<span class="comment">// 向右递归进行分解</span></span><br><span class="line">			mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">			<span class="comment">// 合并</span></span><br><span class="line">			merge(arr, left, mid, right, temp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 合并的方法</span></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> arr   排序的原始数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> mid   中间索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> temp  做中转的数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; <span class="comment">// 初始化i, 左边有序序列的初始索引</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>; <span class="comment">// 初始化j, 右边有序序列的初始索引</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// (一)</span></span><br><span class="line">		<span class="comment">// 先把左右两边(有序)的数据按照规则填充到temp数组</span></span><br><span class="line">		<span class="comment">// 直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<span class="comment">// 继续</span></span><br><span class="line">			<span class="comment">// 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">			<span class="comment">// 即将左边的当前元素，填充到 temp数组</span></span><br><span class="line">			<span class="comment">// 然后 t++, i++</span></span><br><span class="line">			<span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">				temp[t] = arr[i];</span><br><span class="line">				t += <span class="number">1</span>;</span><br><span class="line">				i += <span class="number">1</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123; <span class="comment">// 反之,将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">				temp[t] = arr[j];</span><br><span class="line">				t += <span class="number">1</span>;</span><br><span class="line">				j += <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (二)</span></span><br><span class="line">		<span class="comment">// 把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt;= mid) &#123; <span class="comment">// 左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">			temp[t] = arr[i];</span><br><span class="line">			t += <span class="number">1</span>;</span><br><span class="line">			i += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (j &lt;= right) &#123; <span class="comment">// 右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">			temp[t] = arr[j];</span><br><span class="line">			t += <span class="number">1</span>;</span><br><span class="line">			j += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// (三)</span></span><br><span class="line">		<span class="comment">// 将temp数组的元素拷贝到arr</span></span><br><span class="line">		<span class="comment">// 注意，并不是每次都拷贝所有</span></span><br><span class="line">		t = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">tempLeft</span> <span class="operator">=</span> left; <span class="comment">//</span></span><br><span class="line">		<span class="comment">// 第一次合并 tempLeft = 0 , right = 1 //第二次： tempLeft = 2 right = 3 //第三次： tL=0 ri=3</span></span><br><span class="line">		<span class="comment">// 最后一次 tempLeft = 0 right = 7</span></span><br><span class="line">		<span class="keyword">while</span> (tempLeft &lt;= right) &#123;</span><br><span class="line">			arr[tempLeft] = temp[t];</span><br><span class="line">			t += <span class="number">1</span>;</span><br><span class="line">			tempLeft += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">归并排序后=[1, 2, 3, 4, 5, 6, 7, 8]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-4-2、测试归并排序性能"><a href="#8-4-2、测试归并排序性能" class="headerlink" title="8.4.2、测试归并排序性能"></a>8.4.2、测试归并排序性能</h4><ul>
<li>测试归并排序算法的性能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergetSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试快排的执行速度</span></span><br><span class="line">        <span class="comment">// 创建要给80000个的随机的数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8000000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(data1);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> temp[] = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length]; <span class="comment">// 归并排序需要一个额外空间</span></span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">        System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(&quot;归并排序后=&quot; + Arrays.toString(arr));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分+合方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>; <span class="comment">// 中间索引</span></span><br><span class="line">            <span class="comment">// 向左递归进行分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">// 向右递归进行分解</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">// 合并</span></span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   排序的原始数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid   中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  做中转的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right, <span class="type">int</span>[] temp)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; <span class="comment">// 初始化i, 左边有序序列的初始索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mid + <span class="number">1</span>; <span class="comment">// 初始化j, 右边有序序列的初始索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// (一)</span></span><br><span class="line">        <span class="comment">// 先把左右两边(有序)的数据按照规则填充到temp数组</span></span><br><span class="line">        <span class="comment">// 直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<span class="comment">// 继续</span></span><br><span class="line">            <span class="comment">// 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">            <span class="comment">// 即将左边的当前元素，填充到 temp数组</span></span><br><span class="line">            <span class="comment">// 然后 t++, i++</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 反之,将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (二)</span></span><br><span class="line">        <span class="comment">// 把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123; <span class="comment">// 左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123; <span class="comment">// 右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (三)</span></span><br><span class="line">        <span class="comment">// 将temp数组的元素拷贝到arr</span></span><br><span class="line">        <span class="comment">// 注意，并不是每次都拷贝所有</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tempLeft</span> <span class="operator">=</span> left; <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 第一次合并 tempLeft = 0 , right = 1 //第二次： tempLeft = 2 right = 3 //第三次： tL=0 ri=3</span></span><br><span class="line">        <span class="comment">// 最后一次 tempLeft = 0 right = 7</span></span><br><span class="line">        <span class="keyword">while</span> (tempLeft &lt;= right) &#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            tempLeft += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果：八百万数据用了 1s ，也挺快</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=2020-07-16 16:18:32</span><br><span class="line">排序前的时间是=2020-07-16 16:18:33</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="8-5、总结"><a href="#8-5、总结" class="headerlink" title="8.5、总结"></a>8.5、总结</h3><ul>
<li>先将数组分为左右两半，先执行左半边递归：<ul>
<li>首先执行左递归到最深层，条件 <strong>if (left &lt; right)</strong> 不满足，开始执行合并，合并 { 8, 4 } 到临时数组 temp 中，变为有序数组 { 4, 8 } ，再拷贝回原数组 arr 中</li>
<li>然后执行最深层的右递归，条件 <strong>if (left &lt; right)</strong> 不满足，开始执行合并，合并 { 5, 7 } 到临时数组 temp 中，变为有序数组 { 2, 7 } ，再拷贝回原数组 arr 中</li>
<li>合并完后，递归回溯至上一节，开始执行合并，合并 { 4, 5, 7, 8 } 到临时数组 temp 中，变为有序数组 { 4, 5, 7, 8 } ，再拷贝回原数组 arr 中</li>
</ul>
</li>
<li>右左半边的递归也是同样的道理</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE2MTYxMTM0ODMzLnBuZw?x-oss-process=image/format,png" alt="image-20200716161134833"></p>
<h2 id="9、基数排序"><a href="#9、基数排序" class="headerlink" title="9、基数排序"></a>9、基数排序</h2><h3 id="9-1、基数排序基本介绍"><a href="#9-1、基数排序基本介绍" class="headerlink" title="9.1、基数排序基本介绍"></a>9.1、基数排序基本介绍</h3><ul>
<li><strong>基数排序（radix sort） 属于“分配式排序” （distribution sort） ， 又称“桶子法” （bucket sort） 或 bin sort，</strong> 顾名思义， 它是通过键值的各个位的值，<br>将要排序的元素分配至某些“桶” 中， 达到排序的作用</li>
<li><strong>基数排序法是属于稳定性的排序，</strong> 基数排序法的是效率高的稳定性排序法</li>
<li>基数排序(Radix Sort)是桶排序的扩展</li>
<li>基数排序是 1887 年赫尔曼· 何乐礼发明的。 它是这样实现的： 将整数按位数切割成不同的数字， 然后按每个位数分别比较。</li>
</ul>
<h3 id="9-2、基数排序思想"><a href="#9-2、基数排序思想" class="headerlink" title="9.2、基数排序思想"></a>9.2、基数排序思想</h3><ul>
<li>将所有待比较数值统一为同样的数位长度， 数位较短的数前面补零。</li>
<li>然后， <strong>从最低位开始， 依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</strong></li>
</ul>
<h3 id="9-3、基数排序图解"><a href="#9-3、基数排序图解" class="headerlink" title="9.3、基数排序图解"></a>9.3、基数排序图解</h3><ul>
<li><p>有 10 个桶，对应编号为 0~9</p>
</li>
<li><p>步骤</p>
<ul>
<li>第一步：根据原数组 arr 中每个元素的个位数，将其依次放入 0~9 号桶中（每个桶从前往后放），放置完毕后，再将桶中的数据依次取出（每个桶从前往后取），放回原数组 arr 中，这样原数组 arr<br>中个位数的元素就已经按照顺序排好了</li>
<li>第二步：根据原数组 arr 中每个元素的十位数，将其依次放入 0~9 号桶中（每个桶从前往后放），放置完毕后，再将桶中的数据依次取出（每个桶从前往后取），放回原数组 arr 中，这样原数组 arr 中十位数 +<br>个位数的元素就已经按照顺序排好了</li>
<li>第三步：根据原数组 arr 中每个元素的百位数，将其依次放入 0~9 号桶中（每个桶从前往后放），放置完毕后，再将桶中的数据依次取出（每个桶从前往后取），放回原数组 arr 中，这样原数组 arr 中百位数 + 十位数 +<br>个位数的元素就已经按照顺序排好了</li>
<li>…</li>
</ul>
</li>
<li><p>何时排序完毕？当数组中最长位数的元素处理完毕，排序完成</p>
</li>
<li><p>桶的容量如何确定？假设数组每个元素位数相同，那么单个桶最大容量即为数组容量，我们用一个二维数组来表示桶：<code>int[][] bucket = new int[10][arr.length];</code></p>
</li>
<li><p>我们如何知道每桶中装了几个元素？这也需要记录，用一个一维数组来记录：</p>
<p><code>int[] bucketElementCounts = new int[10];</code></p>
</li>
<li><p>总结：</p>
<ul>
<li><p>假设数组中元素的最长位数为 maxLength ，则处理完 maxLength 位数后，数组排序完毕：<strong>for(int i = 0 , n = 1; i &lt; maxLength; i++, n *= 10) {</strong></p>
</li>
<li><p>使用一个 for 循环处理原一维数组 arr ，将其放入桶中</p>
<p><strong>for(int j = 0; j &lt; arr.length; j++) {</strong></p>
</li>
<li><p>使用两层 for 循环，处理 10 个 桶，将其中的元素放回原一维数组中</p>
<p><strong>for (int k = 0; k &lt; bucketElementCounts.length; k++) {</strong><br><strong>if (bucketElementCounts[k] != 0) {</strong><br><strong>for (int l = 0; l &lt; bucketElementCounts[k]; l++) {</strong></p>
</li>
</ul>
</li>
</ul>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwODA2MTg1ODA5MzE0LnBuZw?x-oss-process=image/format,png" alt="image-20200806185809314"></p>
<h3 id="9-4、代码实现"><a href="#9-4、代码实现" class="headerlink" title="9.4、代码实现"></a>9.4、代码实现</h3><h4 id="9-4-1、理解基数排序"><a href="#9-4-1、理解基数排序" class="headerlink" title="9.4.1、理解基数排序"></a>9.4.1、理解基数排序</h4><ul>
<li>逐步分解，理解基数排序算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">        System.out.println(<span class="string">&quot;基数排序后 &quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基数排序方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//		//根据前面的推导过程，我们可以得到最终的基数排序代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 得到数组中最大的数的位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>]; <span class="comment">//假设第一数就是最大数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">        <span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line">        <span class="comment">//3. 名明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line">        <span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">        <span class="comment">//可以这里理解</span></span><br><span class="line">        <span class="comment">//比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line">        <span class="type">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第1轮(针对每个元素的个位进行排序处理)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">//取出每个元素的个位的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / <span class="number">1</span> % <span class="number">10</span>;</span><br><span class="line">            <span class="comment">//放入到对应的桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">            <span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">            <span class="keyword">if</span> (bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                    <span class="comment">//取出元素放入到arr</span></span><br><span class="line">                    arr[index++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第l轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">            bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第1轮，对个位的排序处理 arr =&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第2轮(针对每个元素的十位进行排序处理)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 取出每个元素的十位的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / <span class="number">10</span> % <span class="number">10</span>; <span class="comment">//748 / 10 =&gt; 74 % 10 =&gt; 4</span></span><br><span class="line">            <span class="comment">// 放入到对应的桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">            <span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">            <span class="keyword">if</span> (bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                    <span class="comment">// 取出元素放入到arr</span></span><br><span class="line">                    arr[index++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第2轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">            bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第2轮，对个位的排序处理 arr =&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第3轮(针对每个元素的百位进行排序处理)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 取出每个元素的百位的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / <span class="number">100</span> % <span class="number">10</span>; <span class="comment">// 748 / 100 =&gt; 7 % 10 = 7</span></span><br><span class="line">            <span class="comment">// 放入到对应的桶中</span></span><br><span class="line">            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">            bucketElementCounts[digitOfElement]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">            <span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">            <span class="keyword">if</span> (bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 循环该桶即第k个桶(即第k个一维数组), 放入</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                    <span class="comment">// 取出元素放入到arr</span></span><br><span class="line">                    arr[index++] = bucket[k][l];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第3轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">            bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;第3轮，对个位的排序处理 arr =&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">第1轮，对个位的排序处理 arr =[542, 53, 3, 14, 214, 748]</span><br><span class="line">第2轮，对个位的排序处理 arr =[3, 14, 214, 542, 748, 53]</span><br><span class="line">第3轮，对个位的排序处理 arr =[3, 14, 53, 214, 542, 748]</span><br><span class="line">基数排序后 [3, 14, 53, 214, 542, 748]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="9-4-2、编写基数排序"><a href="#9-4-2、编写基数排序" class="headerlink" title="9.4.2、编写基数排序"></a>9.4.2、编写基数排序</h4><ul>
<li>编写基数排序算法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> arr[] = &#123; <span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span> &#125;;</span><br><span class="line">		radixSort(arr);</span><br><span class="line">		System.out.println(<span class="string">&quot;基数排序后 &quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 基数排序方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根据前面的推导过程，我们可以得到最终的基数排序代码	</span></span><br><span class="line">		<span class="comment">//1. 得到数组中最大的数的位数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>]; <span class="comment">//假设第一数就是最大数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">				max = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//得到最大数是几位数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">		<span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line">		<span class="comment">//3. 名明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line">		<span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">		<span class="comment">//可以这里理解</span></span><br><span class="line">		<span class="comment">//比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line">		<span class="type">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// n=1 表示处理个位，n=10表示处理十位，n=100表示处理百位 ......</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="comment">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="comment">//取出每个元素的对应位的值</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / n % <span class="number">10</span>;</span><br><span class="line">				<span class="comment">//放入到对应的桶中</span></span><br><span class="line">				bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">				bucketElementCounts[digitOfElement]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//遍历每一桶，并将桶中的数据，放入到原数组</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">				<span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">				<span class="comment">// 遍历第k个桶(即第k个一维数组), 将桶中的数据放回原数组中</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">					<span class="comment">// 取出元素放入到arr</span></span><br><span class="line">					arr[index++] = bucket[k][l];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">				bucketElementCounts[k] = <span class="number">0</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;轮，对个位的排序处理 arr =&quot;</span> + Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">第1轮，对个位的排序处理 arr =[542, 53, 3, 14, 214, 748]</span><br><span class="line">第2轮，对个位的排序处理 arr =[3, 14, 214, 542, 748, 53]</span><br><span class="line">第3轮，对个位的排序处理 arr =[3, 14, 53, 214, 542, 748]</span><br><span class="line">基数排序后 [3, 14, 53, 214, 542, 748]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="9-4-3、测试基数排序性能"><a href="#9-4-3、测试基数排序性能" class="headerlink" title="9.4.3、测试基数排序性能"></a>9.4.3、测试基数排序性能</h4><ul>
<li>测试基数排序算法的性能</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 80000000 * 11 * 4 / 1024 / 1024 / 1024 =3.3G </span></span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">8000000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">8000000</span>; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="type">int</span>) (Math.random() * <span class="number">8000000</span>); <span class="comment">// 生成一个[0, 8000000) 数</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前&quot;</span>);</span><br><span class="line">		<span class="type">Date</span> <span class="variable">data1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">		<span class="type">String</span> <span class="variable">date1Str</span> <span class="operator">=</span> simpleDateFormat.format(data1);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date1Str);</span><br><span class="line">		</span><br><span class="line">		radixSort(arr);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Date</span> <span class="variable">data2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">date2Str</span> <span class="operator">=</span> simpleDateFormat.format(data2);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序前的时间是=&quot;</span> + date2Str);</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 基数排序方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//根据前面的推导过程，我们可以得到最终的基数排序代码	</span></span><br><span class="line">		<span class="comment">//1. 得到数组中最大的数的位数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> arr[<span class="number">0</span>]; <span class="comment">//假设第一数就是最大数</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">				max = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//得到最大数是几位数</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//定义一个二维数组，表示10个桶, 每个桶就是一个一维数组</span></span><br><span class="line">		<span class="comment">//说明</span></span><br><span class="line">		<span class="comment">//1. 二维数组包含10个一维数组</span></span><br><span class="line">		<span class="comment">//2. 为了防止在放入数的时候，数据溢出，则每个一维数组(桶)，大小定为arr.length</span></span><br><span class="line">		<span class="comment">//3. 名明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line">		<span class="type">int</span>[][] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//为了记录每个桶中，实际存放了多少个数据,我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">		<span class="comment">//可以这里理解</span></span><br><span class="line">		<span class="comment">//比如：bucketElementCounts[0] , 记录的就是  bucket[0] 桶的放入数据个数</span></span><br><span class="line">		<span class="type">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// n=1 表示处理个位，n=10表示处理十位，n=100表示处理百位 ......</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , n = <span class="number">1</span>; i &lt; maxLength; i++, n *= <span class="number">10</span>) &#123;</span><br><span class="line">			<span class="comment">//(针对每个元素的对应位进行排序处理)， 第一次是个位，第二次是十位，第三次是百位..</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="comment">//取出每个元素的对应位的值</span></span><br><span class="line">				<span class="type">int</span> <span class="variable">digitOfElement</span> <span class="operator">=</span> arr[j] / n % <span class="number">10</span>;</span><br><span class="line">				<span class="comment">//放入到对应的桶中</span></span><br><span class="line">				bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">				bucketElementCounts[digitOfElement]++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//按照这个桶的顺序(一维数组的下标依次取出数据，放入原来数组)</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//遍历每一桶，并将桶中的数据，放入到原数组</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">				<span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">				<span class="comment">// 遍历第k个桶(即第k个一维数组), 将桶中的数据放回原数组中</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">					<span class="comment">// 取出元素放入到arr</span></span><br><span class="line">					arr[index++] = bucket[k][l];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//第i+1轮处理后，需要将每个 bucketElementCounts[k] = 0 ！！！！</span></span><br><span class="line">				bucketElementCounts[k] = <span class="number">0</span>;				</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;第&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;轮，对个位的排序处理 arr =&quot;</span> + Arrays.toString(arr));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>程序运行结果：可以啊，八百万数据 1s 就排好了，但是太占空间了</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">排序前</span><br><span class="line">排序前的时间是=2020-07-16 18:16:21</span><br><span class="line">排序前的时间是=2020-07-16 18:16:22</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-5、基数排序的说明"><a href="#9-5、基数排序的说明" class="headerlink" title="9.5、基数排序的说明"></a>9.5、基数排序的说明</h3><ul>
<li>基数排序是对传统桶排序的扩展， 速度很快</li>
<li>基数排序是经典的空间换时间的方式， 占用内存很大，当对海量数据排序时， 容易造成 OutOfMemoryError 。</li>
<li>基数排序时稳定的。 [注：假定在待排序的记录序列中， 存在多个具有相同的关键字的记录， 若经过排序， 这些记录的相对次序保持不变， 即在原序列中， r[i]=r[j]， 且 r[i]在 r[j]之前， 而在排序后的序列中， r[i]仍在<br>r[j]之前，则称这种排序算法是稳定的； 否则称为不稳定的]</li>
<li>有负数的数组， 我们不用基数排序来进行排序, 如果要支持负数， 参考: <a href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9</a></li>
</ul>
<h2 id="10、常用排序算法总结和对比"><a href="#10、常用排序算法总结和对比" class="headerlink" title="10、常用排序算法总结和对比"></a>10、常用排序算法总结和对比</h2><h3 id="10-1、排序算法的比较图"><a href="#10-1、排序算法的比较图" class="headerlink" title="10.1、排序算法的比较图"></a>10.1、排序算法的比较图</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2hleWdvLm9zcy1jbi1zaGFuZ2hhaS5hbGl5dW5jcy5jb20vaW1hZ2VzL2ltYWdlLTIwMjAwNzE2MjAxMDQ2NTM0LnBuZw?x-oss-process=image/format,png" alt="image-20200716201046534"></p>
<h3 id="10-2、相关术语解释"><a href="#10-2、相关术语解释" class="headerlink" title="10.2、相关术语解释"></a>10.2、相关术语解释</h3><ul>
<li><strong>稳定</strong>：如果 a 原本在 b 前面， 而 a=b， 排序之后 a 仍然在 b 的前面；</li>
<li><strong>不稳定</strong>：如果 a 原本在 b 的前面， 而 a=b， 排序之后 a 可能会出现在 b 的后面；</li>
<li>内排序： 所有排序操作都在内存中完成；</li>
<li>外排序： 由于数据太大， 因此把数据放在磁盘中， 而排序通过磁盘和内存的数据传输才能进行；</li>
<li>时间复杂度： 一个算法执行所耗费的时间。</li>
<li>空间复杂度： 运行完一个程序所需内存的大小。</li>
<li>n: 数据规模</li>
<li>k: “桶” 的个数</li>
<li><strong>In-place</strong>：不占用额外内存</li>
<li><strong>Out-place</strong>：占用额外内存</li>
</ul>
]]></content>
      <categories>
        <category>java数据结构与算法</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
